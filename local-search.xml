<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker镜像的导入和导出</title>
    <link href="/2023/12/06/04DevOps/31docker%E9%95%9C%E5%83%8F%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA/"/>
    <url>/2023/12/06/04DevOps/31docker%E9%95%9C%E5%83%8F%E7%9A%84%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>对于镜像的导出和导入，Docker 提供了两种方案：① <code>export</code>与<code>import</code>配对使用，②<code>save</code>与<code>load</code>配对使用</p><h1 id="1-export-import"><a href="#1-export-import" class="headerlink" title="1. export/import"></a>1. export/import</h1><h2 id="1-1-导出-export"><a href="#1-1-导出-export" class="headerlink" title="1.1 导出(export)"></a>1.1 导出(export)</h2><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 1. 通过docker ps -a 查看可导出的容器id</span><br>docker ps -a<br><br><span class="hljs-comment"># 2. 使用export命令导出</span><br>docker <span class="hljs-builtin-name">export</span> container_id &gt; xxxx.tar<br></code></pre></td></tr></table></figure><h2 id="1-2-导入-import"><a href="#1-2-导入-import" class="headerlink" title="1.2 导入(import)"></a>1.2 导入(import)</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elm"># <span class="hljs-number">1.</span> 使用 docker <span class="hljs-keyword">import</span> 命令将镜像文件导入<br>以下命令将通过ex<span class="hljs-keyword">port</span>出来的文件ubuntu_20.04_export_dev_ycm_1.tar导入为镜像名为ubuntu_dev_ycm版本号为20.04<br><br><span class="hljs-title">docker</span> <span class="hljs-keyword">import</span> - ubuntu_dev_ycm:20.04 &lt;  ubuntu_20.04_export_dev_ycm_1.tar<br><br><br># <span class="hljs-number">2.</span> 执行 docker images 命令查看导入的镜像<br><span class="hljs-title">docker</span> images<br></code></pre></td></tr></table></figure><h1 id="2-save-load"><a href="#2-save-load" class="headerlink" title="2. save/load"></a>2. save/load</h1><h2 id="2-1-导出-save"><a href="#2-1-导出-save" class="headerlink" title="2.1 导出(save)"></a>2.1 导出(save)</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 1.  docker images 命令查看本机所有的镜像</span><br><span class="hljs-attribute">docker</span> images<br><span class="hljs-comment"># 2. 保存镜像</span><br><span class="hljs-attribute">docker</span> save image_id &gt; qqqq.tar<br><span class="hljs-comment"># 2.1 还可以同时将多个 image 打包成一个文件，比如下面将镜像库中的 postgres 和 mongo 打包：</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">docker</span> save -o images.tar postgres:<span class="hljs-number">9</span>.<span class="hljs-number">6</span> mongo:<span class="hljs-number">3</span>.<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="2-2-导入-load"><a href="#2-2-导入-load" class="headerlink" title="2.2 导入(load)"></a>2.2 导入(load)</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 1. 使用 docker load 命令导入镜像文件</span><br>docker <span class="hljs-keyword">load</span> &lt; pppp.tar<br></code></pre></td></tr></table></figure><h1 id="3-两种方案的差别"><a href="#3-两种方案的差别" class="headerlink" title="3. 两种方案的差别"></a>3. 两种方案的差别</h1><p>导出源不同，export只能从容器中导出, 而save只能从image导出</p><h2 id="3-1-文件大小不同"><a href="#3-1-文件大小不同" class="headerlink" title="3.1 文件大小不同"></a>3.1 文件大小不同</h2><p>export 导出的镜像文件体积小于 save 保存的镜像</p><h2 id="3-2-是否可以对镜像重命名"><a href="#3-2-是否可以对镜像重命名" class="headerlink" title="3.2 是否可以对镜像重命名"></a>3.2 是否可以对镜像重命名</h2><p>docker import 可以为镜像指定新名称</p><p>docker load 不能对载入的镜像重命名</p><h2 id="3-3-是否可以同时将多个镜像打包到一个文件中"><a href="#3-3-是否可以同时将多个镜像打包到一个文件中" class="headerlink" title="3.3 是否可以同时将多个镜像打包到一个文件中"></a>3.3 是否可以同时将多个镜像打包到一个文件中</h2><p>docker export 不支持</p><p>docker save 支持</p><h2 id="3-4-是否包含镜像历史"><a href="#3-4-是否包含镜像历史" class="headerlink" title="3.4 是否包含镜像历史"></a>3.4 是否包含镜像历史</h2><p>export 导出（import 导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史记录和元数据信息（即仅保存容器当时的快照状态），所以无法进行回滚操作。</p><p>而 save 保存（load 加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。</p><h2 id="3-5-应用场景不同"><a href="#3-5-应用场景不同" class="headerlink" title="3.5 应用场景不同"></a>3.5 应用场景不同</h2><p>docker export 的应用场景：主要用来制作基础镜像，比如我们从一个 ubuntu 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p><p>docker save 的应用场景：如果我们的应用是使用 docker-compose.yml 编排的多个镜像组合，但我们要部署的客户服务器并不能连外网。这时就可以使用 docker save</p><p>将用到的镜像打个包，然后拷贝到客户服务器上使用 docker load 载入。</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker镜像制作并上传</title>
    <link href="/2023/12/06/04DevOps/30docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E5%B9%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2023/12/06/04DevOps/30docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E5%B9%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-Linux-版从-dockerfile-制作-Docker-镜像"><a href="#一、-Linux-版从-dockerfile-制作-Docker-镜像" class="headerlink" title="一、 Linux 版从 dockerfile 制作 Docker 镜像"></a>一、 Linux 版从 dockerfile 制作 Docker 镜像</h1><p>制作linux版的docker镜像需要一些准备工作，然后编写对应的dockerfile， 执行dockerfile 、推送镜像到服务端</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="1-1-准备好可访问外网的虚拟机，并安docker等软件"><a href="#1-1-准备好可访问外网的虚拟机，并安docker等软件" class="headerlink" title="1.1 准备好可访问外网的虚拟机，并安docker等软件"></a>1.1 准备好可访问外网的虚拟机，并安docker等软件</h3><figure class="highlight vala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 安装</span><br>yum install -y docker<br>yum install -y git<br><span class="hljs-meta"># 启动</span><br>systemctl start docker.service<br><span class="hljs-meta"># 显示docker 版本</span><br>docker --version<br><span class="hljs-comment">// Docker version 19.03.12, build dd074a9</span><br></code></pre></td></tr></table></figure><h3 id="1-2-登录docker"><a href="#1-2-登录docker" class="headerlink" title="1.2 登录docker"></a>1.2 登录docker</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">docker login docker-registry.qqqqq.virtual<br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>: xxxxx<br><span class="hljs-tag">&lt;<span class="hljs-name">passwd</span>&gt;</span>: xxxxx<br></code></pre></td></tr></table></figure><h3 id="1-3-拉取依赖的基础镜像"><a href="#1-3-拉取依赖的基础镜像" class="headerlink" title="1.3 拉取依赖的基础镜像"></a>1.3 拉取依赖的基础镜像</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull docker-registry.qqqqq.virtual/library/centos<span class="hljs-number">7</span>:<span class="hljs-number">7</span>-iqqqqq-<span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h3 id="1-4-部署andriod编译依赖的gradle工具"><a href="#1-4-部署andriod编译依赖的gradle工具" class="headerlink" title="1.4. 部署andriod编译依赖的gradle工具"></a>1.4. 部署andriod编译依赖的gradle工具</h3><p>通过 <a href="https://gradle.org/releases/">https://gradle.org/releases/</a> 下载4.10.1版二进制包 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 获取二进制包</span><br>wget https:<span class="hljs-regexp">//</span>services.gradle.org<span class="hljs-regexp">/distributions/g</span>radle-<span class="hljs-number">4.10</span>.<span class="hljs-number">1</span>-bin.zip<br><span class="hljs-comment"># 解压</span><br>unzip gradle-<span class="hljs-number">4.10</span>.<span class="hljs-number">1</span>-bin.zip<br>mkdir -p <span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/g</span>radle<br><span class="hljs-comment"># 将gradle拷贝到指定路径下</span><br>mv gradle-<span class="hljs-number">4.10</span>.<span class="hljs-number">1</span> <span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/g</span>radle<br></code></pre></td></tr></table></figure><h3 id="1-5-部署-andriod-编译依赖的NDK工具"><a href="#1-5-部署-andriod-编译依赖的NDK工具" class="headerlink" title="1.5. 部署 andriod 编译依赖的NDK工具"></a>1.5. 部署 andriod 编译依赖的NDK工具</h3><p>NDK的安装是通过 sdkmanager 来安装的，而 sdkmanager 包含在 commandlinetools 包中的，Android Studio 包含了commandlinetools工具，因为不需要图形化界面所以在<code>Command line tools only</code>标题下只下载linux版的 commandlinetools 就好了，不用下载完整的<code>Android Studio </code>。</p><p><a href="https://developer.android.com/studio#downloads">https://developer.android.com/studio#downloads</a></p><h4 id="1-5-1-部署-commandlinetools-及其依赖"><a href="#1-5-1-部署-commandlinetools-及其依赖" class="headerlink" title="1.5.1 部署 commandlinetools 及其依赖"></a>1.5.1 部署 commandlinetools 及其依赖</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># sdkmanager 依赖java开发包，所以先安装java开发包</span><br>yum install java-<span class="hljs-number">1.8</span>.<span class="hljs-number">0</span>-openjdk-devel.x86_64 -y<br><span class="hljs-comment"># 解压</span><br>unzip commandlinetools-linux-<span class="hljs-number">7583922</span>_latest.zip<br>mkdir -p <span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/</span>sdk<span class="hljs-regexp">/cmdline-tools/</span><br><span class="hljs-comment"># 必须为latest目录，否则执行sdkmanager会报错，要求设置</span><br>mv cmdline-tools<span class="hljs-regexp">/ /</span>opt<span class="hljs-regexp">/soft/</span>android<span class="hljs-regexp">/sdk/</span>cmdline-tools/latest<br></code></pre></td></tr></table></figure><h4 id="1-5-2-设置环境变量"><a href="#1-5-2-设置环境变量" class="headerlink" title="1.5.2 设置环境变量"></a>1.5.2 设置环境变量</h4><p>因为 sdkmanager 的执行依赖部分环境变量，所以需要提前设置<br>vim ~/.bash_profile 添加以下内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">export ANDROID_SDK_ROOT=<span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/</span>sdk<br>export ANDROID_HOME=<span class="hljs-variable">$&#123;ANDROID_SDK_ROOT&#125;</span><br>export GRADLE_HOME=<span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/g</span>radle/gradle-<span class="hljs-number">4</span>\.<span class="hljs-number">10</span>\.<span class="hljs-number">1</span><br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span><span class="hljs-regexp">/bin:$ANDROID_HOME/</span>tools:<span class="hljs-variable">$ANDROID_HOME</span><span class="hljs-regexp">/platform-tools:$GRADLE_HOME/</span>bin<br></code></pre></td></tr></table></figure><p><a href="https://developer.android.com/studio/command-line/sdkmanager">官方文档</a>中说不设置ANDROID_HOME也可以,为了减少不必要的麻烦，设置上也没问题</p><p>执行以下命令使环境变量生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><h4 id="1-5-3-验证commandlinetools-部署"><a href="#1-5-3-验证commandlinetools-部署" class="headerlink" title="1.5.3 验证commandlinetools 部署"></a>1.5.3 验证commandlinetools 部署</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/</span>sdk<span class="hljs-regexp">/cmdline-tools/</span>latest/bin<br><span class="hljs-comment"># 成功显示版本号说明 commandlinetools</span><br>./sdkmanager --version<br></code></pre></td></tr></table></figure><h4 id="1-5-4-通过-sdkmanager-安装指定版本的NDK"><a href="#1-5-4-通过-sdkmanager-安装指定版本的NDK" class="headerlink" title="1.5.4 通过 sdkmanager 安装指定版本的NDK"></a>1.5.4 通过 sdkmanager 安装指定版本的NDK</h4><p>sdkmanager的应用参考《<a href="https://developer.android.com/studio/command-line/sdkmanager">官方文档</a>》<br>常规用法如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 显示可通过sdkmanager安装的软件包或已经安装的软件包,其中--channel后的数值 0 (stable), 1 (beta), 2 (dev), or 3 (canary)</span><br><span class="hljs-string">./sdkmanager</span> <span class="hljs-params">--list</span> <span class="hljs-params">--channel=0</span><br><span class="hljs-comment"># CMake 或 NDK，请使用以下语法：</span><br>sdkmanager <span class="hljs-params">--install</span><br>       [<span class="hljs-string">&quot;ndk;major.minor.build[suffix]&quot;</span> | <span class="hljs-string">&quot;cmake;major.minor.micro.build&quot;</span>]<br>       [<span class="hljs-params">--channel=channel_id</span>] <span class="hljs-string">//</span> NDK channels: 0 <span class="hljs-params">(stable)</span>, 1 <span class="hljs-params">(beta)</span>, or 3 <span class="hljs-params">(canary)</span><br></code></pre></td></tr></table></figure><p>执行以下命令安装需要的ndk20版</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 安装ndk20.1.5948944版</span><br><span class="hljs-string">./sdkmanager</span> <span class="hljs-params">--install</span> <span class="hljs-string">&quot;ndk;20.1.5948944&quot;</span> <span class="hljs-params">--channel=0</span><br><span class="hljs-comment"># 下一步将显示软件许可协议，输入 y 即可,然后等待下载完毕</span><br><span class="hljs-comment"># 下载完毕后将会在/opt/soft/android/sdk下自动创建licenses、ndk、patcher 等目录</span><br></code></pre></td></tr></table></figure><p>执行以下命令安装需要的cmake3.10.2版</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># 执行完毕后将在<span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/</span>sdk下自动创建cmake目录<br>./sdkmanager --install <span class="hljs-string">&quot;cmake;3.10.2.4988404&quot;</span>  --channel=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="1-6-通过-gradle-编译mydns"><a href="#1-6-通过-gradle-编译mydns" class="headerlink" title="1.6. 通过 gradle 编译mydns"></a>1.6. 通过 gradle 编译mydns</h3><p>此步骤目的主要是执行gradle 编译指令，由gradle自动获取编译mydns时需要的各种依赖工具，相关的依赖工具内容会存储在当前用户根目录的.gradle目录下，后面需要把这些依赖工具打到制作的docker镜像中</p><h4 id="1-6-1-拉取-mydns-代码"><a href="#1-6-1-拉取-mydns-代码" class="headerlink" title="1.6.1 拉取 mydns 代码"></a>1.6.1 拉取 mydns 代码</h4><p>此内容只适合与首次获取代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone ssh:<span class="hljs-regexp">//gi</span>t@gitlab.qqqqq.domain:<span class="hljs-number">10022</span><span class="hljs-regexp">/edge-cloud/my</span>dns.git <br>cd mydns<br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure><h4 id="1-6-2-通过-gradle-编译mydns及其依赖的子项目"><a href="#1-6-2-通过-gradle-编译mydns及其依赖的子项目" class="headerlink" title="1.6.2 通过 gradle 编译mydns及其依赖的子项目"></a>1.6.2 通过 gradle 编译mydns及其依赖的子项目</h4><h5 id="1-6-2-1替换gradle编译时依赖的sdk-dir和ndk-dir目录"><a href="#1-6-2-1替换gradle编译时依赖的sdk-dir和ndk-dir目录" class="headerlink" title="1.6.2.1替换gradle编译时依赖的sdk.dir和ndk.dir目录"></a>1.6.2.1替换gradle编译时依赖的sdk.dir和ndk.dir目录</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo -e <span class="hljs-string">&quot;sdk.dir=$&#123;ANDROID_SDK_ROOT&#125;\nndk.dir=$&#123;ANDROID_SDK_ROOT&#125;/ndk/20.1.5948944&quot;</span> &gt; .<span class="hljs-regexp">/third-party/</span>acl<span class="hljs-regexp">/android/</span>acl_c++_shared/local.properties<br>echo -e <span class="hljs-string">&quot;sdk.dir=$&#123;ANDROID_SDK_ROOT&#125;\nndk.dir=$&#123;ANDROID_SDK_ROOT&#125;/ndk/20.1.5948944&quot;</span> &gt; .<span class="hljs-regexp">/third-party/m</span>bedtls-<span class="hljs-number">2.7</span>.<span class="hljs-number">12</span><span class="hljs-regexp">/android/m</span>bedtls_c++shared/local.properties<br>echo -e <span class="hljs-string">&quot;sdk.dir=$&#123;ANDROID_SDK_ROOT&#125;\nndk.dir=$&#123;ANDROID_SDK_ROOT&#125;/ndk/20.1.5948944&quot;</span> &gt; src<span class="hljs-regexp">/android/</span>dns_c++shared/local.properties<br></code></pre></td></tr></table></figure><h5 id="1-6-2-2-使用gradle-编译-acl"><a href="#1-6-2-2-使用gradle-编译-acl" class="headerlink" title="1.6.2.2 使用gradle 编译 acl"></a>1.6.2.2 使用gradle 编译 acl</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd .<span class="hljs-regexp">/third-party/</span>acl<span class="hljs-regexp">/android/</span>acl_c++_shared/<br><span class="hljs-comment"># 执行gradle编译</span><br>gradle build<br><span class="hljs-comment"># 执行完毕后回到mydns根目录</span><br>cd -<br></code></pre></td></tr></table></figure><h5 id="1-6-2-3-使用gradle-编译-mbedtls"><a href="#1-6-2-3-使用gradle-编译-mbedtls" class="headerlink" title="1.6.2.3 使用gradle 编译 mbedtls"></a>1.6.2.3 使用gradle 编译 mbedtls</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd third-party<span class="hljs-regexp">/mbedtls-2.7.12/</span>android<span class="hljs-regexp">/mbedtls_c++shared/</span><br><span class="hljs-comment"># 执行gradle编译</span><br>gradle build<br><span class="hljs-comment"># 执行完毕后回到mydns根目录</span><br>cd -<br></code></pre></td></tr></table></figure><h5 id="1-6-2-4-使用gradle-编译-libdns"><a href="#1-6-2-4-使用gradle-编译-libdns" class="headerlink" title="1.6.2.4 使用gradle 编译 libdns"></a>1.6.2.4 使用gradle 编译 libdns</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd src<span class="hljs-regexp">/android/</span>dns_c++shared<span class="hljs-regexp">/libdns/</span><br><span class="hljs-comment"># 执行gradle编译</span><br>gradle build<br><span class="hljs-comment"># 执行完毕后回到mydns根目录</span><br>cd -<br></code></pre></td></tr></table></figure><h5 id="1-6-2-5-使用gradle-编译-libqnet"><a href="#1-6-2-5-使用gradle-编译-libqnet" class="headerlink" title="1.6.2.5 使用gradle 编译 libqnet"></a>1.6.2.5 使用gradle 编译 libqnet</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd src<span class="hljs-regexp">/android/</span>dns_c++shared/libqnet<br><span class="hljs-comment"># 执行gradle编译</span><br>gradle build<br><span class="hljs-comment"># 执行完毕后回到mydns根目录</span><br>cd -<br></code></pre></td></tr></table></figure><h5 id="1-6-2-6-使用gradle-编译-mydns"><a href="#1-6-2-6-使用gradle-编译-mydns" class="headerlink" title="1.6.2.6 使用gradle 编译 mydns"></a>1.6.2.6 使用gradle 编译 mydns</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd src<span class="hljs-regexp">/android/</span>dns_c++shared/mydns<br><span class="hljs-comment"># 执行gradle编译</span><br>gradle build<br><span class="hljs-comment"># 执行完毕后回到mydns根目录</span><br>cd -<br></code></pre></td></tr></table></figure><h3 id="1-7-拷贝gradle缓存目录到docker-镜像制作目录"><a href="#1-7-拷贝gradle缓存目录到docker-镜像制作目录" class="headerlink" title="1.7 拷贝gradle缓存目录到docker 镜像制作目录"></a>1.7 拷贝gradle缓存目录到docker 镜像制作目录</h3><p>因为计划将dockerfile中的COPY命令的context设置在/opt/soft/android目录下，便于生成镜像时拷贝相关目录文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -r ~<span class="hljs-regexp">/.gradle /</span>opt<span class="hljs-regexp">/soft/</span>android<br></code></pre></td></tr></table></figure><h3 id="1-8-异常及解决方法"><a href="#1-8-异常及解决方法" class="headerlink" title="1.8 异常及解决方法"></a>1.8 异常及解决方法</h3><ul><li>编译 libdns 时  <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&gt; Task :libdns:lint FAILED<br><br><span class="hljs-keyword">FAILURE: </span>Build failed with an exception.<br><br>* What went wrong:<br>Execution failed for task &#x27;:libdns:lint&#x27;.<br>&gt; Could not resolve all artifacts for configuration &#x27;:libdns:debugAndroidTestRuntimeClasspath&#x27;.<br>&gt; Could not download hamcrest-core.jar (org.hamcrest:hamcrest-core:1.3)<br>&gt; Could not get resource &#x27;https://jcenter.bintray.com/org/hamcrest/hamcrest-core/1.3/hamcrest-core<span class="hljs-string">-1</span>.3.jar&#x27;.<br>&gt; Could not HEAD &#x27;https://jcenter.bintray.com/org/hamcrest/hamcrest-core/1.3/hamcrest-core<span class="hljs-string">-1</span>.3.jar&#x27;.<br>&gt; Read timed out<br><br></code></pre></td></tr></table></figure>  解决方法  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">方法<span class="hljs-number">1</span> 通过再次执行gradle build  有可能会下载成功<br>方法<span class="hljs-number">2</span> 修改当前目录下的build.gradle 文件，使用阿里镜像 未验证此方法<br>参考 《[如何用gradle配置国内阿里云镜像源](https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/yizhuanlu9607/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">96971042</span>)》<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-编写-dockerfile"><a href="#2-编写-dockerfile" class="headerlink" title="2 编写 dockerfile"></a>2 编写 dockerfile</h2><p>vim /opt/soft/android/dockerfile 文件中的内容如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM docker-registry.qqqqq.virtual<span class="hljs-regexp">/library/</span>centos7:<span class="hljs-number">7</span>-iqqqqq-<span class="hljs-number">13</span><br><br>RUN yum install -y java-<span class="hljs-number">1.8</span>.<span class="hljs-number">0</span>-openjdk-devel.x86_64 which git zip unzip <br><br>COPY .<span class="hljs-regexp">/gradle /</span>opt<span class="hljs-regexp">/soft/</span>android/gradle<br>COPY .<span class="hljs-regexp">/sdk /</span>opt<span class="hljs-regexp">/soft/</span>android/sdk<br>COPY <span class="hljs-regexp">/.gradle /</span>root/.gradle<br>ENV ANDROID_SDK_ROOT=<span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/</span>sdk<br>ENV ANDROID_HOME=<span class="hljs-variable">$ANDROID_SDK_ROOT</span><br>ENV GRADLE_HOME=<span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/g</span>radle/gradle-<span class="hljs-number">4</span>\.<span class="hljs-number">10</span>\.<span class="hljs-number">1</span><br>ENV PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$ANDROID_HOME</span><span class="hljs-regexp">/tools:$ANDROID_HOME/</span>platform-tools:<span class="hljs-variable">$GRADLE_HOME</span><span class="hljs-regexp">/bin:$ANDROID_SDK_ROOT/</span>ndk<span class="hljs-regexp">/20\.1\.5948944/</span>toolchains<span class="hljs-regexp">/aarch64-linux-android-4\.9/</span>prebuilt<span class="hljs-regexp">/linux-x86_64/</span>bin:<span class="hljs-variable">$ANDROID_SDK_ROOT</span><span class="hljs-regexp">/ndk/</span><span class="hljs-number">20</span>\.<span class="hljs-number">1</span>\.<span class="hljs-number">5948944</span><span class="hljs-regexp">/toolchains/</span>arm-linux-androideabi-<span class="hljs-number">4</span>\.<span class="hljs-number">9</span><span class="hljs-regexp">/prebuilt/</span>linux-x86_64<span class="hljs-regexp">/bin:$ANDROID_SDK_ROOT/</span>ndk<span class="hljs-regexp">/20\.1\.5948944/</span>toolchains<span class="hljs-regexp">/x86-4\.9/</span>prebuilt<span class="hljs-regexp">/linux-x86_64/</span>bin<br></code></pre></td></tr></table></figure><h2 id="3-根据-dockerfile-创建镜像"><a href="#3-根据-dockerfile-创建镜像" class="headerlink" title="3 根据 dockerfile 创建镜像"></a>3 根据 dockerfile 创建镜像</h2><ul><li>创建本地镜像</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/android/</span><br><span class="hljs-comment"># 创建镜像，最后的.不能少</span><br>docker build -t mydns_linux_base:<span class="hljs-number">1.0</span> .<br><span class="hljs-comment"># 查看创建的镜像 mydns_linux_base 版本为1.0</span><br>docker images <br></code></pre></td></tr></table></figure><ul><li>根据新的本地镜像创建一个容器,并验证环境变量和目录的正确性<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">docker run --name test_mydns -it -v <span class="hljs-string">`pwd`</span><span class="hljs-symbol">:/root/workspace</span> --privileged=<span class="hljs-literal">true</span> <span class="hljs-symbol">mydns_linux_base:</span><span class="hljs-number">1.0</span> /bin/bash<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-将创建的镜像推送到远端仓库中"><a href="#4-将创建的镜像推送到远端仓库中" class="headerlink" title="4 将创建的镜像推送到远端仓库中"></a>4 将创建的镜像推送到远端仓库中</h2><h3 id="4-1-创建标签并推送到远端仓库中"><a href="#4-1-创建标签并推送到远端仓库中" class="headerlink" title="4.1 创建标签并推送到远端仓库中"></a>4.1 创建标签并推送到远端仓库中</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 查看新创建的mydns_linux_base本地镜像的id</span><br><span class="hljs-attribute">docker</span> images --filter=reference=&#x27;mydns_linux_base:*&#x27;<br><span class="hljs-comment"># 必须创建新的标签，才能push 到远端。</span><br><span class="hljs-comment"># 如要推送的路径是docker-registry.qqqqq.virtual/edge-cloud/mydns_linux_base 的1.0版，则需要先创建以下标签</span><br><span class="hljs-attribute">docker</span> tag f<span class="hljs-number">234786</span>cc<span class="hljs-number">5</span>f<span class="hljs-number">9</span> docker-registry.qqqqq.virtual/edge-cloud/mydns_linux_base:<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-comment"># 推送到仓库 docker-registry.qqqqq.virtual/edge-cloud/mydns_linux_base 下 标签为1.0</span><br><span class="hljs-attribute">docker</span> push docker-registry.qqqqq.virtual/edge-cloud/mydns_linux_base:<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="4-2-推送镜像查看"><a href="#4-2-推送镜像查看" class="headerlink" title="4.2 推送镜像查看"></a>4.2 推送镜像查看</h3><p>打开 以下网址查看是否有新推的 mydns_linux_base 镜像<br><a href="http://qae.cloud.qqqqq.domain/registry/namespaces/?filter_text=undefined:edge-cloud">http://qae.cloud.qqqqq.domain/registry/namespaces/?filter_text=undefined:edge-cloud</a></p><h3 id="4-3-本地清理及使用获取远端仓库镜像"><a href="#4-3-本地清理及使用获取远端仓库镜像" class="headerlink" title="4.3 本地清理及使用获取远端仓库镜像"></a>4.3 本地清理及使用获取远端仓库镜像</h3><p>推送成功后可以将本地的 mydns_linux_base 进行删除</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 此时本地的 mydns_linux_base和docker-registry.qqqqq.virtual/edge-cloud/mydns_linux_base的id都是 f234786cc5f9</span><br><span class="hljs-comment"># 无法通过 以下命令直接删除</span><br><span class="hljs-attribute">docker</span> rmi f<span class="hljs-number">234786</span>cc<span class="hljs-number">5</span>f<span class="hljs-number">9</span> <br><span class="hljs-comment"># 应该先删除docker tag改名前的镜像，使用镜像名称删除，（一般在docker tag镜像改名后，最好删除改名前的镜像</span><br><span class="hljs-attribute">docker</span> rmi docker-registry.qqqqq.virtual/edge-cloud/mydns_linux_base:<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-comment"># 再执行删除 mydns_linux_base</span><br><span class="hljs-attribute">docker</span> rmi mydns_linux_base:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><h3 id="4-4-异常及解决方法"><a href="#4-4-异常及解决方法" class="headerlink" title="4.4 异常及解决方法"></a>4.4 异常及解决方法</h3><ul><li>push时权限错误  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">The</span> <span class="hljs-string">push</span> <span class="hljs-string">refers</span> <span class="hljs-string">to</span> <span class="hljs-string">repository</span> [<span class="hljs-string">docker-registry.qqqqq.virtual/edge-cloud/mydns_linux_base</span>]<br><span class="hljs-attr">1885a8d3b104:</span> <span class="hljs-string">Preparing</span> <br><span class="hljs-attr">7e0dbba8fe17:</span> <span class="hljs-string">Preparing</span> <br><span class="hljs-attr">6bb0d2c98d31:</span> <span class="hljs-string">Preparing</span> <br><span class="hljs-attr">fd846adc3060:</span> <span class="hljs-string">Preparing</span> <br><span class="hljs-attr">41c37881aa1c:</span> <span class="hljs-string">Preparing</span> <br><span class="hljs-attr">edfc6fdcb211:</span> <span class="hljs-string">Preparing</span> <br><span class="hljs-attr">ddd02f1907f4:</span> <span class="hljs-string">Preparing</span> <br><span class="hljs-attr">a51dabe2037e:</span> <span class="hljs-string">Preparing</span> <br><span class="hljs-attr">129b697f70e9:</span> <span class="hljs-string">Preparing</span><br><span class="hljs-attr">error parsing HTTP 403 response body:</span> <span class="hljs-string">invalid</span> <span class="hljs-string">character</span> <span class="hljs-string">&#x27;T&#x27;</span> <span class="hljs-attr">looking for beginning of value:</span> <span class="hljs-string">&quot;The supplied authentication is not authorized to access this resource&quot;</span><br></code></pre></td></tr></table></figure>  解决方法  <figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 退出docker 当前登录用户，使用有权限的账号进行登录</span><br>docker logout docker-registry.qqqqq.<span class="hljs-keyword">virtual</span><br><span class="hljs-meta"># 从新登陆</span><br>docker login docker-registry.qqqqq.<span class="hljs-keyword">virtual</span><br><br>参考http:<span class="hljs-comment">//docker.gitlab.qqqqq.domain/readme/sample.html</span><br></code></pre></td></tr></table></figure><h1 id="二、-Linux-版从-container-制作-Docker-镜像"><a href="#二、-Linux-版从-container-制作-Docker-镜像" class="headerlink" title="二、 Linux 版从 container 制作 Docker 镜像"></a>二、 Linux 版从 container 制作 Docker 镜像</h1>使用以下命令可以从特定的container直接制作新的镜像</li></ul><p><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] </code></p><p>如: docker commit mycontainer myimage:v1.0</p><h1 id="三、Windows-版编译服务器设置"><a href="#三、Windows-版编译服务器设置" class="headerlink" title="三、Windows 版编译服务器设置"></a>三、Windows 版编译服务器设置</h1><h2 id="3-1-安装必要的依赖软件"><a href="#3-1-安装必要的依赖软件" class="headerlink" title="3.1 安装必要的依赖软件"></a>3.1 安装必要的依赖软件</h2><ol><li><p>安装vs2019、git、curl、7-Zip 到默认的c盘路径下</p></li><li><p>配置环境变量</p> <figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">INCLUDE变量内容<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\W</span>indows Kits<span class="hljs-symbol">\1</span>0<span class="hljs-symbol">\I</span>nclude<span class="hljs-symbol">\1</span>0.0.19041.0<span class="hljs-symbol">\s</span>hared<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\W</span>indows Kits<span class="hljs-symbol">\1</span>0<span class="hljs-symbol">\I</span>nclude<span class="hljs-symbol">\1</span>0.0.19041.0<span class="hljs-symbol">\u</span>crt<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\W</span>indows Kits<span class="hljs-symbol">\1</span>0<span class="hljs-symbol">\I</span>nclude<span class="hljs-symbol">\1</span>0.0.19041.0<span class="hljs-symbol">\u</span>m<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\W</span>indows Kits<span class="hljs-symbol">\1</span>0<span class="hljs-symbol">\I</span>nclude<span class="hljs-symbol">\1</span>0.0.19041.0<span class="hljs-symbol">\w</span>inrt<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\M</span>icrosoft Visual Studio<span class="hljs-symbol">\2</span>019<span class="hljs-symbol">\C</span>ommunity<span class="hljs-symbol">\V</span>C<span class="hljs-symbol">\T</span>ools<span class="hljs-symbol">\M</span>SVC<span class="hljs-symbol">\1</span>4.29.30037<span class="hljs-symbol">\i</span>nclude<br><br>LIB变量内容<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\M</span>icrosoft Visual Studio<span class="hljs-symbol">\2</span>019<span class="hljs-symbol">\C</span>ommunity<span class="hljs-symbol">\V</span>C<span class="hljs-symbol">\T</span>ools<span class="hljs-symbol">\M</span>SVC<span class="hljs-symbol">\1</span>4.29.30037<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\x</span>86<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\W</span>indows Kits<span class="hljs-symbol">\1</span>0<span class="hljs-symbol">\L</span>ib<span class="hljs-symbol">\1</span>0.0.19041.0<span class="hljs-symbol">\u</span>crt<span class="hljs-symbol">\x</span>86<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\W</span>indows Kits<span class="hljs-symbol">\1</span>0<span class="hljs-symbol">\L</span>ib<span class="hljs-symbol">\1</span>0.0.19041.0<span class="hljs-symbol">\u</span>m<span class="hljs-symbol">\x</span>86<br><br>PATH变量内容<br>C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\c</span>loudbase-init<span class="hljs-symbol">\c</span>url<span class="hljs-symbol">\c</span>url-7.76.1-win64-mingw<span class="hljs-symbol">\b</span>in<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\M</span>icrosoft Visual Studio<span class="hljs-symbol">\2</span>019<span class="hljs-symbol">\C</span>ommunity<span class="hljs-symbol">\M</span>SBuild<span class="hljs-symbol">\C</span>urrent<span class="hljs-symbol">\B</span>in<br>C:<span class="hljs-symbol">\P</span>rogram Files (x86)<span class="hljs-symbol">\M</span>icrosoft Visual Studio<span class="hljs-symbol">\2</span>019<span class="hljs-symbol">\C</span>ommunity<span class="hljs-symbol">\V</span>C<span class="hljs-symbol">\T</span>ools<span class="hljs-symbol">\M</span>SVC<span class="hljs-symbol">\1</span>4.29.30037<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\H</span>ostx86<span class="hljs-symbol">\x</span>86<br>C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\G</span>it<span class="hljs-symbol">\c</span>md<br>C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\7</span>-Zip<br></code></pre></td></tr></table></figure></li><li><p>生成本机的sshkey<br> 因为在部署git的时候已经默认安装了ssh-keygen工具，所以直接在命令窗口执行ssh-keygen工具生成本机的ssh秘钥即可</p></li><li><p>在mydns项目中添加本机的sshkey<br> 将上一步生成的公钥添加到 mydns/settings/repository 下的 <code>Deploy Keys</code> 中即可</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树的几种实现方式以及应用(转载)</title>
    <link href="/2023/11/29/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8(%E8%BD%AC%E8%BD%BD)/"/>
    <url>/2023/11/29/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8(%E8%BD%AC%E8%BD%BD)/</url>
    
    <content type="html"><![CDATA[<p>本文转自 <a href="http://jiangzhuti.me/posts/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8">http://jiangzhuti.me/posts/%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8</a></p><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>字典树(Trie)这一概念有时候会跟基数树(Radix Tree)、前缀树(Prefix Tree)等混用。其中前缀树、字典树是从字符串存储角度的称呼，基数树更多是从数值(多为二进制)角度的称呼，可以看作广义的字典树。以下以字典树来统称字典树和基数树。</p><p>关于字典树的介绍，前面的文章有一个直观的介绍，也不多赘述。</p><h2 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h2><table><thead><tr><th>数据结构</th><th>增加</th><th>删除</th><th>精确查找</th><th>极值查找</th><th>顺序遍历</th><th>前缀遍历</th><th>数据约束</th></tr></thead><tbody><tr><td>哈希表</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td>哈希函数;等于比较</td></tr><tr><td>堆</td><td>√</td><td>√</td><td></td><td>√</td><td></td><td></td><td>小于比较</td></tr><tr><td>平衡树</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>小于比较</td></tr><tr><td>字典树</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td>二进制比较(字符比较)</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="基础版本字典树的特点："><a href="#基础版本字典树的特点：" class="headerlink" title="基础版本字典树的特点："></a>基础版本字典树的特点：</h2><ul><li>查询时间只和key长度有关，和树中的节点数量无关</li><li>设每个字符长度是s bits，一个key长度是k bits，最多只需要比较k / s个node</li></ul><h2 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h2><ul><li>基本只适用于基本数据(整数，字符串、二进制串)</li><li>很难像哈希表或者平衡树那样，通过自定义哈希函数或者比较函数来存储自定义类型</li></ul><h2 id="字典树的优化方向："><a href="#字典树的优化方向：" class="headerlink" title="字典树的优化方向："></a>字典树的优化方向：</h2><ul><li>减少内存overhead(减少节点大小、分支数量、节点层数)</li><li>缓存友好</li></ul><h1 id="常规优化"><a href="#常规优化" class="headerlink" title="常规优化"></a>常规优化</h1><p>还是主要参见前面介绍HAT的文章。主要有:</p><ul><li>字母表缩减。可以看作基数树换用更小的基数。代价是树的深度变大，速度慢。</li><li>使用关联容器。代价是每次索引运算量增大。</li><li>压缩字典树。把只有一个分叉的节点，连同其唯一的孩子，结合成一个节点。可以通过插入过程中分裂节点来实现：</li></ul><img src="/2023/11/29/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8(%E8%BD%AC%E8%BD%BD)/trie-compress.png" class=""><h1 id="PATRICIA-trie及其变体"><a href="#PATRICIA-trie及其变体" class="headerlink" title="PATRICIA trie及其变体"></a>PATRICIA trie及其变体</h1><h2 id="PATRICIA-trie"><a href="#PATRICIA-trie" class="headerlink" title="PATRICIA trie"></a>PATRICIA trie</h2><p>是一种特殊的字典树，每个中间节点记录key之间公共前缀的位置。从此位置之后，key之间产生不同，根据接下来的不同字符，转到不同的子分支。</p><h2 id="Critial-Bit-trie"><a href="#Critial-Bit-trie" class="headerlink" title="Critial Bit trie"></a>Critial Bit trie</h2><p>从基数树的角度看，PATRICIA trie最简单的一个实现是二进制的，即Critial Bit trie(cb trie)。critical bit的意思是两个串共同前缀分叉之处的比特。参见: <a href="https://cr.yp.to/critbit.html">https://cr.yp.to/critbit.html</a> (这个作者对cb trie的吹捧，说实话有点过了)。</p><h3 id="两种节点类型："><a href="#两种节点类型：" class="headerlink" title="两种节点类型："></a>两种节点类型：</h3><ul><li>中间节点：存储critical-bit的位置，以及左右两个子树</li><li>叶子结点：存储整个串</li></ul><p>构造流程（采用网上某个介绍进行了修改）：</p><figure class="highlight prolog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><pre><code class="hljs prolog">        empty   -- initial state<br><br>---------------------------------------------------<br><br>       <span class="hljs-number">01234</span>    -- number bit positions<br>insert <span class="hljs-number">01011</span>    -- the key<br><br><br>result root ----&gt; <span class="hljs-number">01011</span><br><br>---------------------------------------------------<br><br>insert <span class="hljs-number">01010</span><br>    search ends at <span class="hljs-number">01011</span>~=<span class="hljs-number">01010</span>;<br>    <span class="hljs-number">1</span>st difference is at position <span class="hljs-number">4</span>, so...<br><br>result root ----&gt; [<span class="hljs-number">4</span>]    -- i.e. test position #<span class="hljs-number">4</span><br>                 .   .<br>               <span class="hljs-number">0.</span>     <span class="hljs-number">.1</span><br>              .        .<br>           <span class="hljs-number">01010</span>     <span class="hljs-number">01001</span><br><br>---------------------------------------------------<br><br>insert <span class="hljs-number">10</span><br>    has no position #<span class="hljs-number">4</span>;<br>    can skip key positions but must test in order, so...<br><br>result root ----&gt; [<span class="hljs-number">0</span>]    -- i.e. test position #<span class="hljs-number">0</span><br>                 .   .<br>               <span class="hljs-number">0.</span>     <span class="hljs-number">.1</span><br>              .        .<br>           [<span class="hljs-number">4</span>]          <span class="hljs-number">10</span><br>          .   .<br>        <span class="hljs-number">0.</span>     <span class="hljs-number">.1</span><br>       .         .<br>     <span class="hljs-number">01010</span>      <span class="hljs-number">01011</span><br><br>---------------------------------------------------<br><br>insert <span class="hljs-number">000110</span>;<br>    search ends at <span class="hljs-number">01011</span>~=<span class="hljs-number">000110</span>;<br>    can skip key positions but must test in order, so...<br><br>result root ----&gt; [<span class="hljs-number">0</span>]<br>                 .   .<br>               <span class="hljs-number">0.</span>     <span class="hljs-number">.1</span><br>              .        .<br>           [<span class="hljs-number">1</span>]          <span class="hljs-number">10</span><br>          .   .<br>        <span class="hljs-number">0.</span>     <span class="hljs-number">.1</span><br>       .         .<br>    <span class="hljs-number">000110</span>       [<span class="hljs-number">4</span>]<br>                .   .<br>              <span class="hljs-number">0.</span>     <span class="hljs-number">.1</span><br>             .         .<br>            <span class="hljs-number">01010</span>     <span class="hljs-number">01011</span><br><br>---------------------------------------------------<br><br>insert <span class="hljs-number">01</span>;<br>    <span class="hljs-number">01</span> is also a prefix of <span class="hljs-number">01010</span> and <span class="hljs-number">01011</span>;<br>    must have ability to terminate at an intermediate node, as with <span class="hljs-symbol">Tries</span>.<br>result root ----&gt; [<span class="hljs-number">0</span>]<br>                 .   .<br>               <span class="hljs-number">0.</span>     <span class="hljs-number">.1</span><br>              .        .<br>           [<span class="hljs-number">1</span>]          <span class="hljs-number">10</span><br>          .   .<br>        <span class="hljs-number">0.</span>     <span class="hljs-number">.1</span><br>       .         .<br>    <span class="hljs-number">000110</span>       [<span class="hljs-number">2</span>] ---&gt; <span class="hljs-number">01</span><br>                  .<br>                 <span class="hljs-number">0.</span><br>                  .<br>                 [<span class="hljs-number">4</span>]<br>                .   .<br>              <span class="hljs-number">0.</span>      <span class="hljs-number">.1</span><br>             .          .<br>          <span class="hljs-number">01010</span>        <span class="hljs-number">01011</span><br></code></pre></td></tr></table></figure><h2 id="quelques-bits-popcount-trie"><a href="#quelques-bits-popcount-trie" class="headerlink" title="quelques-bits popcount trie"></a>quelques-bits popcount trie</h2><p>为了减少cb trie的深度，采用4比特一组进行比较。即，基数树以2的4次方等于16为基数。二叉树-&gt;16叉树。同时，采用了位运算来压缩数组，减少了节点大小。quelques-bits popcount trie简写为QP Trie. 参见： <a href="https://dotat.at/prog/qp/README.html">https://dotat.at/prog/qp/README.html</a></p><p>构造过程和CB Trie类似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust">insert keys:<br><br><span class="hljs-string">&quot;foo&quot;</span> -&gt; hex <span class="hljs-built_in">str</span>: <span class="hljs-string">&quot;6 6 6 f 6 f&quot;</span><br><span class="hljs-string">&quot;bar&quot;</span> -&gt; hex <span class="hljs-built_in">str</span>: <span class="hljs-string">&quot;6 2 6 1 7 2&quot;</span><br><span class="hljs-string">&quot;baz&quot;</span> -&gt; hex <span class="hljs-built_in">str</span>: <span class="hljs-string">&quot;6 2 6 1 7 a&quot;</span><br><span class="hljs-string">&quot;hax&quot;</span> -&gt; hex <span class="hljs-built_in">str</span>: <span class="hljs-string">&quot;6 8 6 1 7 8&quot;</span><br><br>result root ----&gt;           [<span class="hljs-number">1</span>]<br>                          .  .  .<br>                        <span class="hljs-number">2</span>.  <span class="hljs-number">6</span>.   <span class="hljs-number">8</span>. ---&gt; <span class="hljs-string">&quot;hax&quot;</span><br>                        .    .<br>                       [<span class="hljs-number">5</span>]   . ---&gt; <span class="hljs-string">&quot;foo&quot;</span><br>                      .   .<br>                    <span class="hljs-number">2</span>.      .a<br>         <span class="hljs-string">&quot;bar&quot;</span> &lt;--- .         .---&gt; <span class="hljs-string">&quot;baz&quot;</span><br></code></pre></td></tr></table></figure><p>减少空间占用：用位图压缩子树数组</p><p>以此为例：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs excel">                            [<span class="hljs-number">1</span>]<br>                          .  .  .<br>                        <span class="hljs-number">2</span>.  <span class="hljs-number">6</span>.   <span class="hljs-number">8</span>. ---&gt; <span class="hljs-string">&quot;hax&quot;</span><br><br>该节点保存有位图<span class="hljs-symbol">:</span><br>bitm<span class="hljs-symbol">ap:</span> <span class="hljs-number">0000000101000100</span><br>ind<span class="hljs-symbol">ex:</span>  fedcba9876543210<br><br>正常情况我们需要一个大小为<span class="hljs-number">16</span>的数组，其下标<span class="hljs-number">2</span>、<span class="hljs-number">6</span>、<span class="hljs-number">8</span>分别指向对应的子数。<br>我们压缩子树数组为：<br>vector[<span class="hljs-number">3</span>]<br>映射：<br>vector[<span class="hljs-number">0</span>] -&gt; &#x27;<span class="hljs-number">2</span>&#x27;所在子树<br>vector[<span class="hljs-number">1</span>] -&gt; &#x27;<span class="hljs-number">6</span>&#x27;所在子树<br>vector[<span class="hljs-number">2</span>] -&gt; &#x27;<span class="hljs-number">8</span>&#x27;所在子树<br><br><br>查询算法：<br>设要查询i位置的子树，<br><br>mask = <span class="hljs-number">1</span> &lt;&lt; i;<br><span class="hljs-built_in">if</span>(bitmap &amp; mask)<br>    member = vector[popcount(bitmap &amp; mask-<span class="hljs-number">1</span>)]<br><br>例如i = <span class="hljs-number">8</span>,<br><br>popcount(bitmap &amp; mask - <span class="hljs-number">1</span>) = popcount(<span class="hljs-number">0000000101000100</span> &amp; <span class="hljs-number">0000000001111111</span>)<br>= popcount(<span class="hljs-number">0000000001000100</span>)<br>= <span class="hljs-number">2</span><br><br>因此vector[<span class="hljs-number">2</span>]就是&#x27;<span class="hljs-number">8</span>&#x27;所在的子树<br></code></pre></td></tr></table></figure><h2 id="HAT-trie"><a href="#HAT-trie" class="headerlink" title="HAT trie"></a>HAT trie</h2><p>参见前面关于HAT trie的文章。</p><h2 id="Adaptive-Radix-Tree"><a href="#Adaptive-Radix-Tree" class="headerlink" title="Adaptive Radix Tree"></a>Adaptive Radix Tree</h2><p>自适应的基数树。Adaptive Radix Tree。参见: <a href="https://db.in.tum.de/~leis/papers/ART.pdf">https://db.in.tum.de/~leis/papers/ART.pdf</a></p><p>存在4种不同类型和大小的节点。根据实际某个节点的子树数量，自适应的改变node类型：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">union Node &#123;<br>    Node4* n4<span class="hljs-comment">;</span><br>    Node16* n16<span class="hljs-comment">;</span><br>    Node48* n48<span class="hljs-comment">;</span><br>    Node256* n256<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于其如何存储k-v，这里不作介绍。</p><p>Node4<br>因为子树数量较少，直接for循环比较查找子树：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct Node4 &#123;<br>    char child_keys[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">Node</span><span class="hljs-title">* child_pointers</span>[<span class="hljs-number">4</span>];<br>&#125;<br><br><span class="hljs-keyword">Node</span><span class="hljs-title">* find_child</span>(char c, Node4* <span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">    Node</span>* ret = NULL;<br>    for (int i = <span class="hljs-number">0</span>; i <span class="hljs-tag">&lt; 4; ++i) &#123;</span><br><span class="hljs-tag">        if (child_keys[i] == c) ret = node-&gt;</span>child_pointers[i];<br>    &#125;<br><br>    return ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>Node16</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct Node16 &#123;<br>    char child_keys[<span class="hljs-number">16</span>]<span class="hljs-comment">;</span><br>    Node* child_pointers[<span class="hljs-number">16</span>]<span class="hljs-comment">;</span><br>    byte num_children<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以采用SIMD进行并行加速查找：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Find the child in `node` that matches `c` by examining all child nodes, in parallel.</span><br>Node* find<span class="hljs-constructor">_child(<span class="hljs-params">char</span> <span class="hljs-params">c</span>, Node16<span class="hljs-operator">*</span> <span class="hljs-params">node</span>)</span> &#123;<br>    <span class="hljs-comment">// key_vec is 16 repeated copies of the searched-for byte, one for every possible position</span><br>    <span class="hljs-comment">// in child_keys that needs to be searched.</span><br>    __mm128i key_vec = <span class="hljs-constructor">_mm_set1_epi8(<span class="hljs-params">c</span>)</span>;<br><br>    <span class="hljs-comment">// Compare all child_keys to &#x27;c&#x27; in parallel. Don&#x27;t worry if some of the keys aren&#x27;t valid,</span><br>    <span class="hljs-comment">// we&#x27;ll mask the results to only consider the valid ones below.</span><br>    __mm128i results = <span class="hljs-constructor">_mm_cmpeq_epi8(<span class="hljs-params">key_vec</span>, <span class="hljs-params">node</span>-&gt;<span class="hljs-params">child_keys</span>)</span>;<br><br>    <span class="hljs-comment">// Build a mask to select only the first node-&gt;num_children values from the comparison</span><br>    <span class="hljs-comment">// (because the other values are meaningless)</span><br>    <span class="hljs-built_in">int</span> mask = (<span class="hljs-number">1</span> &lt;&lt; node-&gt;num_children) - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// Change the results of the comparison into a bitfield, masking off any invalid comparisons.</span><br>    <span class="hljs-built_in">int</span> bitfield = <span class="hljs-constructor">_mm_movemask_epi8(<span class="hljs-params">results</span>)</span> &amp; mask;<br><br>    <span class="hljs-comment">// No match if there are no &#x27;1&#x27;s in the bitfield.</span><br>    <span class="hljs-keyword">if</span> (bitfield<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) return NULL;<br><br>    <span class="hljs-comment">// Find the index of the first &#x27;1&#x27; in the bitfield by counting the leading zeros.</span><br>    <span class="hljs-built_in">int</span> idx = ctz(bitfield);<br><br>    return node-&gt;child_pointers<span class="hljs-literal">[<span class="hljs-identifier">idx</span>]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Node48</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">struct Node48 &#123;<br>    <span class="hljs-comment">// Indexed by the key value, i.e. the child pointer for &#x27;f&#x27;</span><br>    <span class="hljs-comment">// is at child_ptrs[child_ptr_indexes[&#x27;f&#x27;]]</span><br>    char child_ptr_indexes<span class="hljs-selector-attr">[256]</span>;<br><br>    Node* child_ptrs<span class="hljs-selector-attr">[48]</span>;<br>    char num_children;<br>&#125;<br></code></pre></td></tr></table></figure><p>48个子树的数量，遍历等查找较慢，此时做了一个空间和查找速度的折中（可以对比Node256）。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span><span class="hljs-title">* find_child</span>(char c, Node48* <span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">    int</span> idx = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;child_ptr_indexes</span>[c];<br>    if (idx == -<span class="hljs-number">1</span>) return NULL;<br><br>    return <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;child_ptrs</span>[idx];<br>&#125;<br></code></pre></td></tr></table></figure><p>Node256<br>这个就是最原始的做法</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct Node256 &#123;<br>    <span class="hljs-keyword">Node</span><span class="hljs-title">* child_ptrs</span>[<span class="hljs-number">256</span>];<br>&#125;<br><br><span class="hljs-keyword">Node</span><span class="hljs-title">* find_child</span>(char c, Node256* <span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">    return</span> child_ptrs[c];<br>&#125;<br></code></pre></td></tr></table></figure><p>两种优化措施<br>两种优化：延迟展开、路径压缩，基本类似于最前面讲到的压缩字典树。</p><h1 id="字典树的应用"><a href="#字典树的应用" class="headerlink" title="字典树的应用"></a>字典树的应用</h1><p>字典树的应用也是非常广泛，这里举几个有代表性的例子，以后有时间会增加更多例子，以及对某些场景做进一步分析学习。</p><p>DNS(域名数据库、IP地址库)<br>DNS服务器中，通常有两个地方用到字典树：域名数据库和IP地址库。</p><p>互联网中的域名是一个层级结构的字符串，天生适合用字典树存储：</p><img src="/2023/11/29/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8(%E8%BD%AC%E8%BD%BD)/trie-dname.png" class=""><ul><li><p>在Knot DNS Server中，采用了QP Trie作为域名的存储方案：<a href="https://github.com/CZ-NIC/knot/tree/master/src/contrib/qp-trie">https://github.com/CZ-NIC/knot/tree/master/src/contrib/qp-trie</a> (早些时候的版本采用的是HAT trie)。</p></li><li><p>IP地址库，一般由许多条IP地址段(CIDR), 位置(地理区域，服务商)的记录组成。在权威DNS服务器中，用作EDNS进行基于地理位置的解析(geoip); 在Cache DNS中，用于缓存各权威服务的地址段。</p></li><li><p>在Knot中采用的QP trie实现了权威服务的<a href="https://github.com/CZ-NIC/knot/blob/master/src/knot/modules/geoip/geoip.c">geoip</a></p></li><li><p>在Unbound中，采用类似CB trie做了<a href="https://github.com/NLnetLabs/unbound/blob/master/edns-subnet/addrtree.c">EDNS缓存</a></p></li><li><p>路由表<br>路由表的存储、查找算法，经过持续不断的优化，目前可以说五花八门。由于路由表的特性，基于字典树的实现是其中有代表性的一大类。目前linux系统可以查看到按字典树组织路由表：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ cat /proc/net/fib_trie<br>Main:<br>  +-- <span class="hljs-number">0.0.0.0</span>/<span class="hljs-number">0 3 0 5</span><br>     |-- <span class="hljs-number">0.0.0.0</span><br>        /<span class="hljs-number">0</span> universe UNICAST<br>     +-- <span class="hljs-number">127.0.0.0</span>/<span class="hljs-number">8 2 0 2</span><br>        +-- <span class="hljs-number">127.0.0.0</span>/<span class="hljs-number">31 1 0 0</span><br>           |-- <span class="hljs-number">127.0.0.0</span><br>              /<span class="hljs-number">32</span> link BROADCAST<br>              /<span class="hljs-number">8</span> host LOCAL<br>           |-- <span class="hljs-number">127.0.0.1</span><br>              /<span class="hljs-number">32</span> host LOCAL<br>        |-- <span class="hljs-number">127.255.255.255</span><br>           /<span class="hljs-number">32</span> link BROADCAST<br>     +-- <span class="hljs-number">192.168.2.0</span>/<span class="hljs-number">24 2 0 1</span><br>        |-- <span class="hljs-number">192.168.2.0</span><br>           /<span class="hljs-number">32</span> link BROADCAST<br>           /<span class="hljs-number">24</span> link UNICAST<br>        |-- <span class="hljs-number">192.168.2.110</span><br>           /<span class="hljs-number">32</span> host LOCAL<br>        |-- <span class="hljs-number">192.168.2.255</span><br>           /<span class="hljs-number">32</span> link BROADCAST<br>Local:<br>  +-- <span class="hljs-number">0.0.0.0</span>/<span class="hljs-number">0 3 0 5</span><br>     |-- <span class="hljs-number">0.0.0.0</span><br>        /<span class="hljs-number">0</span> universe UNICAST<br>     +-- <span class="hljs-number">127.0.0.0</span>/<span class="hljs-number">8 2 0 2</span><br>        +-- <span class="hljs-number">127.0.0.0</span>/<span class="hljs-number">31 1 0 0</span><br>           |-- <span class="hljs-number">127.0.0.0</span><br>              /<span class="hljs-number">32</span> link BROADCAST<br>              /<span class="hljs-number">8</span> host LOCAL<br>           |-- <span class="hljs-number">127.0.0.1</span><br>              /<span class="hljs-number">32</span> host LOCAL<br>        |-- <span class="hljs-number">127.255.255.255</span><br>           /<span class="hljs-number">32</span> link BROADCAST<br>     +-- <span class="hljs-number">192.168.2.0</span>/<span class="hljs-number">24 2 0 1</span><br>        |-- <span class="hljs-number">192.168.2.0</span><br>           /<span class="hljs-number">32</span> link BROADCAST<br>           /<span class="hljs-number">24</span> link UNICAST<br>        |-- <span class="hljs-number">192.168.2.110</span><br>           /<span class="hljs-number">32</span> host LOCAL<br>        |-- <span class="hljs-number">192.168.2.255</span><br>           /<span class="hljs-number">32</span> link BROADCAST<br></code></pre></td></tr></table></figure></li><li><p>linux IDR<br>使用字典树，维护整数id到指针的映射。</p></li></ul><p>IDR把每一个ID分级数据进行管理，每一级维护着ID的5位数据，这样就可以把IDR分为7级进行管理（5*7=35，维 护的数据大于32位），如下所示：</p><p><code>31 30 | 29 28 27 26 25 | 24 23 22 21 20 | 19 18 17 16 15 | 14 13 12 11 10 | 9 8 7 6 5 | 4 3 2 1 0</code></p><p>例如数据ID为<code>0B 10 11111 10011 00111 11001 100001 00001</code>，寻址如下</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">第一级寻址 ary1[<span class="hljs-number">0b10</span>]得到第二级地址ary2[]<br>ary3 = ary2[<span class="hljs-number">0b11111</span>]<br>ary4 = ary3[<span class="hljs-number">0b10011</span>]<br>ary5 = ary4[<span class="hljs-number">0b00111</span>]<br>ary6 = ary5[<span class="hljs-number">0b11001</span>]<br>ary7 = ary6[<span class="hljs-number">0b100001</span>]<br>ary8 = ary7[<span class="hljs-number">0b00001</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HAT-trie,缓存敏感字典树(转载)</title>
    <link href="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/"/>
    <url>/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/</url>
    
    <content type="html"><![CDATA[<p>本文转自<br><a href="http://jiangzhuti.me/posts/%E8%AF%91-HAT-trie,%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91">http://jiangzhuti.me/posts/%E8%AF%91-HAT-trie,%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91</a></p><p>译自: <a href="https://tessil.github.io/2017/06/22/hat-trie.html">https://tessil.github.io/2017/06/22/hat-trie.html</a></p><p>字典树 (也被称为前缀树) 是个有趣的怪物. 字典树是一种存储字符串的树形结构，一个节点的所有后代都共享相同的前缀. 这种结构可以进行快速的前缀查找, 例如查找所有以ap为前缀的单次, 并且由于共享前缀的特点，它可以采用紧凑的方式存储字符串.</p><p>跟大多数树形数据结构一样，前缀树的主流实现方法都存在缓存不友好的问题.在前缀节点之间遍历的每一步都可能会造成缓存缺失，这不利于进行快速查找。</p><p>本文中我们结合了传统字典树和缓存敏感哈希表，提出了缓存敏感的字典树：HAT-trie.</p><p>你可以从<a href="https://github.com/Tessil/hat-trie">GitHub</a>中找到 C++ 实现 ，以及一些HAT-trie同其他字典树和关联数据结构的基准测试 .</p><p>接下来的章节, 我们首先更详细的介绍字典树的概念. 然后介绍 burst-trie 以及数组哈希表, 这些是HAT-trie所依赖的中间数据结构. 最后我们讲HAT-trie本身.</p><h1 id="字典树-Trie"><a href="#字典树-Trie" class="headerlink" title="字典树(Trie)"></a>字典树(Trie)</h1><p>字典树是一种树， 每个节点拥有从 0 到 |Σ| 个子节点, 其中 |Σ| 表示字母表 Σ的大小. 对于简单的 ASCII 编码, 每个节点拥有总共 128 个子节点. 对于 UTF-8 编码， 我们可以把每个字符分割成 8比特编码单元， 然后每个节点对应存储每个编码单元，总共拥有 256 个子节点. 希腊字母 α 在 UTF-8编码中使用了两个八位单元, 0xCEB1, 可以存储到两个节点中, 一个子节点是 0xCE 八位员， 另一个子节点是 0xB1 八位元.</p><p>一个节点的全部后继节点共享该节点以及它的全部祖先节点作为字符串前缀.</p><p>没有后继的叶子节点，代表字符串结束。</p><p>接下来用图展示上面这些. 在示例中，我们会用到如下单词:</p><div style="float: left; width: 50%;"><ul><li>romane</li><li>romanes</li><li>romanus</li><li>romulus</li><li>rubens</li></ul></div><div style="float: right; width: 50%;"><ul><li>ruber</li><li>rubes</li><li>rubicon</li><li>rubicundus</li><li>rubric</li></ul></div><p>这些单词构成如下的字典树：</p><img src="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/trie.png" class="" title="&lt;br&gt; 由romane, romanes, romanus, romulus, rubens, ruber, rubes, rubicon, rubicundus 和 rubric构成的字典树."><p>当我们想查找全部以roma开头的单词时，只需要向下遍历这棵树，直到找到所有的前缀字母。然后，我们只需要找出该节点的全部后继叶子节点，在本例中，我们将找出romane, romanes 和 romanus。</p><p>这样的结构实现起来就好象是k叉树一样。</p><p>为了存储孩子节点， 我们可以使用一个大小为 |Σ|(例如128, 在我们的例子中只需要支持 ASCII 编码)的数组。这样实现速度很快，但是内存利用率不高（使用稀疏数组/稀疏表可以减少内存消耗，当然也会变慢一点）。</p><figure class="highlight smali"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs smali">class node &#123;<br>    //<span class="hljs-built_in"> array </span>of 128 elements, null<span class="hljs-built_in"> if </span>there is no child for the ASCII letter.<br>    node* children[128]; <br>&#125;;<br></code></pre></td></tr></table></figure><p>在使用数组的情况下，有一种常见的减少内存占用的方法，叫做字母缩减技巧。我们使用一个包含 16 个字符 (4 比特)的字母表，替代包含256个字符(8比特)的字母表. 我们只需要把八位组切分成两个4位组 (4 比特) ，然后存为一对父子节点 (跟前文所述的 UTF-8 编码单元一样的方法). 更加紧凑，但是路径也会变长 (因此也会有更多潜在的缓存不命中).</p><p>另一种方案是简单的使用一个关联容器， 把一个字母编码单元映射到一个子节点. 如果我们想保持顺序，可以使用二叉搜索树或者有序数组, 否则使用哈希表. 速度更慢但是更紧凑，即使在字母表很大的情况下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">class node &#123;<br>    <span class="hljs-regexp">//</span> C++<br>    <span class="hljs-regexp">//</span> Binary search tree<br>    std::map&lt;char, node*&gt; children;<br>    <br>    <span class="hljs-regexp">//</span> Hash table<br>    <span class="hljs-regexp">//</span> std::unordered_map&lt;char, node*&gt; children;<br>    <br>    <span class="hljs-regexp">//</span> Sorted array<br>    <span class="hljs-regexp">//</span> boost::flat_map&lt;char, node*&gt; children;<br>    <br>    <br>    <span class="hljs-regexp">//</span> Java<br>    <span class="hljs-regexp">//</span> Binary search tree<br>    <span class="hljs-regexp">//</span> TreeMap&lt;char, node&gt; children;<br>    <br>    <span class="hljs-regexp">//</span> Hash table<br>    <span class="hljs-regexp">//</span> HashMap&lt;char, node&gt; children;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们也可以把子节点存入一个链表. 父节点拥有一个指向第一个子节点的指针, 每个子节点有一个指针指向下一个节点 (它的兄弟). 这种情况需要做线性搜索来找到一个子节点. 紧凑，但是很慢.</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class <span class="hljs-keyword">node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">    char</span> symbol;<br>    <span class="hljs-keyword">node</span><span class="hljs-title">* first_child</span>;<br>    <span class="hljs-keyword">node</span><span class="hljs-title">* next_sibiling</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意 我们在图中用空节点作为可视化的标记, 来表示字符串的结束。在一个实际的字典树实现中，可以简单的在字符串末尾字符的节点里设置一个表示结尾的标记。</p><h1 id="压缩字典树"><a href="#压缩字典树" class="headerlink" title="压缩字典树"></a>压缩字典树</h1><p>减少节点大小非常重要, 但是我们也可以尝试减少节点数量，构建一个内存高效的字典树.</p><p>你可能注意到, 在前面画的字典树中, 一些节点构成了可以压缩的链表. 例如单词 rubicundus的结尾由 u -&gt; n -&gt; d -&gt; u -&gt; s 链接而成. 我们可以把这条链压缩成一个 undus 节点， 替代原先的5个节点.</p><img src="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/compressed_trie.png" class="&lt;br&gt;" title="由romane, romanes, romanus, romulus, rubens, ruber, rubes, rubicon, rubicundus 和 rubric构成的压缩字典树."><p>这种链压缩的思想已经被许多基于字典树的数据结构所应用. 鉴于篇幅原因，这里不对它们作详细介绍, 如果有兴趣可以参见 <a href="https://en.wikipedia.org/wiki/Radix_tree">radix tries</a>, <a href="https://cr.yp.to/critbit.html">crit-bit tries</a> 和 <a href="https://dotat.at/prog/qp/README.html">qp tries</a>.</p><p>我们已经了解了字典树的基本概念, 接下来进入到 burst-trie.</p><h1 id="Burst-trie"><a href="#Burst-trie" class="headerlink" title="Burst-trie"></a>Burst-trie</h1><p>Burst-trie 是一个类似于字典树的数据结构， 只不过字典树中叶子节点的位置被替换为一个容器，可以高效存储少量字符串. 内部节点是常规字典树的节点 (下图中我们用一个数组来表示指向子节点的指针).</p><p>容器本身可能存在各种各样的实现方式. 最初的论文研究了三种容器: 链表 (采用访问节点后移动到表头的访问方式), 二叉搜索树 和伸展树 (一种自平衡的二叉搜索树，频繁访问的节点会被移动到靠近树根的位置).</p><img src="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/burst_trie.png" class="" title="&lt;br&gt; 使用二叉搜索树作为容器的burst-trie， 包含了 romane, romanes, romanus, romulus, rubens, ruber, rubes, rubicon, rubicundus 和 rubric."><p>Burst-trie 由一个空容器作为初始， 随着新元素不断插入到字典树中而增长， 直到容器被爆裂启发(burst heuristic)判定为低效. 当这发生之时, 该容器会被爆裂为多个容器。</p><p>在容器节点爆裂的过程中, 会创建一个新的字典树节点，取代原先容器节点在字典树中的位置. 对于原先容器中的每一个字符串, 以其首字母作为新节点，除首字母外剩下的字符添加到新容器中，新容器作为新节点的子节点. 这个过程一直递归下去，直到全部新容器满足爆裂启发(burst heuristic).</p><img src="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/burst.png" class="" title="&lt;br&gt; 增加单词 romule 后的爆裂过程，爆裂启发限制容器大小为4个元素."><p>决定一个容器节点何时需要爆裂的爆裂启发方法有各种各样的实现方式. 最初的论文提出了三个选项.</p><ul><li><p><em>限定</em>. 最直接的方式是当容器中的元素数量大于预先定义的限制 L时，容器发生爆裂.</p></li><li><p><em>比率</em>. 启发算法为每个容器节点设置两个计数器. 计数器 N 记录了容器被查询的次数, 计数器 S 命中容器中根节点的查询次数, 例如直接命中. 当比例 S/N 低于某个阈值, 容器会发生爆裂.</p><p>当采用移向根节点的查询策略时，这种启发方法会很有用, 例如在伸展树中, 遇到不均匀的查询时 (一些字符串查询次数比另外的要多).</p></li><li><p><em>趋势</em>. 容器创建时会分配一个资源量 C . 每次访问成功时, 资源量会被修改. 假如访问直接命中, 资源量增加 B, 否则资源量减少 M. 当资源量减少到 0 时，即发生爆裂.</p></li></ul><p>同比率启发一样, 当采用移向根节点的查询策略，并且遇到不均匀查询时，这种启发策略很有效.</p><h1 id="数组哈希表"><a href="#数组哈希表" class="headerlink" title="数组哈希表"></a>数组哈希表</h1><p>数组哈希表，是一种用来高效存储字符串的、缓存敏感的哈希表. 这是用来把 burst-trie 构建为 HAT-trie 的容器.</p><p>哈希表是一种平均查找时间复杂度为 O(1)的数据结构. 为了实现这种效果, 哈希表利用哈希函数把元素映射到一个桶数组中. 经过模运算，哈希函数把一个元素关联到桶数组的特定下标.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">uint hash = hash_funct(<span class="hljs-string">&quot;romulus&quot;</span>); <span class="hljs-regexp">//</span> string to uint <span class="hljs-keyword">function</span><br>uint bucket_index = hash % buckets_array_size; <span class="hljs-regexp">//</span> [<span class="hljs-number">0</span>, buckets_array_size)<br></code></pre></td></tr></table></figure><p>问题在于，两个键可能会映射到同一个哈希桶 (例如， 当<code>hash_funct(&quot;romulus&quot;) % 4 == hash_funct(&quot;romanus&quot;) % 4 </code>时). 为了解决这个问题，所有的哈希表都实现了某种碰撞解决方案。</p><p>一种常见的做法是拉链. 桶数组中的每一个桶，都有一个包含该桶中全部元素的链表. 当插入元素的时候, 如果发生了碰撞, 新元素简单的追加到链表末尾.</p><p>关于哈希表的更多信息, 可以参考这篇<a href="https://en.wikipedia.org/wiki/Hash_table">维基百科</a>的文章， 在此仅作简介.</p><img src="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/linked_hash.png" class="" title="&lt;br&gt; 拉链式哈希表， 包含了 romane, romanes, romanus, romulus, rubens, ruber, rubes, rubicon, rubicundus 和 rubric."><p>这种简单的拉链实现的主要问题在于缓存不友好. 在 C++ 中, 如果我们使用标准容器存储字符串, std::unordered_map&lt;std::string, int&gt;, 访问链表中的每个节点会导致两次指针解引用(如果实现采用了SSO短字符串优化，就只有一次解引用). 一次用来访问下一个节点，一次用来比较键是否相等.</p><p>除了潜在的缓存不命中之外, 这种方式要求一个节点至少存储两个指针 (一个指向下一个节点, 一个指向存储在堆中的字符串). 在字符串比较小的情况下，这会带来很大的开销.</p><p>数组哈希表的目标是，把一个桶中的所有字符串存储在数组而不是链表中，来减少上述这些不便之处. 这些字符串存储在数组中，使用他们各自的长度作为前缀. 大多数情况下, 我们在解决冲突时只会用到一次指针解引用 (如果数组很大的话会有多次解引用). 我们也不必存储多余的指针，从而减少哈希表的内存占用.</p><p>缺点是当一个字符串需要追加到桶中时, 可能会引起整个数组的内存重新分配.</p><img src="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/array_hash.png" class="" title="&lt;br&gt; 数组哈希表: 包含了 romane, romanes, romanus, romulus, rubens, ruber, rubes, rubicon, rubicundus 和 rubric."><p>数组哈希表提供了一种在哈希表中存储字符串的高效、紧凑的方法. 你可以在 <a href="https://github.com/Tessil/array-hash">GitHub</a> 中找到HAT-trie使用的C++ 实现.</p><h1 id="HAT-trie"><a href="#HAT-trie" class="headerlink" title="HAT-trie"></a>HAT-trie</h1><p>现在我们已经有了创建 HAT-trie 的全部材料, 接下来我们把这些全部组合在一起.</p><p>HAT-trie 是一种 burst-trie， 使用数组哈希表作为叶子节点的容器.</p><img src="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/hat_trie.png" class="" title="&lt;br&gt; HAT-trie: 包含了 romane, romanes, romanus, romulus, rubens, ruber, rubes, rubicon, rubicundus 和 rubric."><p>和 burst-trie 一样, HAT-trie 也使用一个空容器作为起始节点，这里用的是数组哈希表. 当容器节点变得过大, 就会开始爆裂过程 (HAT-trie采用了前文所述的限制爆裂启发策略).</p><p>本文提出了两种爆裂方案.</p><ul><li><p><em>单纯</em>. 采用类似于 burst-trie 的方式, 一个新的字典树节点被创建出来，占据了原先的容器节点. 原先容器中每个字符串的首字母被移除， 剩余的字符串被放入新建的数组哈希表中，数组哈希表作为新建字典树节点的子节点，每个新建的字典树节点对应到每个被移除首字母的字符串. 这个过程递归执行下去，直到新建的数组哈希表的大小不超出限制.</p></li><li><p><em>混合</em>. 与单纯容器节点不同, 一个混合容器节点拥有超过一个的父节点. 当我们从一个单纯节点创建多个混合节点时, 我们需要寻找一个分隔字符， 它能尽可能平均的把单纯节点分为两部分. 所有首字母小于分隔字符的字符串进入左边的混合节点，其他的进入右边的混合节点. 然后，父节点会对小于分隔字符的字母设置指针指向左侧混合节点，剩下的指向右侧混合节点. 注意不同于单纯节点, 我们在容器中保留原字符串的首字母，以便于分别出来自哪个父节点.</p></li></ul><p>如果我们爆裂一个混合节点, 我们不需要新建字典树节点. 我们只需要把混合节点分割为两个节点 (有可能成为单纯节点，如果分割后的节点只有一个父节点的话). 然后在父节点中重新分配子节点的指针.</p><p>采用混合节点可以帮助减少 HAT-trie 的大小.</p><img src="/2023/11/28/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06HAT-trie%E7%BC%93%E5%AD%98%E6%95%8F%E6%84%9F%E5%AD%97%E5%85%B8%E6%A0%91(%E8%BD%AC%E8%BD%BD)/hat_trie_hybrid.png" class="" title="&lt;br&gt; 同时拥有 单纯和 混合节点的HAT-trie"><p>HAT-trie 的主要弊端在于元素只是一个近似有序的顺序，因为元素在数组哈希表中是无序排列的.</p><p>导致的结果就是在进行前缀查询时，我们可能需要做额外的工作，从数组哈希表中找到需要的元素.</p><p>如果我们查询全部以 ro 为前缀的单词, 事情比较简单，因为向下遍历树时，我们会到达一个字典树节点. 我们只需要返回该字典树节点下面的全部单词即可.</p><p>如果我们查询以 roma 为前缀的单词，事情就会变的复杂 。向下遍历时我们会到达一个容器节点，我们仍需以ma作为前缀进行进一步的查询. 这里不能保证容器节点中存在ma前缀 (例如 以mulus作为后缀的节点)，我们需要作一次线性查找. 但是由于数组哈希表的大小有上限, 前缀查询的时间复杂度依然是 O(k + M), 其中 k 是前缀的长度，M 是匹配该前缀的单词数, 即使在 HAT-trie 中存了千百万条数据. 我们只是拥有一个较高的常数因子，取决于数组哈希表的大小上限.</p><p>这种近似有序的另一个结果是，如果我们想在所有元素中进行顺序遍历, 当迭代器进入一个新的容器节点时，需要对容器节点的全部元素进行排序. 由于容器节点的大小上限是固定的, 也不会导致太差的结果, 不过在这种需要对元素排序的场景下采用其他数据结构可能更好一些。</p><p>最后，HAT-trie 在速度和内存占用方面取得了比较好的平衡, 你可以从基准测试 中看到, 在牺牲了元素有序性，转而采用近似有序的前提下.</p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用配置</title>
    <link href="/2023/11/24/04DevOps/29%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/11/24/04DevOps/29%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="vscode-常用配置"><a href="#vscode-常用配置" class="headerlink" title="vscode 常用配置"></a>vscode 常用配置</h1><h2 id="点击文件会替换已经打开文件的解决办法"><a href="#点击文件会替换已经打开文件的解决办法" class="headerlink" title="点击文件会替换已经打开文件的解决办法"></a>点击文件会替换已经打开文件的解决办法</h2><ul><li>ctrl+shift+p，弹出搜索框。</li><li>在搜索框中输入Open User Setting，点击打开。 </li><li>打开以后看到如下界面，输入enablePreview搜索，然后将以下两个对勾取消即可<img src="/2023/11/24/04DevOps/29%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/1.png" class=""></li></ul><h2 id="设置默认编码"><a href="#设置默认编码" class="headerlink" title="设置默认编码"></a>设置默认编码</h2><ul><li>打开 VS Code，依次点击<code>文件</code>–&gt;<code>首选项</code>–&gt;<code>设置</code></li><li>在设置中搜索 <code>files.encoding</code>，选择工作区或用户后在下拉菜单中选择编码格式，如<code>utf8</code>等。</li><li>如果你想要 VS Code 自动检测文件编码格式并使用该编码格式打开文件，可以勾选“files.autoGuessEncoding”选项。</li><li>保存关闭</li></ul><h1 id="notepad-常用配置"><a href="#notepad-常用配置" class="headerlink" title="notepad++常用配置"></a>notepad++常用配置</h1><h2 id="配置FignerText"><a href="#配置FignerText" class="headerlink" title="配置FignerText"></a>配置FignerText</h2><p>官方地址：<a href="https://github.com/erinata/FingerText">https://github.com/erinata/FingerText</a></p><p>参考地址：<a href="https://blog.csdn.net/shaoyubin999/article/details/101844831">https://blog.csdn.net/shaoyubin999/article/details/101844831</a></p><p>常用配置方法</p><img src="/2023/11/24/04DevOps/29%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/2.png" class=""><p>blog_head 代码</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <br><span class="hljs-attr">date:</span> <span class="hljs-string">$[![(key)DATE:yyyy-MM-dd]!]</span> <span class="hljs-string">$[![(key)TIME]!]</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">linux</span><br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">devops</span><br><span class="hljs-meta">---</span><br>[<span class="hljs-string">&gt;END&lt;</span>]<br></code></pre></td></tr></table></figure><p>blog_img 代码</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_img</span> xxxx.png %&#125;</span><br></code></pre></td></tr></table></figure><h1 id="windows下配置多个hexo发布到github时每个账号配置不同的sshkey"><a href="#windows下配置多个hexo发布到github时每个账号配置不同的sshkey" class="headerlink" title="windows下配置多个hexo发布到github时每个账号配置不同的sshkey"></a>windows下配置多个hexo发布到github时每个账号配置不同的sshkey</h1><p>由于github账号近几年增加了全局sshkey的重复判定，导致多个github账号间不同使用相同的sshkey。</p><p>所以在hexo自动提交的时候就需要使用不同的用户key进验证。</p><p>省略生成 id_rsa_github_zy 及 ssh-add 加入id_rsa_github_zy的步骤</p><ol><li>在windows的<code>C:\Users\xxxxx\.ssh\config</code> 文件增加新的github用户信息<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host z_github   <span class="hljs-comment"># 注意和西面的repo中的内容相对应</span><br>HostName github.com<br><span class="hljs-keyword">User</span> <span class="hljs-title">z-fly542</span>  <span class="hljs-comment"># 注意和西面的repo中的内容相对应</span><br>IdentityFile C:\Users\xxxx\.ssh\id_rsa_github_zy<br></code></pre></td></tr></table></figure></li><li>修改hexo根目录下的_config.yml文件<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">deploy:</span><br>  <span class="hljs-symbol">type:</span> git<br>  <span class="hljs-symbol">repo:</span><br>        <span class="hljs-symbol">github:</span> git<span class="hljs-variable">@z_github</span><span class="hljs-symbol">:z-fly542/z-fly542</span>.github.io.git,master<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://doreality.xyz/posts/9fda10db.html">https://doreality.xyz/posts/9fda10db.html</a></p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu环境下vim+copilot的部署与使用</title>
    <link href="/2023/11/13/04DevOps/28ubuntu%E7%8E%AF%E5%A2%83vim+copilot%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/13/04DevOps/28ubuntu%E7%8E%AF%E5%A2%83vim+copilot%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>在linux环境下有两种方式让vim可以使用vim,一种是使用neovim,还有一种直接使用vim.</p><p>直接使用vim时vim版本要大于9.0.0185，nodejs&gt;18.0</p><h2 id="更新-vim-版本大于-9-0-0185"><a href="#更新-vim-版本大于-9-0-0185" class="headerlink" title="更新 vim 版本大于 9.0.0185"></a>更新 vim 版本大于 9.0.0185</h2><figure class="highlight smali"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment"># 安装 依赖包 add-apt-repository</span><br>$ apt install software-properties-common<br><span class="hljs-comment"># 添加 Vim 的 PPA</span><br>$<span class="hljs-built_in"> add-apt-repository </span>ppa:jonathonf/vim<br><span class="hljs-comment">#更新系统</span><br>$ apt update<br></code></pre></td></tr></table></figure><h2 id="安装node-sj"><a href="#安装node-sj" class="headerlink" title="安装node.sj"></a>安装node.sj</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 删除老的</span><br>$ apt remove nodejs<br>$ apt autoremove<br><span class="hljs-meta"># 下载noddejs 安装20版</span><br>curl -fsSL https:<span class="hljs-comment">//deb.nodesource.com/setup_20.x | sudo -E bash -</span><br><span class="hljs-meta"># 安装20版</span><br>$ apt-<span class="hljs-keyword">get</span> install -y nodejs<br><span class="hljs-meta"># 验证版本</span><br>$ node -v<br></code></pre></td></tr></table></figure><h2 id="安装-github-copilot-vim"><a href="#安装-github-copilot-vim" class="headerlink" title="安装 github/copilot.vim"></a>安装 github/copilot.vim</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/github/</span>copilot.vim.git ~<span class="hljs-regexp">/.vim/</span>pack<span class="hljs-regexp">/github/</span>start/copilot.vim<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="启用copilot"><a href="#启用copilot" class="headerlink" title="启用copilot"></a>启用copilot</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>. 启动 <span class="hljs-keyword">vim</span><br><span class="hljs-keyword">vim</span><br><span class="hljs-number">2</span>. 部署 copilot并认证 ,在启动后的<span class="hljs-keyword">vim</span> 窗口输入下面命令<br>:Copilot setup<br><span class="hljs-number">3</span>. 启动 copilot, 在<span class="hljs-keyword">vim</span>命令窗口执行如下命令<br>:Copilot enable<br></code></pre></td></tr></table></figure><h2 id="vim-copilot-配置"><a href="#vim-copilot-配置" class="headerlink" title="vim copilot 配置"></a>vim copilot 配置</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>. 修改默认<span class="hljs-keyword">tab</span>键接收建议为ctrl+<span class="hljs-keyword">j</span>键<br><span class="hljs-keyword">vim</span> ~/.vimrc <br>添加以下内容<br><span class="hljs-keyword">imap</span> <span class="hljs-symbol">&lt;silent&gt;</span><span class="hljs-symbol">&lt;script&gt;</span><span class="hljs-symbol">&lt;expr&gt;</span> <span class="hljs-symbol">&lt;C-J&gt;</span> copilot#Accept(<span class="hljs-string">&quot;\&lt;CR&gt;&quot;</span>)<br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:copilot_no_tab_map</span> = <span class="hljs-variable">v:true</span><br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>Invoke :Copilot setup to authenticate and enable GitHub Copilot.<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">```<br>- Failed to open browser.  Visit https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/login/</span>device<br></code></pre></td></tr></table></figure>此时是需要通过网页验证copilot账号信息，在错误行的上一行还有一行下列信息<br>First copy your one-time code: XXXX-XXXX</li></ul><p>通过网页打开 <a href="https://github.com/login/device%EF%BC%8C">https://github.com/login/device，</a>  然后输入上面提示的xxxx-xxxx密码等待通过认证即可。</p><p>```</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://docs.github.com/zh/billing/managing-billing-for-github-copilot/managing-your-github-copilot-subscription-for-your-personal-account">https://docs.github.com/zh/billing/managing-billing-for-github-copilot/managing-your-github-copilot-subscription-for-your-personal-account</a></p><p><a href="https://docs.github.com/zh/copilot/getting-started-with-github-copilot?tool=vimneovim#prerequisites-3">https://docs.github.com/zh/copilot/getting-started-with-github-copilot?tool=vimneovim#prerequisites-3</a></p><p><a href="https://github.com/orgs/community/discussions/8105">https://github.com/orgs/community/discussions/8105</a></p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文读懂C++右值引用和std::move(转载)</title>
    <link href="/2023/11/02/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/17%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82C++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8(%E8%BD%AC%E8%BD%BD)/"/>
    <url>/2023/11/02/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/17%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82C++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8(%E8%BD%AC%E8%BD%BD)/</url>
    
    <content type="html"><![CDATA[<p>本文转自 <a href="https://zhuanlan.zhihu.com/p/335994370">https://zhuanlan.zhihu.com/p/335994370</a></p><h1 id="1-什么是左值、右值"><a href="#1-什么是左值、右值" class="headerlink" title="1. 什么是左值、右值"></a><strong>1. 什么是左值、右值</strong></h1><p>首先不考虑引用以减少干扰，可以从2个角度判断：左值<strong>可以取地址、位于等号左边</strong>；而右值<strong>没法取地址，位于等号右边</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><ul><li>a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li><li>5位于等号右边，5没法通过 &amp; 取地址，所以5是个右值。</li></ul><p>再举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>) &#123;<br>        a_ = a;<br>    &#125;<br>    <span class="hljs-keyword">int</span> a_;<br>&#125;;<br>A a = <span class="hljs-built_in">A</span>();<br></code></pre></td></tr></table></figure><ul><li>同样的，a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li><li>A()是个临时值，没法通过 &amp; 取地址，位于等号右边，所以A()是个右值。</li></ul><p>可见左右值的概念很清晰，<font color=#ff0000>有地址的变量就是左值，没有地址的字面值、临时值就是右值。</font></p><h1 id="2-什么是左值引用、右值引用"><a href="#2-什么是左值引用、右值引用" class="headerlink" title="2. 什么是左值引用、右值引用"></a><strong>2. 什么是左值引用、右值引用</strong></h1><p><strong>引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。</strong></p><p>个人认为，引用出现的本意是为了降低C语言指针的使用难度，但现在指针+左右值引用共同存在，反而大大增加了学习和理解成本。</p><h2 id="2-1-左值引用"><a href="#2-1-左值引用" class="headerlink" title="2.1 左值引用"></a><strong>2.1 左值引用</strong></h2><p>左值引用大家都很熟悉，<strong>能指向左值，不能指向右值的就是左值引用</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> &amp;ref_a = a; <span class="hljs-comment">// 左值引用指向左值，编译通过</span><br><span class="hljs-keyword">int</span> &amp;ref_a = <span class="hljs-number">5</span>; <span class="hljs-comment">// 左值引用指向了右值，会编译失败</span><br></code></pre></td></tr></table></figure><p><strong>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。</strong></p><p>但是，const左值引用是可以指向右值的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ref_a = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 编译通过</span><br></code></pre></td></tr></table></figure><p>const 左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用<code>const &amp;</code>作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> value_type&amp; val)</span></span>;<br></code></pre></td></tr></table></figure><p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p><h2 id="2-2-右值引用"><a href="#2-2-右值引用" class="headerlink" title="2.2 右值引用"></a><strong>2.2 右值引用</strong></h2><p>再看下右值引用，右值引用的标志是<code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;&amp;ref_a_right = <span class="hljs-number">5</span>; <span class="hljs-comment">// ok</span><br> <br><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> &amp;&amp;ref_a_left = a; <span class="hljs-comment">// 编译不过，右值引用不可以指向左值</span><br> <br>ref_a_right = <span class="hljs-number">6</span>; <span class="hljs-comment">// 右值引用的用途：可以修改右值</span><br></code></pre></td></tr></table></figure><h2 id="2-3-对左右值引用本质的讨论"><a href="#2-3-对左右值引用本质的讨论" class="headerlink" title="2.3 对左右值引用本质的讨论"></a><strong>2.3 对左右值引用本质的讨论</strong></h2><p>下边的论述比较复杂，也是本文的核心，对理解这些概念非常重要。</p><h3 id="2-3-1-右值引用有办法指向左值吗？"><a href="#2-3-1-右值引用有办法指向左值吗？" class="headerlink" title="2.3.1 右值引用有办法指向左值吗？"></a><strong>2.3.1 右值引用有办法指向左值吗？</strong></h3><p>有办法，<code>std::move</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// a是个左值</span><br><span class="hljs-keyword">int</span> &amp;ref_a_left = a; <span class="hljs-comment">// 左值引用指向左值</span><br><span class="hljs-keyword">int</span> &amp;&amp;ref_a_right = std::<span class="hljs-built_in">move</span>(a); <span class="hljs-comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span><br> <br>cout &lt;&lt; a; <span class="hljs-comment">// 打印结果：5</span><br></code></pre></td></tr></table></figure><p>在上边的代码里，看上去是左值a通过std::move移动到了右值ref_a_right中，那是不是a里边就没有值了？并不是，打印出a的值仍然是5。</p><p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong>，std::move的使用场景在第三章会讲。</p><p>同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;&amp;ref_a = <span class="hljs-number">5</span>;<br>ref_a = <span class="hljs-number">6</span>; <br> <br>等同于以下代码：<br> <br><span class="hljs-keyword">int</span> temp = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> &amp;&amp;ref_a = std::<span class="hljs-built_in">move</span>(temp);<br>ref_a = <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-2-左值引用、右值引用本身是左值还是右值？"><a href="#2-3-2-左值引用、右值引用本身是左值还是右值？" class="headerlink" title="2.3.2 左值引用、右值引用本身是左值还是右值？"></a><strong>2.3.2 左值引用、右值引用本身是左值还是右值？</strong></h3><p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边。仔细看下边代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 形参是个右值引用</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; right_value)</span> </span>&#123;<br>    right_value = <span class="hljs-number">8</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>; <span class="hljs-comment">// a是个左值</span><br>    <span class="hljs-keyword">int</span> &amp;ref_a_left = a; <span class="hljs-comment">// ref_a_left是个左值引用</span><br>    <span class="hljs-keyword">int</span> &amp;&amp;ref_a_right = std::<span class="hljs-built_in">move</span>(a); <span class="hljs-comment">// ref_a_right是个右值引用</span><br> <br>    <span class="hljs-built_in">change</span>(a); <span class="hljs-comment">// 编译不过，a是左值，change参数要求右值</span><br>    <span class="hljs-built_in">change</span>(ref_a_left); <span class="hljs-comment">// 编译不过，左值引用ref_a_left本身也是个左值</span><br>    <span class="hljs-built_in">change</span>(ref_a_right); <span class="hljs-comment">// 编译不过，右值引用ref_a_right本身也是个左值</span><br>     <br>    <span class="hljs-built_in">change</span>(std::<span class="hljs-built_in">move</span>(a)); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-built_in">change</span>(std::<span class="hljs-built_in">move</span>(ref_a_right)); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-built_in">change</span>(std::<span class="hljs-built_in">move</span>(ref_a_left)); <span class="hljs-comment">// 编译通过</span><br> <br>    <span class="hljs-built_in">change</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 当然可以直接接右值，编译通过</span><br>     <br>    cout &lt;&lt; &amp;a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; &amp;ref_a_left &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; &amp;ref_a_right;<br>    <span class="hljs-comment">// 打印这三个左值的地址，都是一样的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>看完后你可能有个问题，std::move会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以move返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：<strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p><p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 这同样也符合第一章对左值，右值的判定方式：其实引用和普通变量是一样的，<code>int &amp;&amp;ref = std::move(a)</code>和 <code>int a = 5</code>没有什么区别，等号左边就是左值，右边就是右值。</p><p>最后，从上述分析中我们得到如下结论：</p><ol><li><strong>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</strong></li><li><strong>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</strong></li><li><strong>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; n)</span> </span>&#123;<br>    n += <span class="hljs-number">1</span>; <span class="hljs-comment">// 编译失败，const左值引用不能修改指向变量</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;&amp; n)</span> </span>&#123;<br>    n += <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">f2</span>(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-右值引用和std-move的应用场景"><a href="#3-右值引用和std-move的应用场景" class="headerlink" title="3. 右值引用和std::move的应用场景"></a><strong>3. 右值引用和std::move的应用场景</strong></h1><p>按上文分析，<code>std::move</code>只是类型转换工具，不会对性能有好处；右值引用在作为函数形参时更具灵活性，看上去还是挺鸡肋的。他们有什么实际应用场景吗？</p><h2 id="3-1-实现移动语义"><a href="#3-1-实现移动语义" class="headerlink" title="3.1 实现移动语义"></a><strong>3.1 实现移动语义</strong></h2><p>在实际场景中，右值引用和std::move被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。 在没有右值引用之前，一个简单的数组类通常实现如下，有<code>构造函数</code>、<code>拷贝构造函数</code>、<code>赋值运算符重载</code>、<code>析构函数</code>等。深拷贝/浅拷贝在此不做讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">int</span> size) : <span class="hljs-built_in">size_</span>(size) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size_];<br>    &#125;<br>     <br>    <span class="hljs-comment">// 深拷贝构造</span><br>    <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">const</span> Array&amp; temp_array) &#123;<br>        size_ = temp_array.size_;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size_];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size_; i ++) &#123;<br>            data_[i] = temp_array.data_[i];<br>        &#125;<br>    &#125;<br>     <br>    <span class="hljs-comment">// 深拷贝赋值</span><br>    Array&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Array&amp; temp_array) &#123;<br>        <span class="hljs-keyword">delete</span>[] data_;<br> <br>        size_ = temp_array.size_;<br>        data_ = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size_];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size_; i ++) &#123;<br>            data_[i] = temp_array.data_[i];<br>        &#125;<br>    &#125;<br> <br>    ~<span class="hljs-built_in">Array</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data_;<br>    &#125;<br> <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> *data_;<br>    <span class="hljs-keyword">int</span> size_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>该类的拷贝构造函数、赋值运算符重载函数已经通过使用左值引用传参来避免一次多余拷贝了，但是内部实现要深拷贝，无法避免。 这时，有人提出一个想法：是不是可以提供一个<code>移动构造函数</code>，把被拷贝者的数据移动过来，被拷贝者后边就不要了，这样就可以避免深拷贝了，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">int</span> size) : <span class="hljs-built_in">size_</span>(size) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size_];<br>    &#125;<br>     <br>    <span class="hljs-comment">// 深拷贝构造</span><br>    <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">const</span> Array&amp; temp_array) &#123;<br>        ...<br>    &#125;<br>     <br>    <span class="hljs-comment">// 深拷贝赋值</span><br>    Array&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Array&amp; temp_array) &#123;<br>        ...<br>    &#125;<br> <br>    <span class="hljs-comment">// 移动构造函数，可以浅拷贝</span><br>    <span class="hljs-built_in">Array</span>(<span class="hljs-keyword">const</span> Array&amp; temp_array, <span class="hljs-keyword">bool</span> move) &#123;<br>        data_ = temp_array.data_;<br>        size_ = temp_array.size_;<br>        <span class="hljs-comment">// 为防止temp_array析构时delete data，提前置空其data_      </span><br>        temp_array.data_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>     <br> <br>    ~<span class="hljs-built_in">Array</span>() &#123;<br>        <span class="hljs-keyword">delete</span> [] data_;<br>    &#125;<br> <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> *data_;<br>    <span class="hljs-keyword">int</span> size_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这么做有2个问题：</p><ul><li>不优雅，表示移动语义还需要一个额外的参数(或者其他方式)。</li><li>无法实现！<code>temp_array</code>是个const左值引用，无法被修改，所以<code>temp_array.data_ = nullptr;</code>这行会编译不过。当然函数参数可以改成非const：<code>Array(Array&amp; temp_array, bool move)&#123;...&#125;</code>，这样也有问题，由于左值引用不能接右值，<code>Array a = Array(Array(), true);</code>这种调用方式就没法用了。</li></ul><p>可以发现左值引用真是用的很不爽，<strong>右值引用的出现解决了这个问题</strong>，在STL的很多容器中，都实现了以<strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code>，或者其他函数，最常见的如std::vector的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    ......<br> <br>    <span class="hljs-comment">// 优雅</span><br>    <span class="hljs-built_in">Array</span>(Array&amp;&amp; temp_array) &#123;<br>        data_ = temp_array.data_;<br>        size_ = temp_array.size_;<br>        <span class="hljs-comment">// 为防止temp_array析构时delete data，提前置空其data_      </span><br>        temp_array.data_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>     <br> <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> *data_;<br>    <span class="hljs-keyword">int</span> size_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如何使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 例1：Array用法</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Array a;<br> <br>    <span class="hljs-comment">// 做一些操作</span><br>    .....<br>     <br>    <span class="hljs-comment">// 左值a，用std::move转化为右值</span><br>    <span class="hljs-function">Array <span class="hljs-title">b</span><span class="hljs-params">(std::move(a))</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-实例：vector-push-back使用std-move提高性能"><a href="#3-2-实例：vector-push-back使用std-move提高性能" class="headerlink" title="3.2 实例：vector::push_back使用std::move提高性能"></a><strong>3.2 实例：vector::push_back使用std::move提高性能</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 例2：std::vector和std::string的实际例子</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str1 = <span class="hljs-string">&quot;aacasxs&quot;</span>;<br>    std::vector&lt;std::string&gt; vec;<br>     <br>    vec.<span class="hljs-built_in">push_back</span>(str1); <span class="hljs-comment">// 传统方法，copy</span><br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(str1)); <span class="hljs-comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span><br>    vec.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(str1)); <span class="hljs-comment">// emplace_back效果相同，str1会失去原有值</span><br>    vec.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;axcsddcas&quot;</span>); <span class="hljs-comment">// 当然可以直接接右值</span><br>&#125;<br> <br><span class="hljs-comment">// std::vector方法定义</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> value_type&amp; val)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span> <span class="hljs-params">(value_type&amp;&amp; val)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">emplace_back</span> <span class="hljs-params">(Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>在vector和string这个场景，加个<code>std::move</code>会调用到移动语义函数，避免了深拷贝。</p><p>除非设计不允许移动，STL类大都支持移动语义函数，即<code>可移动的</code>。 另外，编译器会<strong>默认</strong>在用户自定义的<code>class</code>和<code>struct</code>中生成移动语义函数，但前提是用户没有主动定义该类的<code>拷贝构造</code>等函数(具体规则自行百度哈)。 <strong>因此，可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用</strong><code>std::move</code><strong>触发移动语义，提升性能。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">moveable_objecta = moveable_objectb; <br>改为： <br>moveable_objecta = std::<span class="hljs-built_in">move</span>(moveable_objectb);<br></code></pre></td></tr></table></figure><p>还有些STL类是<code>move-only</code>的，比如<code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::unique_ptr&lt;A&gt; ptr_a = std::make_unique&lt;A&gt;();<br><br>std::unique_ptr&lt;A&gt; ptr_b = std::<span class="hljs-built_in">move</span>(ptr_a); <span class="hljs-comment">// unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span><br><br>std::unique_ptr&lt;A&gt; ptr_b = ptr_a; <span class="hljs-comment">// 编译不通过</span><br></code></pre></td></tr></table></figure><p><strong>std::move本身只做类型转换，对性能无影响。</strong> <strong>我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。</strong></p><h1 id="4-完美转发-std-forward"><a href="#4-完美转发-std-forward" class="headerlink" title="4. 完美转发 std::forward"></a><strong>4. 完美转发 std::forward</strong></h1><p>和<code>std::move</code>一样，它的兄弟<code>std::forward</code>也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换.</p><p>与move相比，forward更强大，move只能转出来右值，forward都可以。</p><blockquote><p>std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</p></blockquote><p>举个例子，有main，A，B三个函数，调用关系为：<code>main-&gt;A-&gt;B</code>，建议先看懂<em>2.3节对左右值引用本身是左值还是右值的讨论</em>再看这里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; ref_r)</span> </span>&#123;<br>    ref_r = <span class="hljs-number">1</span>;<br>&#125;<br> <br><span class="hljs-comment">// A、B的入参是右值引用</span><br><span class="hljs-comment">// 有名字的右值引用是左值，因此ref_r是左值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; ref_r)</span> </span>&#123;<br>    <span class="hljs-built_in">B</span>(ref_r);  <span class="hljs-comment">// 错误，B的入参是右值引用，需要接右值，ref_r是左值，编译失败</span><br>     <br>    <span class="hljs-built_in">B</span>(std::<span class="hljs-built_in">move</span>(ref_r)); <span class="hljs-comment">// ok，std::move把左值转为右值，编译通过</span><br>    <span class="hljs-built_in">B</span>(std::forward&lt;<span class="hljs-keyword">int</span>&gt;(ref_r));  <span class="hljs-comment">// ok，std::forward的T是int类型，属于条件b，因此会把ref_r转为右值</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">A</span>(std::<span class="hljs-built_in">move</span>(a));<br>&#125;<br></code></pre></td></tr></table></figure><p>例2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; ref_r)</span> </span>&#123;<br>    ref_r = <span class="hljs-number">1</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; ref_l)</span> </span>&#123;<br>    ref_l = <span class="hljs-number">1</span>;<br>&#125;<br> <br><span class="hljs-comment">// change的入参是右值引用</span><br><span class="hljs-comment">// 有名字的右值引用是 左值，因此ref_r是左值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp;&amp; ref_r)</span> </span>&#123;<br>    <span class="hljs-built_in">change2</span>(ref_r);  <span class="hljs-comment">// 错误，change2的入参是右值引用，需要接右值，ref_r是左值，编译失败</span><br>     <br>    <span class="hljs-built_in">change2</span>(std::<span class="hljs-built_in">move</span>(ref_r)); <span class="hljs-comment">// ok，std::move把左值转为右值，编译通过</span><br>    <span class="hljs-built_in">change2</span>(std::forward&lt;<span class="hljs-keyword">int</span> &amp;&amp;&gt;(ref_r));  <span class="hljs-comment">// ok，std::forward的T是右值引用类型(int &amp;&amp;)，符合条件b，因此u(ref_r)会被转换为右值，编译通过</span><br>     <br>    <span class="hljs-built_in">change3</span>(ref_r); <span class="hljs-comment">// ok，change3的入参是左值引用，需要接左值，ref_r是左值，编译通过</span><br>    <span class="hljs-built_in">change3</span>(std::forward&lt;<span class="hljs-keyword">int</span> &amp;&gt;(ref_r)); <span class="hljs-comment">// ok，std::forward的T是左值引用类型(int &amp;)，符合条件a，因此u(ref_r)会被转换为左值，编译通过</span><br>    <span class="hljs-comment">// 可见，forward可以把值转换为左值或者右值</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">change</span>(std::<span class="hljs-built_in">move</span>(a));<br>&#125;<br></code></pre></td></tr></table></figure><p>上边的示例在日常编程中基本不会用到，<code>std::forward</code>最主要运于模版编程的参数转发中，想深入了解需要学习<code>万能引用(T &amp;&amp;)</code>和<code>引用折叠(eg:&amp; &amp;&amp; → ?)</code>等知识</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openssl相关使用方法汇总</title>
    <link href="/2023/10/12/04DevOps/27openssl%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <url>/2023/10/12/04DevOps/27openssl%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="openssl工具用法"><a href="#openssl工具用法" class="headerlink" title="openssl工具用法"></a>openssl工具用法</h1><ul><li><p>要查看一个证书文件（例如 xxx.pem）的详细信息，可以使用以下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span> x<span class="hljs-number">509</span> -in xxx.pem -text -noout<br></code></pre></td></tr></table></figure></li><li><p>要确定密钥的类型，可以使用以下命令:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing">openssl rsa -in priv_key.<span class="hljs-built_in">key</span> -noout -<span class="hljs-built_in">text</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在生产环境中追踪运行态内存崩溃的第一现场</title>
    <link href="/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/"/>
    <url>/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在c/c++开发中，内存相关错误一直都是开发人员的高压线，由于近期工作中上线服务偶尔出现崩溃问题，而崩溃的位置竟然是在 malloc函数的内部（见下图1），看到崩溃的第一反应是自己的程序出了问题，glibc使用多年还是很稳定的。于是先进行了一波代码自查，检查了程序中所有的memcpy、strcpy、memset、sprintf函数的使用并未发现异常，于是放弃人工检查，改为使用工具来进行定位分析。</p><img src="/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/20191211094630--10.25.7.132.png" class=""><h1 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h1><p>在众多内存检测工具中，各有优缺点，需要结合实际情况来选择定位，</p><h2 id="常见的内存错误有以下几种类型"><a href="#常见的内存错误有以下几种类型" class="headerlink" title="常见的内存错误有以下几种类型"></a>常见的内存错误有以下几种类型</h2><table><thead><tr><th>memory overrun</th><th>内存溢出</th></tr></thead><tbody><tr><td>double free</td><td>同一内存多次释放</td></tr><tr><td>use after free</td><td>内存释放后再次使用</td></tr><tr><td>wild free</td><td>释放内存的参数为非法值</td></tr><tr><td>access uninitialized memory</td><td>访问未初始化内存</td></tr><tr><td>memory leak</td><td>内存泄露</td></tr><tr><td>use after return</td><td>函数返回栈内指针</td></tr><tr><td>stack overflow</td><td>栈溢出</td></tr></tbody></table><h2 id="常规的内存错误检测工具及其支持的功能对比"><a href="#常规的内存错误检测工具及其支持的功能对比" class="headerlink" title="常规的内存错误检测工具及其支持的功能对比"></a>常规的内存错误检测工具及其支持的功能对比</h2><table><thead><tr><th></th><th><strong>memory overrun</strong></th><th><strong>double free</strong></th><th><strong>use after free</strong></th><th><strong>wild free</strong></th><th><strong>access uninited</strong></th><th><strong>read invalid memory</strong></th><th><strong>memory leak</strong></th><th><strong>use after return</strong></th><th><strong>stack overflow</strong></th><th><strong>thread safe</strong></th><th><strong>Performance</strong></th></tr></thead><tbody><tr><td>Memory checking tools in Glibc</td><td></td><td>Yes</td><td></td><td>Yes</td><td></td><td></td><td>Yes</td><td></td><td>Yes(if use memcpy, strcpy, etc)</td><td></td><td></td></tr><tr><td>TCMalloc(Gperftools)</td><td></td><td></td><td></td><td></td><td></td><td></td><td>Yes</td><td></td><td></td><td>Yes</td><td></td></tr><tr><td>Valgrind</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>官方文档说明 为 40X</td></tr><tr><td>Address Sanitizer(ASan)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>(Memory Sanitizer)</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>官方文档说明 2x，平均1.8x</td></tr><tr><td>Memwatch</td><td></td><td>Yes</td><td></td><td>Yes</td><td></td><td></td><td></td><td></td><td></td><td>NO</td><td></td></tr><tr><td>Dr.Memory</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td><td></td><td></td></tr><tr><td>Electric Fence</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td><td></td><td></td><td></td><td></td><td>NO</td><td></td></tr><tr><td>Dmalloc</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td><td></td><td>Yes</td><td></td><td></td><td>Yes</td><td></td></tr></tbody></table><h2 id="我们的需求"><a href="#我们的需求" class="headerlink" title="我们的需求"></a>我们的需求</h2><ul><li><p>线程安全</p></li><li><p>测试很难复现，需要线上运行程序，所以性能差异不要太大</p></li><li><p>需要尽可能多的检测出相关未知内存错误</p></li></ul><p>从以上对比分析中来看Address Sanitizer(ASan) 是可以比较全面的检测发现内存等相关问题，且运行时性能损失较小，因此重点研究了Address Sanitizer 的相关用法，其他的tcmalloc和MALLOC_CHECK_ 等也做了相关功能对比测试，Address Sanitizer  确实对各种内存相关问题检测比较全面，且对程序运行时的性能影响相对较小，官方说2x的性能下降，因此决定使用Address Sanitizer来进行相关异常的定位检测。</p><h1 id="Address-Sanitizer的使用研究"><a href="#Address-Sanitizer的使用研究" class="headerlink" title="Address Sanitizer的使用研究"></a>Address Sanitizer的使用研究</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Sanitizer 是google开发的一套检测工具，包含AddressSanitizer, MemorySanitizer, ThreadSanitizer, LeakSanitizer 等，其中Address Sanitizer主要是用于检测地址寻址问题。主要通过libasan动态库在程序执行前替换系统的malloc函数来实现相关地址的检测功能。</p><p>Sanitizer 早先是LLVM中的特性，后被加入GCC 4.8中，在GCC 4.9后加入对ARM平台的支持。因此用时不需要第三方库，通过在编译时指定flag即可打开开关。因为gcc 4.8的Address Sanitizer还不完善，没有符号信息，所以最好使用gcc4.9以后的版本。</p><p>Sanitizer 项目地址： <a href="https://github.com/google/sanitizers">https://github.com/google/sanitizers</a> </p><h2 id="使用-Address-Sanitizer-的注意点"><a href="#使用-Address-Sanitizer-的注意点" class="headerlink" title="使用 Address Sanitizer 的注意点"></a>使用 Address Sanitizer 的注意点</h2><ul><li>要使用系统自带的内存管理库，不能使用第三方的内存管理库，因为这个功能要拦截malloc,free等标准函数。</li><li>虽然Address Sanitizer是gcc的一部分，但默认是没有安装的，所以需要安装 libasan</li><li>不同版本的gcc使用不同版本的libasan， gcc版本和libasan版本对应关系见下图 </li><li>gcc4.8版对应的libasan不支持官方wiki中的相关动态参数，且没有符号信息</li></ul><table><thead><tr><th>gcc版本号</th><th>libasan版本名</th></tr></thead><tbody><tr><td>4.8/4.9</td><td>libasan-x.x</td></tr><tr><td>5.x</td><td>libasan2-x.x</td></tr><tr><td>6.x</td><td>libasan3-x.x</td></tr><tr><td>7.x</td><td>libasan4-x.x</td></tr><tr><td>8.x</td><td>libasan5-x.x</td></tr></tbody></table><h2 id="如何在程序中使用Sanitizer"><a href="#如何在程序中使用Sanitizer" class="headerlink" title="如何在程序中使用Sanitizer"></a>如何在程序中使用Sanitizer</h2><p>Sanitizer通用参数可参考 <a href="https://github.com/google/sanitizers/wiki/SanitizerCommonFlags">https://github.com/google/sanitizers/wiki/SanitizerCommonFlags</a><br>AddressSanitizer参数可参考 <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags">https://github.com/google/sanitizers/wiki/AddressSanitizerFlags</a></p><ol><li><p>在gcc或g++的编译选项中增加 -fsanitize=address -fno-omit-frame-pointer 编译选项以开启sanitize的使用</p> <figure class="highlight haml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs haml">-<span class="ruby">fsanitize=address    <span class="hljs-comment">#开启地址越界检查功能</span></span><br><span class="ruby"></span>-<span class="ruby">fno-omit-frame-pointer  <span class="hljs-comment">#开启后，可以打印详细的堆栈信息和符号表信息</span></span><br><span class="ruby"></span>如：g++ -g -fsanitize=address -fno-omit-frame-pointer main.cpp -o test<br></code></pre></td></tr></table></figure></li><li><p>在程序运行时指定 sanitize 依赖的环境变量 ASAN_OPTIONS 如下：</p> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">如：export ASAN_OPTIONS=abort_on_error=<span class="hljs-number">1</span><span class="hljs-symbol">:disable_coredump=</span>0<span class="hljs-symbol">:unmap_shadow_on_exit=</span><span class="hljs-number">1</span><span class="hljs-symbol">:log_path=/tmp/proxy_ng_err</span><br>abort_on_error=<span class="hljs-number">1</span> <span class="hljs-comment"># 当遇到错误时调用abort而不是_exit来退出程序。默认为0，调用_exit</span><br>disable_coredump=0 <span class="hljs-comment"># 0 开启检测异常时生成coredump文件；若要生效还需配合系统设置 ulimit -c unlimited; 默认为1，禁用coredump , </span><br>unmap_shadow_on_exit=<span class="hljs-number">1</span> <span class="hljs-comment"># 是否在退出时调用unmap解除内存映射，默认0 不解除</span><br>log_path=<span class="hljs-regexp">/tmp/proxy</span>_ng_err <span class="hljs-comment"># 将日志写入/tmp/proxy_ng_err.pid，pid为进程号， 默认输出至标准错误(strerr)</span><br></code></pre></td></tr></table></figure></li><li><p>官方文档说在程序代码中内嵌__asan_default_options 函数的实现，返回ASAN_OPTIONS期望设置的参数也可以起到类似设置环境变量的作用。<br>此方法本人在gcc4/gcc5/gcc6/gcc8中分别做了验证，各个环境下相关设置均未生效:(</p></li></ol><h2 id="如何验证当前编译程序是否开启了Address-Sanitizer检测"><a href="#如何验证当前编译程序是否开启了Address-Sanitizer检测" class="headerlink" title="如何验证当前编译程序是否开启了Address Sanitizer检测"></a>如何验证当前编译程序是否开启了Address Sanitizer检测</h2><ol><li><p>编写如下测试程序main2.cpp， 并使用如下命令生成可执行文件test_oom<br> g++ -g -fsanitize=address -fno-omit-frame-pointer main2.cpp -o test_oom</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Copyright (C) 2015-2018 IQIYI</span><br><span class="hljs-comment">* All rights reserved.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Author     : 王海斌</span><br><span class="hljs-comment">* E-mail     : wanghaibin@qiyi.com</span><br><span class="hljs-comment">* Version    :</span><br><span class="hljs-comment">* Date       : Thu 02 Jan 2020 09:45:24 PM CST</span><br><span class="hljs-comment">* Destription: 验证asan检测</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 测试sprintf内存越界</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_oom_sprintf</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * dd=<span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s&quot;</span>, dd);<br>&#125;<br><br><span class="hljs-comment">//测试memcpy内存越界</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_oom_memcpy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> buf[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * dd=<span class="hljs-string">&quot;123456&quot;</span>;<br><span class="hljs-built_in">memcpy</span>(buf, dd, <span class="hljs-built_in">strlen</span>(dd));<br>&#125;<br><br><br><span class="hljs-comment">// 测试数组访问越界</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_oom_array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> *array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];<br>array[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> res = array[argc + <span class="hljs-number">100</span>];  <span class="hljs-comment">// BOOM</span><br><span class="hljs-keyword">delete</span> [] array;<br><span class="hljs-keyword">for</span>(;;) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sss\n&quot;</span>);<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br><span class="hljs-built_in">test_oom_sprintf</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>执行ldd test_oom 查看依赖库，如下图包含对libasan的引用则说明已启用<br> a. gcc 4.8或4.9编译连接库如下：</p> <img src="/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/gcc4.8_ldd.png" class=""><p> gcc 5.x编译连接库如下图</p> <img src="/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/gcc5.3_ldd.png" class=""><p> gcc 8.x 编译连接库如下图：</p> <img src="/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/gcc8.3_ldd.png" class=""></li><li><p>如何验证执行程序是否是否支持Address Sanitizer相关动态参数的设置<br> gcc4.x 执行help信息， 在gcc4.8下不支持相关参数，所以没有任何help相关信息，如下图</p> <img src="/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/gcc4.8_asan_help.png" class=""><p> gcc 5.x编译后的支持动态参数如下图：</p><p> 先显示help信息，然后才输出检测的异常信息，其中help信息显示支持的动态参数信息</p> <figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><code class="hljs tcl">[root@jiyang-cnc<span class="hljs-number">-10</span><span class="hljs-number">-153</span><span class="hljs-number">-56</span><span class="hljs-number">-72</span> err]# ASAN_OPTIONS=help=<span class="hljs-number">1</span> ./test_oom <br>Available flags <span class="hljs-keyword">for</span> AddressSanitizer:<br>quarantine_size<br>- Deprecated, please use quarantine_size_mb.<br>quarantine_size_mb<br>- Size (in Mb) of quarantine used to detect use-<span class="hljs-keyword">after</span>-free errors. Lower value may reduce <span class="hljs-keyword">memory</span> usage but increase the chance of false negatives.<br>thread_local_quarantine_size_kb<br>- Size (in Kb) of thread local quarantine used to detect use-<span class="hljs-keyword">after</span>-free errors. Lower value may reduce <span class="hljs-keyword">memory</span> usage but increase the chance of false negatives. It is not advised to go lower than <span class="hljs-number">64</span>Kb, otherwise frequent transfers to <span class="hljs-keyword">global</span> quarantine might affect performance.<br>redzone<br>- Minimal size (in bytes) of redzones around heap objects. Requirement: redzone &gt;= <span class="hljs-number">16</span>, is a power of two.<br>max_redzone<br>- Maximal size (in bytes) of redzones around heap objects.<br>debug<br>- If <span class="hljs-keyword">set</span>, prints some debugging information and does additional checks.<br>report_globals<br>- Controls the way to handle globals (<span class="hljs-number">0</span> - don&#x27;t detect buffer overflow on globals, <span class="hljs-number">1</span> - detect buffer overflow, <span class="hljs-number">2</span> - print data about registered globals).<br>check_initialization_order<br>- If <span class="hljs-keyword">set</span>, attempts to <span class="hljs-keyword">catch</span> initialization order issues.<br>replace_str<br>- If <span class="hljs-keyword">set</span>, uses custom wrappers and replacements <span class="hljs-keyword">for</span> libc <span class="hljs-keyword">string</span> functions to find more errors.<br>replace_intrin<br>- If <span class="hljs-keyword">set</span>, uses custom wrappers <span class="hljs-keyword">for</span> memset/memcpy/memmove intrinsics.<br>detect_stack_use_after_return<br>- Enables stack-use-<span class="hljs-keyword">after</span>-<span class="hljs-keyword">return</span> checking at run-<span class="hljs-keyword">time</span>.<br>min_uar_stack_size_log<br>- Minimum fake stack size log.<br>max_uar_stack_size_log<br>- Maximum fake stack size log.<br>uar_noreserve<br>- Use mmap with &#x27;noreserve&#x27; flag to allocate fake stack.<br>max_malloc_fill_size<br>- ASan allocator flag. max_malloc_fill_size is the maximal amount of bytes that will be filled with malloc_fill_byte on malloc.<br>max_free_fill_size<br>- ASan allocator flag. max_free_fill_size is the maximal amount of bytes that will be filled with free_fill_byte during free.<br>malloc_fill_byte<br>- Value used to fill the newly allocated <span class="hljs-keyword">memory</span>.<br>free_fill_byte<br>- Value used to fill deallocated <span class="hljs-keyword">memory</span>.<br>allow_user_poisoning<br>- If <span class="hljs-keyword">set</span>, user may manually mark <span class="hljs-keyword">memory</span> regions as poisoned or unpoisoned.<br>sleep_before_dying<br>- Number of seconds to sleep between printing an <span class="hljs-keyword">error</span> report and terminating the program. Useful <span class="hljs-keyword">for</span> debugging purposes (e.g. when one needs to attach gdb).<br>sleep_after_init<br>- Number of seconds to sleep <span class="hljs-keyword">after</span> AddressSanitizer is initialized. Useful <span class="hljs-keyword">for</span> debugging purposes (e.g. when one needs to attach gdb).<br>check_malloc_usable_size<br>- Allows the users to work around the bug in Nvidia drivers prior to <span class="hljs-number">295.</span>*.<br>unmap_shadow_on_exit<br>- If <span class="hljs-keyword">set</span>, explicitly unmaps the (huge) shadow at <span class="hljs-keyword">exit</span>.<br>protect_shadow_gap<br>- If <span class="hljs-keyword">set</span>, mprotect the shadow gap<br>print_stats<br>- Print various statistics <span class="hljs-keyword">after</span> printing an <span class="hljs-keyword">error</span> message or <span class="hljs-keyword">if</span> atexit=<span class="hljs-number">1.</span><br>print_legend<br>- Print the legend <span class="hljs-keyword">for</span> the shadow bytes.<br>print_scariness<br>- Print the scariness score. Experimental.<br>atexit<br>- If <span class="hljs-keyword">set</span>, prints ASan <span class="hljs-keyword">exit</span> stats even <span class="hljs-keyword">after</span> program terminates successfully.<br>print_full_thread_history<br>- If <span class="hljs-keyword">set</span>, prints thread creation stacks <span class="hljs-keyword">for</span> the threads involved in the report and their ancestors up to the main thread.<br>poison_heap<br>- Poison (or not) the heap <span class="hljs-keyword">memory</span> on [de]allocation. Zero value is useful <span class="hljs-keyword">for</span> benchmarking the allocator or instrumentator.<br>poison_partial<br>- If true, poison partially addressable <span class="hljs-number">8</span>-byte aligned words (default=true). This flag affects heap and <span class="hljs-keyword">global</span> buffers, but not stack buffers.<br>poison_array_cookie<br>- Poison (or not) the <span class="hljs-keyword">array</span> cookie <span class="hljs-keyword">after</span> operator new[].<br>alloc_dealloc_mismatch<br>- Report errors on malloc/delete, new/free, new/delete[], etc.<br>new_delete_type_mismatch<br>- Report errors on mismatch between size of new and delete.<br>strict_init_order<br>- If true, assume that dynamic initializers can never access globals from other modules, even <span class="hljs-keyword">if</span> the latter are already initialized.<br>start_deactivated<br>- If true, ASan tweaks a bunch of other flags (quarantine, redzone, heap poisoning) to reduce <span class="hljs-keyword">memory</span> consumption as much as possible, and restores them to original values when the first instrumented module is loaded into the process. This is mainly intended to be used on Android. <br>detect_invalid_pointer_pairs<br>- If &gt;= <span class="hljs-number">2</span>, detect operations like &lt;, &lt;=, &gt;, &gt;= and - on invalid pointer pairs (e.g. when pointers belong to different objects); If == <span class="hljs-number">1</span>, detect invalid operations only when both pointers are non-null.<br>detect_container_overflow<br>- If true, honor the container overflow annotations. See https://github.com/google/sanitizers/wiki/AddressSanitizerContainerOverflow<br>detect_odr_violation<br>- If &gt;=<span class="hljs-number">2</span>, detect violation of One-Definition-Rule (ODR); If ==<span class="hljs-number">1</span>, detect ODR-violation only <span class="hljs-keyword">if</span> the two variables have different sizes<br>suppressions<br>- Suppressions <span class="hljs-keyword">file</span> name.<br>halt_on_error<br>- Crash the program <span class="hljs-keyword">after</span> printing the first <span class="hljs-keyword">error</span> report (WARNING: USE AT YOUR OWN RISK!)<br>use_odr_indicator<br>- Use special ODR indicator symbol <span class="hljs-keyword">for</span> ODR violation detection<br>allocator_frees_and_returns_null_on_realloc_zero<br>- realloc(p, <span class="hljs-number">0</span>) is equivalent to free(p) by default (Same as the POSIX standard). If <span class="hljs-keyword">set</span> to false, realloc(p, <span class="hljs-number">0</span>) will <span class="hljs-keyword">return</span> a pointer to an allocated space which can not be used.<br>verify_asan_link_order<br>- Check position of ASan runtime in library <span class="hljs-keyword">list</span> (needs to be disabled when other library has to be preloaded system-wide)<br>symbolize<br>- If <span class="hljs-keyword">set</span>, use the online symbolizer from common sanitizer runtime to turn virtual addresses to <span class="hljs-keyword">file</span>/line locations.<br>external_symbolizer_path<br>- Path to external symbolizer. If empty, the tool will search <span class="hljs-variable">$PATH</span> <span class="hljs-keyword">for</span> the symbolizer.<br>allow_addr2line<br>- If <span class="hljs-keyword">set</span>, allows online symbolizer to run addr2line <span class="hljs-keyword">binary</span> to symbolize stack traces (addr2line will only be used <span class="hljs-keyword">if</span> llvm-symbolizer <span class="hljs-keyword">binary</span> is unavailable.<br>strip_path_prefix<br>- Strips this prefix from <span class="hljs-keyword">file</span> paths in <span class="hljs-keyword">error</span> reports.<br>fast_unwind_on_check<br>- If available, use the fast frame-pointer-based unwinder on internal CHECK failures.<br>fast_unwind_on_fatal<br>- If available, use the fast frame-pointer-based unwinder on fatal errors.<br>fast_unwind_on_malloc<br>- If available, use the fast frame-pointer-based unwinder on malloc/free.<br>handle_ioctl<br>- Intercept and handle ioctl requests.<br>malloc_context_size<br>- Max number of stack frames kept <span class="hljs-keyword">for</span> each allocation/deallocation.<br>log_path<br>- Write logs to <span class="hljs-string">&quot;log_path.pid&quot;</span>. The special values are <span class="hljs-string">&quot;stdout&quot;</span> and <span class="hljs-string">&quot;stderr&quot;</span>. The default is <span class="hljs-string">&quot;stderr&quot;</span>.<br>log_exe_name<br>- Mention name of executable when reporting <span class="hljs-keyword">error</span> and <span class="hljs-keyword">append</span> executable name to logs (as in <span class="hljs-string">&quot;log_path.exe_name.pid&quot;</span>).<br>log_to_syslog<br>- Write all sanitizer output to syslog in addition to other means of logging.<br>verbosity<br>- Verbosity level (<span class="hljs-number">0</span> - silent, <span class="hljs-number">1</span> - a bit of output, <span class="hljs-number">2</span>+ - more output).<br>detect_leaks<br>- Enable <span class="hljs-keyword">memory</span> leak detection.<br>leak_check_at_exit<br>- Invoke leak checking in an atexit handler. Has no effect <span class="hljs-keyword">if</span> detect_leaks=false, or <span class="hljs-keyword">if</span> __lsan_do_leak_check() is called before the handler has a chance to run.<br>allocator_may_return_null<br>- If false, the allocator will crash instead of returning <span class="hljs-number">0</span> on out-of-<span class="hljs-keyword">memory</span>.<br>print_summary<br>- If false, disable printing <span class="hljs-keyword">error</span> summaries in addition to <span class="hljs-keyword">error</span> reports.<br>print_module_map<br>- OS X only (<span class="hljs-number">0</span> - don&#x27;t print, <span class="hljs-number">1</span> - print only once before process exits, <span class="hljs-number">2</span> - print <span class="hljs-keyword">after</span> each report).<br>check_printf<br>- Check printf arguments.<br>handle_segv<br>- Controls custom tool&#x27;s SIGSEGV handler (<span class="hljs-number">0</span> - do not registers the handler, <span class="hljs-number">1</span> - register the handler and allow user to <span class="hljs-keyword">set</span> own, <span class="hljs-number">2</span> - registers the handler and block user from changing it). <br>handle_sigbus<br>- Controls custom tool&#x27;s SIGBUS handler (<span class="hljs-number">0</span> - do not registers the handler, <span class="hljs-number">1</span> - register the handler and allow user to <span class="hljs-keyword">set</span> own, <span class="hljs-number">2</span> - registers the handler and block user from changing it). <br>handle_abort<br>- Controls custom tool&#x27;s SIGABRT handler (<span class="hljs-number">0</span> - do not registers the handler, <span class="hljs-number">1</span> - register the handler and allow user to <span class="hljs-keyword">set</span> own, <span class="hljs-number">2</span> - registers the handler and block user from changing it). <br>handle_sigill<br>- Controls custom tool&#x27;s SIGILL handler (<span class="hljs-number">0</span> - do not registers the handler, <span class="hljs-number">1</span> - register the handler and allow user to <span class="hljs-keyword">set</span> own, <span class="hljs-number">2</span> - registers the handler and block user from changing it). <br>handle_sigfpe<br>- Controls custom tool&#x27;s SIGFPE handler (<span class="hljs-number">0</span> - do not registers the handler, <span class="hljs-number">1</span> - register the handler and allow user to <span class="hljs-keyword">set</span> own, <span class="hljs-number">2</span> - registers the handler and block user from changing it). <br>allow_user_segv_handler<br>- Deprecated. True has no effect, use handle_sigbus=<span class="hljs-number">1.</span> If false, handle_*=<span class="hljs-number">1</span> will be upgraded to handle_*=<span class="hljs-number">2.</span><br>use_sigaltstack<br>- If <span class="hljs-keyword">set</span>, uses alternate stack <span class="hljs-keyword">for</span> signal handling.<br>detect_deadlocks<br>- If <span class="hljs-keyword">set</span>, deadlock detection is enabled.<br>clear_shadow_mmap_threshold<br>- Large shadow regions are zero-filled using mmap(NORESERVE) instead of memset(). This is the threshold size in bytes.<br>color<br>- Colorize reports: (always|never|auto).<br>legacy_pthread_cond<br>- Enables support <span class="hljs-keyword">for</span> dynamic libraries linked with libpthread <span class="hljs-number">2.2</span><span class="hljs-number">.5</span>.<br>intercept_tls_get_addr<br>- Intercept __tls_get_addr.<br>help<br>- Print the flag descriptions.<br>mmap_limit_mb<br>- Limit the amount of mmap-ed <span class="hljs-keyword">memory</span> (excluding shadow) in Mb; not a user-facing flag, used mosly <span class="hljs-keyword">for</span> testing the tools<br>hard_rss_limit_mb<br>- Hard RSS limit in Mb. If non-zero, a background thread is spawned at startup which periodically reads RSS and aborts the process <span class="hljs-keyword">if</span> the limit is reached<br>soft_rss_limit_mb<br>- Soft RSS limit in Mb. If non-zero, a background thread is spawned at startup which periodically reads RSS. If the limit is reached all subsequent malloc/new calls will fail or <span class="hljs-keyword">return</span> NULL (depending on the value of allocator_may_return_null) until the RSS goes below the soft limit. This limit does not affect <span class="hljs-keyword">memory</span> allocations other than malloc/new.<br>heap_profile<br>- Experimental heap profiler, asan-only<br>allocator_release_to_os_interval_ms<br>- Experimental. Only affects a <span class="hljs-number">64</span>-bit allocator. If <span class="hljs-keyword">set</span>, tries to release unused <span class="hljs-keyword">memory</span> to the OS, but not more often than this interval (in milliseconds). Negative values mean do not attempt to release <span class="hljs-keyword">memory</span> to the OS.<br><br>can_use_proc_maps_statm<br>- If false, do not attempt to <span class="hljs-keyword">read</span> /<span class="hljs-keyword">proc</span>/maps/statm.<span class="hljs-title"> Mostly</span> useful<span class="hljs-title"> for</span> testing<span class="hljs-title"> sanitizers.</span><br><span class="hljs-title">coverage</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> coverage</span> information<span class="hljs-title"> will</span> be<span class="hljs-title"> dumped</span> at<span class="hljs-title"> program</span> shutdown (if<span class="hljs-title"> the</span> coverage<span class="hljs-title"> instrumentation</span> was<span class="hljs-title"> enabled</span> at<span class="hljs-title"> compile</span> time).<span class="hljs-title"></span><br><span class="hljs-title">coverage_dir</span><br>-<span class="hljs-title"> Target</span> directory<span class="hljs-title"> for</span> coverage<span class="hljs-title"> dumps.</span> Defaults<span class="hljs-title"> to</span> the<span class="hljs-title"> current</span> directory.<span class="hljs-title"></span><br><span class="hljs-title">full_address_space</span><br>-<span class="hljs-title"> Sanitize</span> complete<span class="hljs-title"> address</span> space;<span class="hljs-title"> by</span> default<span class="hljs-title"> kernel</span> area<span class="hljs-title"> on</span> 32-bit<span class="hljs-title"> platforms</span> will<span class="hljs-title"> not</span> be<span class="hljs-title"> sanitized</span><br><span class="hljs-title">print_suppressions</span><br>-<span class="hljs-title"> Print</span> matched<span class="hljs-title"> suppressions</span> at<span class="hljs-title"> exit.</span><br><span class="hljs-title">disable_coredump</span><br>-<span class="hljs-title"> Disable</span> core<span class="hljs-title"> dumping.</span> By<span class="hljs-title"> default,</span> disable_coredump=1<span class="hljs-title"> on</span> 64-bit<span class="hljs-title"> to</span> avoid<span class="hljs-title"> dumping</span> a 16T+<span class="hljs-title"> core</span> file.<span class="hljs-title"> Ignored</span> on<span class="hljs-title"> OSes</span> that<span class="hljs-title"> don&#x27;t</span> dump<span class="hljs-title"> core</span> by<span class="hljs-title"> default</span> and<span class="hljs-title"> for</span> sanitizers<span class="hljs-title"> that</span> don&#x27;t<span class="hljs-title"> reserve</span> lots<span class="hljs-title"> of</span> virtual<span class="hljs-title"> memory.</span><br><span class="hljs-title">use_madv_dontdump</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> instructs</span> kernel<span class="hljs-title"> to</span> not<span class="hljs-title"> store</span> the (huge)<span class="hljs-title"> shadow</span> in<span class="hljs-title"> core</span> file.<span class="hljs-title"></span><br><span class="hljs-title">symbolize_inline_frames</span><br>-<span class="hljs-title"> Print</span> inlined<span class="hljs-title"> frames</span> in<span class="hljs-title"> stacktraces.</span> Defaults<span class="hljs-title"> to</span> true.<span class="hljs-title"></span><br><span class="hljs-title">symbolize_vs_style</span><br>-<span class="hljs-title"> Print</span> file<span class="hljs-title"> locations</span> in<span class="hljs-title"> Visual</span> Studio<span class="hljs-title"> style</span> (e.g:<span class="hljs-title">  file(10,42):</span> ...<span class="hljs-title"></span><br><span class="hljs-title">dedup_token_length</span><br>-<span class="hljs-title"> If</span> positive,<span class="hljs-title"> after</span> printing<span class="hljs-title"> a</span> stack<span class="hljs-title"> trace</span> also<span class="hljs-title"> print</span> a<span class="hljs-title"> short</span> string<span class="hljs-title"> token</span> based<span class="hljs-title"> on</span> this<span class="hljs-title"> number</span> of<span class="hljs-title"> frames</span> that<span class="hljs-title"> will</span> simplify<span class="hljs-title"> deduplication</span> of<span class="hljs-title"> the</span> reports.<span class="hljs-title"> Example:</span> &#x27;DEDUP_TOKEN:<span class="hljs-title"> foo-bar-main&#x27;.</span> Default<span class="hljs-title"> is</span> 0.<span class="hljs-title"></span><br><span class="hljs-title">stack_trace_format</span><br>-<span class="hljs-title"> Format</span> string<span class="hljs-title"> used</span> to<span class="hljs-title"> render</span> stack<span class="hljs-title"> frames.</span> See<span class="hljs-title"> sanitizer_stacktrace_printer.h</span> for<span class="hljs-title"> the</span> format<span class="hljs-title"> description.</span> Use<span class="hljs-title"> DEFAULT</span> to<span class="hljs-title"> get</span> default<span class="hljs-title"> format.</span><br><span class="hljs-title">no_huge_pages_for_shadow</span><br>-<span class="hljs-title"> If</span> true,<span class="hljs-title"> the</span> shadow<span class="hljs-title"> is</span> not<span class="hljs-title"> allowed</span> to<span class="hljs-title"> use</span> huge<span class="hljs-title"> pages.</span> <span class="hljs-title"></span><br><span class="hljs-title">strict_string_checks</span><br>-<span class="hljs-title"> If</span> set<span class="hljs-title"> check</span> that<span class="hljs-title"> string</span> arguments<span class="hljs-title"> are</span> properly<span class="hljs-title"> null-terminated</span><br><span class="hljs-title">intercept_strstr</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> strstr</span> and<span class="hljs-title"> strcasestr</span> functions<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">intercept_strspn</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> strspn</span> and<span class="hljs-title"> strcspn</span> function<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">intercept_strtok</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> a<span class="hljs-title"> custom</span> wrapper<span class="hljs-title"> for</span> the<span class="hljs-title"> strtok</span> function<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">intercept_strpbrk</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> strpbrk</span> function<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">intercept_strlen</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> strlen</span> and<span class="hljs-title"> strnlen</span> functions<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">intercept_strndup</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> strndup</span> functions<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">intercept_strchr</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> strchr,</span> strchrnul,<span class="hljs-title"> and</span> strrchr<span class="hljs-title"> functions</span> to<span class="hljs-title"> find</span> more<span class="hljs-title"> errors.</span><br><span class="hljs-title">intercept_memcmp</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> memcmp</span> function<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">strict_memcmp</span><br>-<span class="hljs-title"> If</span> true,<span class="hljs-title"> assume</span> that<span class="hljs-title"> memcmp(p1,</span> p2,<span class="hljs-title"> n)</span> always<span class="hljs-title"> reads</span> n<span class="hljs-title"> bytes</span> before<span class="hljs-title"> comparing</span> p1<span class="hljs-title"> and</span> p2.<span class="hljs-title"></span><br><span class="hljs-title">intercept_memmem</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> a<span class="hljs-title"> wrapper</span> for<span class="hljs-title"> memmem()</span> to<span class="hljs-title"> find</span> more<span class="hljs-title"> errors.</span><br><span class="hljs-title">intercept_intrin</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> memset/memcpy/memmove</span> intrinsics<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">intercept_stat</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for *stat<span class="hljs-title"> functions</span> to<span class="hljs-title"> find</span> more<span class="hljs-title"> errors.</span><br><span class="hljs-title">intercept_send</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> uses</span> custom<span class="hljs-title"> wrappers</span> for<span class="hljs-title"> send*</span> functions<span class="hljs-title"> to</span> find<span class="hljs-title"> more</span> errors.<span class="hljs-title"></span><br><span class="hljs-title">decorate_proc_maps</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> decorate</span> sanitizer<span class="hljs-title"> mappings</span> in /<span class="hljs-keyword">proc</span>/self/maps<span class="hljs-title"> with</span> user-readable<span class="hljs-title"> names</span><br><span class="hljs-title">exitcode</span><br>-<span class="hljs-title"> Override</span> the<span class="hljs-title"> program</span> exit<span class="hljs-title"> status</span> if<span class="hljs-title"> the</span> tool<span class="hljs-title"> found</span> an<span class="hljs-title"> error</span><br><span class="hljs-title">abort_on_error</span><br>-<span class="hljs-title"> If</span> set,<span class="hljs-title"> the</span> tool<span class="hljs-title"> calls</span> abort()<span class="hljs-title"> instead</span> of<span class="hljs-title"> _exit()</span> after<span class="hljs-title"> printing</span> the<span class="hljs-title"> error</span> report.<span class="hljs-title"></span><br><span class="hljs-title">suppress_equal_pcs</span><br>-<span class="hljs-title"> Deduplicate</span> multiple<span class="hljs-title"> reports</span> for<span class="hljs-title"> single</span> source<span class="hljs-title"> location</span> in<span class="hljs-title"> halt_on_error=false</span> mode (asan<span class="hljs-title"> only).</span><br><span class="hljs-title">print_cmdline</span><br>-<span class="hljs-title"> Print</span> command<span class="hljs-title"> line</span> on<span class="hljs-title"> crash</span> (asan<span class="hljs-title"> only).</span><br><span class="hljs-title">html_cov_report</span><br>-<span class="hljs-title"> Generate</span> html<span class="hljs-title"> coverage</span> report.<span class="hljs-title"></span><br><span class="hljs-title">sancov_path</span><br>-<span class="hljs-title"> Sancov</span> tool<span class="hljs-title"> location.</span><br><span class="hljs-title">dump_instruction_bytes</span><br>-<span class="hljs-title"> If</span> true,<span class="hljs-title"> dump</span> 16<span class="hljs-title"> bytes</span> starting<span class="hljs-title"> at</span> the<span class="hljs-title"> instruction</span> that<span class="hljs-title"> caused</span> SEGV<span class="hljs-title"></span><br><span class="hljs-title">dump_registers</span><br>-<span class="hljs-title"> If</span> true,<span class="hljs-title"> dump</span> values<span class="hljs-title"> of</span> CPU<span class="hljs-title"> registers</span> when<span class="hljs-title"> SEGV</span> happens.<span class="hljs-title"> Only</span> available<span class="hljs-title"> on</span> OS<span class="hljs-title"> X</span> for<span class="hljs-title"> now.</span><br><span class="hljs-title">include</span><br>-<span class="hljs-title"> read</span> more<span class="hljs-title"> options</span> from<span class="hljs-title"> the</span> given<span class="hljs-title"> file</span><br><span class="hljs-title">include_if_exists</span><br>-<span class="hljs-title"> read</span> more<span class="hljs-title"> options</span> from<span class="hljs-title"> the</span> given<span class="hljs-title"> file</span> (if<span class="hljs-title"> it</span> exists)<br>=================================================================<br>==4911==ERROR:<span class="hljs-title"> AddressSanitizer:</span> stack-buffer-overflow<span class="hljs-title"> on</span> address 0x7ffe84af3135<span class="hljs-title"> at</span> pc 0x2ab12ca03533<span class="hljs-title"> bp</span> 0x7ffe84af3000<span class="hljs-title"> sp</span> 0x7ffe84af2790<span class="hljs-title"></span><br><span class="hljs-title">WRITE</span> of<span class="hljs-title"> size</span> 7<span class="hljs-title"> at</span> 0x7ffe84af3135<span class="hljs-title"> thread</span> T0<br>#0 0x2ab12ca03532<span class="hljs-title"> in</span> __interceptor_vsprintf (/usr/lib64/libasan.so.5+0x55532)<br>#1 0x2ab12ca038a6<span class="hljs-title"> in</span> sprintf (/usr/lib64/libasan.so.5+0x558a6)<br>#2 0x400de1<span class="hljs-title"> in</span> test_oom_sprintf() /root/err/main2.cpp:22<br>#3 0x40108d<span class="hljs-title"> in</span> main /root/err/main2.cpp:48<br>#4 0x2ab12e1bdb34<span class="hljs-title"> in</span> __libc_start_main (/usr/lib64/libc.so.6+0x21b34)<br>#5 0x400c28  (/root/err/test_oom+0x400c28)<span class="hljs-title"></span><br><span class="hljs-title"></span><br><span class="hljs-title">Address</span> 0x7ffe84af3135<span class="hljs-title"> is</span> located<span class="hljs-title"> in</span> stack<span class="hljs-title"> of</span> thread<span class="hljs-title"> T0</span> at<span class="hljs-title"> offset</span> 37<span class="hljs-title"> in</span> frame<br>#0 0x400ce1<span class="hljs-title"> in</span> test_oom_sprintf() /root/err/main2.cpp:19<span class="hljs-title"></span><br><span class="hljs-title"></span><br><span class="hljs-title">This</span> frame<span class="hljs-title"> has</span> 1<span class="hljs-title"> object(s):</span><br>[32, 37) &#x27;buf&#x27; &lt;==<span class="hljs-title"> Memory</span> access<span class="hljs-title"> at</span> offset 37<span class="hljs-title"> overflows</span> this<span class="hljs-title"> variable</span><br>HINT:<span class="hljs-title"> this</span> may<span class="hljs-title"> be</span> a<span class="hljs-title"> false</span> positive<span class="hljs-title"> if</span> your<span class="hljs-title"> program</span> uses<span class="hljs-title"> some</span> custom<span class="hljs-title"> stack</span> unwind<span class="hljs-title"> mechanism</span> or<span class="hljs-title"> swapcontext</span><br>(longjmp<span class="hljs-title"> and</span> C++<span class="hljs-title"> exceptions</span> *are*<span class="hljs-title"> supported)</span><br>SUMMARY:<span class="hljs-title"> AddressSanitizer:</span> stack-buffer-overflow (/usr/lib64/libasan.so.5+0x55532)<span class="hljs-title"> in</span> __interceptor_vsprintf<span class="hljs-title"></span><br><span class="hljs-title">Shadow</span> bytes<span class="hljs-title"> around</span> the<span class="hljs-title"> buggy</span> address:<br>0x1000509565d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>0x1000509565e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>0x1000509565f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>0x100050956600: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>0x100050956610: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>=&gt;0x100050956620: 00 00<span class="hljs-title"> f1</span> f1<span class="hljs-title"> f1</span> f1[05]f2<span class="hljs-title"> f2</span> f2<span class="hljs-title"> f3</span> f3<span class="hljs-title"> f3</span> f3 00 00<br>0x100050956630: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>0x100050956640: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>0x100050956650: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>0x100050956660: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>0x100050956670: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<span class="hljs-title"></span><br><span class="hljs-title">Shadow</span> byte<span class="hljs-title"> legend</span> (one<span class="hljs-title"> shadow</span> byte<span class="hljs-title"> represents</span> 8<span class="hljs-title"> application</span> bytes):<span class="hljs-title"></span><br><span class="hljs-title">Addressable:</span>           00<span class="hljs-title"></span><br><span class="hljs-title">Partially</span> addressable: 01 02 03 04 05 06 07<span class="hljs-title"> </span><br><span class="hljs-title">Heap</span> left<span class="hljs-title"> redzone:</span> <span class="hljs-title">      fa</span><br>Freed<span class="hljs-title"> heap</span> region:<span class="hljs-title">       fd</span><br>Stack<span class="hljs-title"> left</span> redzone:<span class="hljs-title">      f1</span><br>Stack<span class="hljs-title"> mid</span> redzone:<span class="hljs-title">       f2</span><br>Stack<span class="hljs-title"> right</span> redzone:<span class="hljs-title">     f3</span><br>Stack<span class="hljs-title"> after</span> return:<span class="hljs-title">      f5</span><br>Stack<span class="hljs-title"> use</span> after<span class="hljs-title"> scope:</span> <span class="hljs-title">  f8</span><br>Global<span class="hljs-title"> redzone:</span> <span class="hljs-title">         f9</span><br>Global<span class="hljs-title"> init</span> order:<span class="hljs-title">       f6</span><br>Poisoned<span class="hljs-title"> by</span> user:<span class="hljs-title">        f7</span><br>Container<span class="hljs-title"> overflow:</span> <span class="hljs-title">     fc</span><br>Array<span class="hljs-title"> cookie:</span> <span class="hljs-title">           ac</span><br>Intra<span class="hljs-title"> object</span> redzone:<span class="hljs-title">    bb</span><br>ASan<span class="hljs-title"> internal:</span> <span class="hljs-title">          fe</span><br>Left<span class="hljs-title"> alloca</span> redzone:<span class="hljs-title">     ca</span><br>Right<span class="hljs-title"> alloca</span> redzone:<span class="hljs-title">    cb</span><br>==4911==ABORTING<br></code></pre></td></tr></table></figure></li></ol><h2 id="遇到的问题和解决方法"><a href="#遇到的问题和解决方法" class="headerlink" title="遇到的问题和解决方法"></a>遇到的问题和解决方法</h2><ul><li>找不到 libasan_preinit.o<br>  安装和gcc版本匹配的libasan-devel库即可</li><li>错误信息只能输出到屏幕，不能输出到日志<br>  一般是gcc版本&lt;5.x导致，升级gcc和对应的libasan库即可</li><li>升级到高版gcc后，程序执行后仍然不能输出错误信息到到日志文件中，或者设置的ASAN_OPTIONS参数根本没效果<br>  确保编译时添加了-fsanitize=address等编译参数后，仍无法输出，可以考虑在程序中添加环境变量信息输出验证是否设置了ASAN_OPTIONS</li><li>是否可以在程序main函数入口处调用setenv函数来设置ASAN_OPTIONS来达到启用asan动态参数的目的<br>  经验证不可以,程序在执行main函数前libasan已经检测ASAN_OPTIONS参数，所以要在程序启动时传递或已经设置系统环境变量</li><li>当前开发机gcc为4.x版本，怎么样可以快速的切换gcc到高版本且不破坏当前的开发环境<br>  安装SCL，通过SCL安装各个不同版本的gcc，且可以快速方便的切换不同版本, scl enable devtoolset-4 bash<h1 id="使用SCL-快速构建不同gcc-g-版本开发环境"><a href="#使用SCL-快速构建不同gcc-g-版本开发环境" class="headerlink" title="使用SCL 快速构建不同gcc/g++版本开发环境"></a>使用SCL 快速构建不同gcc/g++版本开发环境</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2>SCL(Software Collections)可以让您能够在同一系统上构建，安装和使用多个版本的软件，而不会影响整个系统已安装的软件包。</li></ul><p>devtoolset 就是按照 Software Collections 的规范打出来的一套 rpm 包。通过scl可以方便的切换不同版本的devtoolset开发环境。个人认为可以理解为类似docker的开发环境，只是更轻量，更方便。</p><p>SCL项目主页：<a href="https://www.softwarecollections.org/">https://www.softwarecollections.org/</a></p><h2 id="安装及使用"><a href="#安装及使用" class="headerlink" title="安装及使用"></a>安装及使用</h2><h3 id="安装scl源"><a href="#安装scl源" class="headerlink" title="安装scl源"></a>安装scl源</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">yum <span class="hljs-keyword">install </span>centos-release-<span class="hljs-keyword">scl </span><span class="hljs-keyword">scl-utils-build</span><br></code></pre></td></tr></table></figure><h3 id="列出scl源有哪些包可以用："><a href="#列出scl源有哪些包可以用：" class="headerlink" title="列出scl源有哪些包可以用："></a>列出scl源有哪些包可以用：</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">yum list <span class="hljs-keyword">all</span> <span class="hljs-comment">--enablerepo=&#x27;centos-sclo-rh&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="安装对应版本的devtoolset开发包"><a href="#安装对应版本的devtoolset开发包" class="headerlink" title="安装对应版本的devtoolset开发包"></a>安装对应版本的devtoolset开发包</h3><p>如：安装8.3版本的gcc、gcc-c++等开发环境需要的包执行如下安装命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install -y devtoolset-<span class="hljs-number">8</span>-gcc-gdb-plugin-<span class="hljs-number">8</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> devtoolset-<span class="hljs-number">8</span>-libstdc++-devel-<span class="hljs-number">8</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> devtoolset-<span class="hljs-number">8</span>-binutils-<span class="hljs-number">2</span>.<span class="hljs-number">30</span>-<span class="hljs-number">54</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> devtoolset-<span class="hljs-number">8</span>-gcc-<span class="hljs-number">8</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> devtoolset-<span class="hljs-number">8</span>-libasan-devel-<span class="hljs-number">8</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> devtoolset-<span class="hljs-number">8</span>-gcc-c++-<span class="hljs-number">8</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span> devtoolset-<span class="hljs-number">8</span>-runtime-<span class="hljs-number">8</span>.<span class="hljs-number">1</span>-<span class="hljs-number">1</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><h3 id="查看安装的devtoolset环境列表"><a href="#查看安装的devtoolset环境列表" class="headerlink" title="查看安装的devtoolset环境列表"></a>查看安装的devtoolset环境列表</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">scl -l</span><br></code></pre></td></tr></table></figure><img src="/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/image2020-1-3_13-53-13.png" class=""><h3 id="切换到devtoolset-8环境"><a href="#切换到devtoolset-8环境" class="headerlink" title="切换到devtoolset-8环境"></a>切换到devtoolset-8环境</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">scl <span class="hljs-builtin-name">enable</span> devtoolset-8 bash<br></code></pre></td></tr></table></figure><p>切换后效果如下：</p><img src="/2023/10/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/16%E5%A6%82%E4%BD%95%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%BD%E8%B8%AA%E8%BF%90%E8%A1%8C%E6%80%81%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E7%9A%84%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA/image2020-1-3_13-50-10.png" class=""> ]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基数树(Radix Trie)</title>
    <link href="/2023/08/15/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05%E5%9F%BA%E6%95%B0%E6%A0%91(RadixTrie)/"/>
    <url>/2023/08/15/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05%E5%9F%BA%E6%95%B0%E6%A0%91(RadixTrie)/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在计算机科学中，基数树（Radix Trie，也叫基数特里树或压缩前缀树）是一种数据结构，是一种更节省空间的Trie（前缀树），其中作为唯一子节点的每个节点都与其父节点合并，边既可以表示为元素序列又可以表示为单个元素。 因此每个内部节点的子节点数最多为基数树的基数r ，其中r为正整数，是2的x次方，x≥1，这使得基数树更适用于对于较小的集合（尤其是字符串很长的情况下）和有很长相同前缀的字符串集合。</p><p>基数树的查找方式也与常规树不同（常规的树查找一开始就对整个键进行比较，直到不相同为止），基数树查找时节点时，对于节点上的键都按块进行逐块比较，其中该节点中块的长度是基数r； 当r为2时，基数树为二进制的（即该节点的键的长度为1比特位），能最大程度地减小树的深度来最小化稀疏性（最大限度地合并键中没有分叉的节点）。 当r≥4且为2的整数次幂时，基数树是r元基数树，能以潜在的稀疏性为代价降低基数树的深度。</p><p>基数树支持插入、删除、查找操作。查找包括完全匹配、前缀匹配、前驱查找、后继查找。所有这些操作都是O(k)复杂度，其中k是所有字符串中最大的长度。</p><h1 id="使用场景举例"><a href="#使用场景举例" class="headerlink" title="使用场景举例"></a>使用场景举例</h1><ol><li><p>IP 路由表查找：利用基数树将 IP 地址按子网分组，实现快速和高效的路由表查找。</p></li><li><p>DNS 缓存：将带有子网信息的 DNS 条目存储在基数树中，以实现高效的缓存查找和分配。</p></li><li><p>字符串匹配和搜索：在基数树中存储字符串，可以缩短搜索和匹配的时间复杂度。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/404700132">https://zhuanlan.zhihu.com/p/404700132</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%A0%91">https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%A0%91</a><br><a href="https://ivanzz1001.github.io/records/post/data-structure/2018/11/18/ds-radix-tree">https://ivanzz1001.github.io/records/post/data-structure/2018/11/18/ds-radix-tree</a></p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RFC1034(域名 - 概念和设施)</title>
    <link href="/2023/08/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/22-rfc1034/"/>
    <url>/2023/08/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/22-rfc1034/</url>
    
    <content type="html"><![CDATA[<p>DOMAIN NAMES - CONCEPTS AND FACILITIES(域名-概念和设施)</p><h1 id="1-STATUS-OF-THIS-MEMO-本备忘录的状态"><a href="#1-STATUS-OF-THIS-MEMO-本备忘录的状态" class="headerlink" title="1. STATUS OF THIS MEMO(本备忘录的状态)"></a>1. STATUS OF THIS MEMO(本备忘录的状态)</h1><p>This RFC is an introduction to the Domain Name System (DNS), and omits<br>many details which can be found in a companion RFC, “Domain Names -<br>Implementation and Specification” [RFC-1035].  That RFC assumes that the<br>reader is familiar with the concepts discussed in this memo.</p><p><em>该 RFC 是对域名系统 (DNS) 的介绍，省略了许多细节，这些细节可以在配套 RFC中找到,<a href="%E5%9F%9F%E5%90%8D%E5%AE%9E%E7%8E%B0%E5%92%8C%E8%A7%84%E8%8C%83">RFC1035</a>。 该 RFC 假定读者熟悉本备忘录中讨论的概念。</em></p><p>A subset of DNS functions and data types constitute an official<br>protocol.  The official protocol includes standard queries and their<br>responses and most of the Internet class data formats (e.g., host<br>addresses).</p><p>However, the domain system is intentionally extensible.  Researchers are<br>continuously proposing, implementing and experimenting with new data<br>types, query types, classes, functions, etc.  Thus while the components<br>of the official protocol are expected to stay essentially unchanged and<br>operate as a production service, experimental behavior should always be<br>expected in extensions beyond the official protocol.  Experimental or<br>obsolete features are clearly marked in these RFCs, and such information<br>should be used with caution.</p><p>The reader is especially cautioned not to depend on the values which<br>appear in examples to be current or complete, since their purpose is<br>primarily pedagogical.  Distribution of this memo is unlimited.</p><h1 id="2-INTRODUCTION"><a href="#2-INTRODUCTION" class="headerlink" title="2. INTRODUCTION"></a>2. INTRODUCTION</h1><p>This RFC introduces domain style names, their use for Internet mail and<br>host address support, and the protocols and servers used to implement<br>domain name facilities.</p><h2 id="2-1-The-history-of-domain-names"><a href="#2-1-The-history-of-domain-names" class="headerlink" title="2.1. The history of domain names"></a>2.1. The history of domain names</h2><p>The impetus for the development of the domain system was growth in the<br>Internet:</p><ul><li><p>Host name to address mappings were maintained by the Network<br>Information Center (NIC) in a single file (HOSTS.TXT) which<br>was FTPed by all hosts [RFC-952, RFC-953].  The total network<br>bandwidth consumed in distributing a new version by this<br>scheme is proportional to the square of the number of hosts in<br>the network, and even when multiple levels of FTP are used,<br>the outgoing FTP load on the NIC host is considerable.<br>Explosive growth in the number of hosts didn’t bode well for<br>the future.</p></li><li><p>The network population was also changing in character.  The<br>timeshared hosts that made up the original ARPANET were being<br>replaced with local networks of workstations.  Local<br>organizations were administering their own names and<br>addresses, but had to wait for the NIC to change HOSTS.TXT to<br>make changes visible to the Internet at large.  Organizations<br>also wanted some local structure on the name space.</p></li><li><p>The applications on the Internet were getting more<br>sophisticated and creating a need for general purpose name<br>service.</p></li></ul><p>The result was several ideas about name spaces and their management<br>[IEN-116, RFC-799, RFC-819, RFC-830].  The proposals varied, but a<br>common thread was the idea of a hierarchical name space, with the<br>hierarchy roughly corresponding to organizational structure, and names<br>using “.”  as the character to mark the boundary between hierarchy<br>levels.  A design using a distributed database and generalized resources<br>was described in [RFC-882, RFC-883].  Based on experience with several<br>implementations, the system evolved into the scheme described in this<br>memo.</p><p>The terms “domain” or “domain name” are used in many contexts beyond the<br>DNS described here.  Very often, the term domain name is used to refer<br>to a name with structure indicated by dots, but no relation to the DNS.<br>This is particularly true in mail addressing [Quarterman 86].</p><h2 id="2-2-DNS-design-goals-DNS设计目标"><a href="#2-2-DNS-design-goals-DNS设计目标" class="headerlink" title="2.2. DNS design goals(DNS设计目标)"></a>2.2. DNS design goals(DNS设计目标)</h2><p>The design goals of the DNS influence its structure.  They are:<br><em>DNS 的设计目标影响其结构。 他们是:</em></p><ul><li>The primary goal is a consistent name space which will be used for referring to resources.  In order to avoid the problems caused by ad hoc encodings, names should not be required to contain network identifiers, addresses, routes, or similar information as part of the name.</li></ul><div class="code-wrapper"><pre><code class="hljs">*主要目标是用于引用资源的一致的名称空间。 为了避免临时编码引起的问题，不应要求名称包含网络标识符、地址、路由或类似信息作为名称的一部分。*</code></pre></div><ul><li><p>The sheer size of the database and frequency of updates suggest that it must be maintained in a distributed manner, with local caching to improve performance.  Approaches that attempt to collect a consistent copy of the entire database will become more and more expensive and difficult, and hence should be avoided.  The same principle holds for the structure of the name space, and in particular mechanisms for creating and deleting names; these should also be distributed.</p><p><em>数据库的庞大规模和更新频率表明必须以分布式方式维护它，并使用本地缓存来提高性能。 尝试收集整个数据库的一致副本的方法将变得越来越昂贵和困难，因此应该避免。 同样的原则也适用于名称空间的结构，特别是创建和删除名称的机制； 这些也应该分发。</em></p></li><li><p>Where there tradeoffs between the cost of acquiring data, the speed of updates, and the accuracy of caches, the source of the data should control the tradeoff.</p><p><em>当获取数据的成本、更新速度和缓存的准确性之间存在权衡时，数据源应该控制权衡。</em></p></li><li><p>The costs of implementing such a facility dictate that it be generally useful, and not restricted to a single application. We should be able to use names to retrieve host addresses, mailbox data, and other as yet undetermined information. All data associated with a name is tagged with a type, and queries can be limited to a single type.</p><p><em>实施这种设施的成本决定了它通常是有用的，并且不限于单个应用程序。 我们应该能够使用名称来检索主机地址、邮箱数据和其他尚未确定的信息。 与名称关联的所有数据都用类型标记，并且查询可以限制为单一类型。</em></p></li><li><p>Because we want the name space to be useful in dissimilar networks and applications, we provide the ability to use the same name space with different protocol families or management.  For example, host address formats differ between protocols, though all protocols have the notion of address. The DNS tags all data with a class as well as the type, so that we can allow parallel use of different formats for data of type address.</p><p><em>因为我们希望名称空间在不同的网络和应用程序中有用，所以我们提供了在不同协议族或管理中使用相同名称空间的能力。 例如，尽管所有协议都有地址的概念，但协议之间的主机地址格式有所不同。 DNS 用类别和类型标记所有数据，以便我们可以允许并行使用地址类型数据的不同格式。</em></p></li><li><p>We want name server transactions to be independent of the communications system that carries them.  Some systems may wish to use datagrams for queries and responses, and only establish virtual circuits for transactions that need the reliability (e.g., database updates, long transactions); other systems will use virtual circuits exclusively.</p><p><em>我们希望名称服务器事务独立于承载它们的通信系统。 有些系统可能希望使用数据报进行查询和响应，并且只为需要可靠性的事务（例如数据库更新、长事务）建立虚拟电路； 其他系统将专门使用虚拟电路。</em></p></li><li><p>The system should be useful across a wide spectrum of host capabilities.  Both personal computers and large timeshared hosts should be able to use the system, though perhaps in different ways.</p><p><em>该系统应该适用于广泛的主机功能。 个人计算机和大型分时主机都应该能够使用该系统，尽管方式可能不同。</em></p></li></ul><h2 id="2-3-Assumptions-about-usage-使用假设"><a href="#2-3-Assumptions-about-usage-使用假设" class="headerlink" title="2.3. Assumptions about usage(使用假设)"></a>2.3. Assumptions about usage(使用假设)</h2><p>The organization of the domain system derives from some assumptions about the needs and usage patterns of its user community and is designed to avoid many of the the complicated problems found in general purpose database systems.</p><p><em>域系统的组织源于对其用户社区的需求和使用模式的一些假设，并且旨在避免通用数据库系统中发现的许多复杂问题。</em></p><p>The assumptions are:(假设如下:)</p><ul><li><p>The size of the total database will initially be proportional to the number of hosts using the system, but will eventually grow to be proportional to the number of users on those hosts as mailboxes and other information are added to the domain system.<br><em>总数据库的大小最初将与使用系统的主机数量成正比，但随着邮箱和其他信息添加到域系统中，最终将与这些主机上的用户数量成正比。</em></p></li><li><p>Most of the data in the system will change very slowly (e.g., mailbox bindings, host addresses), but that the system should be able to deal with subsets that change more rapidly (on the order of seconds or minutes).<br><em>系统中的大多数数据将非常缓慢地变化（例如，邮箱绑定、主机地址），但是系统应该能够处理变化更快的子集（大约以秒或分钟为单位）。</em></p></li><li><p>The administrative boundaries used to distribute responsibility for the database will usually correspond to organizations that have one or more hosts.  Each organization that has responsibility for a particular set of domains will provide redundant name servers, either on the organization’s own hosts or other hosts that the organization arranges to use.<br><em>用于分配数据库职责的管理边界通常对应于拥有一台或多台主机的组织。 负责一组特定域的每个组织都将在该组织自己的主机上或该组织安排使用的其他主机上提供冗余名称服务器。</em></p></li><li><p>Clients of the domain system should be able to identify trusted name servers they prefer to use before accepting referrals to name servers outside of this “trusted” set.<br><em>域系统的客户端应该能够在接受对此“受信任”集合之外的名称服务器的引用之前识别他们更喜欢使用的受信任名称服务器。</em></p></li><li><p>Access to information is more critical than instantaneous updates or guarantees of consistency.  Hence the update process allows updates to percolate out through the users of the domain system rather than guaranteeing that all copies are simultaneously updated.  When updates are unavailable due to network or host failure, the usual course is to believe old information while continuing efforts to update it.  The general model is that copies are distributed with timeouts for refreshing.  The distributor sets the timeout value and the recipient of the distribution is responsible for performing the refresh.  In special situations, very short intervals can be specified, or the owner can prohibit copies.<br><em>获取信息比即时更新或保证一致性更重要。 因此，更新过程允许更新通过域系统的用户渗透出去，而不是保证所有副本同时更新。 当由于网络或主机故障而无法进行更新时，通常的做法是相信旧信息，同时继续努力更新它。 一般模型是分发副本并设置超时刷新。 分发者设置超时值，分发的接收者负责执行刷新。 在特殊情况下，可以指定非常短的间隔，或者所有者可以禁止复制。</em></p></li><li><p>In any system that has a distributed database, a particular name server may be presented with a query that can only be answered by some other server.  The two general approaches to dealing with this problem are “recursive”, in which the first server pursues the query for the client at another server, and “iterative”, in which the server refers the client to another server and lets the client pursue the query. Both approaches have advantages and disadvantages, but the iterative approach is preferred for the datagram style of access.  The domain system requires implementation of the iterative approach, but allows the recursive approach as an option.<br><em>在任何具有分布式数据库的系统中，特定的名称服务器可能会收到只能由其他服务器回答的查询。 处理此问题的两种通用方法是”recursive(递归)”，其中第一个服务器在另一台服务器上执行客户端的查询；以及“iterative(迭代)”，其中服务器将客户端引用到另一台服务器并让客户端执行查询 询问。 两种方法都有优点和缺点，但对于数据报样式的访问，迭代方法是首选。 域系统需要迭代方法的实现，但允许递归方法作为选项。</em></p></li></ul><p>The domain system assumes that all data originates in master files scattered through the hosts that use the domain system.  These master files are updated by local system administrators.  Master files are text files that are read by a local name server, and hence become available through the name servers to users of the domain system.  The user programs access name servers through standard programs called resolvers.<br><em>域系统假定所有数据都源自分散在使用域系统的主机中的主文件。 这些主文件由本地系统管理员更新。 主文件是由本地名称服务器读取的文本文件，因此可以通过名称服务器供域系统的用户使用。 用户程序通过称为解析器的标准程序访问名称服务器。</em></p><p>The standard format of master files allows them to be exchanged between hosts (via FTP, mail, or some other mechanism); this facility is useful when an organization wants a domain, but doesn’t want to support a name server.  The organization can maintain the master files locally using a text editor, transfer them to a foreign host which runs a name server, and then arrange with the system administrator of the name server to get the files loaded.<br><em>主文件的标准格式允许它们在主机之间交换（通过 FTP、邮件或其他一些机制）； 当组织想要域但不想支持名称服务器时，此功能非常有用。 组织可以使用文本编辑器在本地维护主文件，将它们传输到运行名称服务器的外部主机，然后与名称服务器的系统管理员安排加载文件。</em></p><p>Each host’s name servers and resolvers are configured by a local system administrator [RFC-1033].  For a name server, this configuration data includes the identity of local master files and instructions on which non-local master files are to be loaded from foreign servers.  The name server uses the master files or copies to load its zones.  For resolvers, the configuration data identifies the name servers which should be the primary sources of information.<br><em>每个主机的名称服务器和解析器均由本地系统管理员配置[RFC-1033]。 对于名称服务器，此配置数据包括本地主文件的标识以及从外部服务器加载非本地主文件的指令。 名称服务器使用主文件或副本来加载其区域。 对于解析器，配置数据标识名称服务器，该名称服务器应该是主要信息源。</em></p><p>The domain system defines procedures for accessing the data and for referrals to other name servers.  The domain system also defines procedures for caching retrieved data and for periodic refreshing of data defined by the system administrator.<br><em>域系统定义了访问数据和引用其他名称服务器的过程。 域系统还定义了用于缓存检索到的数据和定期刷新由系统管理员定义的数据的过程。</em></p><p>The system administrators provide:<br><em>系统管理员提供：</em></p><ul><li><p>The definition of zone boundaries.<br><em>区域边界的定义。</em></p></li><li><p>Master files of data.<br><em>主数据文件。</em></p></li><li><p>Updates to master files.<br><em>主文件更新</em></p></li><li><p>Statements of the refresh policies desired.<br><em>所需刷新策略的声明。</em></p></li></ul><p>The domain system provides:<br>域系统提供：</p><ul><li><p>Standard formats for resource data.<br><em>资源数据的标准格式。</em></p></li><li><p>Standard methods for querying the database.<br><em>查询数据库的标准方法。</em></p></li><li><p>Standard methods for name servers to refresh local data from foreign name servers.<br><em>名称服务器从外部名称服务器刷新本地数据的标准方法。</em></p></li></ul><h2 id="2-4-Elements-of-the-DNS（DNS元素）"><a href="#2-4-Elements-of-the-DNS（DNS元素）" class="headerlink" title="2.4. Elements of the DNS（DNS元素）"></a>2.4. Elements of the DNS（DNS元素）</h2><p>The DNS has three major components:<br><em>DNS 有三个主要组件：</em></p><ul><li><p>The DOMAIN NAME SPACE and RESOURCE RECORDS, which are specifications for a tree structured name space and data associated with the names.  Conceptually, each node and leaf of the domain name space tree names a set of information, and query operations are attempts to extract specific types of information from a particular set.  A query names the domain name of interest and describes the type of resource information that is desired.  For example, the Internet uses some of its domain names to identify hosts; queries for address resources return Internet host addresses.<br><em>域名空间和资源记录，它们是树结构名称空间和与名称相关的数据的规范。 从概念上讲，域名空间树的每个节点和叶子命名了一组信息，而查询操作是尝试从特定集合中提取特定类型的信息。 查询命名感兴趣的域名并描述所需的资源信息的类型。 例如，互联网使用一些域名来识别主机； 地址资源查询返回互联网主机地址。</em></p></li><li><p>NAME SERVERS are server programs which hold information about the domain tree’s structure and set information.  A name server may cache structure or set information about any part of the domain tree, but in general a particular name server has complete information about a subset of the domain space, and pointers to other name servers that can be used to lead to information from any part of the domain tree.  Name servers know the parts of the domain tree for which they have complete information; a name server is said to be an AUTHORITY for these parts of the name space.  Authoritative information is organized into units called ZONEs, and these zones can be automatically distributed to the name servers which provide redundant service for the data in a zone.<br><em>名称服务器是保存有关域树结构和设置信息的服务器程序。 名称服务器可以缓存有关域树任何部分的结构或设置信息，但通常特定的名称服务器具有有关域空间子集的完整信息，以及指向其他名称服务器的指针，这些指针可用于从 域树的任何部分。 名称服务器知道域树中它们拥有完整信息的部分； 名称服务器被认为是名称空间这些部分的权威。 权威信息被组织成称为“区域”的单元，这些区域可以自动分发到为区域中的数据提供冗余服务的名称服务器。</em></p></li><li><p>RESOLVERS are programs that extract information from name servers in response to client requests.  Resolvers must be able to access at least one name server and use that name server’s information to answer a query directly, or pursue the query using referrals to other name servers.  A resolver will typically be a system routine that is directly accessible to user programs; hence no protocol is necessary between the resolver and the user program.<br><em>解析器是从名称服务器中提取信息以响应客户端请求的程序。 解析器必须能够访问至少一个名称服务器并使用该名称服务器的信息直接回答查询，或者使用对其他名称服务器的引用来执行查询。 解析器通常是用户程序可以直接访问的系统例程； 因此解析器和用户程序之间不需要任何协议。</em></p></li></ul><p>These three components roughly correspond to the three layers or views of the domain system:<br><em>这三个组件大致对应于领域系统的三个层或视图：</em></p><ul><li><p>From the user’s point of view, the domain system is accessed through a simple procedure or OS call to a local resolver. The domain space consists of a single tree and the user can request information from any section of the tree.<br><em>从用户的角度来看，域系统是通过简单的过程或操作系统调用本地解析器来访问的。 域空间由一棵树组成，用户可以从树的任何部分请求信息。</em></p></li><li><p>From the resolver’s point of view, the domain system is composed of an unknown number of name servers.  Each name server has one or more pieces of the whole domain tree’s data, but the resolver views each of these databases as essentially static.<br><em>从解析器的角度来看，域系统由未知数量的名称服务器组成。 每个名称服务器都有整个域树的一个或多个数据，但解析器将每个数据库视为本质上静态的。</em></p></li><li><p>From a name server’s point of view, the domain system consists of separate sets of local information called zones.  The name server has local copies of some of the zones.  The name server must periodically refresh its zones from master copies in local files or foreign name servers.  The name server must concurrently process queries that arrive from resolvers.<br><em>从名称服务器的角度来看，域系统由称为区域的独立本地信息集组成。 名称服务器具有某些区域的本地副本。 名称服务器必须定期从本地文件或外部名称服务器中的主副本刷新其区域。 名称服务器必须同时处理来自解析器的查询。</em></p></li></ul><p>In the interests of performance, implementations may couple these functions.  For example, a resolver on the same machine as a name server might share a database consisting of the the zones managed by the name server and the cache managed by the resolver.<br><em>为了性能的考虑，实现可以耦合这些功能。 例如，与名称服务器位于同一计算机上的解析器可能共享一个数据库，该数据库由名称服务器管理的区域和解析器管理的缓存组成。</em></p><h1 id="3-DOMAIN-NAME-SPACE-and-RESOURCE-RECORDS-域名空间和资源记录"><a href="#3-DOMAIN-NAME-SPACE-and-RESOURCE-RECORDS-域名空间和资源记录" class="headerlink" title="3. DOMAIN NAME SPACE and RESOURCE RECORDS(域名空间和资源记录)"></a>3. DOMAIN NAME SPACE and RESOURCE RECORDS(域名空间和资源记录)</h1><h2 id="3-1-Name-space-specifications-and-terminology-命名空间规范和术语"><a href="#3-1-Name-space-specifications-and-terminology-命名空间规范和术语" class="headerlink" title="3.1. Name space specifications and terminology(命名空间规范和术语)"></a>3.1. Name space specifications and terminology(命名空间规范和术语)</h2><p>The domain name space is a tree structure.  Each node and leaf on the tree corresponds to a resource set (which may be empty).  The domain system makes no distinctions between the uses of the interior nodes and leaves, and this memo uses the term “node” to refer to both.<br><em>域名空间是一个树形结构。 树上的每个节点和叶子对应一个资源集（可能为空）。 域系统对内部节点和叶子的使用没有区别，本备忘录使用术语“节点”来指代两者。</em></p><p>Each node has a label, which is zero to 63 octets in length.  Brother nodes may not have the same label, although the same label can be used for nodes which are not brothers.  One label is reserved, and that is the null (i.e., zero length) label used for the root.<br><em>每个节点都有一个标签，长度为 0~63 个字节。 兄弟节点可能不具有相同的标签，尽管相同的标签可以用于非兄弟的节点。 保留一个标签，即用于根的空（即零长度）标签。</em></p><p>The domain name of a node is the list of the labels on the path from the node to the root of the tree.  By convention, the labels that compose a domain name are printed or read left to right, from the most specific (lowest, farthest from the root) to the least specific (highest, closest to the root).<br><em>节点的域名是从该节点到树根的路径上的标签列表。 按照惯例，组成域名的标签是从左到右打印或读取的，从最具体的（最低的，距离根最远的）到最不具体的（最高的，最接近根的）。</em></p><p>Internally, programs that manipulate domain names should represent them as sequences of labels, where each label is a length octet followed by an octet string.  Because all domain names end at the root, which has a null string for a label, these internal representations can use a length byte of zero to terminate a domain name.<br><em>在内部，操作域名的程序应将它们表示为标签序列，其中每个标签是一个长度八位位组，后跟一个八位位组字符串。 由于所有域名都以根结尾，并且其标签为空字符串，因此这些内部表示可以使用长度为零的字节来终止域名。</em></p><p>By convention, domain names can be stored with arbitrary case, but domain name comparisons for all present domain functions are done in a case-insensitive manner, assuming an ASCII character set, and a high order zero bit.  This means that you are free to create a node with label “A” or a node with label “a”, but not both as brothers; you could refer to either using “a” or “A”.  When you receive a domain name or label, you should preserve its case.  The rationale for this choice is that we may someday need to add full binary domain names for new services; existing services would not be changed.<br><em>按照惯例，域名可以任意大小写存储，但所有现有域函数的域名比较都是以不区分大小写的方式完成的，假设使用 ASCII 字符集和高阶零位。 这意味着您可以自由创建标签为“A”的节点或标签为“a”的节点，但不能两者都是兄弟； 您可以参考使用“a”或“A”。 当您收到域名或标签时，应保留其大小写。 这种选择的理由是，有一天我们可能需要为新服务添加完整的二进制域名； 现有服务不会改变。</em></p><p>When a user needs to type a domain name, the length of each label is omitted and the labels are separated by dots (“.”).  Since a complete domain name ends with the root label, this leads to a printed form which ends in a dot.  We use this property to distinguish between:<br><em>当用户需要输入域名时，每个标签的长度被省略，并且标签之间用点（“.”）分隔。 由于完整的域名以根标签结尾，因此这会导致打印形式以点结尾。 我们使用这个属性来区分：</em></p><ul><li><p>a character string which represents a complete domain name (often called “absolute”).  For example, “poneria.ISI.EDU.”<br><em>代表完整域名的字符串（通常称为“绝对”）。 例如，“poneria.ISI.EDU”。</em></p></li><li><p>a character string that represents the starting labels of a domain name which is incomplete, and should be completed by local software using knowledge of the local domain (often called “relative”).  For example, “poneria” used in the ISI.EDU domain.<br><em>表示域名起始标签的字符串，该字符串不完整，应由本地软件使用本地域的知识（通常称为“相对”）来完成。 例如，ISI.EDU 域中使用的“poneria”。</em></p></li></ul><p>Relative names are either taken relative to a well known origin, or to a list of domains used as a search list.  Relative names appear mostly at the user interface, where their interpretation varies from implementation to implementation, and in master files, where they are relative to a single origin domain name.  The most common interpretation uses the root “.” as either the single origin or as one of the members of the search list, so a multi-label relative name is often one where the trailing dot has been omitted to save typing.<br><em>相对名称要么相对于众所周知的来源，要么相对于用作搜索列表的域列表。 相对名称主要出现在用户界面中，其中它们的解释因实现而异，并且出现在主文件中，其中它们与单个原始域名相关。 最常见的解释是使用词根“.”。 作为单一来源或作为搜索列表的成员之一，因此多标签相对名称通常是省略尾随点以节省输入的名称。</em></p><p>To simplify implementations, the total number of octets that represent a domain name (i.e., the sum of all label octets and label lengths) is limited to 255.<br><em>为了简化实现，表示域名的八位字节总数（即所有标签八位字节和标签长度的总和）限制为 255。</em></p><p>A domain is identified by a domain name, and consists of that part of the domain name space that is at or below the domain name which specifies the domain.  A domain is a subdomain of another domain if it is contained within that domain.  This relationship can be tested by seeing if the subdomain’s name ends with the containing domain’s name. For example, A.B.C.D is a subdomain of B.C.D, C.D, D, and “ “.<br><em>域由域名标识，并且由域名空间中位于或低于指定该域的域名的部分组成。 如果一个域包含在另一个域中，则该域是另一个域的子域。 可以通过查看子域的名称是否以包含域的名称结尾来测试这种关系。 例如，A.B.C.D 是 B.C.D、C.D、D 和“ ”的子域。</em></p><h2 id="3-2-Administrative-guidelines-on-use-使用管理指南"><a href="#3-2-Administrative-guidelines-on-use-使用管理指南" class="headerlink" title="3.2. Administrative guidelines on use(使用管理指南)"></a>3.2. Administrative guidelines on use(使用管理指南)</h2><p>As a matter of policy, the DNS technical specifications do not mandate a particular tree structure or rules for selecting labels; its goal is to be as general as possible, so that it can be used to build arbitrary applications.  In particular, the system was designed so that the name space did not have to be organized along the lines of network boundaries, name servers, etc.  The rationale for this is not that the name space should have no implied semantics, but rather that the choice of implied semantics should be left open to be used for the problem at hand, and that different parts of the tree can have different implied semantics.  For example, the IN-ADDR.ARPA domain is organized and distributed by network and host address because its role is to translate from network or host numbers to names; NetBIOS domains [RFC-1001, RFC-1002] are flat because that is appropriate for that application.</p><p>However, there are some guidelines that apply to the “normal” parts of the name space used for hosts, mailboxes, etc., that will make the name space more uniform, provide for growth, and minimize problems as software is converted from the older host table.  The political decisions about the top levels of the tree originated in RFC-920. Current policy for the top levels is discussed in [RFC-1032].  MILNET conversion issues are covered in [RFC-1031].<br><em>然而，有一些准则适用于用于主机、邮箱等的名称空间的“正常”部分，这些准则将使名称空间更加统一、提供增长并最大限度地减少软件从旧版本转换时出现的问题。 主机表。 有关树顶层的政治决策源自 RFC-920。 [RFC-1032] 中讨论了当前针对高层的政策。 [RFC-1031] 中涵盖了 MILNET 转换问题。</em></p><p>Lower domains which will eventually be broken into multiple zones should provide branching at the top of the domain so that the eventual decomposition can be done without renaming.  Node labels which use special characters, leading digits, etc., are likely to break older software which depends on more restrictive choices.<br><em>最终将被分成多个区域的较低域应该在域的顶部提供分支，以便最终可以在不重命名的情况下完成分解。 使用特殊字符、前导数字等的节点标签可能会破坏依赖于更严格选择的旧软件。</em></p><h2 id="3-3-Technical-guidelines-on-use-使用技术指南"><a href="#3-3-Technical-guidelines-on-use-使用技术指南" class="headerlink" title="3.3. Technical guidelines on use(使用技术指南)"></a>3.3. Technical guidelines on use(使用技术指南)</h2><p>Before the DNS can be used to hold naming information for some kind of object, two needs must be met:<br><em>在 DNS 可用于保存某种对象的命名信息之前，必须满足两个需求：</em></p><ul><li><p>A convention for mapping between object names and domain names.  This describes how information about an object is accessed.<br> <em>对象名称和域名之间映射的约定。 这描述了如何访问有关对象的信息。</em></p></li><li><p>RR types and data formats for describing the object.<br> <em>用于描述对象的RR类型和数据格式。</em></p></li></ul><p>These rules can be quite simple or fairly complex.  Very often, the designer must take into account existing formats and plan for upward compatibility for existing usage.  Multiple mappings or levels of mapping may be required.<br><em>这些规则可以非常简单，也可以非常复杂。 很多时候，设计者必须考虑现有格式并规划现有用途的向上兼容性。 可能需要多个映射或映射级别。</em></p><p>For hosts, the mapping depends on the existing syntax for host names which is a subset of the usual text representation for domain names, together with RR formats for describing host addresses, etc.  Because we need a reliable inverse mapping from address to host name, a special mapping for addresses into the IN-ADDR.ARPA domain is also defined.<br><em>对于主机，映射取决于主机名的现有语法，主机名是常用文本表示形式的子集，以及用于描述主机地址的 RR 格式等。因为我们需要从地址到主机名的可靠逆映射， 还定义了地址到 IN-ADDR.ARPA 域的特殊映射。</em></p><p>For mailboxes, the mapping is slightly more complex.  The usual mail address <local-part>@<mail-domain> is mapped into a domain name by converting <local-part> into a single label (regardles of dots it contains), converting <mail-domain> into a domain name using the usual text format for domain names (dots denote label breaks), and concatenating the two to form a single domain name.  Thus the mailbox <a href="mailto:&#72;&#x4f;&#83;&#x54;&#x4d;&#x41;&#x53;&#84;&#x45;&#x52;&#x40;&#83;&#x52;&#x49;&#x2d;&#78;&#73;&#x43;&#46;&#65;&#x52;&#x50;&#65;">&#72;&#x4f;&#83;&#x54;&#x4d;&#x41;&#x53;&#84;&#x45;&#x52;&#x40;&#83;&#x52;&#x49;&#x2d;&#78;&#73;&#x43;&#46;&#65;&#x52;&#x50;&#65;</a> is represented as a domain name by HOSTMASTER.SRI-NIC.ARPA.  An appreciation for the reasons behind this design also must take into account the scheme for mail exchanges [RFC-974].<br><em>对于邮箱，映射稍微复杂一些。 通常的邮件地址 <local-part>@<mail-domain> 通过将 <local-part> 转换为单个标签（不管它包含的点），将 <mail-domain> 转换为域名来映射为域名 使用域名的常用文本格式（点表示标签分隔符），并将两者连接起来形成一个域名。 因此，邮箱 <a href="mailto:&#x48;&#79;&#83;&#84;&#77;&#x41;&#83;&#84;&#69;&#82;&#x40;&#83;&#82;&#x49;&#x2d;&#78;&#73;&#x43;&#x2e;&#65;&#x52;&#x50;&#x41;">&#x48;&#79;&#83;&#84;&#77;&#x41;&#83;&#84;&#69;&#82;&#x40;&#83;&#82;&#x49;&#x2d;&#78;&#73;&#x43;&#x2e;&#65;&#x52;&#x50;&#x41;</a> 由 HOSTMASTER.SRI-NIC.ARPA 表示为域名。 了解此设计背后的原因还必须考虑邮件交换方案 [RFC-974]。</em></p><p>The typical user is not concerned with defining these rules, but should understand that they usually are the result of numerous compromises between desires for upward compatibility with old usage, interactions between different object definitions, and the inevitable urge to add new features when defining the rules.  The way the DNS is used to support some object is often more crucial than the restrictions inherent in the DNS.<br><em>典型的用户不关心定义这些规则，但应该理解，它们通常是与旧用法向上兼容的愿望、不同对象定义之间的交互以及定义规则时不可避免地添加新功能的冲动之间众多妥协的结果 。 DNS 用于支持某些对象的方式通常比 DNS 固有的限制更为重要。</em></p><h2 id="3-4-Example-name-space-命名空间示例"><a href="#3-4-Example-name-space-命名空间示例" class="headerlink" title="3.4. Example name space(命名空间示例)"></a>3.4. Example name space(命名空间示例)</h2><p>The following figure shows a part of the current domain name space, and is used in many examples in this RFC.  Note that the tree is a very small subset of the actual name space.<br><em>下图显示了当前域名空间的一部分，并在本 RFC 的许多示例中使用。 请注意，树是实际名称空间的一个非常小的子集。</em></p><figure class="highlight gherkin"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs gherkin">                             |<span class="hljs-string"></span><br><span class="hljs-string">                             </span>|<br>       +---------------------+------------------+<br>       |<span class="hljs-string">                     </span>|<span class="hljs-string">                  </span>|<br>      MIL                   EDU                ARPA<br>       |<span class="hljs-string">                     </span>|<span class="hljs-string">                  </span>|<br>       |<span class="hljs-string">                     </span>|<span class="hljs-string">                  </span>|<br> +-----+-----+               |<span class="hljs-string">     +------+-----+-----+</span><br><span class="hljs-string"> </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     </span>|<span class="hljs-string">               </span>|<span class="hljs-string">     </span>|<span class="hljs-string">      </span>|<span class="hljs-string">           </span>|<br>BRL  NOSC  DARPA             |<span class="hljs-string">  IN-ADDR  SRI-NIC     ACC</span><br><span class="hljs-string">                             </span>|<br> +--------+------------------+---------------+--------+<br> |<span class="hljs-string">        </span>|<span class="hljs-string">                  </span>|<span class="hljs-string">               </span>|<span class="hljs-string">        </span>|<br>UCI      MIT                 |<span class="hljs-string">              UDEL     YALE</span><br><span class="hljs-string">          </span>|<span class="hljs-string">                 ISI</span><br><span class="hljs-string">          </span>|<span class="hljs-string">                  </span>|<br>      +---+---+              |<span class="hljs-string"></span><br><span class="hljs-string">      </span>|<span class="hljs-string">       </span>|<span class="hljs-string">              </span>|<br>     LCS  ACHILLES  +--+-----+-----+--------+<br>      |<span class="hljs-string">             </span>|<span class="hljs-string">  </span>|<span class="hljs-string">     </span>|<span class="hljs-string">     </span>|<span class="hljs-string">        </span>|<br>      XX            A  C   VAXA  VENERA Mockapetris<br></code></pre></td></tr></table></figure><p>In this example, the root domain has three immediate subdomains: MIL, EDU, and ARPA.  The LCS.MIT.EDU domain has one immediate subdomain named XX.LCS.MIT.EDU.  All of the leaves are also domains.<br><em>在此示例中，根域具有三个直接子域：MIL、EDU 和 ARPA。 LCS.MIT.EDU 域有一个名为 XX.LCS.MIT.EDU 的直接子域。 所有的叶子也是域。</em></p><h2 id="3-5-Preferred-name-syntax-首选名称语法"><a href="#3-5-Preferred-name-syntax-首选名称语法" class="headerlink" title="3.5. Preferred name syntax(首选名称语法)"></a>3.5. Preferred name syntax(首选名称语法)</h2><p>The DNS specifications attempt to be as general as possible in the rules for constructing domain names.  The idea is that the name of any existing object can be expressed as a domain name with minimal changes. However, when assigning a domain name for an object, the prudent user will select a name which satisfies both the rules of the domain system and any existing rules for the object, whether these rules are published or implied by existing programs.<br><em>DNS 规范试图在构建域名的规则中尽可能通用。 这个想法是任何现有对象的名称都可以表示为域名，只需进行最少的更改。 然而，当为对象分配域名时，谨慎的用户将选择既满足域系统的规则又满足该对象的任何现有规则的名称，无论这些规则是公开的还是由现有程序暗示的。</em></p><p>For example, when naming a mail domain, the user should satisfy both the rules of this memo and those in RFC-822.  When creating a new host name, the old rules for HOSTS.TXT should be followed.  This avoids problems when old software is converted to use domain names.<br><em>例如，在命名邮件域时，用户应同时满足本备忘录的规则和RFC-822中的规则。创建新主机名时，应遵循 HOSTS.TXT 的旧规则。 这可以避免旧软件转换为使用域名时出现问题。</em></p><p>The following syntax will result in fewer problems with many applications that use domain names (e.g., mail, TELNET).<br><em>以下语法将减少许多使用域名的应用程序（例如邮件、TELNET）的问题。</em></p><p><domain> ::= <subdomain> | “ “</p><p><subdomain> ::= <label> | <subdomain> “.” <label></p><p><label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]</p><p><ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str></p><p><let-dig-hyp> ::= <let-dig> | “-“</p><p><let-dig> ::= <letter> | <digit></p><p><letter> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case</p><p><digit> ::= any one of the ten digits 0 through 9</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;domain&gt;</span>表示一个域名，可以是一个子域名<span class="hljs-params">&lt;subdomain&gt;</span>，或者为空格<span class="hljs-string">&quot; &quot;</span>（即没有域名）。<br><span class="hljs-params">&lt;subdomain&gt;</span>表示一个子域名，可以是一个标签<span class="hljs-params">&lt;label&gt;</span>，或者是一个子域名后跟一个点`.`和一个标签。<br><span class="hljs-params">&lt;label&gt;</span>表示一个标签，它由一个字母<span class="hljs-params">&lt;letter&gt;</span>开始，后面可以跟一个<span class="hljs-params">&lt;ldh-str&gt;</span>（可选）和一个字母数字字<span class="hljs-params">&lt;let-dig&gt;</span>。<br><span class="hljs-params">&lt;ldh-str&gt;</span>是由字母数字字符和连字符构成的字符串，它可以是一个<span class="hljs-params">&lt;let-dig-hyp&gt;</span>，或者是一个<span class="hljs-params">&lt;let-dig-hyp&gt;</span>跟一个<span class="hljs-params">&lt;ldh-str&gt;</span>。<br><span class="hljs-params">&lt;let-dig-hyp&gt;</span>是字母数字字符<span class="hljs-params">&lt;let-dig&gt;</span>或连字符-。<br><span class="hljs-params">&lt;let-dig&gt;</span>是一个字母<span class="hljs-params">&lt;letter&gt;</span>或一个数字<span class="hljs-params">&lt;digit&gt;</span>。<br><span class="hljs-params">&lt;letter&gt;</span>是从A到Z的大写字母和从a到z的小写字母中的任意一个。<br><span class="hljs-params">&lt;digit&gt;</span>是从<span class="hljs-number">0</span>到<span class="hljs-number">9</span>的十个数字中的任意一个。<br></code></pre></td></tr></table></figure><p>Note that while upper and lower case letters are allowed in domain names, no significance is attached to the case.  That is, two names with the same spelling but different case are to be treated as if identical.<br><em>请注意，虽然域名中允许使用大小写字母，但大小写没有任何意义。 也就是说，拼写相同但大小写不同的两个名称将被视为相同。</em></p><p>The labels must follow the rules for ARPANET host names.  They must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen.  There are also some restrictions on the length.  Labels must be 63 characters or less.<br><em>标签必须遵循 ARPANET 主机名的规则。 它们必须以字母开头，以字母或数字结尾，并且内部字符只能是字母、数字和连字符。 长度也有一些限制。 标签不得超过 63 个字符。</em></p><p>For example, the following strings identify hosts in the Internet:<br><em>例如，以下字符串标识 Internet 中的主机：</em></p><p>A.ISI.EDU  XX.LCS.MIT.EDU  SRI-NIC.ARPA</p><h2 id="3-6-Resource-Records-资源记录"><a href="#3-6-Resource-Records-资源记录" class="headerlink" title="3.6. Resource Records(资源记录)"></a>3.6. Resource Records(资源记录)</h2><p>A domain name identifies a node.  Each node has a set of resource information, which may be empty.  The set of resource information associated with a particular name is composed of separate resource records (RRs).  The order of RRs in a set is not significant, and need not be preserved by name servers, resolvers, or other parts of the DNS.<br><em>一个域名标识一个节点。 每个节点都有一组资源信息，该信息可能为空。 与特定名称关联的资源信息集由单独的资源记录 (RR) 组成。 集合中 RR 的顺序并不重要，并且不需要由名称服务器、解析器或 DNS 的其他部分保存。</em></p><p>When we talk about a specific RR, we assume it has the following:<br><em>当我们谈论特定的 RR 时，我们假设它具有以下内容：</em></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">owner           which is <span class="hljs-keyword">the</span> domain name where <span class="hljs-keyword">the</span> RR is found.<br>RR所属的域名<br><br>type            which is <span class="hljs-keyword">an</span> encoded <span class="hljs-number">16</span> bit <span class="hljs-built_in">value</span> that specifies <span class="hljs-keyword">the</span> type<br>                <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> resource <span class="hljs-keyword">in</span> this resource record.  Types refer <span class="hljs-built_in">to</span><br>                abstract resources.<br>这是一个编码的 <span class="hljs-number">16</span> 位值，指定此资源记录中的资源类型。 类型指的是抽象资源。<br><br>                This memo uses <span class="hljs-keyword">the</span> following types:<br>本备忘录使用以下类型：<br>    <br>                A               <span class="hljs-keyword">a</span> host address<br>    <br>                CNAME           identifies <span class="hljs-keyword">the</span> canonical name <span class="hljs-keyword">of</span> <span class="hljs-keyword">an</span><br>                                <span class="hljs-built_in">alias</span><br>    <br>                HINFO           identifies <span class="hljs-keyword">the</span> CPU <span class="hljs-keyword">and</span> OS used <span class="hljs-keyword">by</span> <span class="hljs-keyword">a</span> host<br>    <br>                MX              identifies <span class="hljs-keyword">a</span> mail exchange <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span><br>                                domain.  See [RFC<span class="hljs-number">-974</span> <span class="hljs-keyword">for</span> details.<br>    <br>                NS<br>                <span class="hljs-keyword">the</span> authoritative name server <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> domain<br>*域的权威名称服务器*<br>    <br>                PTR<br>                <span class="hljs-keyword">a</span> pointer <span class="hljs-built_in">to</span> another part <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> domain name <span class="hljs-literal">space</span><br>*一个指向域名空间另一部分的指针*<br>    <br>                SOA<br>                identifies <span class="hljs-keyword">the</span> <span class="hljs-built_in">start</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> zone <span class="hljs-keyword">of</span> authority]<br>区域权限的开始标识<br><br>class           which is <span class="hljs-keyword">an</span> encoded <span class="hljs-number">16</span> bit <span class="hljs-built_in">value</span> which identifies <span class="hljs-keyword">a</span><br>                protocol family <span class="hljs-keyword">or</span> instance <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> protocol.<br>*这是一个编码的 <span class="hljs-number">16</span> 位值，用于标识协议族或协议实例。*<br><br>                This memo uses <span class="hljs-keyword">the</span> following classes:<br>    <br>                IN              <span class="hljs-keyword">the</span> Internet <span class="hljs-keyword">system</span><br>    <br>                CH              <span class="hljs-keyword">the</span> Chaos <span class="hljs-keyword">system</span><br><br>TTL             which is <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> <span class="hljs-built_in">to</span> live <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> RR.  This field is <span class="hljs-keyword">a</span> <span class="hljs-number">32</span><br>                bit <span class="hljs-keyword">integer</span> <span class="hljs-keyword">in</span> units <span class="hljs-keyword">of</span> <span class="hljs-built_in">seconds</span>, <span class="hljs-keyword">an</span> is primarily used <span class="hljs-keyword">by</span><br>                resolvers when they cache RRs.  The TTL describes how<br>                <span class="hljs-keyword">long</span> <span class="hljs-keyword">a</span> RR can be cached <span class="hljs-keyword">before</span> <span class="hljs-keyword">it</span> should be discarded.<br>这是 RR 的生存时间。 该字段是以秒为单位的 <span class="hljs-number">32</span> 位整数，<br>主要由解析器在缓存 RR 时使用。 TTL 描述了 RR 在被丢弃之前可以被缓存多长时间。<br><br>RDATA           which is <span class="hljs-keyword">the</span> type <span class="hljs-keyword">and</span> sometimes class dependent data<br>                which describes <span class="hljs-keyword">the</span> resource:<br>这是描述资源的类型（有时是类相关数据）：<br><br>                A               For <span class="hljs-keyword">the</span> IN class, <span class="hljs-keyword">a</span> <span class="hljs-number">32</span> bit IP address<br>    <br>                                For <span class="hljs-keyword">the</span> CH class, <span class="hljs-keyword">a</span> domain name followed<br>                                <span class="hljs-keyword">by</span> <span class="hljs-keyword">a</span> <span class="hljs-number">16</span> bit octal Chaos address.<br>    <br>                CNAME           <span class="hljs-keyword">a</span> domain name.<br>    <br>                MX              <span class="hljs-keyword">a</span> <span class="hljs-number">16</span> bit preference <span class="hljs-built_in">value</span> (<span class="hljs-built_in">lower</span> is<br>                                better) followed <span class="hljs-keyword">by</span> <span class="hljs-keyword">a</span> host name willing<br>                                <span class="hljs-built_in">to</span> act <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> mail exchange <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> owner<br>                                domain.<br>    <br>                NS              <span class="hljs-keyword">a</span> host name.<br>一个host名<br><br>                PTR             <span class="hljs-keyword">a</span> domain name.<br>一个域名<br><br>                SOA             several fields.<br></code></pre></td></tr></table></figure><p>The owner name is often implicit, rather than forming an integral part of the RR.  For example, many name servers internally form tree or hash structures for the name space, and chain RRs off nodes.  The remaining RR parts are the fixed header (type, class, TTL) which is consistent for all RRs, and a variable part (RDATA) that fits the needs of the resource being described.<br><em>所有者名称通常是隐含的，而不是形成 RR 的组成部分。 例如，许多名称服务器在内部形成名称空间的树形或散列结构，并将 RR 链接到节点上。 其余的 RR 部分是对所有 RR 一致的固定标头（类型、类、TTL）和适合所描述资源的需要的可变部分（RDATA）。</em></p><p>The meaning of the TTL field is a time limit on how long an RR can be kept in a cache.  This limit does not apply to authoritative data in zones; it is also timed out, but by the refreshing policies for the zone.  The TTL is assigned by the administrator for the zone where the data originates.  While short TTLs can be used to minimize caching, and a zero TTL prohibits caching, the realities of Internet performance suggest that these times should be on the order of days for the typical host.  If a change can be anticipated, the TTL can be reduced prior to the change to minimize inconsistency during the change, and then increased back to its former value following the change.<br><em>TTL字段的含义是限制RR在缓存中保存的时间。 此限制不适用于区域内的权威数据； 它也超时了，但是由于该区域的刷新策略。 TTL 由数据来源区域的管理员分配。 虽然短 TTL 可用于最大程度地减少缓存，而 TTL 为0则禁止缓存，但 Internet 性能的实际情况表明，对于典型主机来说，这些时间应为几天左右。 如果可以预期发生更改，则可以在更改之前减小 TTL，以最大程度地减少更改期间的不一致，然后在更改后将其恢复到之前的值。</em></p><p>The data in the RDATA section of RRs is carried as a combination of binary strings and domain names.  The domain names are frequently used as “pointers” to other data in the DNS.<br><em>RR 的 RDATA 部分中的数据以二进制字符串和域名的组合形式传送。 域名经常用作指向 DNS 中其他数据的“指针”。</em></p><h3 id="3-6-1-Textual-expression-of-RRs-RR-的文本表达"><a href="#3-6-1-Textual-expression-of-RRs-RR-的文本表达" class="headerlink" title="3.6.1. Textual expression of RRs(RR 的文本表达)"></a>3.6.1. Textual expression of RRs(RR 的文本表达)</h3><p>RRs are represented in binary form in the packets of the DNS protocol,<br>and are usually represented in highly encoded form when stored in a name<br>server or resolver.  In this memo, we adopt a style similar to that used<br>in master files in order to show the contents of RRs.  In this format,<br>most RRs are shown on a single line, although continuation lines are<br>possible using parentheses.</p><p>The start of the line gives the owner of the RR.  If a line begins with<br>a blank, then the owner is assumed to be the same as that of the<br>previous RR.  Blank lines are often included for readability.</p><p>Following the owner, we list the TTL, type, and class of the RR.  Class<br>and type use the mnemonics defined above, and TTL is an integer before<br>the type field.  In order to avoid ambiguity in parsing, type and class<br>mnemonics are disjoint, TTLs are integers, and the type mnemonic is<br>always last. The IN class and TTL values are often omitted from examples<br>in the interests of clarity.</p><p>The resource data or RDATA section of the RR are given using knowledge<br>of the typical representation for the data.</p><p>For example, we might show the RRs carried in a message as:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">ISI.EDU.        <span class="hljs-keyword">MX</span>      <span class="hljs-number">10</span> VENERA.ISI.EDU.<br>                <span class="hljs-keyword">MX</span>      <span class="hljs-number">10</span> VAXA.ISI.EDU.<br>VENERA.ISI.EDU. <span class="hljs-keyword">A</span>       <span class="hljs-number">128.9.0.32</span><br>                <span class="hljs-keyword">A</span>       <span class="hljs-number">10.1.0.52</span><br>VAXA.ISI.EDU.   <span class="hljs-keyword">A</span>       <span class="hljs-number">10.2.0.27</span><br>                <span class="hljs-keyword">A</span>       <span class="hljs-number">128.9.0.33</span><br></code></pre></td></tr></table></figure><p>The MX RRs have an RDATA section which consists of a 16 bit number<br>followed by a domain name.  The address RRs use a standard IP address<br>format to contain a 32 bit internet address.</p><p>This example shows six RRs, with two RRs at each of three domain names.</p><p>Similarly we might see:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">XX<span class="hljs-selector-class">.LCS</span><span class="hljs-selector-class">.MIT</span><span class="hljs-selector-class">.EDU</span>. IN      A       <span class="hljs-number">10.0</span>.<span class="hljs-number">0.44</span><br>                CH      A       MIT<span class="hljs-selector-class">.EDU</span>. <span class="hljs-number">2420</span><br></code></pre></td></tr></table></figure><p>This example shows two addresses for XX.LCS.MIT.EDU, each of a different<br>class.</p><h3 id="3-6-2-Aliases-and-canonical-names-别名和规范名称"><a href="#3-6-2-Aliases-and-canonical-names-别名和规范名称" class="headerlink" title="3.6.2. Aliases and canonical names(别名和规范名称)"></a>3.6.2. Aliases and canonical names(别名和规范名称)</h3><p>In existing systems, hosts and other resources often have several names that identify the same resource.  For example, the names C.ISI.EDU and USC-ISIC.ARPA both identify the same host.  Similarly, in the case of mailboxes, many organizations provide many names that actually go to the same mailbox; for example <a href="mailto:&#77;&#x6f;&#x63;&#107;&#x61;&#112;&#101;&#116;&#114;&#105;&#x73;&#64;&#67;&#x2e;&#73;&#x53;&#73;&#x2e;&#x45;&#68;&#85;">&#77;&#x6f;&#x63;&#107;&#x61;&#112;&#101;&#116;&#114;&#105;&#x73;&#64;&#67;&#x2e;&#73;&#x53;&#73;&#x2e;&#x45;&#68;&#85;</a>, <a href="mailto:&#77;&#111;&#x63;&#x6b;&#97;&#112;&#101;&#116;&#x72;&#x69;&#115;&#x40;&#66;&#46;&#73;&#x53;&#x49;&#46;&#69;&#x44;&#85;">&#77;&#111;&#x63;&#x6b;&#97;&#112;&#101;&#116;&#x72;&#x69;&#115;&#x40;&#66;&#46;&#73;&#x53;&#x49;&#46;&#69;&#x44;&#85;</a>, and <a href="mailto:&#x50;&#x56;&#x4d;&#64;&#x49;&#x53;&#x49;&#46;&#x45;&#68;&#x55;">&#x50;&#x56;&#x4d;&#64;&#x49;&#x53;&#x49;&#46;&#x45;&#68;&#x55;</a> all go to the same mailbox (although the mechanism behind this is somewhat complicated).<br><em>在现有系统中，主机和其他资源通常有多个名称来标识同一资源。 例如，名称 C.ISI.EDU 和 USC-ISIC.ARPA 都标识同一主机。 同样，就邮箱而言，许多组织提供了许多实际上发送到同一个邮箱的名称； 例如，<a href="mailto:&#77;&#111;&#99;&#107;&#97;&#x70;&#101;&#116;&#114;&#105;&#115;&#x40;&#67;&#46;&#73;&#83;&#73;&#x2e;&#69;&#68;&#x55;">&#77;&#111;&#99;&#107;&#97;&#x70;&#101;&#116;&#114;&#105;&#115;&#x40;&#67;&#46;&#73;&#83;&#73;&#x2e;&#69;&#68;&#x55;</a>、<a href="mailto:&#x4d;&#111;&#x63;&#x6b;&#97;&#x70;&#101;&#116;&#114;&#105;&#115;&#64;&#66;&#x2e;&#73;&#x53;&#73;&#x2e;&#x45;&#68;&#x55;">&#x4d;&#111;&#x63;&#x6b;&#97;&#x70;&#101;&#116;&#114;&#105;&#115;&#64;&#66;&#x2e;&#73;&#x53;&#73;&#x2e;&#x45;&#68;&#x55;</a> 和 <a href="mailto:&#80;&#86;&#x4d;&#64;&#73;&#83;&#73;&#46;&#69;&#68;&#x55;">&#80;&#86;&#x4d;&#64;&#73;&#83;&#73;&#46;&#69;&#68;&#x55;</a> 都发送到同一个邮箱（尽管其背后的机制有些复杂）。</em></p><p>Most of these systems have a notion that one of the equivalent set of names is the canonical or primary name and all others are aliases.<br><em>这些系统中的大多数都有一个概念，即等效名称集之一是规范名称或主要名称，所有其他名称都是别名。</em></p><p>The domain system provides such a feature using the canonical name (CNAME) RR.  A CNAME RR identifies its owner name as an alias, and specifies the corresponding canonical name in the RDATA section of the RR.  If a CNAME RR is present at a node, no other data should be present; this ensures that the data for a canonical name and its aliases cannot be different.  This rule also insures that a cached CNAME can be used without checking with an authoritative server for other RR types.<br><em>域系统使用规范名称 (CNAME) RR 提供此类功能。 CNAME RR 将其所有者名称标识为别名，并在 RR 的 RDATA 部分中指定相应的规范名称。 如果节点上存在 CNAME RR，则不应存在其他数据； 这确保规范名称及其别名的数据不能不同。 此规则还确保可以使用缓存的 CNAME，而无需与权威服务器检查其他 RR 类型。</em></p><p>CNAME RRs cause special action in DNS software.  When a name server fails to find a desired RR in the resource set associated with the domain name, it checks to see if the resource set consists of a CNAME record with a matching class.  If so, the name server includes the CNAME record in the response and restarts the query at the domain name specified in the data field of the CNAME record.  The one exception to this rule is that queries which match the CNAME type are not restarted.<br><em>CNAME RR 会导致 DNS 软件采取特殊操作。 当名称服务器无法在与域名关联的资源集中找到所需的 RR 时，它会检查该资源集是否包含具有匹配类的 CNAME 记录。 如果是，则名称服务器在响应中包含 CNAME 记录，并在 CNAME 记录的数据字段中指定的域名重新启动查询。 此规则的一个例外是与 CNAME 类型匹配的查询不会重新启动。</em></p><p>For example, suppose a name server was processing a query with for USC-ISIC.ARPA, asking for type A information, and had the following resource records:<br><em>例如，假设名称服务器正在处理 USC-ISIC.ARPA 的查询，请求类型 A 信息，并具有以下资源记录：</em></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">USC-ISIC<span class="hljs-selector-class">.ARPA</span>   IN      CNAME   C<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span><br><br>C<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>       IN      A       <span class="hljs-number">10.0</span>.<span class="hljs-number">0.52</span><br></code></pre></td></tr></table></figure><p>Both of these RRs would be returned in the response to the type A query, while a type CNAME or * query should return just the CNAME.<br><em>这两个 RR 都将在 A 类型查询的响应中返回，而 CNAME 或 * 类型查询应仅返回 CNAME。</em></p><p>Domain names in RRs which point at another name should always point at the primary name and not the alias.  This avoids extra indirections in accessing information.  For example, the address to name RR for the above host should be:<br><em>RR 中指向另一个名称的域名应始终指向(ptr记录)主名称而不是别名。 这避免了访问信息时的额外间接。 例如，上述主机的名为 RR 的地址应为：</em></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">52.0.0.10</span>.IN-ADDR.ARPA  IN      PTR     C.ISI.EDU<br></code></pre></td></tr></table></figure><p>rather than pointing at USC-ISIC.ARPA.  Of course, by the robustness principle, domain software should not fail when presented with CNAME chains or loops; CNAME chains should be followed and CNAME loops signalled as an error.</p><p><em>而不是指向 USC-ISIC.ARPA。 当然，根据稳健性原则，域软件在出现 CNAME 链或循环时不应失败； 应遵循 CNAME 链，并将 CNAME 循环标记为错误。</em></p><h2 id="3-7-Queries"><a href="#3-7-Queries" class="headerlink" title="3.7. Queries"></a>3.7. Queries</h2><p>Queries are messages which may be sent to a name server to provoke a<br>response.  In the Internet, queries are carried in UDP datagrams or over<br>TCP connections.  The response by the name server either answers the<br>question posed in the query, refers the requester to another set of name<br>servers, or signals some error condition.</p><p>In general, the user does not generate queries directly, but instead<br>makes a request to a resolver which in turn sends one or more queries to<br>name servers and deals with the error conditions and referrals that may<br>result.  Of course, the possible questions which can be asked in a query<br>does shape the kind of service a resolver can provide.</p><p>DNS queries and responses are carried in a standard message format.  The<br>message format has a header containing a number of fixed fields which<br>are always present, and four sections which carry query parameters and<br>RRs.</p><p>The most important field in the header is a four bit field called an<br>opcode which separates different queries.  Of the possible 16 values,<br>one (standard query) is part of the official protocol, two (inverse<br>query and status query) are options, one (completion) is obsolete, and<br>the rest are unassigned.</p><p>The four sections are:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs erlang">Question        Carries the <span class="hljs-keyword">query</span> name <span class="hljs-keyword">and</span> other <span class="hljs-keyword">query</span> parameters.<br><br>Answer          Carries RRs which directly answer the <span class="hljs-keyword">query</span>.<br><br>Authority       Carries RRs which describe other authoritative servers.<br>                May optionally carry the SOA RR for the authoritative<br>                data in the answer section.<br><br>Additional      Carries RRs which may be helpful in using the RRs in the<br>                other sections.<br></code></pre></td></tr></table></figure><p>Note that the content, but not the format, of these sections varies with<br>header opcode.</p><h3 id="3-7-1-Standard-queries"><a href="#3-7-1-Standard-queries" class="headerlink" title="3.7.1. Standard queries"></a>3.7.1. Standard queries</h3><p>A standard query specifies a target domain name (QNAME), query type<br>(QTYPE), and query class (QCLASS) and asks for RRs which match.  This<br>type of query makes up such a vast majority of DNS queries that we use<br>the term “query” to mean standard query unless otherwise specified.  The<br>QTYPE and QCLASS fields are each 16 bits long, and are a superset of<br>defined types and classes.</p><p>The QTYPE field may contain:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&lt;<span class="hljs-built_in">any</span> <span class="hljs-keyword">type</span>&gt;      matches just that <span class="hljs-keyword">type</span>. (e.g., A, PTR).<br><br>AXFR            special zone <span class="hljs-built_in">transfer</span> QTYPE.<br><br>MAILB           matches <span class="hljs-built_in">all</span> mail box related RRs (e.g. MB and MG).<br><br>*               matches <span class="hljs-built_in">all</span> RR types.<br><br>The QCLASS field may contain:<br><br>&lt;<span class="hljs-built_in">any</span> <span class="hljs-keyword">class</span>&gt;     matches just that <span class="hljs-keyword">class</span> (e.g., <span class="hljs-keyword">IN</span>, CH).<br><br>*               matches <span class="hljs-built_in">aLL</span> RR classes.<br></code></pre></td></tr></table></figure><p>Using the query domain name, QTYPE, and QCLASS, the name server looks<br>for matching RRs.  In addition to relevant records, the name server may<br>return RRs that point toward a name server that has the desired<br>information or RRs that are expected to be useful in interpreting the<br>relevant RRs.  For example, a name server that doesn’t have the<br>requested information may know a name server that does; a name server<br>that returns a domain name in a relevant RR may also return the RR that<br>binds that domain name to an address.</p><p>For example, a mailer tying to send mail to <a href="mailto:&#x4d;&#x6f;&#99;&#107;&#x61;&#112;&#101;&#116;&#114;&#x69;&#x73;&#x40;&#x49;&#83;&#73;&#x2e;&#x45;&#x44;&#85;">&#x4d;&#x6f;&#99;&#107;&#x61;&#112;&#101;&#116;&#114;&#x69;&#x73;&#x40;&#x49;&#83;&#73;&#x2e;&#x45;&#x44;&#85;</a> might<br>ask the resolver for mail information about ISI.EDU, resulting in a<br>query for QNAME=ISI.EDU, QTYPE=MX, QCLASS=IN.  The response’s answer<br>section would be:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ISI<span class="hljs-selector-class">.EDU</span>.        MX      <span class="hljs-number">10</span> VENERA<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br>                MX      <span class="hljs-number">10</span> VAXA<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br></code></pre></td></tr></table></figure><p>while the additional section might be:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">VAXA.ISI.EDU.   <span class="hljs-keyword">A</span>       <span class="hljs-number">10.2.0.27</span><br>                <span class="hljs-keyword">A</span>       <span class="hljs-number">128.9.0.33</span><br>VENERA.ISI.EDU. <span class="hljs-keyword">A</span>       <span class="hljs-number">10.1.0.52</span><br>                <span class="hljs-keyword">A</span>       <span class="hljs-number">128.9.0.32</span><br></code></pre></td></tr></table></figure><p>Because the server assumes that if the requester wants mail exchange<br>information, it will probably want the addresses of the mail exchanges<br>soon afterward.</p><p>Note that the QCLASS=* construct requires special interpretation<br>regarding authority.  Since a particular name server may not know all of<br>the classes available in the domain system, it can never know if it is<br>authoritative for all classes.  Hence responses to QCLASS=* queries can<br>never be authoritative.</p><h3 id="3-7-2-Inverse-queries-Optional-反向查询（可选）"><a href="#3-7-2-Inverse-queries-Optional-反向查询（可选）" class="headerlink" title="3.7.2. Inverse queries (Optional)(反向查询（可选）)"></a>3.7.2. Inverse queries (Optional)(反向查询（可选）)</h3><p>Name servers may also support inverse queries that map a particular resource to a domain name or domain names that have that resource.  For example, while a standard query might map a domain name to a SOA RR, the corresponding inverse query might map the SOA RR back to the domain name.<br><em>名称服务器还可以支持将特定资源映射到具有该资源的一个或多个域名的反向查询。 例如，虽然标准查询可能将域名映射到 SOA RR，但相应的逆查询可能将 SOA RR 映射回域名。</em></p><p>Implementation of this service is optional in a name server, but all name servers must at least be able to understand an inverse query message and return a not-implemented error response.<br><em>在名称服务器中，此服务的实现是可选的，但所有名称服务器必须至少能够理解反向查询消息并返回未实现的错误响应。</em></p><p>The domain system cannot guarantee the completeness or uniqueness of inverse queries because the domain system is organized by domain name rather than by host address or any other resource type.  Inverse queries are primarily useful for debugging and database maintenance activities.<br><em>域系统不能保证逆向查询的完整性或唯一性，因为域系统是按域名而不是按主机地址或任何其他资源类型组织的。 反向查询主要用于调试和数据库维护活动。</em></p><p>Inverse queries may not return the proper TTL, and do not indicate cases where the identified RR is one of a set (for example, one address for a host having multiple addresses).  Therefore, the RRs returned in inverse queries should never be cached.<br><em>反向查询可能不会返回正确的 TTL，并且不会指示所识别的 RR 是一组中的一个的情况（例如，具有多个地址的主机的一个地址）。 因此，在反向查询中返回的 RR 永远不应该被缓存。</em></p><p>Inverse queries are NOT an acceptable method for mapping host addresses to host names; use the IN-ADDR.ARPA domain instead.<br><em>反向查询不是将主机地址映射到主机名的可接受的方法； 请改用 IN-ADDR.ARPA 域。</em></p><p>A detailed discussion of inverse queries is contained in [RFC-1035].<br><em>反向查询的详细讨论包含在 [RFC-1035] 中。</em></p><h2 id="3-8-Status-queries-Experimental-实验性的状态查询"><a href="#3-8-Status-queries-Experimental-实验性的状态查询" class="headerlink" title="3.8. Status queries (Experimental) (实验性的状态查询)"></a>3.8. Status queries (Experimental) (实验性的状态查询)</h2><p>To be defined.</p><h2 id="3-9-Completion-queries-Obsolete"><a href="#3-9-Completion-queries-Obsolete" class="headerlink" title="3.9. Completion queries (Obsolete)"></a>3.9. Completion queries (Obsolete)</h2><p>The optional completion services described in RFCs 882 and 883 have been<br>deleted.  Redesigned services may become available in the future, or the<br>opcodes may be reclaimed for other use.</p><h1 id="4-NAME-SERVERS-名称服务器"><a href="#4-NAME-SERVERS-名称服务器" class="headerlink" title="4. NAME SERVERS(名称服务器)"></a>4. NAME SERVERS(名称服务器)</h1><h2 id="4-1-Introduction-介绍"><a href="#4-1-Introduction-介绍" class="headerlink" title="4.1. Introduction(介绍)"></a>4.1. Introduction(介绍)</h2><p>Name servers are the repositories of information that make up the domain database.  The database is divided up into sections called zones, which are distributed among the name servers.  While name servers can have several optional functions and sources of data, the essential task of a name server is to answer queries using data in its zones.  By design, name servers can answer queries in a simple manner; the response can always be generated using only local data, and either contains the answer to the question or a referral to other name servers “closer” to the desired information.<br><em>名称服务器是构成域数据库的信息存储库。 数据库被分为称为区域的部分，这些部分分布在名称服务器之间。 虽然名称服务器可以具有多种可选功能和数据源，但名称服务器的基本任务是使用其区域中的数据来回答查询。 按照设计，名称服务器可以以简单的方式回答查询； 响应始终可以仅使用本地数据生成，并且包含问题的答案或对“更接近”所需信息的其他名称服务器的引用。</em></p><p>A given zone will be available from several name servers to insure its availability in spite of host or communication link failure.  By administrative fiat, we require every zone to be available on at least two servers, and many zones have more redundancy than that.<br><em>尽管主机或通信链路发生故障，给定区域仍可从多个名称服务器获得，以确保其可用性。 根据管理命令，我们要求每个区域在至少两台服务器上可用，并且许多区域具有比这更多的冗余。</em></p><p>A given name server will typically support one or more zones, but this gives it authoritative information about only a small section of the domain tree.  It may also have some cached non-authoritative data about other parts of the tree.  The name server marks its responses to queries so that the requester can tell whether the response comes from authoritative data or not.<br><em>给定的名称服务器通常支持一个或多个区域，但这仅为其提供有关域树的一小部分的权威信息。 它还可能有一些关于树其他部分的缓存非权威数据。 名称服务器标记其对查询的响应，以便请求者可以判断响应是否来自权威数据。</em></p><h2 id="4-2-How-the-database-is-divided-into-zones-数据库是怎么拆分为区域的"><a href="#4-2-How-the-database-is-divided-into-zones-数据库是怎么拆分为区域的" class="headerlink" title="4.2. How the database is divided into zones(数据库是怎么拆分为区域的)"></a>4.2. How the database is divided into zones(数据库是怎么拆分为区域的)</h2><p>The domain database is partitioned in two ways: by class, and by “cuts” made in the name space between nodes.<br><em>域数据库以两种方式分区：按class分区，以及按节点间的名称空间中的”cuts”分区。</em></p><p>The class partition is simple.  The database for any class is organized, delegated, and maintained separately from all other classes.  Since, by convention, the name spaces are the same for all classes, the separate classes can be thought of as an array of parallel namespace trees.  Note that the data attached to nodes will be different for these different parallel classes.  The most common reasons for creating a new class are the necessity for a new data format for existing types or a desire for a separately managed version of the existing name space.<br><em>class划分很简单。 任何class的数据库都是与所有其他class分开组织、委托和维护的。 由于按照惯例，所有class的名称空间都是相同的，因此可以将单独的类视为并行名称空间树的数组。 请注意，对于这些不同的并行class，附加到节点的数据将有所不同。 创建新class的最常见原因是现有类型需要新的数据格式或需要现有名称空间的单独管理版本。</em></p><p>Within a class, “cuts” in the name space can be made between any two adjacent nodes.  After all cuts are made, each group of connected name space is a separate zone.  The zone is said to be authoritative for all names in the connected region.  Note that the “cuts” in the name space may be in different places for different classes, the name servers may be different, etc.<br><em>在class中，可以在任意两个相邻节点之间进行名称空间的”cuts”。 完成所有切割后，每组连接的名称空间都是一个单独的区域。 据说该区域对所连接区域中的所有名称具有权威性。 请注意，名称空间中的”cuts”对于不同的类可能位于不同的位置，名称服务器可能不同，等等。</em></p><p>These rules mean that every zone has at least one node, and hence domain name, for which it is authoritative, and all of the nodes in a particular zone are connected.  Given, the tree structure, every zone has a highest node which is closer to the root than any other node in the zone.  The name of this node is often used to identify the zone.<br><em>这些规则意味着每个区域至少有一个节点，因此也有一个具有权威的域名，并且特定区域中的所有节点都是连接的。 鉴于树结构，每个区域都有一个最高节点，该节点比该区域中的任何其他节点更接近根。 该节点的名称通常用于标识区域。</em></p><p>It would be possible, though not particularly useful, to partition the name space so that each domain name was in a separate zone or so that all nodes were in a single zone.  Instead, the database is partitioned at points where a particular organization wants to take over control of a subtree.  Once an organization controls its own zone it can unilaterally change the data in the zone, grow new tree sections connected to the zone, delete existing nodes, or delegate new subzones under its zone.<br><em>尽管不是特别有用，但可以对名称空间进行分区，以便每个域名位于单独的区域中，或者使所有节点位于单个区域中。 相反，数据库在特定组织想要接管子树控制权的点上进行分区。 一旦组织控制了自己的区域，它就可以单方面更改区域中的数据、生成连接到该区域的新树部分、删除现有节点或在其区域下委派新的子区域。</em></p><p>If the organization has substructure, it may want to make further internal partitions to achieve nested delegations of name space control. In some cases, such divisions are made purely to make database maintenance more convenient.<br><em>如果组织有子结构，它可能希望进行进一步的内部分区以实现名称空间控制的嵌套委托。 在某些情况下，这样的划分纯粹是为了使数据库维护更加方便。</em></p><h3 id="4-2-1-Technical-considerations-技术上的考虑"><a href="#4-2-1-Technical-considerations-技术上的考虑" class="headerlink" title="4.2.1. Technical considerations(技术上的考虑)"></a>4.2.1. Technical considerations(技术上的考虑)</h3><p>The data that describes a zone has four major parts:<br><em>描述区域的数据有四个主要部分：</em></p><ul><li>Authoritative data for all nodes within the zone.</li></ul><p>   <em>区域内所有节点的权威数据。</em></p><ul><li>Data that defines the top node of the zone (can be thought of as part of the authoritative data).</li></ul><p>   <em>定义区域顶部节点的数据（可以认为是权威数据的一部分）。</em></p><ul><li>Data that describes delegated subzones, i.e., cuts around the bottom of the zone.</li></ul><p>   <em>描述委托子区域的数据，即围绕区域底部的切割。</em></p><ul><li>Data that allows access to name servers for subzones (sometimes called “glue” data).</li></ul><p>   <em>允许访问子区域的名称服务器的数据（有时称为”glue”数据）。</em></p><p>All of this data is expressed in the form of RRs, so a zone can be<br>completely described in terms of a set of RRs.  Whole zones can be<br>transferred between name servers by transferring the RRs, either carried<br>in a series of messages or by FTPing a master file which is a textual<br>representation.</p><p>The authoritative data for a zone is simply all of the RRs attached to<br>all of the nodes from the top node of the zone down to leaf nodes or<br>nodes above cuts around the bottom edge of the zone.</p><p>Though logically part of the authoritative data, the RRs that describe<br>the top node of the zone are especially important to the zone’s<br>management.  These RRs are of two types: name server RRs that list, one<br>per RR, all of the servers for the zone, and a single SOA RR that<br>describes zone management parameters.</p><p>The RRs that describe cuts around the bottom of the zone are NS RRs that<br>name the servers for the subzones.  Since the cuts are between nodes,<br>these RRs are NOT part of the authoritative data of the zone, and should<br>be exactly the same as the corresponding RRs in the top node of the<br>subzone.  Since name servers are always associated with zone boundaries,<br>NS RRs are only found at nodes which are the top node of some zone.  In<br>the data that makes up a zone, NS RRs are found at the top node of the<br>zone (and are authoritative) and at cuts around the bottom of the zone<br>(where they are not authoritative), but never in between.</p><p>One of the goals of the zone structure is that any zone have all the<br>data required to set up communications with the name servers for any<br>subzones.  That is, parent zones have all the information needed to<br>access servers for their children zones.  The NS RRs that name the<br>servers for subzones are often not enough for this task since they name<br>the servers, but do not give their addresses.  In particular, if the<br>name of the name server is itself in the subzone, we could be faced with<br>the situation where the NS RRs tell us that in order to learn a name<br>server’s address, we should contact the server using the address we wish<br>to learn.  To fix this problem, a zone contains “glue” RRs which are not<br>part of the authoritative data, and are address RRs for the servers.<br>These RRs are only necessary if the name server’s name is “below” the<br>cut, and are only used as part of a referral response.</p><h3 id="4-2-2-Administrative-considerations-管理上的考虑"><a href="#4-2-2-Administrative-considerations-管理上的考虑" class="headerlink" title="4.2.2. Administrative considerations(管理上的考虑)"></a>4.2.2. Administrative considerations(管理上的考虑)</h3><p>When some organization wants to control its own domain, the first step<br>is to identify the proper parent zone, and get the parent zone’s owners<br>to agree to the delegation of control.  While there are no particular<br>technical constraints dealing with where in the tree this can be done,<br>there are some administrative groupings discussed in [RFC-1032] which<br>deal with top level organization, and middle level zones are free to<br>create their own rules.  For example, one university might choose to use<br>a single zone, while another might choose to organize by subzones<br>dedicated to individual departments or schools.  [RFC-1033] catalogs<br>available DNS software an discusses administration procedures.</p><p>Once the proper name for the new subzone is selected, the new owners<br>should be required to demonstrate redundant name server support.  Note<br>that there is no requirement that the servers for a zone reside in a<br>host which has a name in that domain.  In many cases, a zone will be<br>more accessible to the internet at large if its servers are widely<br>distributed rather than being within the physical facilities controlled<br>by the same organization that manages the zone.  For example, in the<br>current DNS, one of the name servers for the United Kingdom, or UK<br>domain, is found in the US.  This allows US hosts to get UK data without<br>using limited transatlantic bandwidth.</p><p>As the last installation step, the delegation NS RRs and glue RRs<br>necessary to make the delegation effective should be added to the parent<br>zone.  The administrators of both zones should insure that the NS and<br>glue RRs which mark both sides of the cut are consistent and remain so.</p><h2 id="4-3-Name-server-internals-名称服务器内部结构"><a href="#4-3-Name-server-internals-名称服务器内部结构" class="headerlink" title="4.3. Name server internals (名称服务器内部结构)"></a>4.3. Name server internals (名称服务器内部结构)</h2><h3 id="4-3-1-Queries-and-responses-查询和应答"><a href="#4-3-1-Queries-and-responses-查询和应答" class="headerlink" title="4.3.1. Queries and responses (查询和应答)"></a>4.3.1. Queries and responses (查询和应答)</h3><p>The principal activity of name servers is to answer standard queries.<br>Both the query and its response are carried in a standard message format<br>which is described in [RFC-1035].  The query contains a QTYPE, QCLASS,<br>and QNAME, which describe the types and classes of desired information<br>and the name of interest.</p><p>The way that the name server answers the query depends upon whether it<br>is operating in recursive mode or not:<br><em>名称服务器回答查询的方式取决于它是否以递归模式运行：</em></p><ul><li><p>The simplest mode for the server is non-recursive, since it<br>can answer queries using only local information: the response<br>contains an error, the answer, or a referral to some other<br>server “closer” to the answer.  All name servers must<br>implement non-recursive queries.</p></li><li><p>The simplest mode for the client is recursive, since in this<br>mode the name server acts in the role of a resolver and<br>returns either an error or the answer, but never referrals.<br>This service is optional in a name server, and the name server<br>may also choose to restrict the clients which can use<br>recursive mode.</p></li></ul><p>Recursive service is helpful in several situations:<br><em>递归服务在多种情况下很有用：</em></p><ul><li>a relatively simple requester that lacks the ability to use anything other than a direct answer to the question.</li></ul><p>   <em>相对简单的请求者，除了直接回答问题之外无法使用任何其他内容。</em></p><ul><li>a request that needs to cross protocol or other boundaries and can be sent to a server which can act as intermediary.</li></ul><p>   <em>需要跨越协议或其他边界并且可以发送到可以充当中介的服务器的请求。</em></p><ul><li>a network where we want to concentrate the cache rather than having a separate cache for each client.</li></ul><p>   <em>我们希望集中缓存而不是为每个客户端提供单独的缓存的网络。</em></p><p>Non-recursive service is appropriate if the requester is capable of pursuing referrals and interested in information which will aid future requests.<br><em>如果请求者能够寻求推荐并且对有助于未来请求的信息感兴趣，则非递归服务是合适的。</em></p><p>The use of recursive mode is limited to cases where both the client and the name server agree to its use.  The agreement is negotiated through the use of two bits in query and response messages:<br><em>递归模式的使用仅限于客户端和名称服务器都同意其使用的情况。 该协议是通过使用查询和响应消息中的两个位来协商的：</em></p><ul><li>The recursion available, or RA bit, is set or cleared by a name server in all responses.  The bit is true if the name server is willing to provide recursive service for the client, regardless of whether the client requested recursive service. That is, RA signals availability rather than use.</li></ul><p>   <em>可用递归或 RA 位由名称服务器在所有响应中设置或清除。 如果名称服务器愿意为客户端提供递归服务，则该位为真，无论客户端是否请求递归服务。也就是说，RA 表示可用性而不是使用。</em></p><ul><li>Queries contain a bit called recursion desired or RD.  This bit specifies specifies whether the requester wants recursive service for this query.  Clients may request recursive service from any name server, though they should depend upon receiving it only from servers which have previously sent an RA, or servers which have agreed to provide service through private agreement or some other means outside of the DNS protocol.</li></ul><p>   <em>查询包含一个称为所需递归或 RD 的位。 该位指定请求者是否希望为此查询提供递归服务。 客户端可以从任何名称服务器请求递归服务，尽管它们应该依赖于仅从先前发送过 RA 的服务器或同意通过私有协议或 DNS 协议之外的其他方式提供服务的服务器接收递归服务。</em></p><p>The recursive mode occurs when a query with RD set arrives at a server<br>which is willing to provide recursive service; the client can verify<br>that recursive mode was used by checking that both RA and RD are set in<br>the reply.  Note that the name server should never perform recursive<br>service unless asked via RD, since this interferes with trouble shooting<br>of name servers and their databases.</p><p>If recursive service is requested and available, the recursive response<br>to a query will be one of the following:</p><ul><li><p>The answer to the query, possibly preface by one or more CNAME<br>RRs that specify aliases encountered on the way to an answer.</p></li><li><p>A name error indicating that the name does not exist.  This<br>may include CNAME RRs that indicate that the original query<br>name was an alias for a name which does not exist.</p></li><li><p>A temporary error indication.</p></li></ul><p>If recursive service is not requested or is not available, the non-<br>recursive response will be one of the following:</p><ul><li><p>An authoritative name error indicating that the name does not<br>exist.</p></li><li><p>A temporary error indication.</p></li><li><p>Some combination of:</p><p>RRs that answer the question, together with an indication<br>whether the data comes from a zone or is cached.</p><p>A referral to name servers which have zones which are closer<br>ancestors to the name than the server sending the reply.</p></li><li><p>RRs that the name server thinks will prove useful to the<br>requester.</p></li></ul><h3 id="4-3-2-Algorithm-算法"><a href="#4-3-2-Algorithm-算法" class="headerlink" title="4.3.2. Algorithm(算法)"></a>4.3.2. Algorithm(算法)</h3><p>The actual algorithm used by the name server will depend on the local OS and data structures used to store RRs.  The following algorithm assumes that the RRs are organized in several tree structures, one for each zone, and another for the cache:<br><em>名称服务器使用的实际算法将取决于本地操作系统和用于存储 RR 的数据结构。 以下算法假设 RR 被组织成多个树结构，一个用于每个区域，另一个用于缓存：</em></p><ol><li><p>Set or clear the value of recursion available in the response<br>depending on whether the name server is willing to provide<br>recursive service.  If recursive service is available and<br>requested via the RD bit in the query, go to step 5,<br>otherwise step 2.</p></li><li><p>Search the available zones for the zone which is the nearest<br>ancestor to QNAME.  If such a zone is found, go to step 3,<br>otherwise step 4.</p></li><li><p>Start matching down, label by label, in the zone.  The<br>matching process can terminate several ways:</p><p>   a. If the whole of QNAME is matched, we have found the</p><div class="code-wrapper"><pre><code class="hljs">  node.  If the data at the node is a CNAME, and QTYPE doesn&#39;t  match CNAME, copy the CNAME RR into the answer section  of the response, change QNAME to the canonical name in  the CNAME RR, and go back to step 1.    Otherwise, copy all RRs which match QTYPE into the  answer section and go to step 6.</code></pre></div><p>   b. If a match would take us out of the authoritative data,</p><div class="code-wrapper"><pre><code class="hljs">  we have a referral.  This happens when we encounter a  node with NS RRs marking cuts along the bottom of a  zone.  Copy the NS RRs for the subzone into the authority  section of the reply.  Put whatever addresses are  available into the additional section, using glue RRs  if the addresses are not available from authoritative  data or the cache.  Go to step 4.</code></pre></div><p>   c. If at some label, a match is impossible (i.e., the</p><div class="code-wrapper"><pre><code class="hljs">  corresponding label does not exist), look to see if a  the &quot;*&quot; label exists.  If the &quot;*&quot; label does not exist, check whether the name  we are looking for is the original QNAME in the query  or a name we have followed due to a CNAME.  If the name  is original, set an authoritative name error in the  response and exit.  Otherwise just exit.    If the &quot;*&quot; label does exist, match RRs at that node  against QTYPE.  If any match, copy them into the answer  section, but set the owner of the RR to be QNAME, and  not the node with the &quot;*&quot; label.  Go to step 6.</code></pre></div></li><li><p>Start matching down in the cache.  If QNAME is found in the<br>cache, copy all RRs attached to it that match QTYPE into the<br>answer section.  If there was no delegation from<br>authoritative data, look for the best one from the cache, and<br>put it in the authority section.  Go to step 6.</p></li><li><p>Using the local resolver or a copy of its algorithm (see<br>resolver section of this memo) to answer the query.  Store<br>the results, including any intermediate CNAMEs, in the answer<br>section of the response.</p></li><li><p>Using local data only, attempt to add other RRs which may be<br>useful to the additional section of the query.  Exit.</p></li></ol><h3 id="4-3-3-Wildcards-通配符"><a href="#4-3-3-Wildcards-通配符" class="headerlink" title="4.3.3. Wildcards(通配符)"></a>4.3.3. Wildcards(通配符)</h3><p>In the previous algorithm, special treatment was given to RRs with owner<br>names starting with the label “*”.  Such RRs are called wildcards.<br>Wildcard RRs can be thought of as instructions for synthesizing RRs.<br>When the appropriate conditions are met, the name server creates RRs<br>with an owner name equal to the query name and contents taken from the<br>wildcard RRs.</p><p>This facility is most often used to create a zone which will be used to<br>forward mail from the Internet to some other mail system.  The general<br>idea is that any name in that zone which is presented to server in a<br>query will be assumed to exist, with certain properties, unless explicit<br>evidence exists to the contrary.  Note that the use of the term zone<br>here, instead of domain, is intentional; such defaults do not propagate<br>across zone boundaries, although a subzone may choose to achieve that<br>appearance by setting up similar defaults.</p><p>The contents of the wildcard RRs follows the usual rules and formats for<br>RRs.  The wildcards in the zone have an owner name that controls the<br>query names they will match.  The owner name of the wildcard RRs is of<br>the form “<em>.<anydomain>“, where <anydomain> is any domain name.<br><anydomain> should not contain other * labels, and should be in the<br>authoritative data of the zone.  The wildcards potentially apply to<br>descendants of <anydomain>, but not to <anydomain> itself.  Another way<br>to look at this is that the “</em>“ label always matches at least one whole<br>label and sometimes more, but always whole labels.</p><p>Wildcard RRs do not apply:</p><ul><li><p>When the query is in another zone.  That is, delegation cancels<br>the wildcard defaults.</p></li><li><p>When the query name or a name between the wildcard domain and<br>the query name is know to exist.  For example, if a wildcard<br>RR has an owner name of “*.X”, and the zone also contains RRs<br>attached to B.X, the wildcards would apply to queries for name<br>Z.X (presuming there is no explicit information for Z.X), but<br>not to B.X, A.B.X, or X.</p></li></ul><p>A * label appearing in a query name has no special effect, but can be<br>used to test for wildcards in an authoritative zone; such a query is the<br>only way to get a response containing RRs with an owner name with * in<br>it.  The result of such a query should not be cached.</p><p>Note that the contents of the wildcard RRs are not modified when used to<br>synthesize RRs.</p><p>To illustrate the use of wildcard RRs, suppose a large company with a<br>large, non-IP/TCP, network wanted to create a mail gateway.  If the<br>company was called X.COM, and IP/TCP capable gateway machine was called<br>A.X.COM, the following RRs might be entered into the COM zone:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">X<span class="hljs-selector-class">.COM</span>           MX      <span class="hljs-number">10</span>      A<span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.COM</span><br><br>*<span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.COM</span>         MX      <span class="hljs-number">10</span>      A<span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.COM</span><br><br>A<span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.COM</span>         A       <span class="hljs-number">1.2</span>.<span class="hljs-number">3.4</span><br>A<span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.COM</span>         MX      <span class="hljs-number">10</span>      A<span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.COM</span><br><br>*<span class="hljs-selector-class">.A</span><span class="hljs-selector-class">.X</span><span class="hljs-selector-class">.COM</span>       MX      <span class="hljs-number">10</span>      A<span class="hljs-selector-class">.X</span>.COM<br></code></pre></td></tr></table></figure><p>This would cause any MX query for any domain name ending in X.COM to return an MX RR pointing at A.X.COM.  Two wildcard RRs are required since the effect of the wildcard at *.X.COM is inhibited in the A.X.COM subtree by the explicit data for A.X.COM.  Note also that the explicit MX data at X.COM and A.X.COM is required, and that none of the RRs above would match a query name of XX.COM.<br><em>这将导致任何以 X.COM 结尾的 MX 查询都返回指向 A.X.COM 的 RR。其中的两个通配符 RR 是必要，因为 *.X.COM 处的通配符的影响在 A.X.COM 子树中被 A.X.COM 的显式数据所抑制。 另请注意，X.COM 和 A.X.COM 处的显式 MX 数据是必需的，并且以上 RR 均不会与 XX.COM 的查询名称匹配。</em></p><h3 id="4-3-4-Negative-response-caching-Optional-否定响应缓存"><a href="#4-3-4-Negative-response-caching-Optional-否定响应缓存" class="headerlink" title="4.3.4. Negative response caching (Optional)(否定响应缓存)"></a>4.3.4. Negative response caching (Optional)(否定响应缓存)</h3><p>The DNS provides an optional service which allows name servers to<br>distribute, and resolvers to cache, negative results with TTLs.  For<br>example, a name server can distribute a TTL along with a name error<br>indication, and a resolver receiving such information is allowed to<br>assume that the name does not exist during the TTL period without<br>consulting authoritative data.  Similarly, a resolver can make a query<br>with a QTYPE which matches multiple types, and cache the fact that some<br>of the types are not present.</p><p>This feature can be particularly important in a system which implements<br>naming shorthands that use search lists beacuse a popular shorthand,<br>which happens to require a suffix toward the end of the search list,<br>will generate multiple name errors whenever it is used.</p><p>The method is that a name server may add an SOA RR to the additional<br>section of a response when that response is authoritative.  The SOA must<br>be that of the zone which was the source of the authoritative data in<br>the answer section, or name error if applicable.  The MINIMUM field of<br>the SOA controls the length of time that the negative result may be<br>cached.</p><p>Note that in some circumstances, the answer section may contain multiple<br>owner names.  In this case, the SOA mechanism should only be used for<br>the data which matches QNAME, which is the only authoritative data in<br>this section.</p><p>Name servers and resolvers should never attempt to add SOAs to the<br>additional section of a non-authoritative response, or attempt to infer<br>results which are not directly stated in an authoritative response.<br>There are several reasons for this, including: cached information isn’t<br>usually enough to match up RRs and their zone names, SOA RRs may be<br>cached due to direct SOA queries, and name servers are not required to<br>output the SOAs in the authority section.</p><p>This feature is optional, although a refined version is expected to<br>become part of the standard protocol in the future.  Name servers are<br>not required to add the SOA RRs in all authoritative responses, nor are<br>resolvers required to cache negative results.  Both are recommended.<br>All resolvers and recursive name servers are required to at least be<br>able to ignore the SOA RR when it is present in a response.</p><p>Some experiments have also been proposed which will use this feature.<br>The idea is that if cached data is known to come from a particular zone,<br>and if an authoritative copy of the zone’s SOA is obtained, and if the<br>zone’s SERIAL has not changed since the data was cached, then the TTL of<br>the cached data can be reset to the zone MINIMUM value if it is smaller.<br>This usage is mentioned for planning purposes only, and is not<br>recommended as yet.</p><h3 id="4-3-5-Zone-maintenance-and-transfers-区域维护和转移"><a href="#4-3-5-Zone-maintenance-and-transfers-区域维护和转移" class="headerlink" title="4.3.5. Zone maintenance and transfers(区域维护和转移)"></a>4.3.5. Zone maintenance and transfers(区域维护和转移)</h3><p>Part of the job of a zone administrator is to maintain the zones at all<br>of the name servers which are authoritative for the zone.  When the<br>inevitable changes are made, they must be distributed to all of the name<br>servers.  While this distribution can be accomplished using FTP or some<br>other ad hoc procedure, the preferred method is the zone transfer part<br>of the DNS protocol.</p><p>The general model of automatic zone transfer or refreshing is that one<br>of the name servers is the master or primary for the zone.  Changes are<br>coordinated at the primary, typically by editing a master file for the<br>zone.  After editing, the administrator signals the master server to<br>load the new zone.  The other non-master or secondary servers for the<br>zone periodically check for changes (at a selectable interval) and<br>obtain new zone copies when changes have been made.</p><p>To detect changes, secondaries just check the SERIAL field of the SOA<br>for the zone.  In addition to whatever other changes are made, the<br>SERIAL field in the SOA of the zone is always advanced whenever any<br>change is made to the zone.  The advancing can be a simple increment, or<br>could be based on the write date and time of the master file, etc.  The<br>purpose is to make it possible to determine which of two copies of a<br>zone is more recent by comparing serial numbers.  Serial number advances<br>and comparisons use sequence space arithmetic, so there is a theoretic<br>limit on how fast a zone can be updated, basically that old copies must<br>die out before the serial number covers half of its 32 bit range.  In<br>practice, the only concern is that the compare operation deals properly<br>with comparisons around the boundary between the most positive and most<br>negative 32 bit numbers.</p><p>The periodic polling of the secondary servers is controlled by<br>parameters in the SOA RR for the zone, which set the minimum acceptable<br>polling intervals.  The parameters are called REFRESH, RETRY, and<br>EXPIRE.  Whenever a new zone is loaded in a secondary, the secondary<br>waits REFRESH seconds before checking with the primary for a new serial.<br>If this check cannot be completed, new checks are started every RETRY<br>seconds.  The check is a simple query to the primary for the SOA RR of<br>the zone.  If the serial field in the secondary’s zone copy is equal to<br>the serial returned by the primary, then no changes have occurred, and<br>the REFRESH interval wait is restarted.  If the secondary finds it<br>impossible to perform a serial check for the EXPIRE interval, it must<br>assume that its copy of the zone is obsolete an discard it.</p><p>When the poll shows that the zone has changed, then the secondary server<br>must request a zone transfer via an AXFR request for the zone.  The AXFR<br>may cause an error, such as refused, but normally is answered by a<br>sequence of response messages.  The first and last messages must contain<br>the data for the top authoritative node of the zone.  Intermediate<br>messages carry all of the other RRs from the zone, including both<br>authoritative and non-authoritative RRs.  The stream of messages allows<br>the secondary to construct a copy of the zone.  Because accuracy is<br>essential, TCP or some other reliable protocol must be used for AXFR<br>requests.</p><p>Each secondary server is required to perform the following operations<br>against the master, but may also optionally perform these operations<br>against other secondary servers.  This strategy can improve the transfer<br>process when the primary is unavailable due to host downtime or network<br>problems, or when a secondary server has better network access to an<br>“intermediate” secondary than to the primary.</p><h1 id="5-RESOLVERS-解析器"><a href="#5-RESOLVERS-解析器" class="headerlink" title="5. RESOLVERS(解析器)"></a>5. RESOLVERS(解析器)</h1><h2 id="5-1-Introduction（介绍）"><a href="#5-1-Introduction（介绍）" class="headerlink" title="5.1. Introduction（介绍）"></a>5.1. Introduction（介绍）</h2><p>Resolvers are programs that interface user programs to domain name servers.  In the simplest case, a resolver receives a request from a user program (e.g., mail programs, TELNET, FTP) in the form of a subroutine call, system call etc., and returns the desired information in a form compatible with the local host’s data formats.</p><p><em>解析器是将用户程序连接到域名服务器的程序。 在最简单的情况下，解析器以子程序调用、系统调用等形式接收来自用户程序（例如邮件程序、TELNET、FTP）的请求，并以与本地主机兼容形式的数据格式返回所需信息。</em></p><p>The resolver is located on the same machine as the program that requests the resolver’s services, but it may need to consult name servers on other hosts.  Because a resolver may need to consult several name servers, or may have the requested information in a local cache, the amount of time that a resolver will take to complete can vary quite a bit, from milliseconds to several seconds.<br><em>解析器与请求解析器服务的程序位于同一台机器上，但它可能需要咨询其他主机上的名称服务器。 由于解析器可能需要咨询多个名称服务器，或者可能在本地缓存中具有所请求的信息，因此解析器完成所需的时间可能会有很大差异，从几毫秒到几秒不等。</em></p><p>A very important goal of the resolver is to eliminate network delay and name server load from most requests by answering them from its cache of prior results.  It follows that caches which are shared by multiple processes, users, machines, etc., are more efficient than non-shared caches.<br><em>解析器的一个非常重要的目标是通过从先前结果的缓存中应答大多数请求来消除网络延迟和名称服务器负载。 由此可见，由多个进程、用户、机器等共享的缓存比非共享缓存更有效。</em></p><h2 id="5-2-Client-resolver-interface-客户端-解析器接口"><a href="#5-2-Client-resolver-interface-客户端-解析器接口" class="headerlink" title="5.2. Client-resolver interface(客户端-解析器接口)"></a>5.2. Client-resolver interface(客户端-解析器接口)</h2><h3 id="5-2-1-Typical-functions-典型功能"><a href="#5-2-1-Typical-functions-典型功能" class="headerlink" title="5.2.1. Typical functions(典型功能)"></a>5.2.1. Typical functions(典型功能)</h3><p>The client interface to the resolver is influenced by the local host’s conventions, but the typical resolver-client interface has three functions:<br><em>解析器的客户端接口受本地主机约定的影响，但典型的解析器-客户端接口具有三个功能：</em></p><div class="code-wrapper"><pre><code class="hljs">1. Host name to host address translation.(主机名到主机地址的转换)This function is often defined to mimic a previous HOSTS.TXT based function.  Given a character string, the caller wants one or more 32 bit IP addresses.  Under the DNS, it  translates into a request for type A RRs.  Since the DNS does not preserve the order of RRs, this function may choose to sort the returned addresses or select the &quot;best&quot; address if the service returns only one choice to the client.  Note that a multiple address return is recommended, but a single address may be the only way to emulate prior HOSTS.TXT services.此函数通常定义为模仿先前基于 HOSTS.TXT 的函数。 给定一个字符串，调用者需要一个或多个 32 位 IP 地址。 在 DNS 下，它会转换为 A 类 RR 的请求。 由于 DNS 不保留 RR 的顺序，因此该函数可以选择对返回的地址进行排序，或者如果服务仅向客户端返回一种选择，则选择“最佳”地址。 请注意，建议返回多个地址，但单个地址可能是模拟先前 HOSTS.TXT 服务的唯一方法。2. Host address to host name translation(主机地址到主机名的转换)  This function will often follow the form of previous functions.  Given a 32 bit IP address, the caller wants a character string.  The octets of the IP address are reversed, used as name components, and suffixed with &quot;IN-ADDR.ARPA&quot;.  A type PTR query is used to get the RR with the primary name of the host.  For example, a request for the host name corresponding to IP address 1.2.3.4 looks for PTR RRs for domain name &quot;4.3.2.1.IN-ADDR.ARPA&quot;.    该函数通常遵循先前函数的形式。 给定一个 32 位 IP 地址，调用者需要一个字符串。 IP 地址的八位字节被反转，用作名称组件，并带有“IN-ADDR.ARPA”后缀。 PTR 类型查询用于获取带有主机主名称的 RR。 例如，对与IP地址1.2.3.4对应的主机名的请求查找域名“4.3.2.1.IN-ADDR.ARPA”的PTR RR。  3. General lookup function(通用查找功能)  This function retrieves arbitrary information from the DNS, and has no counterpart in previous systems.  The caller supplies a QNAME, QTYPE, and QCLASS, and wants all of the matching RRs.  This function will often use the DNS format for all RR data instead of the local host&#39;s, and returns all RR content (e.g., TTL) instead of a processed form with local quoting conventions.    该函数从 DNS 检索任意信息，并且在以前的系统中没有对应的函数。 调用者提供 QNAME、QTYPE 和 QCLASS，并需要所有匹配的 RR。 该函数通常对所有 RR 数据使用 DNS 格式而不是本地主机的格式，并返回所有 RR 内容（例如 TTL）而不是具有本地引用约定的处理形式。</code></pre></div><p>When the resolver performs the indicated function, it usually has one of the following results to pass back to the client:<br><em>当解析器执行指定的功能时，它通常会将以下结果之一传回客户端：</em></p><div class="code-wrapper"><pre><code class="hljs">1. One or more RRs giving the requested data.(一个或多个 RR 提供所请求的数据。)  In this case the resolver returns the answer in the appropriate format.   在这种情况下，解析器会以适当的格式返回答案。   2. A name error (NE).(名称错误) This happens when the referenced name does not exist.  For example, a user may have mistyped a host name.&#39;   当引用的名称不存在时会发生这种情况。 例如，用户可能输错了主机名。3. A data not found error.(未找到数据错误) This happens when the referenced name exists, but data of the appropriate type does not. For example, a host address function applied to a mailbox name would return this error since the name exists, but no address RR is present.   当引用的名称存在但适当类型的数据不存在时，就会发生这种情况。 例如，应用于邮箱名称的主机地址函数将返回此错误，因为该名称存在，但不存在地址 RR。</code></pre></div><p>It is important to note that the functions for translating between host names and addresses may combine the “name error” and “data not found” error conditions into a single type of error return, but the general function should not.  One reason for this is that applications may ask first for one type of information about a name followed by a second request to the same name for some other type of information; if the two errors are combined, then useless queries may slow the application.<br><em>需要注意的是，用于在主机名和地址之间进行转换的函数可能会将“名称错误”和“未找到数据”错误条件合并为单一类型的错误返回，但通用函数不应该这样做。 原因之一是应用程序可能首先请求有关名称的一种类型的信息，然后再请求相同名称的其他类型的信息； 如果这两个错误结合在一起，那么无用的查询可能会减慢应用程序的速度。</em></p><h3 id="5-2-2-Aliases-别名"><a href="#5-2-2-Aliases-别名" class="headerlink" title="5.2.2. Aliases(别名)"></a>5.2.2. Aliases(别名)</h3><p>While attempting to resolve a particular request, the resolver may find that the name in question is an alias.  For example, the resolver might find that the name given for host name to address translation is an alias when it finds the CNAME RR.  If possible, the alias condition should be signalled back from the resolver to the client.<br><em>在尝试解析特定请求时，解析器可能会发现所讨论的名称是别名。 例如，解析器在找到 CNAME RR 时可能会发现为主机名到地址转换指定的名称是别名。 如果可能，别名条件应从解析器发回客户端。</em></p><p>In most cases a resolver simply restarts the query at the new name when it encounters a CNAME.  However, when performing the general function, the resolver should not pursue aliases when the CNAME RR matches the query type.  This allows queries which ask whether an alias is present. For example, if the query type is CNAME, the user is interested in the CNAME RR itself, and not the RRs at the name it points to.<br><em>在大多数情况下，解析器在遇到 CNAME 时只是以新名称重新启动查询。 然而，在执行一般功能时，当 CNAME RR 与查询类型匹配时，解析器不应追求别名。 这允许查询询问别名是否存在。 例如，如果查询类型是 CNAME，则用户对 CNAME RR 本身感兴趣，而不是它所指向的名称处的 RR。</em></p><p>Several special conditions can occur with aliases.  Multiple levels of aliases should be avoided due to their lack of efficiency, but should not be signalled as an error.  Alias loops and aliases which point to non-existent names should be caught and an error condition passed back to the client.<br><em>别名可能会出现一些特殊情况。 应避免使用多级别名，因为它们缺乏效率，但不应将其标记为错误。 应捕获别名循环和指向不存在名称的别名，并将错误条件传递回客户端。</em></p><h3 id="5-2-3-Temporary-failures-临时故障"><a href="#5-2-3-Temporary-failures-临时故障" class="headerlink" title="5.2.3. Temporary failures(临时故障)"></a>5.2.3. Temporary failures(临时故障)</h3><p>In a less than perfect world, all resolvers will occasionally be unable to resolve a particular request.  This condition can be caused by a resolver which becomes separated from the rest of the network due to a link failure or gateway problem, or less often by coincident failure or unavailability of all servers for a particular domain.<br><em>在不太完美的世界中，所有解析器有时都无法解决特定请求。 这种情况可能是由解析器引起的，该解析器由于链路故障或网关问题而与网络的其余部分分离，或者很少由于特定域的所有服务器同时发生故障或不可用而引起。</em></p><p>It is essential that this sort of condition should not be signalled as a name or data not present error to applications.  This sort of behavior is annoying to humans, and can wreak havoc when mail systems use the DNS.<br><em>重要的是，这种情况不应作为名称或数据不存在错误向应用程序发出信号。 这种行为对人类来说很烦人，并且当邮件系统使用 DNS 时可能会造成严重破坏。</em></p><p>While in some cases it is possible to deal with such a temporary problem by blocking the request indefinitely, this is usually not a good choice, particularly when the client is a server process that could move on to other tasks.  The recommended solution is to always have temporary failure as one of the possible results of a resolver function, even though this may make emulation of existing HOSTS.TXT functions more difficult.<br><em>虽然在某些情况下可以通过无限期地阻止请求来处理此类临时问题，但这通常不是一个好的选择，特别是当客户端是可以继续执行其他任务的服务器进程时。 建议的解决方案是始终将临时故障作为解析器函数的可能结果之一，即使这可能会使现有 HOSTS.TXT 函数的模拟变得更加困难。</em></p><h2 id="5-3-Resolver-internals-解析器内部结构"><a href="#5-3-Resolver-internals-解析器内部结构" class="headerlink" title="5.3. Resolver internals(解析器内部结构)"></a>5.3. Resolver internals(解析器内部结构)</h2><p>Every resolver implementation uses slightly different algorithms, and typically spends much more logic dealing with errors of various sorts than typical occurances.  This section outlines a recommended basic strategy for resolver operation, but leaves details to [RFC-1035].</p><ul><li>每个解析器实现都使用略有不同的算法，并且与典型事件处理相比将花费更多的逻辑来处理各种类型的错误。 本节概述了推荐的解析器操作基本策略，但将详细信息留给[RFC-1035]。 *</li></ul><h3 id="5-3-1-Stub-resolvers-存根解析器-即缓存解析器"><a href="#5-3-1-Stub-resolvers-存根解析器-即缓存解析器" class="headerlink" title="5.3.1. Stub resolvers(存根解析器-即缓存解析器)"></a>5.3.1. Stub resolvers(存根解析器-即缓存解析器)</h3><p>One option for implementing a resolver is to move the resolution function out of the local machine and into a name server which supports recursive queries.  This can provide an easy method of providing domain service in a PC which lacks the resources to perform the resolver<br>function, or can centralize the cache for a whole local network or organization.</p><p>*实现解析器的一种选择是将解析功能从本地计算机移出并移至支持递归查询的名称服务器中。 这可以提供一种在缺乏执行解析器功能的资源的 PC 中提供域服务的简单方法，或者可以集中整个本地网络或组织的缓存。 *</p><p>All that the remaining stub needs is a list of name server addresses that will perform the recursive requests.  This type of resolver presumably needs the information in a configuration file, since it probably lacks the sophistication to locate it in the domain database. The user also needs to verify that the listed servers will perform the recursive service; a name server is free to refuse to perform recursive services for any or all clients.  The user should consult the local system administrator to find name servers willing to perform the service.</p><p><em>存根解析器只需要拥有递归请求的名称服务器地址列表即可。 这种类型的解析器可能需要配置文件中的信息，因为它可能缺乏在域数据库中定位它的复杂性。 用户还需要验证列出的服务器是否会执行递归服务； 名称服务器可以自由拒绝为任何或所有客户端执行递归服务。 用户应咨询本地系统管理员以查找愿意执行该服务的名称服务器。</em></p><p>This type of service suffers from some drawbacks. Since the recursive requests may take an arbitrary amount of time to perform, the stub may have difficulty optimizing retransmission intervals to deal with both lost UDP packets and dead servers; the name server can be easily overloaded by too zealous a stub if it interprets retransmissions as new requests.  Use of TCP may be an answer, but TCP may well place burdens on the host’s capabilities which are similar to those of a real resolver.</p><p><em>这种类型的服务有一些缺点。 由于递归请求可能需要任意时间来执行，因此存根可能难以优化重传间隔来处理丢失的 UDP 数据包和失效的服务器； 如果名称服务器将重传解释为新请求，则名称服务器很容易因过于热心的存根而过载。 使用 TCP 可能是一个答案，但 TCP 很可能会给主机的能力带来负担，这与真正的解析器的能力类似。</em></p><h3 id="5-3-2-Resources-资源"><a href="#5-3-2-Resources-资源" class="headerlink" title="5.3.2. Resources(资源)"></a>5.3.2. Resources(资源)</h3><p>In addition to its own resources, the resolver may also have shared access to zones maintained by a local name server.  This gives the resolver the advantage of more rapid access, but the resolver must be careful to never let cached information override zone data.  In this discussion the term “local information” is meant to mean the union of the cache and such shared zones, with the understanding that authoritative data is always used in preference to cached data when both are present.</p><p><em>除了其自己的资源之外，解析器还可以共享对本地名称服务器维护的区域的访问。 这为解析器提供了更快速访问的优势，但解析器必须小心，切勿让缓存的信息覆盖区域数据。 在本讨论中，术语“本地信息”意指高速缓存和此类共享区域的联合，并理解当两者都存在时，权威数据总是优先于高速缓存数据使用。</em></p><p>The following resolver algorithm assumes that all functions have been converted to a general lookup function, and uses the following data structures to represent the state of a request in progress in the<br>resolver:</p><p><em>以下解析器算法假设所有函数都已转换为通用查找函数，并使用以下数据结构来表示解析器中正在进行的请求的状态</em></p><table><thead><tr><th>结构体名</th><th>说明</th></tr></thead><tbody><tr><td>SNAME</td><td>the domain name we are searching for.<br><em>正在搜索的域名</em></td></tr><tr><td>STYPE</td><td>the QTYPE of the search request.<br><em>搜索请求的QTYPE</em></td></tr><tr><td>SCLASS</td><td>the QCLASS of the search request.<br><em>搜索请求的QCLASS</em></td></tr><tr><td>SLIST</td><td>a structure which describes the name servers and the  zone which the resolver is currently trying to query. This structure keeps track of the resolver’s current best guess about which name servers hold the desired information; it is updated when arriving information changes the guess.  This structure includes the equivalent of a zone name, the known name servers for the zone, the known addresses for the name servers, and history information which can be used to suggest which server is likely to be the best one to try next.  The zone name equivalent is a match count of the number of labels from the root down which SNAME has in common with the zone being queried; this is used as a measure of how “close” the resolver is to SNAME.<br><em>描述名称服务器和解析器当前尝试查询的区域的结构。 该结构跟踪解析器当前对哪些名称服务器保存所需信息的最佳猜测； 当到达的信息改变猜测时，它就会更新。 该结构包括区域名称的等效项、该区域的已知名称服务器、名称服务器的已知地址以及可用于建议哪个服务器可能是下一步尝试的最佳服务器的历史信息。 区域名称等效项是从根向下的标签数量的匹配计数，SNAME 与正在查询的区域有共同点； 这用于衡量解析器与 SNAME 的“接近”程度。</em></td></tr><tr><td>SBELT</td><td>a “safety belt” structure of the same form as SLIST, which is initialized from a configuration file, and lists servers which should be used when the resolver doesn’t have any local information to guide name server selection.  The match count will be -1 to indicate that no labels are known to match.<br><em>与 SLIST 形式相同的“安全带”结构，它从配置文件初始化，并列出当解析器没有任何本地信息来指导名称服务器选择时应使用的服务器。 匹配计数将为 -1，表示没有已知的匹配标签。</em></td></tr><tr><td>CACHE</td><td>A structure which stores the results from previous responses.  Since resolvers are responsible for discarding old RRs whose TTL has expired, most implementations convert the interval specified in arriving RRs to some sort of absolute time when the RR is stored in the cache.  Instead of counting the TTLs down individually, the resolver just ignores or discards old RRs when it runs across them in the course of a search, or discards them during periodic sweeps to reclaim the memory consumed by old RRs.<br><em>存储先前响应结果的结构。 由于解析器负责丢弃 TTL 已过期的旧 RR，因此大多数实现会将到达 RR 中指定的间隔转换为 RR 存储在缓存中时的某种绝对时间。 解析器不是单独对 TTL 进行计数，而是在搜索过程中遇到旧 RR 时忽略或丢弃它们，或者在定期扫描期间丢弃它们以回收旧 RR 消耗的内存。</em></td></tr></tbody></table><h3 id="5-3-3-Algorithm-算法"><a href="#5-3-3-Algorithm-算法" class="headerlink" title="5.3.3. Algorithm(算法)"></a>5.3.3. Algorithm(算法)</h3><p>The top level algorithm has four steps:<br><em>顶层算法有四个步骤：</em></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-number">1.</span> See <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> answer is <span class="hljs-keyword">in</span> <span class="hljs-built_in">local</span> information, <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span> so <span class="hljs-literal">return</span> <span class="hljs-keyword">it</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> client.<br>查看本地信息中是否有答案，如果有则返回给客户端。<br><br><span class="hljs-number">2.</span> Find <span class="hljs-keyword">the</span> best servers <span class="hljs-built_in">to</span> ask.<br>找到最好的服务器来询问。<br><br><span class="hljs-number">3.</span> Send them queries <span class="hljs-keyword">until</span> <span class="hljs-literal">one</span> returns <span class="hljs-keyword">a</span> response.<br>向他们发送查询，直到有人返回响应。<br><br><span class="hljs-number">4.</span> Analyze <span class="hljs-keyword">the</span> response, either:<br>分析响应：<br>     <span class="hljs-keyword">a</span>. <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> response answers <span class="hljs-keyword">the</span> question <span class="hljs-keyword">or</span> <span class="hljs-keyword">contains</span> <span class="hljs-keyword">a</span> name<br>        error, cache <span class="hljs-keyword">the</span> data <span class="hljs-keyword">as</span> well <span class="hljs-keyword">as</span> returning <span class="hljs-keyword">it</span> back <span class="hljs-built_in">to</span><br>        <span class="hljs-keyword">the</span> client.<br>如果响应回答了问题或包含名称错误，则缓存数据并将其返回给客户端。<br><br>     b. <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> response <span class="hljs-keyword">contains</span> <span class="hljs-keyword">a</span> better delegation <span class="hljs-built_in">to</span> other<br>        servers, cache <span class="hljs-keyword">the</span> delegation information, <span class="hljs-keyword">and</span> go <span class="hljs-built_in">to</span><br>        step <span class="hljs-number">2.</span><br>如果响应包含对其他服务器的更好代理，则缓存代理信息，然后转到步骤<span class="hljs-number">2</span>。<br><br>     c. <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> response shows <span class="hljs-keyword">a</span> CNAME <span class="hljs-keyword">and</span> that is <span class="hljs-keyword">not</span> <span class="hljs-keyword">the</span><br>        answer itself, cache <span class="hljs-keyword">the</span> CNAME, change <span class="hljs-keyword">the</span> SNAME <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span><br>        canonical name <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> CNAME RR <span class="hljs-keyword">and</span> go <span class="hljs-built_in">to</span> step <span class="hljs-number">1.</span><br>如果响应显示 CNAME 而不是答案本身，则缓存 CNAME，<br>将 SNAME 更改为 CNAME RR 中的规范名称，然后转到步骤 <span class="hljs-number">1</span>。<br><br>     d. <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> response shows <span class="hljs-keyword">a</span> servers failure <span class="hljs-keyword">or</span> other<br>        bizarre contents, <span class="hljs-built_in">delete</span> <span class="hljs-keyword">the</span> server <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> SLIST <span class="hljs-keyword">and</span><br>        go back <span class="hljs-built_in">to</span> step <span class="hljs-number">3.</span><br>如果响应显示服务器故障或其他奇怪的内容，<br>请从 SLIST 中删除该服务器并返回到步骤 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p>Step 1 searches the cache for the desired data. If the data is in the cache, it is assumed to be good enough for normal use.  Some resolvers have an option at the user interface which will force the resolver to ignore the cached data and consult with an authoritative server. This is not recommended as the default.  If the resolver has direct access to a name server’s zones, it should check to see if the desired data is present in authoritative form, and if so, use the authoritative data in preference to cached data.</p><p><strong>步骤1: 在缓存中搜索所需数据。 如果数据在缓存中，则认为它足以满足正常使用。 某些解析器在用户界面上有一个选项，该选项将强制解析器忽略缓存的数据并咨询权威服务器。 不建议将此作为默认值。 如果解析器可以直接访问名称服务器的区域，则它应该检查所需的数据是否以权威形式存在，如果是，则优先使用权威数据而不是缓存数据。</strong></p><p>Step 2 looks for a name server to ask for the required data.  The general strategy is to look for locally-available name server RRs, starting at SNAME, then the parent domain name of SNAME, the grandparent, and so on toward the root.  Thus if SNAME were Mockapetris.ISI.EDU, this step would look for NS RRs for Mockapetris.ISI.EDU, then ISI.EDU, then EDU, and then . (the root). These NS RRs list the names of hosts for a zone at or above SNAME.  Copy the names into SLIST.  Set up their addresses using local data.  It may be the case that the addresses are not available.  The resolver has many choices here; the best is to start parallel resolver processes looking for the addresses while continuing onward with the addresses which are available.  Obviously, the design choices and options are complicated and a function of the local host’s capabilities.  The recommended priorities for the resolver designer are:</p><p><strong>步骤2:查找名称服务器以请求所需的数据。 一般策略是寻找本地可用的名称服务器 RR，从 SNAME 开始，然后是 SNAME 的父域名、祖父域名，依此类推，直至root(根)。 因此，如果 SNAME 是 Mockapetris.ISI.EDU，则此步骤将查找 Mockapetris.ISI.EDU 的 NS 资源记录(RR)，然后是 ISI.EDU，然后是 EDU，最后是.(即根)。 这些 NS 资源记录(RR) 列出了 SNAME 或以上区域的主机名称。 将名称复制到 SLIST 中。 使用本地数据设置他们的地址。 可能是地址不可用的情况。 解析器在这里有很多选择； 最好的方法是启动并行解析器进程来查找地址，同时继续查找可用的地址。 显然，设计选择和选项很复杂，并且取决于本地主机的功能。 优先推荐的解析器设计是:</strong></p><ol><li><p>Bound the amount of work (packets sent, parallel processes started) so that a request can’t get into an infinite loop or start off a chain reaction of requests or queries with other implementations EVEN IF SOMEONE HAS INCORRECTLY CONFIGURED SOME DATA.<br>   <em>限制工作量（发送数据包、启动并行进程），以便请求无法进入无限循环或启动请求或查询与其他实现的连锁反应，即使有人错误地配置了某些数据。</em></p></li><li><p>Get back an answer if at all possible.<br>   <em>如果可能的话，请返回答案。</em></p></li><li><p>Avoid unnecessary transmissions.<br>   <em>避免不必要的传输。</em></p></li><li><p>Get the answer as quickly as possible.<br>   <em>尽快得到答案。</em></p></li></ol><p>If the search for NS RRs fails, then the resolver initializes SLIST from the safety belt SBELT.  The basic idea is that when the resolver has no idea what servers to ask, it should use information from a configuration file that lists several servers which are expected to be helpful. Although there are special situations, the usual choice is two of the root servers and two of the servers for the host’s domain.  The reason for two of each is for redundancy.  The root servers will provide eventual access to all of the domain space.  The two local servers will allow the resolver to continue to resolve local names if the local network becomes isolated from the internet due to gateway or link failure.<br><em>如果搜索 NS RR(资源记录) 失败，则解析器从’安全带 ‘SBELT 初始化 SLIST。 基本思想是，当解析器不知道要询问哪些服务器时，它应该使用配置文件中的信息，该配置文件列出了预计有帮助的几个服务器。 尽管有特殊情况，但通常的选择是两台根服务器和两台主机域服务器。 各两个的原因是为了冗余。 根服务器将提供对所有域空间的最终访问。 如果本地网络由于网关或链路故障而与互联网隔离，这两个本地服务器将允许解析器继续解析本地名称。</em></p><p>In addition to the names and addresses of the servers, the SLIST data structure can be sorted to use the best servers first, and to insure that all addresses of all servers are used in a round-robin manner.  The sorting can be a simple function of preferring addresses on the local network over others, or may involve statistics from past events, such as previous response times and batting averages.<br><em>除了服务器的名称和地址之外，还可以对SLIST数据结构进行排序，以首先使用最好的服务器，并确保以循环方式使用所有服务器的所有地址。 排序可以是优先选择本地网络上的地址而不是其他地址的简单功能，也可以涉及过去事件的统计数据，例如先前的响应时间和成功率。</em></p><p>Step 3 sends out queries until a response is received.  The strategy is to cycle around all of the addresses for all of the servers with a timeout between each transmission.  In practice it is important to use all addresses of a multihomed host, and too aggressive a retransmission policy actually slows response when used by multiple resolvers contending for the same name server and even occasionally for a single resolver.  SLIST typically contains data values to control the timeouts and keep track of previous transmissions.<br><strong>步骤3:发出查询，直到收到响应。 该策略是循环所有服务器的所有地址，并在每次传输之间设置超时。 实际上，使用多宿主主机的所有地址非常重要，当多个解析器争用同一名称服务器时，甚至偶尔争用单个解析器时，过于激进的重传策略实际上会减慢响应速度。 SLIST 通常包含用于控制超时并跟踪先前传输的数据值。</strong></p><p>Step 4 involves analyzing responses.  The resolver should be highly paranoid in its parsing of responses.  It should also check that the response matches the query it sent using the ID field in the response.<br>**步骤4: 响应分析。 解析器在解析响应时应该高度偏执。 它还应该使用响应中的 ID 字段检查响应是否与其发送的查询匹配。 **</p><p>The ideal answer is one from a server authoritative for the query which either gives the required data or a name error.  The data is passed back to the user and entered in the cache for future use if its TTL is greater than zero.<br><em>理想的答案是来自对查询具有权威性的服务器的答案，该服务器要么给出所需的数据，要么给出名称错误。 如果数据的 TTL 大于零，则数据将传回用户并输入到缓存中以供将来使用。</em></p><p>If the response shows a delegation, the resolver should check to see that the delegation is “closer” to the answer than the servers in SLIST are.  This can be done by comparing the match count in SLIST with that computed from SNAME and the NS RRs in the delegation.  If not, the reply is bogus and should be ignored.  If the delegation is valid the NS delegation RRs and any address RRs for the servers should be cached. The name servers are entered in the SLIST, and the search is restarted.<br><em>如果响应显示是一个代理，则解析器应检查代理是否比 SLIST 中的服务器“更接近”答案。 可以通过将 SLIST 中的匹配计数与从 SNAME 和委派中的 NS 资源记录（RRs）计算得出的匹配计数进行比较来实现。 如果不是，则该回复是假的，应被忽略。 如果委派有效，则应缓存 NS 委派 RR 和服务器的任何地址 RR。 名称服务器将输入 SLIST，然后重新启动搜索。</em></p><p>If the response contains a CNAME, the search is restarted at the CNAME unless the response has the data for the canonical name or if the CNAME is the answer itself.<br><em>如果响应包含 CNAME，则搜索将在 CNAME 处重新启动，除非响应具有规范名称的数据或者 CNAME 就是答案本身。</em></p><p>Details and implementation hints can be found in [RFC-1035].<br><em>详细信息和实现提示可以在 [RFC-1035] 中找到。</em></p><h1 id="6-A-SCENARIO-一个场景"><a href="#6-A-SCENARIO-一个场景" class="headerlink" title="6. A SCENARIO(一个场景)"></a>6. A SCENARIO(一个场景)</h1><p>In our sample domain space, suppose we wanted separate administrative<br>control for the root, MIL, EDU, MIT.EDU and ISI.EDU zones.  We might<br>allocate name servers as follows:</p><div class="code-wrapper"><pre><code class="hljs">                               |(C.ISI.EDU,SRI-NIC.ARPA                               | A.ISI.EDU)         +---------------------+------------------+         |                     |                  |        MIL                   EDU                ARPA         |(SRI-NIC.ARPA,       |(SRI-NIC.ARPA,    |         | A.ISI.EDU           | C.ISI.EDU)       |   +-----+-----+               |     +------+-----+-----+   |     |     |               |     |      |           |  BRL  NOSC  DARPA             |  IN-ADDR  SRI-NIC     ACC                               |   +--------+------------------+---------------+--------+   |        |                  |               |        |  UCI      MIT                 |              UDEL     YALE            |(XX.LCS.MIT.EDU, ISI            |ACHILLES.MIT.EDU) |(VAXA.ISI.EDU,VENERA.ISI.EDU,        +---+---+              | A.ISI.EDU)        |       |              |       LCS   ACHILLES +--+-----+-----+--------+        |             |  |     |     |        |        XX            A  C   VAXA  VENERA Mockapetris</code></pre></div><p>In this example, the authoritative name server is shown in parentheses<br>at the point in the domain tree at which is assumes control.</p><p>Thus the root name servers are on C.ISI.EDU, SRI-NIC.ARPA, and<br>A.ISI.EDU.  The MIL domain is served by SRI-NIC.ARPA and A.ISI.EDU.  The<br>EDU domain is served by SRI-NIC.ARPA. and C.ISI.EDU.  Note that servers<br>may have zones which are contiguous or disjoint.  In this scenario,<br>C.ISI.EDU has contiguous zones at the root and EDU domains.  A.ISI.EDU<br>has contiguous zones at the root and MIL domains, but also has a non-<br>contiguous zone at ISI.EDU.</p><h2 id="6-1-C-ISI-EDU-name-server"><a href="#6-1-C-ISI-EDU-name-server" class="headerlink" title="6.1. C.ISI.EDU name server"></a>6.1. C.ISI.EDU name server</h2><p>C.ISI.EDU is a name server for the root, MIL, and EDU domains of the IN<br>class, and would have zones for these domains.  The zone data for the<br>root domain might be:</p><div class="code-wrapper"><pre><code class="hljs">.       IN      SOA     SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA. (                        870611          ;serial                        1800            ;refresh every 30 min                        300             ;retry every 5 min                        604800          ;expire after a week                        86400)          ;minimum of a day                NS      A.ISI.EDU.                NS      C.ISI.EDU.                NS      SRI-NIC.ARPA.MIL.    86400   NS      SRI-NIC.ARPA.        86400   NS      A.ISI.EDU.EDU.    86400   NS      SRI-NIC.ARPA.        86400   NS      C.ISI.EDU.SRI-NIC.ARPA.   A       26.0.0.73                A       10.0.0.51                MX      0 SRI-NIC.ARPA.                HINFO   DEC-2060 TOPS20ACC.ARPA.       A       26.6.0.65                HINFO   PDP-11/70 UNIX                MX      10 ACC.ARPA.USC-ISIC.ARPA.  CNAME   C.ISI.EDU.73.0.0.26.IN-ADDR.ARPA.  PTR    SRI-NIC.ARPA.65.0.6.26.IN-ADDR.ARPA.  PTR    ACC.ARPA.51.0.0.10.IN-ADDR.ARPA.  PTR    SRI-NIC.ARPA.52.0.0.10.IN-ADDR.ARPA.  PTR    C.ISI.EDU.103.0.3.26.IN-ADDR.ARPA. PTR    A.ISI.EDU.A.ISI.EDU. 86400 A      26.3.0.103C.ISI.EDU. 86400 A      10.0.0.52</code></pre></div><p>This data is represented as it would be in a master file.  Most RRs are<br>single line entries; the sole exception here is the SOA RR, which uses<br>“(“ to start a multi-line RR and “)” to show the end of a multi-line RR.<br>Since the class of all RRs in a zone must be the same, only the first RR<br>in a zone need specify the class.  When a name server loads a zone, it<br>forces the TTL of all authoritative RRs to be at least the MINIMUM field<br>of the SOA, here 86400 seconds, or one day.  The NS RRs marking<br>delegation of the MIL and EDU domains, together with the glue RRs for<br>the servers host addresses, are not part of the authoritative data in<br>the zone, and hence have explicit TTLs.</p><p>Four RRs are attached to the root node: the SOA which describes the root<br>zone and the 3 NS RRs which list the name servers for the root.  The<br>data in the SOA RR describes the management of the zone.  The zone data<br>is maintained on host SRI-NIC.ARPA, and the responsible party for the<br>zone is <a href="mailto:&#72;&#x4f;&#83;&#x54;&#77;&#65;&#x53;&#84;&#69;&#x52;&#64;&#83;&#x52;&#73;&#45;&#x4e;&#73;&#x43;&#46;&#65;&#x52;&#80;&#x41;">&#72;&#x4f;&#83;&#x54;&#77;&#65;&#x53;&#84;&#69;&#x52;&#64;&#83;&#x52;&#73;&#45;&#x4e;&#73;&#x43;&#46;&#65;&#x52;&#80;&#x41;</a>.  A key item in the SOA is the 86400<br>second minimum TTL, which means that all authoritative data in the zone<br>has at least that TTL, although higher values may be explicitly<br>specified.</p><p>The NS RRs for the MIL and EDU domains mark the boundary between the<br>root zone and the MIL and EDU zones.  Note that in this example, the<br>lower zones happen to be supported by name servers which also support<br>the root zone.</p><p>The master file for the EDU zone might be stated relative to the origin<br>EDU.  The zone data for the EDU domain might be:</p><div class="code-wrapper"><pre><code class="hljs">EDU.  IN SOA SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA. (                        870729 ;serial                        1800 ;refresh every 30 minutes                        300 ;retry every 5 minutes                        604800 ;expire after a week                        86400 ;minimum of a day                        )                NS SRI-NIC.ARPA.                NS C.ISI.EDU.UCI 172800 NS ICS.UCI                172800 NS ROME.UCIICS.UCI 172800 A 192.5.19.1ROME.UCI 172800 A 192.5.19.31ISI 172800 NS VAXA.ISI                172800 NS A.ISI                172800 NS VENERA.ISI.EDU.VAXA.ISI 172800 A 10.2.0.27                172800 A 128.9.0.33VENERA.ISI.EDU. 172800 A 10.1.0.52                172800 A 128.9.0.32A.ISI 172800 A 26.3.0.103UDEL.EDU.  172800 NS LOUIE.UDEL.EDU.                172800 NS UMN-REI-UC.ARPA.LOUIE.UDEL.EDU. 172800 A 10.0.0.96                172800 A 192.5.39.3YALE.EDU.  172800 NS YALE.ARPA.YALE.EDU.  172800 NS YALE-BULLDOG.ARPA.MIT.EDU.  43200 NS XX.LCS.MIT.EDU.                  43200 NS ACHILLES.MIT.EDU.XX.LCS.MIT.EDU.  43200 A 10.0.0.44ACHILLES.MIT.EDU. 43200 A 18.72.0.8</code></pre></div><p>Note the use of relative names here.  The owner name for the ISI.EDU. is<br>stated using a relative name, as are two of the name server RR contents.<br>Relative and absolute domain names may be freely intermixed in a master</p><h2 id="6-2-Example-standard-queries"><a href="#6-2-Example-standard-queries" class="headerlink" title="6.2. Example standard queries"></a>6.2. Example standard queries</h2><p>The following queries and responses illustrate name server behavior.<br>Unless otherwise noted, the queries do not have recursion desired (RD)<br>in the header.  Note that the answers to non-recursive queries do depend<br>on the server being asked, but do not depend on the identity of the<br>requester.</p><h3 id="6-2-1-QNAME-SRI-NIC-ARPA-QTYPE-A"><a href="#6-2-1-QNAME-SRI-NIC-ARPA-QTYPE-A" class="headerlink" title="6.2.1. QNAME=SRI-NIC.ARPA, QTYPE=A"></a>6.2.1. QNAME=SRI-NIC.ARPA, QTYPE=A</h3><p>The query would look like:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY                                     |           +---------------------------------------------------+Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |           +---------------------------------------------------+Answer     | &lt;empty&gt;                                           |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>The response from C.ISI.EDU would be:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA                       |           +---------------------------------------------------+Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |           +---------------------------------------------------+Answer     | SRI-NIC.ARPA. 86400 IN A 26.0.0.73                |           |               86400 IN A 10.0.0.51                |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>The header of the response looks like the header of the query, except<br>that the RESPONSE bit is set, indicating that this message is a<br>response, not a query, and the Authoritative Answer (AA) bit is set<br>indicating that the address RRs in the answer section are from<br>authoritative data.  The question section of the response matches the<br>question section of the query.</p><p>If the same query was sent to some other server which was not<br>authoritative for SRI-NIC.ARPA, the response might be:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY,RESPONSE                            |           +---------------------------------------------------+Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=A           |           +---------------------------------------------------+Answer     | SRI-NIC.ARPA. 1777 IN A 10.0.0.51                 |           |               1777 IN A 26.0.0.73                 |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>This response is different from the previous one in two ways: the header<br>does not have AA set, and the TTLs are different.  The inference is that<br>the data did not come from a zone, but from a cache.  The difference<br>between the authoritative TTL and the TTL here is due to aging of the<br>data in a cache.  The difference in ordering of the RRs in the answer<br>section is not significant.</p><h3 id="6-2-2-QNAME-SRI-NIC-ARPA-QTYPE"><a href="#6-2-2-QNAME-SRI-NIC-ARPA-QTYPE" class="headerlink" title="6.2.2. QNAME=SRI-NIC.ARPA, QTYPE=*"></a>6.2.2. QNAME=SRI-NIC.ARPA, QTYPE=*</h3><p>A query similar to the previous one, but using a QTYPE of *, would<br>receive the following response from C.ISI.EDU:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA                       |           +---------------------------------------------------+Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |           +---------------------------------------------------+Answer     | SRI-NIC.ARPA. 86400 IN  A     26.0.0.73           |           |                         A     10.0.0.51           |           |                         MX    0 SRI-NIC.ARPA.     |           |                         HINFO DEC-2060 TOPS20     |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>If a similar query was directed to two name servers which are not<br>authoritative for SRI-NIC.ARPA, the responses might be:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE                           |           +---------------------------------------------------+Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |           +---------------------------------------------------+Answer     | SRI-NIC.ARPA. 12345 IN     A       26.0.0.73      |           |                            A       10.0.0.51      |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>and</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE                           |           +---------------------------------------------------+Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=*           |           +---------------------------------------------------+Answer     | SRI-NIC.ARPA. 1290 IN HINFO  DEC-2060 TOPS20      |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>Neither of these answers have AA set, so neither response comes from<br>authoritative data.  The different contents and different TTLs suggest<br>that the two servers cached data at different times, and that the first<br>server cached the response to a QTYPE=A query and the second cached the<br>response to a HINFO query.</p><h3 id="6-2-3-QNAME-SRI-NIC-ARPA-QTYPE-MX"><a href="#6-2-3-QNAME-SRI-NIC-ARPA-QTYPE-MX" class="headerlink" title="6.2.3. QNAME=SRI-NIC.ARPA, QTYPE=MX"></a>6.2.3. QNAME=SRI-NIC.ARPA, QTYPE=MX</h3><p>This type of query might be result from a mailer trying to look up<br>routing information for the mail destination <a href="mailto:&#x48;&#x4f;&#83;&#x54;&#77;&#65;&#x53;&#x54;&#69;&#82;&#x40;&#x53;&#x52;&#x49;&#45;&#x4e;&#73;&#x43;&#x2e;&#x41;&#82;&#x50;&#x41;">&#x48;&#x4f;&#83;&#x54;&#77;&#65;&#x53;&#x54;&#69;&#82;&#x40;&#x53;&#x52;&#x49;&#45;&#x4e;&#73;&#x43;&#x2e;&#x41;&#82;&#x50;&#x41;</a>.<br>The response from C.ISI.EDU would be:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA                       |           +---------------------------------------------------+Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=MX          |           +---------------------------------------------------+Answer     | SRI-NIC.ARPA. 86400 IN     MX      0 SRI-NIC.ARPA.|           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | SRI-NIC.ARPA. 86400 IN     A       26.0.0.73      |           |                            A       10.0.0.51      |           +---------------------------------------------------+</code></pre></div><p>This response contains the MX RR in the answer section of the response.<br>The additional section contains the address RRs because the name server<br>at C.ISI.EDU guesses that the requester will need the addresses in order<br>to properly use the information carried by the MX.</p><h3 id="6-2-4-QNAME-SRI-NIC-ARPA-QTYPE-NS"><a href="#6-2-4-QNAME-SRI-NIC-ARPA-QTYPE-NS" class="headerlink" title="6.2.4. QNAME=SRI-NIC.ARPA, QTYPE=NS"></a>6.2.4. QNAME=SRI-NIC.ARPA, QTYPE=NS</h3><p>C.ISI.EDU would reply to this query with:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA                       |           +---------------------------------------------------+Question   | QNAME=SRI-NIC.ARPA., QCLASS=IN, QTYPE=NS          |           +---------------------------------------------------+Answer     | &lt;empty&gt;                                           |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>The only difference between the response and the query is the AA and<br>RESPONSE bits in the header.  The interpretation of this response is<br>that the server is authoritative for the name, and the name exists, but<br>no RRs of type NS are present there.</p><h3 id="6-2-5-QNAME-SIR-NIC-ARPA-QTYPE-A"><a href="#6-2-5-QNAME-SIR-NIC-ARPA-QTYPE-A" class="headerlink" title="6.2.5. QNAME=SIR-NIC.ARPA, QTYPE=A"></a>6.2.5. QNAME=SIR-NIC.ARPA, QTYPE=A</h3><p>If a user mistyped a host name, we might see this type of query.<br>C.ISI.EDU would answer it with:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA, RCODE=NE             |           +---------------------------------------------------+Question   | QNAME=SIR-NIC.ARPA., QCLASS=IN, QTYPE=A           |           +---------------------------------------------------+Answer     | &lt;empty&gt;                                           |           +---------------------------------------------------+Authority  | . SOA SRI-NIC.ARPA. HOSTMASTER.SRI-NIC.ARPA.      |           |       870611 1800 300 604800 86400                |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>This response states that the name does not exist.  This condition is<br>signalled in the response code (RCODE) section of the header.</p><p>The SOA RR in the authority section is the optional negative caching<br>information which allows the resolver using this response to assume that<br>the name will not exist for the SOA MINIMUM (86400) seconds.</p><h3 id="6-2-6-QNAME-BRL-MIL-QTYPE-A"><a href="#6-2-6-QNAME-BRL-MIL-QTYPE-A" class="headerlink" title="6.2.6. QNAME=BRL.MIL, QTYPE=A"></a>6.2.6. QNAME=BRL.MIL, QTYPE=A</h3><p>If this query is sent to C.ISI.EDU, the reply would be:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE                           |           +---------------------------------------------------+Question   | QNAME=BRL.MIL, QCLASS=IN, QTYPE=A                 |           +---------------------------------------------------+Answer     | &lt;empty&gt;                                           |           +---------------------------------------------------+Authority  | MIL.             86400 IN NS       SRI-NIC.ARPA.  |           |                  86400    NS       A.ISI.EDU.     |           +---------------------------------------------------+Additional | A.ISI.EDU.                A        26.3.0.103     |           | SRI-NIC.ARPA.             A        26.0.0.73      |           |                           A        10.0.0.51      |           +---------------------------------------------------+</code></pre></div><p>This response has an empty answer section, but is not authoritative, so<br>it is a referral.  The name server on C.ISI.EDU, realizing that it is<br>not authoritative for the MIL domain, has referred the requester to<br>servers on A.ISI.EDU and SRI-NIC.ARPA, which it knows are authoritative<br>for the MIL domain.</p><h3 id="6-2-7-QNAME-USC-ISIC-ARPA-QTYPE-A"><a href="#6-2-7-QNAME-USC-ISIC-ARPA-QTYPE-A" class="headerlink" title="6.2.7. QNAME=USC-ISIC.ARPA, QTYPE=A"></a>6.2.7. QNAME=USC-ISIC.ARPA, QTYPE=A</h3><p>The response to this query from A.ISI.EDU would be:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA                       |           +---------------------------------------------------+Question   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |           +---------------------------------------------------+Answer     | USC-ISIC.ARPA. 86400 IN CNAME      C.ISI.EDU.     |           | C.ISI.EDU.     86400 IN A          10.0.0.52      |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>Note that the AA bit in the header guarantees that the data matching<br>QNAME is authoritative, but does not say anything about whether the data<br>for C.ISI.EDU is authoritative.  This complete reply is possible because<br>A.ISI.EDU happens to be authoritative for both the ARPA domain where<br>USC-ISIC.ARPA is found and the ISI.EDU domain where C.ISI.EDU data is<br>found.</p><p>If the same query was sent to C.ISI.EDU, its response might be the same<br>as shown above if it had its own address in its cache, but might also<br>be:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA                       |           +---------------------------------------------------+Question   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |           +---------------------------------------------------+Answer     | USC-ISIC.ARPA.   86400 IN CNAME   C.ISI.EDU.      |           +---------------------------------------------------+Authority  | ISI.EDU.        172800 IN NS      VAXA.ISI.EDU.   |           |                           NS      A.ISI.EDU.      |           |                           NS      VENERA.ISI.EDU. |           +---------------------------------------------------+Additional | VAXA.ISI.EDU.   172800    A       10.2.0.27       |           |                 172800    A       128.9.0.33      |           | VENERA.ISI.EDU. 172800    A       10.1.0.52       |           |                 172800    A       128.9.0.32      |           | A.ISI.EDU.      172800    A       26.3.0.103      |           +---------------------------------------------------+</code></pre></div><p>This reply contains an authoritative reply for the alias USC-ISIC.ARPA,<br>plus a referral to the name servers for ISI.EDU.  This sort of reply<br>isn’t very likely given that the query is for the host name of the name<br>server being asked, but would be common for other aliases.</p><h3 id="6-2-8-QNAME-USC-ISIC-ARPA-QTYPE-CNAME"><a href="#6-2-8-QNAME-USC-ISIC-ARPA-QTYPE-CNAME" class="headerlink" title="6.2.8. QNAME=USC-ISIC.ARPA, QTYPE=CNAME"></a>6.2.8. QNAME=USC-ISIC.ARPA, QTYPE=CNAME</h3><p>If this query is sent to either A.ISI.EDU or C.ISI.EDU, the reply would<br>be:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA                       |           +---------------------------------------------------+Question   | QNAME=USC-ISIC.ARPA., QCLASS=IN, QTYPE=A          |           +---------------------------------------------------+Answer     | USC-ISIC.ARPA. 86400 IN CNAME      C.ISI.EDU.     |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>Because QTYPE=CNAME, the CNAME RR itself answers the query, and the name<br>server doesn’t attempt to look up anything for C.ISI.EDU.  (Except<br>possibly for the additional section.)</p><h2 id="6-3-Example-resolution"><a href="#6-3-Example-resolution" class="headerlink" title="6.3. Example resolution"></a>6.3. Example resolution</h2><p>The following examples illustrate the operations a resolver must perform<br>for its client.  We assume that the resolver is starting without a<br>cache, as might be the case after system boot.  We further assume that<br>the system is not one of the hosts in the data and that the host is<br>located somewhere on net 26, and that its safety belt (SBELT) data<br>structure has the following information:</p><div class="code-wrapper"><pre><code class="hljs">Match count = -1SRI-NIC.ARPA.   26.0.0.73       10.0.0.51A.ISI.EDU.      26.3.0.103</code></pre></div><p>This information specifies servers to try, their addresses, and a match<br>count of -1, which says that the servers aren’t very close to the<br>target.  Note that the -1 isn’t supposed to be an accurate closeness<br>measure, just a value so that later stages of the algorithm will work.</p><p>The following examples illustrate the use of a cache, so each example<br>assumes that previous requests have completed.</p><h3 id="6-3-1-Resolve-MX-for-ISI-EDU"><a href="#6-3-1-Resolve-MX-for-ISI-EDU" class="headerlink" title="6.3.1. Resolve MX for ISI.EDU."></a>6.3.1. Resolve MX for ISI.EDU.</h3><p>Suppose the first request to the resolver comes from the local mailer,<br>which has mail for <a href="mailto:&#x50;&#x56;&#77;&#x40;&#73;&#83;&#73;&#46;&#x45;&#68;&#85;">&#x50;&#x56;&#77;&#x40;&#73;&#83;&#73;&#46;&#x45;&#68;&#85;</a>.  The mailer might then ask for type MX<br>RRs for the domain name ISI.EDU.</p><p>The resolver would look in its cache for MX RRs at ISI.EDU, but the<br>empty cache wouldn’t be helpful.  The resolver would recognize that it<br>needed to query foreign servers and try to determine the best servers to<br>query.  This search would look for NS RRs for the domains ISI.EDU, EDU,<br>and the root.  These searches of the cache would also fail.  As a last<br>resort, the resolver would use the information from the SBELT, copying<br>it into its SLIST structure.</p><p>At this point the resolver would need to pick one of the three available<br>addresses to try.  Given that the resolver is on net 26, it should<br>choose either 26.0.0.73 or 26.3.0.103 as its first choice.  It would<br>then send off a query of the form:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY                                     |           +---------------------------------------------------+Question   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |           +---------------------------------------------------+Answer     | &lt;empty&gt;                                           |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | &lt;empty&gt;                                           |           +---------------------------------------------------+</code></pre></div><p>The resolver would then wait for a response to its query or a timeout.<br>If the timeout occurs, it would try different servers, then different<br>addresses of the same servers, lastly retrying addresses already tried.<br>It might eventually receive a reply from SRI-NIC.ARPA:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE                           |           +---------------------------------------------------+Question   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |           +---------------------------------------------------+Answer     | &lt;empty&gt;                                           |           +---------------------------------------------------+Authority  | ISI.EDU.        172800 IN NS       VAXA.ISI.EDU.  |           |                           NS       A.ISI.EDU.     |           |                           NS       VENERA.ISI.EDU.|           +---------------------------------------------------+Additional | VAXA.ISI.EDU.   172800    A        10.2.0.27      |           |                 172800    A        128.9.0.33     |           | VENERA.ISI.EDU. 172800    A        10.1.0.52      |           |                 172800    A        128.9.0.32     |           | A.ISI.EDU.      172800    A        26.3.0.103     |           +---------------------------------------------------+</code></pre></div><p>The resolver would notice that the information in the response gave a<br>closer delegation to ISI.EDU than its existing SLIST (since it matches<br>three labels).  The resolver would then cache the information in this<br>response and use it to set up a new SLIST:</p><div class="code-wrapper"><pre><code class="hljs">Match count = 3A.ISI.EDU.      26.3.0.103VAXA.ISI.EDU.   10.2.0.27       128.9.0.33VENERA.ISI.EDU. 10.1.0.52       128.9.0.32</code></pre></div><p>A.ISI.EDU appears on this list as well as the previous one, but that is<br>purely coincidental.  The resolver would again start transmitting and<br>waiting for responses.  Eventually it would get an answer:</p><div class="code-wrapper"><pre><code class="hljs">           +---------------------------------------------------+Header     | OPCODE=SQUERY, RESPONSE, AA                       |           +---------------------------------------------------+Question   | QNAME=ISI.EDU., QCLASS=IN, QTYPE=MX               |           +---------------------------------------------------+Answer     | ISI.EDU.                MX 10 VENERA.ISI.EDU.     |           |                         MX 20 VAXA.ISI.EDU.       |           +---------------------------------------------------+Authority  | &lt;empty&gt;                                           |           +---------------------------------------------------+Additional | VAXA.ISI.EDU.   172800  A  10.2.0.27              |           |                 172800  A  128.9.0.33             |           | VENERA.ISI.EDU. 172800  A  10.1.0.52              |           |                 172800  A  128.9.0.32             |           +---------------------------------------------------+</code></pre></div><p>The resolver would add this information to its cache, and return the MX<br>RRs to its client.</p><h3 id="6-3-2-Get-the-host-name-for-address-26-6-0-65"><a href="#6-3-2-Get-the-host-name-for-address-26-6-0-65" class="headerlink" title="6.3.2. Get the host name for address 26.6.0.65"></a>6.3.2. Get the host name for address 26.6.0.65</h3><p>The resolver would translate this into a request for PTR RRs for<br>65.0.6.26.IN-ADDR.ARPA.  This information is not in the cache, so the<br>resolver would look for foreign servers to ask.  No servers would match,<br>so it would use SBELT again.  (Note that the servers for the ISI.EDU<br>domain are in the cache, but ISI.EDU is not an ancestor of<br>65.0.6.26.IN-ADDR.ARPA, so the SBELT is used.)</p><p>Since this request is within the authoritative data of both servers in<br>SBELT, eventually one would return:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">           +---------------------------------------------------+<br>Header     |<span class="hljs-string"> OPCODE=SQUERY, RESPONSE, AA                       </span>|<br>           +---------------------------------------------------+<br>Question   |<span class="hljs-string"> QNAME=65.0.6.26.IN-ADDR.ARPA.,QCLASS=IN,QTYPE=PTR </span>|<br>           +---------------------------------------------------+<br>Answer     |<span class="hljs-string"> 65.0.6.26.IN-ADDR.ARPA.    PTR     ACC.ARPA.      </span>|<br>           +---------------------------------------------------+<br>Authority  |<span class="hljs-string"> &lt;empty&gt;                                           </span>|<br>           +---------------------------------------------------+<br>Additional |<span class="hljs-string"> &lt;empty&gt;                                           </span>|<br>           +---------------------------------------------------+<br></code></pre></td></tr></table></figure><h3 id="6-3-3-Get-the-host-address-of-poneria-ISI-EDU"><a href="#6-3-3-Get-the-host-address-of-poneria-ISI-EDU" class="headerlink" title="6.3.3. Get the host address of poneria.ISI.EDU"></a>6.3.3. Get the host address of poneria.ISI.EDU</h3><p>This request would translate into a type A request for poneria.ISI.EDU.<br>The resolver would not find any cached data for this name, but would<br>find the NS RRs in the cache for ISI.EDU when it looks for foreign<br>servers to ask.  Using this data, it would construct a SLIST of the<br>form:</p><div class="code-wrapper"><pre><code class="hljs">Match count = 3A.ISI.EDU.      26.3.0.103VAXA.ISI.EDU.   10.2.0.27       128.9.0.33VENERA.ISI.EDU. 10.1.0.52</code></pre></div><p>A.ISI.EDU is listed first on the assumption that the resolver orders its<br>choices by preference, and A.ISI.EDU is on the same network.</p><p>One of these servers would answer the query.</p><h1 id="7-REFERENCES-and-BIBLIOGRAPHY"><a href="#7-REFERENCES-and-BIBLIOGRAPHY" class="headerlink" title="7. REFERENCES and BIBLIOGRAPHY"></a>7. REFERENCES and BIBLIOGRAPHY</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[Dyer <span class="hljs-number">87</span>]       Dyer, S., <span class="hljs-keyword">and</span> F. Hsu, &quot;Hesiod&quot;, Project Athena<br>                Technical Plan - <span class="hljs-type">Name</span> Service, April <span class="hljs-number">1987</span>, <span class="hljs-keyword">version</span> <span class="hljs-number">1.9</span>.<br><br>                Describes the fundamentals <span class="hljs-keyword">of</span> the Hesiod <span class="hljs-type">name</span> service.<br><br>[IEN<span class="hljs-number">-116</span>]       J. Postel, &quot;Internet Name Server&quot;, IEN<span class="hljs-number">-116</span>,<br>                USC/Information Sciences Institute, August <span class="hljs-number">1979.</span><br><br>                A <span class="hljs-type">name</span> service obsoleted <span class="hljs-keyword">by</span> the <span class="hljs-keyword">Domain</span> <span class="hljs-type">Name</span> <span class="hljs-keyword">System</span>, but<br>                still <span class="hljs-keyword">in</span> use.<br><br>[Quarterman <span class="hljs-number">86</span>] Quarterman, J., <span class="hljs-keyword">and</span> J. Hoskins, &quot;Notable Computer<br>                Networks&quot;,Communications <span class="hljs-keyword">of</span> the ACM, October <span class="hljs-number">1986</span>,<br>                volume <span class="hljs-number">29</span>, number <span class="hljs-number">10.</span><br><br>[RFC<span class="hljs-number">-742</span>]       K. Harrenstien, &quot;NAME/FINGER&quot;, RFC<span class="hljs-number">-742</span>, Network<br>                Information Center, SRI International, December <span class="hljs-number">1977.</span><br><br>[RFC<span class="hljs-number">-768</span>]       J. Postel, &quot;User Datagram Protocol&quot;, RFC<span class="hljs-number">-768</span>,<br>                USC/Information Sciences Institute, August <span class="hljs-number">1980.</span><br><br>[RFC<span class="hljs-number">-793</span>]       J. Postel, &quot;Transmission Control Protocol&quot;, RFC<span class="hljs-number">-793</span>,<br>                USC/Information Sciences Institute, September <span class="hljs-number">1981.</span><br><br>[RFC<span class="hljs-number">-799</span>]       D. Mills, &quot;Internet Name Domains&quot;, RFC<span class="hljs-number">-799</span>, COMSAT,<br>                September <span class="hljs-number">1981.</span><br><br>                Suggests introduction <span class="hljs-keyword">of</span> a hierarchy <span class="hljs-keyword">in</span> place <span class="hljs-keyword">of</span> a flat<br>                <span class="hljs-type">name</span> space <span class="hljs-keyword">for</span> the Internet.<br><br>[RFC<span class="hljs-number">-805</span>]       J. Postel, &quot;Computer Mail Meeting Notes&quot;, RFC<span class="hljs-number">-805</span>,<br>                USC/Information Sciences Institute, February <span class="hljs-number">1982.</span><br><br>[RFC<span class="hljs-number">-810</span>]       E. Feinler, K. Harrenstien, Z. Su, <span class="hljs-keyword">and</span> V. White, &quot;DOD<br>                Internet Host Table Specification&quot;, RFC<span class="hljs-number">-810</span>, Network<br>                Information Center, SRI International, March <span class="hljs-number">1982.</span><br><br>                Obsolete.  See RFC<span class="hljs-number">-952.</span><br><br>[RFC<span class="hljs-number">-811</span>]       K. Harrenstien, V. White, <span class="hljs-keyword">and</span> E. Feinler, &quot;Hostnames<br>                Server&quot;, RFC<span class="hljs-number">-811</span>, Network Information Center, SRI<br>                International, March <span class="hljs-number">1982.</span><br><br>                Obsolete.  See RFC<span class="hljs-number">-953.</span><br><br>[RFC<span class="hljs-number">-812</span>]       K. Harrenstien, <span class="hljs-keyword">and</span> V. White, &quot;NICNAME/WHOIS&quot;, RFC<span class="hljs-number">-812</span>,<br>                Network Information Center, SRI International, March<br>                <span class="hljs-number">1982.</span><br><br>[RFC<span class="hljs-number">-819</span>]       Z. Su, <span class="hljs-keyword">and</span> J. Postel, &quot;The Domain Naming Convention for<br>                Internet User Applications&quot;, RFC<span class="hljs-number">-819</span>, Network<br>                Information Center, SRI International, August <span class="hljs-number">1982.</span><br><br>                Early thoughts <span class="hljs-keyword">on</span> the design <span class="hljs-keyword">of</span> the <span class="hljs-keyword">domain</span> <span class="hljs-keyword">system</span>.<br>                <span class="hljs-keyword">Current</span> implementation <span class="hljs-keyword">is</span> completely different.<br><br>[RFC<span class="hljs-number">-821</span>]       J. Postel, &quot;Simple Mail Transfer Protocol&quot;, RFC<span class="hljs-number">-821</span>,<br>                USC/Information Sciences Institute, August <span class="hljs-number">1980.</span><br><br>[RFC<span class="hljs-number">-830</span>]       Z. Su, &quot;A Distributed System for Internet Name Service&quot;,<br>                RFC<span class="hljs-number">-830</span>, Network Information Center, SRI International,<br>                October <span class="hljs-number">1982.</span><br><br>                Early thoughts <span class="hljs-keyword">on</span> the design <span class="hljs-keyword">of</span> the <span class="hljs-keyword">domain</span> <span class="hljs-keyword">system</span>.<br>                <span class="hljs-keyword">Current</span> implementation <span class="hljs-keyword">is</span> completely different.<br><br>[RFC<span class="hljs-number">-882</span>]       P. Mockapetris, &quot;Domain names - Concepts and<br>                Facilities,&quot; RFC<span class="hljs-number">-882</span>, USC/Information Sciences<br>                Institute, November <span class="hljs-number">1983.</span><br><br>                Superceeded <span class="hljs-keyword">by</span> this memo.<br><br>[RFC<span class="hljs-number">-883</span>]       P. Mockapetris, &quot;Domain names - Implementation and<br>                Specification,&quot; RFC<span class="hljs-number">-883</span>, USC/Information Sciences<br>                Institute, November <span class="hljs-number">1983.</span><br><br>                Superceeded <span class="hljs-keyword">by</span> this memo.<br><br>[RFC<span class="hljs-number">-920</span>]       J. Postel <span class="hljs-keyword">and</span> J. Reynolds, &quot;Domain Requirements&quot;,<br>                RFC<span class="hljs-number">-920</span>, USC/Information Sciences Institute<br>                October <span class="hljs-number">1984.</span><br><br>                Explains the naming scheme <span class="hljs-keyword">for</span> top <span class="hljs-keyword">level</span> domains.<br><br>[RFC<span class="hljs-number">-952</span>]       K. Harrenstien, M. Stahl, E. Feinler, &quot;DoD Internet Host<br>                Table Specification&quot;, RFC<span class="hljs-number">-952</span>, SRI, October <span class="hljs-number">1985.</span><br><br>                Specifies the <span class="hljs-keyword">format</span> <span class="hljs-keyword">of</span> HOSTS.TXT, the host/address<br>                <span class="hljs-keyword">table</span> replaced <span class="hljs-keyword">by</span> the DNS.<br><br>[RFC<span class="hljs-number">-953</span>]       K. Harrenstien, M. Stahl, E. Feinler, &quot;HOSTNAME Server&quot;,<br>                RFC<span class="hljs-number">-953</span>, SRI, October <span class="hljs-number">1985.</span><br><br>                This RFC contains the official specification <span class="hljs-keyword">of</span> the<br>                hostname <span class="hljs-keyword">server</span> protocol, which <span class="hljs-keyword">is</span> obsoleted <span class="hljs-keyword">by</span> the DNS.<br>                This TCP based protocol accesses information stored <span class="hljs-keyword">in</span><br>                the RFC<span class="hljs-number">-952</span> <span class="hljs-keyword">format</span>, <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> obtain copies <span class="hljs-keyword">of</span> the<br>                host <span class="hljs-keyword">table</span>.<br><br>[RFC<span class="hljs-number">-973</span>]       P. Mockapetris, &quot;Domain System Changes and<br>                Observations&quot;, RFC<span class="hljs-number">-973</span>, USC/Information Sciences<br>                Institute, January <span class="hljs-number">1986.</span><br><br>                Describes changes <span class="hljs-keyword">to</span> RFC<span class="hljs-number">-882</span> <span class="hljs-keyword">and</span> RFC<span class="hljs-number">-883</span> <span class="hljs-keyword">and</span> reasons <span class="hljs-keyword">for</span><br>                them.  Now obsolete.<br><br>[RFC<span class="hljs-number">-974</span>]       C. Partridge, &quot;Mail routing and the domain system&quot;,<br>                RFC<span class="hljs-number">-974</span>, CSNET CIC BBN Labs, January <span class="hljs-number">1986.</span><br><br>                Describes the transition <span class="hljs-keyword">from</span> HOSTS.TXT based mail<br>                addressing <span class="hljs-keyword">to</span> the more powerful MX <span class="hljs-keyword">system</span> used <span class="hljs-keyword">with</span> the<br>                <span class="hljs-keyword">domain</span> <span class="hljs-keyword">system</span>.<br><br>[RFC<span class="hljs-number">-1001</span>]      NetBIOS Working <span class="hljs-keyword">Group</span>, &quot;Protocol standard for a NetBIOS<br>                service on a TCP/UDP transport: Concepts and Methods&quot;,<br>                RFC<span class="hljs-number">-1001</span>, March <span class="hljs-number">1987.</span><br><br>                This RFC <span class="hljs-keyword">and</span> RFC<span class="hljs-number">-1002</span> are a preliminary design <span class="hljs-keyword">for</span><br>                NETBIOS <span class="hljs-keyword">on</span> top <span class="hljs-keyword">of</span> TCP/IP which proposes <span class="hljs-keyword">to</span> base NetBIOS<br>                <span class="hljs-type">name</span> service <span class="hljs-keyword">on</span> top <span class="hljs-keyword">of</span> the DNS.<br><br>[RFC<span class="hljs-number">-1002</span>]      NetBIOS Working <span class="hljs-keyword">Group</span>, &quot;Protocol standard for a NetBIOS<br>                service on a TCP/UDP transport: Detailed<br>                Specifications&quot;, RFC<span class="hljs-number">-1002</span>, March <span class="hljs-number">1987.</span><br><br>[RFC<span class="hljs-number">-1010</span>]      J. Reynolds <span class="hljs-keyword">and</span> J. Postel, &quot;Assigned Numbers&quot;, RFC<span class="hljs-number">-1010</span>,<br>                USC/Information Sciences Institute, May <span class="hljs-number">1987</span><br><br>                Contains socket numbers <span class="hljs-keyword">and</span> mnemonics <span class="hljs-keyword">for</span> host names,<br>                operating systems, etc.<br><br>[RFC<span class="hljs-number">-1031</span>]      W. Lazear, &quot;MILNET Name Domain Transition&quot;, RFC<span class="hljs-number">-1031</span>,<br>                November <span class="hljs-number">1987.</span><br><br>                Describes a plan <span class="hljs-keyword">for</span> converting the MILNET <span class="hljs-keyword">to</span> the DNS.<br><br>[RFC<span class="hljs-number">-1032</span>]      M. K. Stahl, &quot;Establishing a Domain - Guidelines for<br>                Administrators&quot;, RFC<span class="hljs-number">-1032</span>, November <span class="hljs-number">1987.</span><br><br>                Describes the registration policies used <span class="hljs-keyword">by</span> the NIC <span class="hljs-keyword">to</span><br>                administer the top <span class="hljs-keyword">level</span> domains <span class="hljs-keyword">and</span> delegate subzones.<br><br>[RFC<span class="hljs-number">-1033</span>]      M. K. Lottor, &quot;Domain Administrators Operations Guide&quot;,<br>                RFC<span class="hljs-number">-1033</span>, November <span class="hljs-number">1987.</span><br><br>                A cookbook <span class="hljs-keyword">for</span> <span class="hljs-keyword">domain</span> administrators.<br><br>[Solomon <span class="hljs-number">82</span>]    M. Solomon, L. Landweber, <span class="hljs-keyword">and</span> D. Neuhengen, &quot;The CSNET<br>                Name Server&quot;, Computer Networks, vol <span class="hljs-number">6</span>, nr <span class="hljs-number">3</span>, July <span class="hljs-number">1982.</span><br><br>                Describes a <span class="hljs-type">name</span> service <span class="hljs-keyword">for</span> CSNET which <span class="hljs-keyword">is</span> independent<br>                <span class="hljs-keyword">from</span> the DNS <span class="hljs-keyword">and</span> DNS use <span class="hljs-keyword">in</span> the CSNET.<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/23-rfc7871/"/>
    <url>/2023/08/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/23-rfc7871/</url>
    
    <content type="html"><![CDATA[<p>Internet Engineering Task Force (IETF)                     C. Contavalli<br>Request for Comments: 7871                              W. van der Gaast<br>Category: Informational                                           Google<br>ISSN: 2070-1721                                              D. Lawrence<br>                                                     Akamai Technologies<br>                                                               W. Kumari<br>                                                                  Google<br>                                                                May 2016</p><div class="code-wrapper"><pre><code class="hljs">                  Client Subnet in DNS Queries</code></pre></div><p>Abstract</p><p>   This document describes an Extension Mechanisms for DNS (EDNS0)<br>   option that is in active use to carry information about the network<br>   that originated a DNS query and the network for which the subsequent<br>   response can be cached.  Since it has some known operational and<br>   privacy shortcomings, a revision will be worked through the IETF for<br>   improvement.</p><p>Status of This Memo</p><p>   This document is not an Internet Standards Track specification; it is<br>   published for informational purposes.</p><p>   This document is a product of the Internet Engineering Task Force<br>   (IETF).  It represents the consensus of the IETF community.  It has<br>   received public review and has been approved for publication by the<br>   Internet Engineering Steering Group (IESG).  Not all documents<br>   approved by the IESG are a candidate for any level of Internet<br>   Standard; see Section 2 of RFC 5741.</p><p>   Information about the current status of this document, any errata,<br>   and how to provide feedback on it may be obtained at<br>   <a href="http://www.rfc-editor.org/info/rfc7871">http://www.rfc-editor.org/info/rfc7871</a>.</p><p>Contavalli, et al.            Informational                     [Page 1]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>Copyright Notice</p><p>   Copyright (c) 2016 IETF Trust and the persons identified as the<br>   document authors.  All rights reserved.</p><p>   This document is subject to BCP 78 and the IETF Trust’s Legal<br>   Provisions Relating to IETF Documents<br>   (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of<br>   publication of this document.  Please review these documents<br>   carefully, as they describe your rights and restrictions with respect<br>   to this document.  Code Components extracted from this document must<br>   include Simplified BSD License text as described in Section 4.e of<br>   the Trust Legal Provisions and are provided without warranty as<br>   described in the Simplified BSD License.</p><p>Contavalli, et al.            Informational                     [Page 2]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>Table of Contents</p><ol><li>Introduction …………………………………………….4</li><li>Privacy Note …………………………………………….5</li><li>Requirements Notation …………………………………….5</li><li>Terminology ……………………………………………..6</li><li>Overview ………………………………………………..7</li><li>Option Format ……………………………………………8</li><li>Protocol Description ……………………………………..9<br>7.1. Originating the Option ……………………………….9<div class="code-wrapper"><pre><code class="hljs"> 7.1.1. Recursive Resolvers .................................9 7.1.2. Stub Resolvers .....................................10 7.1.3. Forwarding Resolvers ...............................11</code></pre></div>7.2. Generating a Response ……………………………….11<div class="code-wrapper"><pre><code class="hljs"> 7.2.1. Authoritative Nameserver ...........................11 7.2.2. Intermediate Nameserver ............................13</code></pre></div>7.3. Handling ECS Responses and Caching ……………………14<div class="code-wrapper"><pre><code class="hljs"> 7.3.1. Caching the Response ...............................15 7.3.2. Answering from Cache ...............................16</code></pre></div>7.4. Delegations and Negative Answers ……………………..17<br>7.5. Transitivity ……………………………………….18</li><li>IANA Considerations ……………………………………..18</li><li>DNSSEC Considerations ……………………………………19</li><li>NAT Considerations ……………………………………..19</li><li>Security Considerations …………………………………20      11.1. Privacy …………………………………………..20      11.2. Birthday Attacks …………………………………..21      11.3. Cache Pollution ……………………………………22</li><li>Sending the Option ……………………………………..23      12.1. Probing …………………………………………..23      12.2. Whitelist …………………………………………24</li><li>Example ……………………………………………….24</li><li>References …………………………………………….26      14.1. Normative References ……………………………….26      14.2. Informative References ……………………………..27<br>Acknowledgements …………………………………………..28<br>Contributors ………………………………………………29<br>Authors’ Addresses …………………………………………30</li></ol><p>Contavalli, et al.            Informational                     [Page 3]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><ol><li> Introduction</li></ol><p>   Many Authoritative Nameservers today return different responses based<br>   on the perceived topological location of the user.  These servers use<br>   the IP address of the incoming query to identify that location.</p><p>   Since most queries come from Intermediate Recursive Resolvers, the<br>   source address is that of the Recursive Resolver rather than of the<br>   query originator.</p><p>   Traditionally, and probably still in the majority of instances,<br>   Recursive Resolvers are reasonably close in the topological sense to<br>   the Stub Resolvers or Forwarding Resolvers that are the source of<br>   queries.  For these resolvers, using their own IP address is<br>   sufficient for Authoritative Nameservers that tailor responses based<br>   upon location of the querier.</p><p>   Increasingly, though, a class of Recursive Resolvers has arisen that<br>   handles query sources that are often not topologically close.  The<br>   motivation for having such Centralized Resolvers varies but is<br>   usually because of some enhanced experience, such as greater cache<br>   security or applying policies regarding where users may connect.<br>   (Although political censorship usually comes to mind here, the same<br>   actions may be used by a parent when setting controls on where a<br>   minor may connect.)  Similarly, many ISPs and other organizations use<br>   a Centralized Resolver infrastructure that can be distant from the<br>   clients the resolvers serve.  These cases all lead to less than<br>   desirable responses from topology-sensitive Authoritative<br>   Nameservers.</p><p>   This document defines an EDNS0 [RFC6891] option to convey network<br>   information that is relevant to the DNS message.  It will carry<br>   sufficient network information about the originator for the<br>   Authoritative Nameserver to tailor responses.  It will also provide<br>   for the Authoritative Nameserver to indicate the scope of network<br>   addresses for which the tailored answer is intended.  This EDNS0<br>   option is intended for those Recursive Resolvers and Authoritative<br>   Nameservers that would benefit from the extension and not for general<br>   purpose deployment.  This is completely optional and can safely be<br>   ignored by servers that choose not to implement or enable it.</p><p>   This document also includes guidelines on how best to cache those<br>   results, and it provides recommendations on when this protocol<br>   extension should be used.</p><p>   At least a dozen different client and server implementations have<br>   been written based on earlier draft versions of this specification.<br>   The protocol is in active production use today.  While the</p><p>Contavalli, et al.            Informational                     [Page 4]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   implementations interoperate, there is varying behavior around edge<br>   cases that were poorly specified.  Known incompatibilities are<br>   described in this document, and the authors believe that it is better<br>   to describe the system as it is working today, even if not everyone<br>   agrees with the details of the original specification<br>   ([VANDERGAAST]).  The alternative is an undocumented and proprietary<br>   system.</p><p>   A revised proposal to improve upon the minor flaws in this protocol<br>   will be forthcoming to the IETF.</p><ol start="2"><li> Privacy Note</li></ol><p>   If we were just beginning to design this mechanism, and not<br>   documenting existing protocol, it is unlikely that we would have done<br>   things exactly this way.</p><p>   The IETF is actively working on enhancing DNS privacy<br>   [DPRIVE_Working_Group] and the reinjection of metadata [METADATA] has<br>   been identified as a problematic design pattern.</p><p>   As noted above however, this document primarily describes existing<br>   behavior of a deployed method to further the understanding of the<br>   Internet community.</p><p>   We recommend that the feature be turned off by default in all<br>   nameserver software, and that operators only enable it explicitly in<br>   those circumstances where it provides a clear benefit for their<br>   clients.  We also encourage the deployment of means to allow users to<br>   make use of the opt-out provided.  Finally, we recommend that others<br>   avoid techniques that may introduce additional metadata in future<br>   work, as it may damage user trust.</p><p>   Regrettably, support for the opt-out provisions of this specification<br>   are currently limited.  Only one stub resolver, getdns, is known to<br>   be able to originate queries with anonymity requested, and as yet no<br>   applications are known to be able to indicate that user preference to<br>   the stub resolver.</p><ol start="3"><li> Requirements Notation</li></ol><p>   The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,<br>   “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this<br>   document are to be interpreted as described in [RFC2119].</p><p>Contavalli, et al.            Informational                     [Page 5]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><ol start="4"><li> Terminology</li></ol><p>   ECS:  EDNS Client Subnet.</p><p>   Client:  A Stub Resolver, Forwarding Resolver, or Recursive Resolver.<br>      A client to a Recursive Resolver or a Forwarding Resolver.</p><p>   Server:  A Forwarding Resolver, Recursive Resolver, or Authoritative<br>      Nameserver.</p><p>   Stub Resolver:  A simple DNS protocol implementation on the client<br>      side as described in [RFC1034], Section 5.3.1.  A client to a<br>      Recursive Resolver or a Forwarding Resolver.</p><p>   Authoritative Nameserver:  A nameserver that has authority over one<br>      or more DNS zones.  These are normally not contacted by Stub<br>      Resolver or end user clients directly but by Recursive Resolvers.<br>      Described in [RFC1035], Section 6.</p><p>   Recursive Resolver:  A nameserver that is responsible for resolving<br>      domain names for clients by following the domain’s delegation<br>      chain.  Recursive Resolvers frequently use caches to be able to<br>      respond to client queries quickly.  Described in [RFC1035],<br>      Section 7.</p><p>   Forwarding Resolver:  A nameserver that does not do iterative<br>      resolution itself, but instead passes that responsibility to<br>      another Recursive Resolver, called a “Forwarder” in [RFC2308],<br>      Section 1.</p><p>   Intermediate Nameserver:  Any nameserver in between the Stub Resolver<br>      and the Authoritative Nameserver, such as a Recursive Resolver or<br>      a Forwarding Resolver.</p><p>   Centralized Resolvers:  Intermediate Nameservers that serve a<br>      topologically diverse network address space.</p><p>   Tailored Response:  A response from a nameserver that is customized<br>      for the node that sent the query, often based on performance<br>      (i.e., lowest latency, least number of hops, topological distance,<br>      etc.).</p><p>   Topologically Close:  Refers to two hosts being close in terms of the<br>      number of hops or the time it takes for a packet to travel from<br>      one host to the other.  The concept of topological distance is<br>      only loosely related to the concept of geographical distance: two</p><p>Contavalli, et al.            Informational                     [Page 6]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><div class="code-wrapper"><pre><code class="hljs">  geographically close hosts can still be very distant from a  topological perspective, and two geographically distant hosts can  be quite close on the network.</code></pre></div><p>   For a more comprehensive treatment of DNS terms, please see<br>   [RFC7719].</p><ol start="5"><li> Overview</li></ol><p>   The general idea of this document is to provide an EDNS0 option to<br>   allow Recursive Resolvers, if they are willing, to forward details<br>   about the origin network from which a query is coming when talking to<br>   other nameservers.</p><p>   The format of the edns-client-subnet (ECS) EDNS0 option is described<br>   in Section 6 and is meant to be added in queries sent by Intermediate<br>   Nameservers in a way that is transparent to Stub Resolvers and end<br>   users, as described in Section 7.1.  ECS is only defined for the<br>   Internet (IN) DNS class.</p><p>   As described in Section 7.2, an Authoritative Nameserver could use<br>   ECS as a hint to the end user’s network location and provide a better<br>   answer.  Its response would also contain an ECS option, clearly<br>   indicating that the server made use of this information, and that the<br>   answer is tied to the client’s network.</p><p>   As described in Section 7.3, Intermediate Nameservers would use this<br>   information to cache the response.</p><p>   Some Intermediate Nameservers may also have to be able to forward ECS<br>   queries they receive, as described in Section 7.5.</p><p>   The mechanisms provided by ECS raise various security-related<br>   concerns related to cache growth, the ability to spoof EDNS0 options,<br>   and privacy.  Section 11 explores various mitigation techniques.</p><p>   The expectation, however, is that this option will primarily be used<br>   between Recursive Resolvers and Authoritative Nameservers that are<br>   sensitive to network location issues.  Most Recursive Resolvers,<br>   Authoritative Nameservers, and Stub Resolvers will never need to know<br>   about this option and will continue working as they had been.</p><p>   Failure to support this option or its improper handling will, at<br>   worst, cause suboptimal identification of client network location,<br>   which is a common occurrence in current Content Delivery Network<br>   (CDN) setups.</p><p>Contavalli, et al.            Informational                     [Page 7]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   Section 7.1 also provides a mechanism for Stub Resolvers to signal<br>   Recursive Resolvers that they do not want ECS treatment for specific<br>   queries.</p><p>   Additionally, operators of Intermediate Nameservers with ECS enabled<br>   are allowed to choose how many bits of the address of received<br>   queries to forward or to reduce the number of bits forwarded for<br>   queries already including an ECS option.</p><ol start="6"><li> Option Format</li></ol><p>   This protocol uses an EDNS0 [RFC6891] option to include client<br>   address information in DNS messages.  The option is structured as<br>   follows:</p><div class="code-wrapper"><pre><code class="hljs">            +0 (MSB)                            +1 (LSB)  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</code></pre></div><p>   0: |                          OPTION-CODE                          |<br>      +—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+<br>   2: |                         OPTION-LENGTH                         |<br>      +—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+<br>   4: |                            FAMILY                             |<br>      +—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+<br>   6: |     SOURCE PREFIX-LENGTH      |     SCOPE PREFIX-LENGTH       |<br>      +—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+<br>   8: |                           ADDRESS…                          /<br>      +—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+—+</p><p>   o  (Defined in [RFC6891]) OPTION-CODE, 2 octets, for ECS is 8 (0x00<br>      0x08).</p><p>   o  (Defined in [RFC6891]) OPTION-LENGTH, 2 octets, contains the<br>      length of the payload (everything after OPTION-LENGTH) in octets.</p><p>   o  FAMILY, 2 octets, indicates the family of the address contained in<br>      the option, using address family codes as assigned by IANA in<br>      Address Family Numbers [Address_Family_Numbers].</p><p>   The format of the address part depends on the value of FAMILY.  This<br>   document only defines the format for FAMILY 1 (IPv4) and FAMILY 2<br>   (IPv6), which are as follows:</p><p>   o  SOURCE PREFIX-LENGTH, an unsigned octet representing the leftmost<br>      number of significant bits of ADDRESS to be used for the lookup.<br>      In responses, it mirrors the same value as in the queries.</p><p>Contavalli, et al.            Informational                     [Page 8]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   o  SCOPE PREFIX-LENGTH, an unsigned octet representing the leftmost<br>      number of significant bits of ADDRESS that the response covers.<br>      In queries, it MUST be set to 0.</p><p>   o  ADDRESS, variable number of octets, contains either an IPv4 or<br>      IPv6 address, depending on FAMILY, which MUST be truncated to the<br>      number of bits indicated by the SOURCE PREFIX-LENGTH field,<br>      padding with 0 bits to pad to the end of the last octet needed.</p><p>   o  A server receiving an ECS option that uses either too few or too<br>      many ADDRESS octets, or that has non-zero ADDRESS bits set beyond<br>      SOURCE PREFIX-LENGTH, SHOULD return FORMERR to reject the packet,<br>      as a signal to the software developer making the request to fix<br>      their implementation.</p><p>   All fields are in network byte order (“big-endian”, per [RFC1700],<br>   Data Notation).</p><ol start="7"><li> Protocol Description</li></ol><p>7.1.  Originating the Option</p><p>   The ECS option should generally be added by Recursive Resolvers when<br>   querying Authoritative Nameservers, as described in Section 12.  The<br>   option can also be initialized by a Stub Resolver or Forwarding<br>   Resolver.</p><p>7.1.1.  Recursive Resolvers</p><p>   The setup of the ECS option in a Recursive Resolver depends on the<br>   client query that triggered the resolution process.</p><p>   In the usual case, where no ECS option was present in the client<br>   query, the Recursive Resolver initializes the option by setting<br>   FAMILY of the client’s address.  It then uses the value of its<br>   maximum cacheable prefix length to set SOURCE PREFIX-LENGTH.  For<br>   privacy reasons, and because the whole IP address is rarely required<br>   to determine a tailored response, this length SHOULD be shorter than<br>   the full address, as described in Section 11.</p><p>   If the triggering query included an ECS option itself, it MUST be<br>   examined for its SOURCE PREFIX-LENGTH.  The Recursive Resolver’s<br>   outgoing query MUST then set SOURCE PREFIX-LENGTH to the shorter of<br>   the incoming query’s SOURCE PREFIX-LENGTH or the server’s maximum<br>   cacheable prefix length.</p><p>Contavalli, et al.            Informational                     [Page 9]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   Finally, in both cases, SCOPE PREFIX-LENGTH is set to 0 and ADDRESS<br>   is then added up to SOURCE PREFIX-LENGTH number of bits, with<br>   trailing 0 bits added, if needed, to fill the final octet.  The total<br>   number of octets used MUST only be enough to cover SOURCE PREFIX-<br>   LENGTH bits, rather than the full width that would normally be used<br>   by addresses in FAMILY.</p><p>   FAMILY and ADDRESS information MAY be used from the ECS option in the<br>   incoming query.  Passing the existing address data is supportive of<br>   the Recursive Resolver being used as the target of a Forwarding<br>   Resolver, but could possibly run into policy problems with regard to<br>   usage agreements between the Recursive Resolver and Authoritative<br>   Nameserver.  See Section 12.2 for more discussion on this point.  If<br>   the Recursive Resolver will not forward FAMILY and ADDRESS data from<br>   the incoming ECS option, it SHOULD return a REFUSED response.</p><p>   Subsequent queries to refresh the data MUST, if unrestricted by an<br>   incoming SOURCE PREFIX-LENGTH, specify the longest SOURCE PREFIX-<br>   LENGTH that the Recursive Resolver is willing to cache, even if a<br>   previous response indicated that a shorter prefix length was<br>   sufficient.</p><p>7.1.2.  Stub Resolvers</p><p>   A Stub Resolver MAY generate DNS queries with an ECS option that sets<br>   SOURCE PREFIX-LENGTH to limit how network information should be<br>   revealed.  An Intermediate Nameserver that receives such a query MUST<br>   NOT make queries that include more bits of client address than in the<br>   originating query.</p><p>   A SOURCE PREFIX-LENGTH value of 0 means that the Recursive Resolver<br>   MUST NOT add the client’s address information to its queries.  The<br>   subsequent Recursive Resolver query to the Authoritative Nameserver<br>   will then either not include an ECS option or MAY optionally include<br>   its own address information, which is what the Authoritative<br>   Nameserver will almost certainly use to generate any Tailored<br>   Response in lieu of an option.  This allows the answer to be handled<br>   by the same caching mechanism as other queries, with an explicit<br>   indicator of the applicable scope.  Subsequent Stub Resolver queries<br>   for /0 can then be answered from this cached response.</p><p>   A Stub Resolver MUST set SCOPE PREFIX-LENGTH to 0.  It MAY include<br>   FAMILY and ADDRESS data, but should be prepared to handle a REFUSED<br>   response if the Intermediate Nameserver that it queries has a policy<br>   that denies forwarding of ADDRESS.  If there is no ADDRESS set, i.e.,<br>   SOURCE PREFIX-LENGTH is set to 0, then FAMILY SHOULD be set to the<br>   transport over which the query is sent.  This is for</p><p>Contavalli, et al.            Informational                    [Page 10]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   interoperability; at least one major authoritative server will ignore<br>   the option if FAMILY is not 1 or 2, even though it is irrelevant if<br>   there are no ADDRESS bits.</p><p>7.1.3.  Forwarding Resolvers</p><p>   Forwarding Resolvers essentially appear to be Stub Resolvers to<br>   whatever Recursive Resolver is ultimately handling the query, but<br>   they look like a Recursive Resolver to their client.  A Forwarding<br>   Resolver using this option MUST prepare it as described in<br>   Section 7.1.1, “Recursive Resolvers”.  In particular, a Forwarding<br>   Resolver that implements this protocol MUST honor SOURCE PREFIX-<br>   LENGTH restrictions indicated in the incoming query from its client.<br>   See also Section 7.5.</p><p>   Since the Recursive Resolver it contacts will treat the Forwarding<br>   Resolver like a Stub Resolver, the Recursive Resolver’s policies<br>   regarding incoming ADDRESS information will apply in the same way.<br>   If the Forwarding Resolver receives a REFUSED response when it sends<br>   a query that includes a non-zero ADDRESS, it MUST retry with no<br>   ADDRESS.</p><p>7.2.  Generating a Response</p><p>7.2.1.  Authoritative Nameserver</p><p>   When a query containing an ECS option is received, an Authoritative<br>   Nameserver supporting ECS MAY use the address information specified<br>   in the option to generate a tailored response.</p><p>   Authoritative Nameservers that have not implemented or enabled<br>   support for the ECS option ought to safely ignore it within incoming<br>   queries, per [RFC6891], Section 6.1.2.  Such a server MUST NOT<br>   include an ECS option within replies to indicate lack of support for<br>   it.  Implementers of Intermediate Nameservers should be aware,<br>   however, that some nameservers incorrectly echo back unknown EDNS0<br>   options.  In this protocol, that should be mostly harmless, as the<br>   SCOPE PREFIX-LENGTH should come back as 0, thus marking the response<br>   as covering all networks.</p><p>   A query with a wrongly formatted option (e.g., an unknown FAMILY)<br>   MUST be rejected and a FORMERR response MUST be returned to the<br>   sender, as described in [RFC6891], “Transport Considerations”.</p><p>   An Authoritative Nameserver that implements this protocol and<br>   receives an ECS option MUST include an ECS option in its response to<br>   indicate that it SHOULD be cached accordingly, regardless of whether<br>   the client information was needed to formulate an answer.  (Note that</p><p>Contavalli, et al.            Informational                    [Page 11]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   the requirement in [RFC6891] to reserve space for the OPT record<br>   could mean that the Answer section of the response will be truncated<br>   and fall back to TCP indicated accordingly.)  If an ECS option was<br>   not included in a query, one MUST NOT be included in the response<br>   even if the server is providing a Tailored Response – presumably<br>   based on the address from which it received the query.</p><p>   FAMILY, SOURCE PREFIX-LENGTH, and ADDRESS in the response MUST match<br>   those in the query.  Echoing back these values helps to mitigate<br>   certain attack vectors, as described in Section 11.</p><p>   SCOPE PREFIX-LENGTH in the response indicates the network for which<br>   the answer is intended.</p><p>   A SCOPE PREFIX-LENGTH value longer than SOURCE PREFIX-LENGTH<br>   indicates that the provided prefix length was not specific enough to<br>   select the most appropriate Tailored Response.  Future queries for<br>   the name within the specified network SHOULD use the longer SCOPE<br>   PREFIX-LENGTH.  Factors affecting whether the Recursive Resolver<br>   would use the longer length include the amount of privacy masking the<br>   operator wants to provide their users, and the additional resource<br>   implications for the cache.</p><p>   Conversely, a shorter SCOPE PREFIX-LENGTH indicates that more bits<br>   than necessary were provided, and the answer is suitable for a<br>   broader range of addresses.  This could be as short as 0, to indicate<br>   that the answer is suitable for all addresses in FAMILY.</p><p>   As the logical topology of any part of the network with regard to the<br>   tailored response can vary, an Authoritative Nameserver may return<br>   different values of SCOPE PREFIX-LENGTH for different networks.</p><p>   Since some queries can result in multiple RRsets being added to the<br>   response, there is an unfortunate ambiguity from the original<br>   specification as to how SCOPE PREFIX-LENGTH would apply to each<br>   individual RRset.  For example, multiple types in response to an ANY<br>   metaquery could all have different applicable SCOPE PREFIX-LENGTH<br>   values, but this protocol only has the ability to signal one.  The<br>   response SHOULD therefore, include the longest relevant PREFIX-LENGTH<br>   of any RRset in the answer, which could have the unfortunate side<br>   effect of redundantly caching some data that could be cached more<br>   broadly.  For the specific case of a Canonical Name (CNAME) chain,<br>   the Authoritative Nameserver SHOULD only place the initial CNAME<br>   record in the Answer section, to have it cached unambiguously and<br>   appropriately.  Most modern Recursive Resolvers restart the query<br>   with the CNAME, so the remainder of the chain is typically ignored</p><p>Contavalli, et al.            Informational                    [Page 12]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   anyway.  For message-focused resolvers, rather than RRset-focused<br>   ones, this will mean caching the entire CNAME chain at the longest<br>   PREFIX-LENGTH of any RRset in the chain.</p><p>   The specific logic that an Authoritative Nameserver uses to choose a<br>   tailored response is not in the scope of this document.  Implementers<br>   are encouraged, however, to carefully consider their selection of<br>   SCOPE PREFIX-LENGTH for the response in the event that the best<br>   tailored response cannot be determined, and what the implications<br>   would be over the life of the TTL.</p><p>   Authoritative Nameservers might have situations where one Tailored<br>   Response is appropriate for a relatively broad address range, such as<br>   an IPv4 /20, except for some exceptions, such as a few /24 ranges<br>   within that /20.  Because it can’t be guaranteed that queries for all<br>   longer prefix lengths would arrive before one that would be answered<br>   by the shorter prefix length, an Authoritative Nameserver MUST NOT<br>   overlap prefixes.</p><p>   When the Authoritative Nameserver has a longer prefix length Tailored<br>   Response within a shorter prefix length Tailored Response, then<br>   implementations can either:</p><ol><li><p>Deaggregate the shorter prefix response into multiple longer<br> prefix responses, or</p></li><li><p>Alert the operator that the order of queries will determine which<br> answers get cached, and either warn and continue or treat this as<br> an error and refuse to load the configuration.</p></li></ol><p>   This choice should be documented for the operator, for example, in<br>   the user manual.</p><p>   When deaggregating to correct the overlap, prefix lengths should be<br>   optimized to use the minimum necessary to cover the address space, in<br>   order to reduce the overhead that results from having multiple copies<br>   of the same answer.  As a trivial example, if the Tailored Response<br>   for 1.2.0/20 is A but there is one exception of 1.2.3/24 for B, then<br>   the Authoritative Nameserver would need to provide Tailored Responses<br>   for 1.2.0/23, 1.2.2/24, 1.2.4/22, and 1.2.8/21 all pointing to A, and<br>   1.2.3/24 to B.</p><p>7.2.2.  Intermediate Nameserver</p><p>   When an Intermediate Nameserver uses ECS, whether it passes an ECS<br>   option in its own response to its client is predicated on whether the<br>   client originally included the option.  Because a client that did not<br>   use an ECS option might not be able to understand it, the server MUST</p><p>Contavalli, et al.            Informational                    [Page 13]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   NOT provide one in its response.  If the client query did include the<br>   option, the server MUST include one in its response, especially as it<br>   could be talking to a Forwarding Resolver, which would need the<br>   information for its own caching.</p><p>   If an Intermediate Nameserver receives a response that has a longer<br>   SCOPE PREFIX-LENGTH than SOURCE PREFIX-LENGTH that it provided in its<br>   query, it SHOULD still provide the result as the answer to the<br>   triggering client request even if the client is in a different<br>   address range.  The Intermediate Nameserver MAY instead opt to retry<br>   with a longer SOURCE PREFIX-LENGTH to get a better reply before<br>   responding to its client, as long as it does not exceed a SOURCE<br>   PREFIX-LENGTH specified in the query that triggered resolution, but<br>   this obviously has implications for the latency of the overall<br>   lookup.</p><p>   The logic for using the cache to determine whether the Intermediate<br>   Nameserver already knows the response to provide to its client is<br>   covered in the next section.</p><p>7.3.  Handling ECS Responses and Caching</p><p>   When an Intermediate Nameserver receives a response containing an ECS<br>   option and without the TC bit set, it SHOULD cache the result based<br>   on the data in the option.  If the TC bit was set, the Intermediate<br>   Resolver SHOULD retry the query over TCP to get the complete Answer<br>   section for caching.</p><p>   If FAMILY, SOURCE PREFIX-LENGTH, and SOURCE PREFIX-LENGTH bits of<br>   ADDRESS in the response don’t match the non-zero fields in the<br>   corresponding query, the full response MUST be dropped, as described<br>   in Section 11.  In a response to a query that specified only SOURCE<br>   PREFIX-LENGTH for privacy masking, the FAMILY and ADDRESS fields MUST<br>   contain the appropriate non-zero information that the Authoritative<br>   Nameserver used to generate the answer, so that it can be cached<br>   accordingly.</p><p>   If no ECS option is contained in the response, the Intermediate<br>   Nameserver SHOULD treat this as being equivalent to having received a<br>   SCOPE PREFIX-LENGTH of 0, which is an answer suitable for all client<br>   addresses.  See further discussion on the security implications of<br>   this in Section 11.</p><p>   If a REFUSED response is received from an Authoritative Nameserver,<br>   an ECS-aware resolver MUST retry the query without ECS to distinguish<br>   the response from one where the Authoritative Nameserver is not<br>   responsible for the name, which is a common convention for the<br>   REFUSED status.  Similarly, a client of a Recursive Resolver SHOULD</p><p>Contavalli, et al.            Informational                    [Page 14]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   retry after receiving a REFUSED response because it is not<br>   sufficiently clear whether the REFUSED response was because of the<br>   ECS option or some other reason.</p><p>7.3.1.  Caching the Response</p><p>   In the cache, all resource records in the Answer section MUST be tied<br>   to the network specified in the response.  The appropriate prefix<br>   length depends on the relationship between SOURCE PREFIX-LENGTH,<br>   SCOPE PREFIX-LENGTH, and the maximum cacheable prefix length<br>   configured for the cache.</p><p>   If SCOPE PREFIX-LENGTH is not longer than SOURCE PREFIX-LENGTH, store<br>   SCOPE PREFIX-LENGTH bits of ADDRESS, and then mark the response as<br>   valid for all addresses that fall within that range.</p><p>   Similarly, if SOURCE PREFIX-LENGTH is the maximum configured for the<br>   cache, store SOURCE PREFIX-LENGTH bits of ADDRESS, and then mark the<br>   response as valid for all addresses that fall within that range.</p><p>   If SOURCE PREFIX-LENGTH is shorter than the configured maximum and<br>   SCOPE PREFIX-LENGTH is longer than SOURCE PREFIX-LENGTH, store SOURCE<br>   PREFIX-LENGTH bits of ADDRESS, and then mark the response as valid<br>   only to answer client queries that specify exactly the same SOURCE<br>   PREFIX-LENGTH in their own ECS option.</p><p>   The handling of DNSSEC-related records in the Answer section was<br>   unspecified in the original draft version of this document and is<br>   inconsistently handled in existing implementations.  A Resource<br>   Record Signature (RRSIG) must obviously be tied to the RRset that it<br>   signs, but it is RECOMMENDED that all other DNSSEC records be scoped<br>   at /0.  See Section 9 for more information.</p><p>   Note that the Additional and Authority sections from a DNS response<br>   message are specifically excluded here.  Any records from these<br>   sections MUST NOT be tied to a network.  See Section 7.4 for more<br>   information.</p><p>   Records that are cached as /0 because of a query’s SOURCE PREFIX-<br>   LENGTH of 0 MUST be distinguished from those that are cached as /0<br>   because of a response’s SCOPE PREFIX-LENGTH of 0.  The former should<br>   only be used for other /0 queries that the Intermediate Resolver<br>   receives, but the latter is suitable as a response for all networks.</p><p>Contavalli, et al.            Informational                    [Page 15]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   Although omitting network-specific caching will significantly<br>   simplify an implementation, the resulting drop in cache hits is very<br>   likely to defeat most latency benefits provided by ECS.  Therefore,<br>   implementing full caching support as described in this section is<br>   strongly RECOMMENDED.</p><p>   Enabling support for ECS in an Intermediate Nameserver will<br>   significantly increase the size of the cache, reduce the number of<br>   results that can be served from cache, and increase the load on the<br>   server.  Implementing the mitigation techniques described in<br>   Section 11 is strongly recommended.  For cache size issues,<br>   implementers should consider data storage formats that allow the same<br>   answer data to be shared among multiple prefixes.</p><p>7.3.2.  Answering from Cache</p><p>   Cache lookups are first done as usual for a DNS query, using the<br>   query tuple of &lt;name, type, class&gt;.  Then, the appropriate RRset MUST<br>   be chosen based on the longest prefix matching.  The client address<br>   to use for comparison will depend on whether the Intermediate<br>   Nameserver received an ECS option in its client query.</p><p>   o  If no ECS option was provided, the client’s address is used.</p><p>   o  If there was an ECS option specifying SOURCE PREFIX-LENGTH and<br>      ADDRESS covering the client’s address, the client address is used<br>      but SOURCE PREFIX-LENGTH is initially ignored.  If no covering<br>      entry is found and SOURCE PREFIX-LENGTH is shorter than the<br>      configured maximum length allowed for the cache, repeat the cache<br>      lookup for an entry that exactly matches SOURCE PREFIX-LENGTH.<br>      These special entries, which do not cover longer prefix lengths,<br>      occur as described in the previous section.</p><p>   o  If there was an ECS option with an ADDRESS, the ADDRESS from it<br>      MAY be used if the local policy allows.  The policy can vary<br>      depending on the agreements the operator of the Intermediate<br>      Nameserver has with Authoritative Nameserver operators; see<br>      Section 12.2.  If the policy does not allow it, a REFUSED response<br>      SHOULD be sent.  See Section 7.5 for more information.</p><p>   If a matching network is found and the relevant data is unexpired,<br>   the response is generated as per Section 7.2.</p><p>   If no matching network is found, the Intermediate Nameserver MUST<br>   perform resolution as usual.  This is necessary to avoid Tailored<br>   Responses in the cache from being returned to the wrong clients, and</p><p>Contavalli, et al.            Informational                    [Page 16]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   to avoid a single query coming from a client on a different network<br>   from polluting the cache with a Tailored Response for all the users<br>   of that resolver.</p><p>7.4.  Delegations and Negative Answers</p><p>   The prohibition against tying ECS data to records from the Authority<br>   and Additional sections left an unfortunate ambiguity in the original<br>   specification, primarily with regard to negative answers.  The<br>   expectation of the original authors was that ECS would only really be<br>   used for address requests and the positive result in the response’s<br>   Answer section, which was the use case that was driving the<br>   definition of the protocol.</p><p>   For negative answers, some independent implementations of both<br>   resolvers and authorities did not see the section restriction as<br>   necessarily meaning that a given name and type must only have either<br>   positive ECS-tagged answers or a negative answer.  They support being<br>   able to tell one part of the network that the data does not exist,<br>   while telling another part of the network that it does.</p><p>   Several other implementations, however, do not support being able to<br>   mix positive and negative answers; thus, interoperability is a<br>   problem.  It is RECOMMENDED that no specific behavior regarding<br>   negative answers be relied upon, but that Authoritative Nameservers<br>   should conservatively expect that Intermediate Nameservers will treat<br>   all negative answers as /0; therefore, they SHOULD set SCOPE PREFIX-<br>   LENGTH accordingly.</p><p>   This issue is expected to be revisited in a future revision of the<br>   protocol, possibly blessing the mixing of positive and negative<br>   answers.  There are implications for cache data structures that<br>   developers should consider when writing new ECS code.</p><p>   The delegations case is a bit easier to tease out.  In operational<br>   practice, if an authoritative server is using address information to<br>   provide customized delegations, it is the resolver that will be using<br>   the answer for its next iterative query.  Addresses in the Additional<br>   section SHOULD therefore ignore ECS data, and the Authoritative<br>   Nameserver SHOULD return a zero SCOPE PREFIX-LENGTH on delegations.<br>   A Recursive Resolver SHOULD treat a non-zero SCOPE PREFIX LENGTH in a<br>   delegation as though it were zero.</p><p>Contavalli, et al.            Informational                    [Page 17]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>7.5.  Transitivity</p><p>   Generally, ECS options will only be present in DNS messages between a<br>   Recursive Resolver and an Authoritative Nameserver, i.e., one hop.<br>   However, in certain configurations, for example, multi-tier<br>   nameserver setups, it may be necessary to implement transitive<br>   behavior on Intermediate Nameservers.</p><p>   Any Intermediate Nameserver that forwards ECS options received from<br>   its clients MUST fully implement the caching behavior described in<br>   Section 7.3.</p><p>   An Intermediate Nameserver MAY forward ECS options with address<br>   information.  This information MAY match the source IP address of the<br>   incoming query, and MAY have more or fewer address bits than the<br>   nameserver would normally include in a locally originated ECS option.<br>   If an Intermediate Nameserver receives a query with SOURCE PREFIX-<br>   LENGTH set to 0, it MUST NOT include client address information in<br>   queries made to resolve that client’s request (see Section 7.1.2).</p><p>   If, for any reason, the Intermediate Nameserver does not want to use<br>   the information in an ECS option it receives (too little address<br>   information, network address from a range not authorized to use the<br>   server, private/unroutable address space, etc.), it SHOULD drop the<br>   query and return a REFUSED response.  Note again that a query MUST<br>   NOT be refused solely because it provides 0 address bits.</p><p>   Be aware that at least one major existing implementation does not<br>   return REFUSED and instead just processes the query as though the<br>   problematic information were not present.  This can lead to anomalous<br>   situations, such as a response from the Intermediate Nameserver that<br>   indicates it is tailored for one network (the one passed in the<br>   original query, since the ADDRESS must match) when actually it is for<br>   another network (the one which contains the address that the<br>   Intermediate Nameserver saw as making the query).</p><ol start="8"><li> IANA Considerations</li></ol><p>   IANA has assigned option code 8 in the “DNS EDNS0 Option Codes (OPT)”<br>   registry to edns-client-subnet.</p><p>   IANA has updated the reference to refer to this RFC.</p><p>Contavalli, et al.            Informational                    [Page 18]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><ol start="9"><li> DNSSEC Considerations</li></ol><p>   The presence or absence of an EDNS0 OPT resource record ([RFC6891])<br>   containing an ECS option in a DNS query does not change the usage of<br>   the resource records and mechanisms used to provide data origin<br>   authentication and data integrity to the DNS, as described in<br>   [RFC4033], [RFC4034], and [RFC4035].  OPT records are not signed.</p><p>   Use of this option, however, does imply increased DNS traffic between<br>   any given Recursive Resolver and Authoritative Nameserver, which<br>   could be another barrier to further DNSSEC adoption in this area.</p><p>   The initial version of this protocol, against which several<br>   Authoritative and Recursive Nameserver implementations were written,<br>   did not discuss the handling of DNSSEC RRs; thus, it is expected that<br>   there are operational inconsistencies in handling them.</p><p>   Given the intention of this document to describe how ECS is currently<br>   deployed, specifying new requirements for DNSSEC handling is out of<br>   scope.  However, some recommendations can be made as to what is most<br>   likely to result in successful interoperation for a DNSSEC-signed ECS<br>   zone, mainly from the point of view of Authoritative Nameservers.</p><p>   Most DNSSEC records SHOULD be scoped at /0, except for the RRSIG<br>   records, which MUST be tied to the RRset that they sign in a Tailored<br>   Response.  While it is possible to conceive of a way to get other<br>   DNSSEC records working in a network-specific way, it has little<br>   apparent benefit or likelihood of working with deployed validating<br>   resolvers.</p><p>   One further implication here is that, despite the discussion about<br>   negative answers in Section 7.4, scoping NextSECure (NSEC) or NSEC3<br>   records at /0 per the previous paragraph necessarily implies that<br>   DNSSEC-signed negative answers must also be network-invariant.</p><ol start="10"><li> NAT Considerations</li></ol><p>   Special awareness of ECS in devices that perform Network Address<br>   Translation (NAT) as described in [RFC2663] is not required; queries<br>   can be passed through as is.  The client’s network address SHOULD NOT<br>   be added, and existing ECS options, if present, SHOULD NOT be<br>   modified by NAT devices.</p><p>   In large-scale global networks behind a NAT device (but, for example<br>   with Centralized Resolver infrastructure), an internal Intermediate<br>   Nameserver might have detailed network layout information, and may</p><p>Contavalli, et al.            Informational                    [Page 19]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   know which external subnets are used for egress traffic by each<br>   internal network.  In such cases, the Intermediate Nameserver MAY use<br>   that information when originating ECS options.</p><p>   In other cases, if a Recursive Resolver knows that it is situated<br>   behind a NAT device, it SHOULD NOT originate ECS options with their<br>   external IP address and instead rely on downstream Intermediate<br>   Nameservers to do so.  It MAY, however, choose to include the option<br>   with their internal address for the purposes of signaling its own<br>   limit for SOURCE PREFIX-LENGTH.</p><p>   Full treatment of special network addresses is beyond the scope of<br>   this document; handling them will likely differ according to the<br>   operational environments of each service provider.  As a general<br>   guideline, if an Authoritative Nameserver on the publicly routed<br>   Internet receives a query that specifies an ADDRESS in [RFC1918] or<br>   [RFC4193] private address space, it SHOULD ignore ADDRESS and look up<br>   its answer based on the address of the Recursive Resolver.  In the<br>   response, it SHOULD set SCOPE PREFIX-LENGTH to cover all of the<br>   relevant private space.  For example, a query for ADDRESS 10.1.2.0<br>   with a SOURCE PREFIX-LENGTH of 24 would get a returned SCOPE PREFIX-<br>   LENGTH of 8.  The Intermediate Nameserver MAY elect to cache the<br>   answer under one entry for special-purpose addresses [RFC6890]; see<br>   Section 11.3 of this document.</p><ol start="11"><li> Security Considerations</li></ol><p>11.1.  Privacy</p><p>   With the ECS option, the network address of the client that initiated<br>   the resolution becomes visible to all servers involved in the<br>   resolution process.  Additionally, it will be visible from any<br>   network traversed by the DNS packets.</p><p>   To protect users’ privacy, Recursive Resolvers are strongly<br>   encouraged to conceal part of the user’s IP address by truncating<br>   IPv4 addresses to 24 bits. 56 bits are recommended for IPv6, based on<br>   [RFC6177].</p><p>   ISPs should have more detailed knowledge of their own networks.  That<br>   is, they might know that all 24-bit prefixes in a /20 are in the same<br>   area.  In those cases, for optimal cache utilization and improved<br>   privacy, the ISP’s Recursive Resolver SHOULD truncate IP addresses in<br>   this /20 to just 20 bits, instead of 24 as recommended above.</p><p>   Users who wish their full IP address to be hidden need to configure<br>   their client software, if possible, to include an ECS option<br>   specifying the wildcard address (i.e., a SOURCE PREFIX-LENGTH of 0).</p><p>Contavalli, et al.            Informational                    [Page 20]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   As described in previous sections, this option will be forwarded<br>   across all the Recursive Resolvers supporting ECS, which MUST NOT<br>   modify it to include the network address of the client.</p><p>   Note that even without an ECS option, any server queried directly by<br>   the user will be able to see the full client IP address.  Recursive<br>   Resolvers or Authoritative Nameservers MAY use the source IP address<br>   of queries to return a cached entry or to generate a Tailored<br>   Response that best matches the query.</p><p>11.2.  Birthday Attacks</p><p>   ECS adds information to the DNS query tuple (q-tuple).  This allows<br>   an attacker to send a caching Intermediate Nameserver multiple<br>   queries with spoofed IP addresses either in the ECS option or as the<br>   source IP.  These queries will trigger multiple outgoing queries with<br>   the same name, type, and class, just with different address<br>   information in the ECS option.</p><p>   With multiple queries for the same name in flight, the attacker has a<br>   higher chance of success to send a matching response with SCOPE<br>   PREFIX-LENGTH set to 0 to get it cached for all hosts.</p><p>   To counter this, the ECS option in a response packet MUST contain the<br>   full FAMILY, ADDRESS, and SOURCE PREFIX-LENGTH fields from the<br>   corresponding query.  Intermediate Nameservers processing a response<br>   MUST verify that these match, and they SHOULD discard the entire<br>   response if they do not.</p><p>   The requirement to discard is categorized as “SHOULD” instead of<br>   “MUST” because it stands in opposition to the instruction in<br>   Section 7.3, which states that a response lacking an ECS option<br>   should be treated as though it had one of SCOPE PREFIX-LENGTH of 0.<br>   If that is always true, then an attacker does not need to worry about<br>   matching the original ECS option data and just needs to flood back<br>   responses that have no ECS option at all.</p><p>   This type of attack could be detected in ongoing operations by<br>   marking whether the responding nameserver had previously been sending<br>   ECS options and/or by taking note of an incoming flood of bogus<br>   responses and flagging the relevant query for re-resolution.  This<br>   type of detection is more complex than existing nameserver responses<br>   to spoof floods, and it would also need to be sensitive to a<br>   nameserver legitimately stopping ECS replies even though it had<br>   previously given them.</p><p>Contavalli, et al.            Informational                    [Page 21]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>11.3.  Cache Pollution</p><p>   It is simple for an arbitrary resolver or client to provide false<br>   information in the ECS option, or to send UDP packets with forged<br>   source IP addresses.</p><p>   This could be used to:</p><p>   o  pollute the cache of Intermediate Resolvers by filling it with<br>      results that will rarely (if ever) be used.</p><p>   o  reverse-engineer the algorithms (or data) used by the<br>      Authoritative Nameserver to calculate Tailored Responses.</p><p>   o  mount a denial-of-service attack against an Intermediate<br>      Nameserver by forcing it to perform many more recursive queries<br>      than it would normally do, due to how caching is handled for<br>      queries containing the ECS option.</p><p>   Even without malicious intent, Centralized Resolvers providing<br>   answers to clients in multiple networks will need to cache different<br>   responses for different networks, putting more memory pressure on the<br>   cache.</p><p>   To mitigate those problems:</p><p>   o  Recursive Resolvers implementing ECS should only enable it in<br>      deployments where it is expected to bring clear advantages to the<br>      end users, such as when expecting clients from a variety of<br>      networks or from a wide geographical area.  Due to the high cache<br>      pressure introduced by ECS, the feature SHOULD be disabled in all<br>      default configurations.</p><p>   o  Recursive Resolvers SHOULD limit the number of networks and<br>      answers they keep in the cache for any given query.</p><p>   o  Recursive Resolvers SHOULD limit the total number of different<br>      networks that they keep in cache.</p><p>   o  Recursive Resolvers MUST NOT send an ECS option with SOURCE<br>      PREFIX-LENGTH providing more bits in ADDRESS than they are willing<br>      to cache responses for.</p><p>   o  Recursive Resolvers should implement algorithms to improve the<br>      cache hit rate, given the size constraints indicated above.<br>      Recursive Resolvers MAY, for example, decide to discard more-<br>      specific cache entries first.</p><p>Contavalli, et al.            Informational                    [Page 22]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   o  Authoritative Nameservers and Recursive Resolvers should discard<br>      ECS options that are either obviously forged or otherwise known to<br>      be wrong.  They SHOULD at least treat unroutable addresses, such<br>      as some of the address blocks defined in [RFC6890], as equivalent<br>      to the Recursive Resolver’s own identity.  They SHOULD ignore and<br>      never forward ECS options specifying other routable addresses that<br>      are known not to be served by the query source.</p><p>   o  The ECS option is just a hint to Authoritative Nameservers for<br>      customizing results.  They can decide to ignore the content of the<br>      ECS option based on blacklists or whitelists, rate-limiting<br>      mechanisms, or any other logic implemented in the software.</p><ol start="12"><li> Sending the Option</li></ol><p>   When implementing a Recursive Resolver, there are two strategies on<br>   deciding when to include an ECS option in a query.  At this stage,<br>   it’s not clear which strategy is best.</p><p>12.1.  Probing</p><p>   A Recursive Resolver can send the ECS option with every outgoing<br>   query.  However, it is RECOMMENDED that resolvers remember which<br>   Authoritative Nameservers did not return the option with their<br>   response and omit client address information from subsequent queries<br>   to those nameservers.</p><p>   Additionally, Recursive Resolvers SHOULD be configured never to send<br>   the option when querying root, top-level, and effective top-level<br>   (i.e., “public suffix” [Public_Suffix_List]) domain servers.  These<br>   domains are delegation-centric and are very unlikely to generate<br>   different responses based on the address of the client.</p><p>   When probing, it is important that several things are probed: support<br>   for ECS, support for EDNS0, support for EDNS0 options, or possibly an<br>   unreachable nameserver.  Various implementations are known to drop<br>   DNS packets with OPT RRs (with or without options), thus several<br>   probes are required to discover what is supported.</p><p>   Probing, if implemented, MUST be repeated periodically, e.g., daily.<br>   If an Authoritative Nameserver indicates ECS support for one zone, it<br>   is to be expected that the nameserver supports ECS for all of its<br>   zones.  Likewise, an Authoritative Nameserver that uses ECS<br>   information for one of its zones MUST indicate support for the option<br>   in all of its responses to ECS queries.  If the option is supported<br>   but not actually used for generating a response, its SCOPE PREFIX-<br>   LENGTH MUST be set to 0.</p><p>Contavalli, et al.            Informational                    [Page 23]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>12.2.  Whitelist</p><p>   As described previously, it is expected that only a few Recursive<br>   Resolvers will need to use ECS, and that it will generally be enabled<br>   only if it offers a clear benefit to the users.</p><p>   To avoid the complexity of implementing a probing and detection<br>   mechanism (and the possible query loss/delay that may come with it),<br>   an implementation could use a whitelist of Authoritative Nameservers<br>   to send the option to, likely specified by their domain name.<br>   Implementations MAY also allow additional configuring of this based<br>   on other criteria, such as zone or query type.  As of the time of<br>   this writing, at least one implementation makes use of a whitelist.</p><p>   An advantage of using a whitelist is that partial client address<br>   information is only disclosed to nameservers that are known to use<br>   the information, improving privacy.</p><p>   A drawback is scalability.  The operator needs to track which<br>   Authoritative Nameservers support ECS, making it harder for new<br>   Authoritative Nameservers to start using the option.</p><p>   Similarly, Authoritative Nameservers can also use whitelists to limit<br>   the feature to only certain clients.  For example, a CDN that does<br>   not want all of their mapping trivially walked might require a legal<br>   agreement with the Recursive Resolver operator, to clearly describe<br>   the acceptable use of the feature.</p><p>   The maintenance of access control mechanisms is out of scope for this<br>   protocol definition.</p><ol start="13"><li><p> Example</p></li><li><p>A Stub Resolver, SR, with the IP address<br>  2001:0db8:fd13:4231:2112:8a2e:c37b:7334 tries to resolve<br>  <a href="http://www.example.com/">www.example.com</a> by forwarding the query to the Recursive<br>  Resolver, RNS, asking for recursion.</p></li><li><p>RNS, supporting ECS, looks up <a href="http://www.example.com/">www.example.com</a> in its cache.  An<br>  entry is found neither for <a href="http://www.example.com/">www.example.com</a> nor for example.com.</p></li><li><p>RNS builds a query to send to the root and .com servers.  The<br>  implementation of RNS provides facilities so that an<br>  administrator can configure it not to forward ECS in certain<br>  cases.  In particular, RNS is configured not to include an ECS<br>  option when talking to Top-Level-Domain or root nameservers, as<br>  described in Section 7.1.  Thus, no ECS option is added, and<br>  resolution is performed as usual.</p></li></ol><p>Contavalli, et al.            Informational                    [Page 24]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><ol start="4"><li><p>RNS now knows the next server to query: the Authoritative<br>  Nameserver, ANS, responsible for example.com.</p></li><li><p>RNS prepares a new query for <a href="http://www.example.com/">www.example.com</a>, including an ECS<br>  option with:</p><ul><li><p> OPTION-CODE set to 8.</p></li><li><p>OPTION-LENGTH set to 0x00 0x0b for the following fixed 4<br> octets plus the 7 octets that will be used for ADDRESS.</p></li><li><p> FAMILY set to 0x00 0x02, as IP is an IPv6 address.</p></li><li><p>SOURCE PREFIX-LENGTH set to 0x38, as RNS is configured to<br> conceal the last 72 bits of every IPv6 address.</p></li><li><p>SCOPE PREFIX-LENGTH set to 0x00, as specified by this<br> document for all queries.</p></li><li><p>ADDRESS set to 0x20 0x01 0x0d 0xb8 0xfd 0x13 0x42, providing<br> only the first 56 bits of the IPv6 address.</p></li></ul></li><li><p>The query is sent.  ANS understands and uses ECS.  It parses the<br>  ECS option, and generates a Tailored Response.</p></li><li><p>Due its internal implementation, ANS finds a response that is<br>  tailored for the whole /16 of the client that performed the<br>  query.</p></li><li><p>ANS adds an ECS option in the response, containing:</p><ul><li><p> OPTION-CODE set to 8.</p></li><li><p> OPTION-LENGTH set to 0x00 0x07.</p></li><li><p> FAMILY set to 0x00 0x02.</p></li><li><p> SOURCE PREFIX-LENGTH set to 0x38, copied from the query.</p></li><li><p> SCOPE PREFIX-LENGTH set to 0x30, indicating a /48 network.</p></li><li><p>ADDRESS set to 0x20 0x01 0x0d 0xb8 0xfd 0x13 0x42, copied<br> from the query.</p></li></ul></li><li><p>RNS receives the response containing an ECS option.  It verifies<br>  that FAMILY, SOURCE PREFIX-LENGTH, and ADDRESS match the query.<br>  If not, the message is discarded.</p></li></ol><p>Contavalli, et al.            Informational                    [Page 25]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><ol start="10"><li><p>The response is interpreted as usual.  Since the response<br> contains an ECS option, ADDRESS, SCOPE PREFIX-LENGTH, and FAMILY<br> in the response are used to cache the entry.</p></li><li><p>RNS sends a response to Stub Resolver, SR, without including an<br> ECS option.</p></li><li><p>RNS receives another query to resolve <a href="http://www.example.com/">www.example.com</a>.  This<br> time, a response is cached.  The response, however, is tied to a<br> particular network.  If the client’s address matches any network<br> in the cache, then the response is returned from the cache.<br> Otherwise, another query is performed.  If multiple results<br> match, the one with the longest SCOPE PREFIX-LENGTH is chosen,<br> as per common best-network-match algorithms.</p></li><li><p> References</p></li></ol><p>14.1.  Normative References</p><p>   [RFC1034]  Mockapetris, P., “Domain Names - Concepts and Facilities”,<br>              STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987,<br>              <a href="http://www.rfc-editor.org/info/rfc1034">http://www.rfc-editor.org/info/rfc1034</a>.</p><p>   [RFC1035]  Mockapetris, P., “Domain Names - Implementation and<br>              Specification”, STD 13, RFC 1035, DOI 10.17487/RFC1035,<br>              November 1987, <a href="http://www.rfc-editor.org/info/rfc1035">http://www.rfc-editor.org/info/rfc1035</a>.</p><p>   [RFC1700]  Reynolds, J. and J. Postel, “Assigned Numbers”, RFC 1700,<br>              DOI 10.17487/RFC1700, October 1994,<br>              <a href="http://www.rfc-editor.org/info/rfc1700">http://www.rfc-editor.org/info/rfc1700</a>.</p><p>   [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.,<br>              and E. Lear, “Address Allocation for Private Internets”,<br>              BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996,<br>              <a href="http://www.rfc-editor.org/info/rfc1918">http://www.rfc-editor.org/info/rfc1918</a>.</p><p>   [RFC2119]  Bradner, S., “Key words for use in RFCs to Indicate<br>              Requirement Levels”, BCP 14, RFC 2119,<br>              DOI 10.17487/RFC2119, March 1997,<br>              <a href="http://www.rfc-editor.org/info/rfc2119">http://www.rfc-editor.org/info/rfc2119</a>.</p><p>   [RFC4033]  Arends, R., Austein, R., Larson, M., Massey, D., and S.<br>              Rose, “DNS Security Introduction and Requirements”,<br>              RFC 4033, DOI 10.17487/RFC4033, March 2005,<br>              <a href="http://www.rfc-editor.org/info/rfc4033">http://www.rfc-editor.org/info/rfc4033</a>.</p><p>Contavalli, et al.            Informational                    [Page 26]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   [RFC4034]  Arends, R., Austein, R., Larson, M., Massey, D., and S.<br>              Rose, “Resource Records for the DNS Security Extensions”,<br>              RFC 4034, DOI 10.17487/RFC4034, March 2005,<br>              <a href="http://www.rfc-editor.org/info/rfc4034">http://www.rfc-editor.org/info/rfc4034</a>.</p><p>   [RFC4035]  Arends, R., Austein, R., Larson, M., Massey, D., and S.<br>              Rose, “Protocol Modifications for the DNS Security<br>              Extensions”, RFC 4035, DOI 10.17487/RFC4035, March 2005,<br>              <a href="http://www.rfc-editor.org/info/rfc4035">http://www.rfc-editor.org/info/rfc4035</a>.</p><p>   [RFC4193]  Hinden, R. and B. Haberman, “Unique Local IPv6 Unicast<br>              Addresses”, RFC 4193, DOI 10.17487/RFC4193, October 2005,<br>              <a href="http://www.rfc-editor.org/info/rfc4193">http://www.rfc-editor.org/info/rfc4193</a>.</p><p>   [RFC6177]  Narten, T., Huston, G., and L. Roberts, “IPv6 Address<br>              Assignment to End Sites”, BCP 157, RFC 6177,<br>              DOI 10.17487/RFC6177, March 2011,<br>              <a href="http://www.rfc-editor.org/info/rfc6177">http://www.rfc-editor.org/info/rfc6177</a>.</p><p>   [RFC6890]  Cotton, M., Vegoda, L., Bonica, R., Ed., and B. Haberman,<br>              “Special-Purpose IP Address Registries”, BCP 153,<br>              RFC 6890, DOI 10.17487/RFC6890, April 2013,<br>              <a href="http://www.rfc-editor.org/info/rfc6890">http://www.rfc-editor.org/info/rfc6890</a>.</p><p>   [RFC6891]  Damas, J., Graff, M., and P. Vixie, “Extension Mechanisms<br>              for DNS (EDNS(0))”, STD 75, RFC 6891,<br>              DOI 10.17487/RFC6891, April 2013,<br>              <a href="http://www.rfc-editor.org/info/rfc6891">http://www.rfc-editor.org/info/rfc6891</a>.</p><p>14.2.  Informative References</p><p>   [Address_Family_Numbers]<br>              IANA, “Address Family Numbers”,<br>              <a href="http://www.iana.org/assignments/address-family-numbers">http://www.iana.org/assignments/address-family-numbers</a>.</p><p>   [DPRIVE_Working_Group]<br>              IETF, “PNS PRIVate Exchange (dprive) DPRIVE Working<br>              Group”, 2015,<br>              <a href="https://datatracker.ietf.org/wg/dprive/charter/">https://datatracker.ietf.org/wg/dprive/charter/</a>.</p><p>   [METADATA]<br>              Hardie, T., Ed., “Design considerations for Metadata<br>              Insertion”, Work in Progress, draft-hardie-privsec-<br>              metadata-insertion-02, March 2016.</p><p>   [Public_Suffix_List]<br>              “Public Suffix List”, <a href="https://publicsuffix.org/">https://publicsuffix.org/</a>.</p><p>Contavalli, et al.            Informational                    [Page 27]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>   [RFC2308]  Andrews, M., “Negative Caching of DNS Queries (DNS<br>              NCACHE)”, RFC 2308, DOI 10.17487/RFC2308, March 1998,<br>              <a href="http://www.rfc-editor.org/info/rfc2308">http://www.rfc-editor.org/info/rfc2308</a>.</p><p>   [RFC2663]  Srisuresh, P. and M. Holdrege, “IP Network Address<br>              Translator (NAT) Terminology and Considerations”,<br>              RFC 2663, DOI 10.17487/RFC2663, August 1999,<br>              <a href="http://www.rfc-editor.org/info/rfc2663">http://www.rfc-editor.org/info/rfc2663</a>.</p><p>   [RFC7719]  Hoffman, P., Sullivan, A., and K. Fujiwara, “DNS<br>              Terminology”, RFC 7719, DOI 10.17487/RFC7719, December<br>              2015, <a href="http://www.rfc-editor.org/info/rfc7719">http://www.rfc-editor.org/info/rfc7719</a>.</p><p>   [VANDERGAAST]<br>              Contavalli, C., Gaast, W., Leach, S., and E. Lewis,<br>              “Client Subnet in DNS Requests”, Work in Progress,<br>              draft-vandergaast-edns-client-subnet-02, July 2013.</p><p>Acknowledgements</p><p>   The authors wish to thank Darryl Rodden for his work as a co-author,<br>   and the following people for reviewing this document and for<br>   providing useful feedback: Paul S. R. Chisholm, B. Narendran,<br>   Leonidas Kontothanassis, David Presotto, Philip Rowlands, Chris<br>   Morrow, Kara Moscoe, Alex Nizhner, Warren Kumari, and Richard Rabbat<br>   from Google; Terry Farmer, Mark Teodoro, Edward Lewis, and Eric<br>   Burger from Neustar; David Ulevitch and Matthew Dempsky from OpenDNS;<br>   Patrick W. Gilmore and Steve Hill from Akamai; Colm MacCarthaigh and<br>   Richard Sheehan from Amazon; Tatuya Jinmei from Infoblox; Andrew<br>   Sullivan from Dyn; John Dickinson from Sinodun; Mark Delany from<br>   Apple; Yuri Schaeffer from NLnet Labs; Duane Wessels Verisign;<br>   Antonio Querubin; Daniel Kahn Gillmor from the ACLU; Evan Hunt and<br>   Mukund Sivaraman from the Internet Software Consortium; Russ Housley<br>   from Vigilsec; Stephen Farrell from Trinity College Dublin; Alissa<br>   Cooper from Cisco; Suzanne Woolf; and all of the other people that<br>   replied to our emails on various mailing lists.</p><p>Contavalli, et al.            Informational                    [Page 28]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>Contributors</p><p>   The individuals below contributed significantly to this document.</p><p>   Edward Lewis<br>   ICANN<br>   12025 Waterfront Drive, Suite 300<br>   Los Angeles, CA 90094-2536<br>   United States</p><p>   Email: <a href="mailto:&#x65;&#x64;&#x77;&#97;&#114;&#100;&#46;&#x6c;&#101;&#x77;&#x69;&#115;&#64;&#105;&#x63;&#97;&#110;&#x6e;&#46;&#111;&#x72;&#x67;">&#x65;&#x64;&#x77;&#97;&#114;&#100;&#46;&#x6c;&#101;&#x77;&#x69;&#115;&#64;&#105;&#x63;&#97;&#110;&#x6e;&#46;&#111;&#x72;&#x67;</a></p><p>   Sean Leach<br>   Fastly<br>   P.O. Box 78266<br>   San Francisco, CA 94107<br>   United States</p><p>   Jason Moreau<br>   Akamai Technologies<br>   150 Broadway<br>   Cambridge, MA 02142-1413<br>   United States</p><p>Contavalli, et al.            Informational                    [Page 29]<br><br>RFC 7871              Client Subnet in DNS Queries              May 2016</p><p>Authors’ Addresses</p><p>   Carlo Contavalli<br>   Google<br>   1600 Amphitheater Parkway<br>   Mountain View, CA  94043<br>   United States</p><p>   Email: <a href="mailto:&#x63;&#x63;&#x6f;&#110;&#x74;&#x61;&#x76;&#x61;&#x6c;&#108;&#x69;&#64;&#x67;&#x6f;&#111;&#x67;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#x63;&#x63;&#x6f;&#110;&#x74;&#x61;&#x76;&#x61;&#x6c;&#108;&#x69;&#64;&#x67;&#x6f;&#111;&#x67;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></p><p>   Wilmer van der Gaast<br>   Google<br>   Belgrave House, 76 Buckingham Palace Road<br>   London  SW1W 9TQ<br>   United Kingdom</p><p>   Email: <a href="mailto:&#119;&#105;&#x6c;&#x6d;&#101;&#x72;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;">&#119;&#105;&#x6c;&#x6d;&#101;&#x72;&#x40;&#x67;&#111;&#x6f;&#x67;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#109;</a></p><p>   David C Lawrence<br>   Akamai Technologies<br>   150 Broadway<br>   Cambridge, MA  02142-1054<br>   United States</p><p>   Email: <a href="mailto:&#x74;&#97;&#x6c;&#x65;&#64;&#97;&#107;&#97;&#109;&#97;&#x69;&#x2e;&#x63;&#x6f;&#x6d;">&#x74;&#97;&#x6c;&#x65;&#64;&#97;&#107;&#97;&#109;&#97;&#x69;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p>   Warren Kumari<br>   Google<br>   1600 Amphitheatre Parkway<br>   Mountain View, CA  94043<br>   United States</p><p>   Email: <a href="mailto:&#119;&#x61;&#x72;&#x72;&#x65;&#x6e;&#x40;&#x6b;&#x75;&#109;&#x61;&#114;&#x69;&#46;&#110;&#101;&#x74;">&#119;&#x61;&#x72;&#x72;&#x65;&#x6e;&#x40;&#x6b;&#x75;&#109;&#x61;&#114;&#x69;&#46;&#110;&#101;&#x74;</a></p><p>Contavalli, et al.            Informational                    [Page 30]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RFC1035(域名 - 实施和规范)</title>
    <link href="/2023/08/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/21-rfc1035/"/>
    <url>/2023/08/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/21-rfc1035/</url>
    
    <content type="html"><![CDATA[<p>DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION (域名 - 实施和规范)</p><h1 id="1-STATUS-OF-THIS-MEMO-此备忘录的状态"><a href="#1-STATUS-OF-THIS-MEMO-此备忘录的状态" class="headerlink" title="1. STATUS OF THIS MEMO(此备忘录的状态)"></a>1. STATUS OF THIS MEMO(此备忘录的状态)</h1><p>This RFC describes the details of the domain system and protocol, and assumes that the reader is familiar with the concepts discussed in a companion RFC, “Domain Names - Concepts and Facilities” [RFC-1034].</p><p><em>本 RFC 描述了域系统和协议的详细信息，并假设读者熟悉配套 RFC中所讨论的概念.<a href="%E5%9F%9F%E5%90%8D-%E6%A6%82%E5%BF%B5%E5%92%8C%E8%AE%BE%E6%96%BD">RFC1034</a>.</em></p><p>The domain system is a mixture of functions and data types which are an official protocol and functions and data types which are still experimental.  Since the domain system is intentionally extensible, new data types and experimental behavior should always be expected in parts of the system beyond the official protocol.  The official protocol parts include standard queries, responses and the Internet class RR data formats (e.g., host addresses).  Since the previous RFC set, several definitions have changed, so some previous definitions are obsolete.</p><p>Experimental or obsolete features are clearly marked in these RFCs, and such information should be used with caution.</p><p>The reader is especially cautioned not to depend on the values which appear in examples to be current or complete, since their purpose is primarily pedagogical.  Distribution of this memo is unlimited.</p><h1 id="2-INTRODUCTION"><a href="#2-INTRODUCTION" class="headerlink" title="2. INTRODUCTION"></a>2. INTRODUCTION</h1><h2 id="2-1-Overview"><a href="#2-1-Overview" class="headerlink" title="2.1. Overview"></a>2.1. Overview</h2><p>The goal of domain names is to provide a mechanism for naming resources in such a way that the names are usable in different hosts, networks, protocol families, internets, and administrative organizations.</p><p>From the user’s point of view, domain names are useful as arguments to a local agent, called a resolver, which retrieves information associated with the domain name.  Thus a user might ask for the host address or mail information associated with a particular domain name.  To enable the user to request a particular type of information, an appropriate query type is passed to the resolver with the domain name.  To the user, the domain tree is a single information space; the resolver is responsible for hiding the distribution of data among name servers from the user.</p><p>From the resolver’s point of view, the database that makes up the domain space is distributed among various name servers.  Different parts of the domain space are stored in different name servers, although a particular data item will be stored redundantly in two or more name servers.  The resolver starts with knowledge of at least one name server.  When the resolver processes a user query it asks a known name server for the information; in return, the resolver either receives the desired information or a referral to another name server.  Using these referrals, resolvers learn the identities and contents of other name servers.  Resolvers are responsible for dealing with the distribution of the domain space and dealing with the effects of name server failure by consulting redundant databases in other servers.</p><p>Name servers manage two kinds of data.  The first kind of data held in sets called zones; each zone is the complete database for a particular<br>“pruned” subtree of the domain space.  This data is called authoritative.  A name server periodically checks to make sure that its zones are up to date, and if not, obtains a new copy of updated zones from master files stored locally or in another name server.  The second kind of data is cached data which was acquired by a local resolver. This data may be incomplete, but improves the performance of the retrieval process when non-local data is repeatedly accessed.  Cached data is eventually discarded by a timeout mechanism.</p><p>This functional structure isolates the problems of user interface, failure recovery, and distribution in the resolvers and isolates the database update and refresh problems in the name servers.</p><h2 id="2-2-Common-configurations"><a href="#2-2-Common-configurations" class="headerlink" title="2.2. Common configurations"></a>2.2. Common configurations</h2><p>A host can participate in the domain name system in a number of ways, depending on whether the host runs programs that retrieve information<br>from the domain system, name servers that answer queries from other hosts, or various combinations of both functions.  The simplest, and perhaps most typical, configuration is shown below:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs gherkin">             Local Host                        |<span class="hljs-string">  Foreign</span><br><span class="hljs-string">                                               </span>|<br>+---------+               +----------+         |<span class="hljs-string">  +--------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> user queries  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">queries  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string">  User   </span>|<span class="hljs-string">--------------&gt;</span>|<span class="hljs-string">          </span>|<span class="hljs-string">---------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">Foreign </span>|<br>|<span class="hljs-string"> Program </span>|<span class="hljs-string">               </span>|<span class="hljs-string"> Resolver </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Name  </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;--------------</span>|<span class="hljs-string">          </span>|<span class="hljs-string">&lt;--------</span>|<span class="hljs-string">--</span>|<span class="hljs-string"> Server </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string"> user responses</span>|<span class="hljs-string">          </span>|<span class="hljs-string">responses</span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>+---------+               +----------+         |<span class="hljs-string">  +--------+</span><br><span class="hljs-string">                            </span>|<span class="hljs-string">     A            </span>|<br>            cache additions |<span class="hljs-string">     </span>|<span class="hljs-string"> references </span>|<br>                            V     |<span class="hljs-string">            </span>|<br>                          +----------+         |<span class="hljs-string"></span><br><span class="hljs-string">                          </span>|<span class="hljs-string">  cache   </span>|<span class="hljs-string">         </span>|<br>                          +----------+         |<br></code></pre></td></tr></table></figure><p>User programs interact with the domain name space through resolvers; the  format of user queries and user responses is specific to the host and its operating system.  User queries will typically be operating system calls, and the resolver and its cache will be part of the host operating system.  Less capable hosts may choose to implement the resolver as a subroutine to be linked in with every program that needs its services. Resolvers answer user queries with information they acquire via queries to foreign name servers and the local cache.</p><p>Note that the resolver may have to make several queries to several different foreign name servers to answer a particular user query, and hence the resolution of a user query may involve several network accesses and an arbitrary amount of time.  The queries to foreign name servers and the corresponding responses have a standard format described</p><p>in this memo, and may be datagrams.</p><p>Depending on its capabilities, a name server could be a stand alone program on a dedicated machine or a process or processes on a large timeshared host.  A simple configuration might be:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">             Local Host                        |<span class="hljs-string">  Foreign</span><br><span class="hljs-string">                                               </span>|<br>  +---------+                                  |<span class="hljs-string"></span><br><span class="hljs-string"> /         /</span>|<span class="hljs-string">                                  </span>|<br>+---------+ |<span class="hljs-string">             +----------+         </span>|<span class="hljs-string">  +--------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">          </span>|<span class="hljs-string">responses</span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">   Name   </span>|<span class="hljs-string">---------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">Foreign </span>|<br>|<span class="hljs-string">  Master </span>|<span class="hljs-string">--------------&gt;</span>|<span class="hljs-string">  Server  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">Resolver</span>|<br>|<span class="hljs-string">  files  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">          </span>|<span class="hljs-string">&lt;--------</span>|<span class="hljs-string">--</span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">/              </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> queries </span>|<span class="hljs-string">  +--------+</span><br><span class="hljs-string">+---------+               +----------+         </span>|<br></code></pre></td></tr></table></figure><p>Here a primary name server acquires information about one or more zones by reading master files from its local file system, and answers queries about those zones that arrive from foreign resolvers.</p><p>The DNS requires that all zones be redundantly supported by more than one name server.  Designated secondary servers can acquire zones and check for updates from the primary server using the zone transfer protocol of the DNS. This configuration is shown below:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">             Local Host                        |<span class="hljs-string">  Foreign</span><br><span class="hljs-string">                                               </span>|<br>  +---------+                                  |<span class="hljs-string"></span><br><span class="hljs-string"> /         /</span>|<span class="hljs-string">                                  </span>|<br>+---------+ |<span class="hljs-string">             +----------+         </span>|<span class="hljs-string">  +--------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">          </span>|<span class="hljs-string">responses</span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">   Name   </span>|<span class="hljs-string">---------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">Foreign </span>|<br>|<span class="hljs-string">  Master </span>|<span class="hljs-string">--------------&gt;</span>|<span class="hljs-string">  Server  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">Resolver</span>|<br>|<span class="hljs-string">  files  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">          </span>|<span class="hljs-string">&lt;--------</span>|<span class="hljs-string">--</span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">/              </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> queries </span>|<span class="hljs-string">  +--------+</span><br><span class="hljs-string">+---------+               +----------+         </span>|<br>                            A     |<span class="hljs-string">maintenance </span>|<span class="hljs-string">  +--------+</span><br><span class="hljs-string">                            </span>|<span class="hljs-string">     +------------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">        </span>|<br>                            |<span class="hljs-string">      queries     </span>|<span class="hljs-string">  </span>|<span class="hljs-string">Foreign </span>|<br>                            |<span class="hljs-string">                  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Name  </span>|<br>                            +------------------|<span class="hljs-string">--</span>|<span class="hljs-string"> Server </span>|<br>                         maintenance responses |<span class="hljs-string">  +--------+</span><br></code></pre></td></tr></table></figure><p>In this configuration, the name server periodically establishes a virtual circuit to a foreign name server to acquire a copy of a zone or to check that an existing copy has not changed.  The messages sent for these maintenance activities follow the same form as queries and responses, but the message sequences are somewhat different.</p><p>The information flow in a host that supports all aspects of the domain name system is shown below:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">             Local Host                        |<span class="hljs-string">  Foreign</span><br><span class="hljs-string">                                               </span>|<br>+---------+               +----------+         |<span class="hljs-string">  +--------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> user queries  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">queries  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string">  User   </span>|<span class="hljs-string">--------------&gt;</span>|<span class="hljs-string">          </span>|<span class="hljs-string">---------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">Foreign </span>|<br>|<span class="hljs-string"> Program </span>|<span class="hljs-string">               </span>|<span class="hljs-string"> Resolver </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Name  </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;--------------</span>|<span class="hljs-string">          </span>|<span class="hljs-string">&lt;--------</span>|<span class="hljs-string">--</span>|<span class="hljs-string"> Server </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string"> user responses</span>|<span class="hljs-string">          </span>|<span class="hljs-string">responses</span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>+---------+               +----------+         |<span class="hljs-string">  +--------+</span><br><span class="hljs-string">                            </span>|<span class="hljs-string">     A            </span>|<br>            cache additions |<span class="hljs-string">     </span>|<span class="hljs-string"> references </span>|<br>                            V     |<span class="hljs-string">            </span>|<br>                          +----------+         |<span class="hljs-string"></span><br><span class="hljs-string">                          </span>|<span class="hljs-string">  Shared  </span>|<span class="hljs-string">         </span>|<br>                          |<span class="hljs-string"> database </span>|<span class="hljs-string">         </span>|<br>                          +----------+         |<span class="hljs-string"></span><br><span class="hljs-string">                            A     </span>|<span class="hljs-string">            </span>|<br>  +---------+     refreshes |<span class="hljs-string">     </span>|<span class="hljs-string"> references </span>|<br> /         /|<span class="hljs-string">               </span>|<span class="hljs-string">     V            </span>|<br>+---------+ |<span class="hljs-string">             +----------+         </span>|<span class="hljs-string">  +--------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">          </span>|<span class="hljs-string">responses</span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">   Name   </span>|<span class="hljs-string">---------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">Foreign </span>|<br>|<span class="hljs-string">  Master </span>|<span class="hljs-string">--------------&gt;</span>|<span class="hljs-string">  Server  </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">Resolver</span>|<br>|<span class="hljs-string">  files  </span>|<span class="hljs-string"> </span>|<span class="hljs-string">             </span>|<span class="hljs-string">          </span>|<span class="hljs-string">&lt;--------</span>|<span class="hljs-string">--</span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">/              </span>|<span class="hljs-string">          </span>|<span class="hljs-string"> queries </span>|<span class="hljs-string">  +--------+</span><br><span class="hljs-string">+---------+               +----------+         </span>|<br>                            A     |<span class="hljs-string">maintenance </span>|<span class="hljs-string">  +--------+</span><br><span class="hljs-string">                            </span>|<span class="hljs-string">     +------------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">        </span>|<br>                            |<span class="hljs-string">      queries     </span>|<span class="hljs-string">  </span>|<span class="hljs-string">Foreign </span>|<br>                            |<span class="hljs-string">                  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Name  </span>|<br>                            +------------------|<span class="hljs-string">--</span>|<span class="hljs-string"> Server </span>|<br>                         maintenance responses |<span class="hljs-string">  +--------+</span><br></code></pre></td></tr></table></figure><p>The shared database holds domain space data for the local name server and resolver.  The contents of the shared database will typically be a mixture of authoritative data maintained by the periodic refresh operations of the name server and cached data from previous resolver requests.  The structure of the domain data and the necessity for synchronization between name servers and resolvers imply the general characteristics of this database, but the actual format is up to the local implementor.</p><p>Information flow can also be tailored so that a group of hosts act together to optimize activities.  Sometimes this is done to offload less capable hosts so that they do not have to implement a full resolver. This can be appropriate for PCs or hosts which want to minimize the amount of new network code which is required.  This scheme can also allow a group of hosts can share a small number of caches rather than maintaining a large number of separate caches, on the premise that the centralized caches will have a higher hit ratio.  In either case, resolvers are replaced with stub resolvers which act as front ends to resolvers located in a recursive server in one or more name servers known to perform that service:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">               Local Hosts                     |<span class="hljs-string">  Foreign</span><br><span class="hljs-string">                                               </span>|<br>+---------+                                    |<span class="hljs-string"></span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> responses                          </span>|<br>|<span class="hljs-string"> Stub    </span>|<span class="hljs-string">&lt;--------------------+              </span>|<br>|<span class="hljs-string"> Resolver</span>|<span class="hljs-string">                     </span>|<span class="hljs-string">              </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">----------------+    </span>|<span class="hljs-string">              </span>|<br>+---------+ recursive      |<span class="hljs-string">    </span>|<span class="hljs-string">              </span>|<br>            queries        |<span class="hljs-string">    </span>|<span class="hljs-string">              </span>|<br>                           V    |<span class="hljs-string">              </span>|<br>+---------+ recursive     +----------+         |<span class="hljs-string">  +--------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> queries       </span>|<span class="hljs-string">          </span>|<span class="hljs-string">queries  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string"> Stub    </span>|<span class="hljs-string">--------------&gt;</span>|<span class="hljs-string"> Recursive</span>|<span class="hljs-string">---------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">Foreign </span>|<br>|<span class="hljs-string"> Resolver</span>|<span class="hljs-string">               </span>|<span class="hljs-string"> Server   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Name  </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;--------------</span>|<span class="hljs-string">          </span>|<span class="hljs-string">&lt;--------</span>|<span class="hljs-string">--</span>|<span class="hljs-string"> Server </span>|<br>+---------+ responses     |<span class="hljs-string">          </span>|<span class="hljs-string">responses</span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>                          +----------+         |<span class="hljs-string">  +--------+</span><br><span class="hljs-string">                          </span>|<span class="hljs-string">  Central </span>|<span class="hljs-string">         </span>|<br>                          |<span class="hljs-string">   cache  </span>|<span class="hljs-string">         </span>|<br>                          +----------+         |<br></code></pre></td></tr></table></figure><p>In any case, note that domain components are always replicated for reliability whenever possible.</p><h2 id="2-3-Conventions"><a href="#2-3-Conventions" class="headerlink" title="2.3. Conventions"></a>2.3. Conventions</h2><p>The domain system has several conventions dealing with low-level, but fundamental, issues.  While the implementor is free to violate these conventions WITHIN HIS OWN SYSTEM, he must observe these conventions in ALL behavior observed from other hosts.</p><h3 id="2-3-1-Preferred-name-syntax"><a href="#2-3-1-Preferred-name-syntax" class="headerlink" title="2.3.1. Preferred name syntax"></a>2.3.1. Preferred name syntax</h3><p>The DNS specifications attempt to be as general as possible in the rules for constructing domain names.  The idea is that the name of any existing object can be expressed as a domain name with minimal changes.</p><p>However, when assigning a domain name for an object, the prudent user will select a name which satisfies both the rules of the domain system and any existing rules for the object, whether these rules are published or implied by existing programs.</p><p>For example, when naming a mail domain, the user should satisfy both the rules of this memo and those in RFC-822.  When creating a new host name, the old rules for HOSTS.TXT should be followed.  This avoids problems when old software is converted to use domain names.</p><p>The following syntax will result in fewer problems with many applications that use domain names (e.g., mail, TELNET).</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;domain&gt;</span> ::= &lt;subdomain&gt; | <span class="hljs-string">&quot; &quot;</span><br><br><span class="hljs-attribute">&lt;subdomain&gt;</span> ::= &lt;label&gt; | &lt;subdomain&gt; <span class="hljs-string">&quot;.&quot;</span> &lt;label&gt;<br><br><span class="hljs-attribute">&lt;label&gt;</span> ::= &lt;letter&gt; [ [ &lt;ldh-str&gt; ] &lt;let-dig&gt; ]<br><br><span class="hljs-attribute">&lt;ldh-str&gt;</span> ::= &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;<br><br><span class="hljs-attribute">&lt;let-dig-hyp&gt;</span> ::= &lt;let-dig&gt; | <span class="hljs-string">&quot;-&quot;</span><br><br><span class="hljs-attribute">&lt;let-dig&gt;</span> ::= &lt;letter&gt; | &lt;digit&gt;<br><br><span class="hljs-attribute">&lt;letter&gt;</span> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case<br><br><span class="hljs-attribute">&lt;digit&gt;</span> ::= any one of the ten digits 0 through 9<br></code></pre></td></tr></table></figure><p>Note that while upper and lower case letters are allowed in domain names, no significance is attached to the case.  That is, two names with the same spelling but different case are to be treated as if identical.</p><p>The labels must follow the rules for ARPANET host names.  They must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen.  There are also some restrictions on the length.  Labels must be 63 characters or less.</p><p>For example, the following strings identify hosts in the Internet:</p><p>A.ISI.EDU XX.LCS.MIT.EDU SRI-NIC.ARPA</p><h3 id="2-3-2-Data-Transmission-Order"><a href="#2-3-2-Data-Transmission-Order" class="headerlink" title="2.3.2. Data Transmission Order"></a>2.3.2. Data Transmission Order</h3><p>The order of transmission of the header and data described in this document is resolved to the octet level.  Whenever a diagram shows a</p><p>group of octets, the order of transmission of those octets is the normal order in which they are read in English.  For example, in the following diagram, the octets are transmitted in the order they are numbered.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1</span><br><span class="hljs-section"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|       1       |       2       |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|       3       |       4       |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|       5       |       6       |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure><p>Whenever an octet represents a numeric quantity, the left most bit in the diagram is the high order or most significant bit.  That is, the bit labeled 0 is the most significant bit.  For example, the following diagram represents the value 170 (decimal).</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section"> 0 1 2 3 4 5 6 7</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|1 0 1 0 1 0 1 0|</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure><p>Similarly, whenever a multi-octet field represents a numeric quantity the left most bit of the whole field is the most significant bit.  When a multi-octet quantity is transmitted the most significant octet is transmitted first.</p><p>2.3.3. Character Case</p><p>For all parts of the DNS that are part of the official protocol, all comparisons between character strings (e.g., labels, domain names, etc.) are done in a case-insensitive manner.  At present, this rule is in force throughout the domain system without exception.  However, future additions beyond current usage may need to use the full binary octet capabilities in names, so attempts to store domain names in 7-bit ASCII or use of special bytes to terminate labels, etc., should be avoided.</p><p>When data enters the domain system, its original case should be preserved whenever possible.  In certain circumstances this cannot be done.  For example, if two RRs are stored in a database, one at x.y and one at X.Y, they are actually stored at the same place in the database, and hence only one casing would be preserved.  The basic rule is that case can be discarded only when data is used to define structure in a database, and two names are identical when compared in a case insensitive manner.</p><p>Loss of case sensitive data must be minimized.  Thus while data for x.y and X.Y may both be stored under a single location x.y or X.Y, data for a.x and B.X would never be stored under A.x, A.X, b.x, or b.X.  In general, this preserves the case of the first label of a domain name, but forces standardization of interior node labels.</p><p>Systems administrators who enter data into the domain database should take care to represent the data they supply to the domain system in a case-consistent manner if their system is case-sensitive.  The data distribution system in the domain system will ensure that consistent representations are preserved.</p><h3 id="2-3-4-Size-limits"><a href="#2-3-4-Size-limits" class="headerlink" title="2.3.4.  Size limits"></a>2.3.4.  Size limits</h3><p>Various objects and parameters in the DNS have size limits.  They are listed below.  Some could be easily changed, others are more fundamental.</p><p>labels          63 octets or less </p><p>names           255 octets or less </p><p>TTL             positive values of a signed 32 bit number.  </p><p>UDP messages    512 octets or less  </p><h1 id="3-DOMAIN-NAME-SPACE-AND-RR-DEFINITIONS"><a href="#3-DOMAIN-NAME-SPACE-AND-RR-DEFINITIONS" class="headerlink" title="3.  DOMAIN NAME SPACE AND RR DEFINITIONS"></a>3.  DOMAIN NAME SPACE AND RR DEFINITIONS</h1><h2 id="3-1-Name-space-definitions"><a href="#3-1-Name-space-definitions" class="headerlink" title="3.1.   Name space definitions"></a>3.1.   Name space definitions</h2><p>Domain names in messages are expressed in terms of a sequence of labels. Each label is represented as a one octet length field followed by that number of octets.  Since every domain name ends with the null label of the root, a domain name is terminated by a length byte of zero.  The high order two bits of every length octet must be zero, and the remaining six bits of the length field limit the label to 63 octets or less.</p><p>To simplify implementations, the total length of a domain name (i.e., label octets and label length octets) is restricted to 255 octets or less.</p><p>Although labels can contain any 8 bit values in octets that make up a label, it is strongly recommended that labels follow the preferred syntax described elsewhere in this memo, which is compatible with existing host naming conventions.  Name servers and resolvers must compare labels in a case-insensitive manner (i.e., A=a), assuming ASCII with zero parity.  Non-alphabetic codes must match exactly.</p><h2 id="3-2-RR-definitions"><a href="#3-2-RR-definitions" class="headerlink" title="3.2.  RR definitions"></a>3.2.  RR definitions</h2><h3 id="3-2-1-Format"><a href="#3-2-1-Format" class="headerlink" title="3.2.1. Format"></a>3.2.1. Format</h3><p>All RRs have the same top level format shown below:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">                                1  1  1  1  1  1</span><br><span class="hljs-section">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                                               |<br>/                                               /<br>/                      NAME                     /<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                      TYPE                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                     CLASS                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                      TTL                      |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                   RDLENGTH                    |<br><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--|<br>/                     RDATA                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><br></code></pre></td></tr></table></figure><p>where:</p><p>NAME             an owner name, i.e., the name of the node to which this resource record pertains.</p><p>TYPE             two octets containing one of the RR TYPE codes.</p><p>CLASS           two octets containing one of the RR CLASS codes.</p><p>TTL             a 32 bit signed integer that specifies the time interval that the resource record may be cached before the source of the information should again be consulted.  Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached.  For example, SOA records are always distributed with a zero TTL to prohibit caching.  Zero values can also be used for extremely volatile data.</p><p>RDLENGTH        an unsigned 16 bit integer that specifies the length in octets of the RDATA field.</p><p>RDATA           a variable length string of octets that describes the resource.  The format of this information varies according to the TYPE and CLASS of the resource record.</p><h3 id="3-2-2-TYPE-values"><a href="#3-2-2-TYPE-values" class="headerlink" title="3.2.2.  TYPE values"></a>3.2.2.  TYPE values</h3><p>TYPE fields are used in resource records.  Note that these types are a subset of QTYPEs.</p><p>TYPE            value and meaning</p><p>A               1 a host address</p><p>NS              2 an authoritative name server</p><p>MD              3 a mail destination (Obsolete - use MX)</p><p>MF              4 a mail forwarder (Obsolete - use MX)</p><p>CNAME           5 the canonical name for an alias</p><p>SOA             6 marks the start of a zone of authority</p><p>MB              7 a mailbox domain name (EXPERIMENTAL)</p><p>MG              8 a mail group member (EXPERIMENTAL)</p><p>MR              9 a mail rename domain name (EXPERIMENTAL)</p><p>NULL            10 a null RR (EXPERIMENTAL)</p><p>WKS             11 a well known service description</p><p>PTR             12 a domain name pointer</p><p>HINFO           13 host information</p><p>MINFO           14 mailbox or mail list information</p><p>MX              15 mail exchange</p><p>TXT             16 text strings</p><h3 id="3-2-3-QTYPE-values"><a href="#3-2-3-QTYPE-values" class="headerlink" title="3.2.3. QTYPE values"></a>3.2.3. QTYPE values</h3><p>QTYPE fields appear in the question part of a query.  QTYPES are a superset of TYPEs, hence all TYPEs are valid QTYPEs.  In addition, the following QTYPEs are defined:</p><p>AXFR            252 A request for a transfer of an entire zone</p><p>MAILB           253 A request for mailbox-related records (MB, MG or MR)</p><p>MAILA           254 A request for mail agent RRs (Obsolete - see MX)</p><ul><li><div class="code-wrapper"><pre><code class="hljs">          255 A request for all records</code></pre></div></li></ul><h3 id="3-2-4-CLASS-values"><a href="#3-2-4-CLASS-values" class="headerlink" title="3.2.4. CLASS values"></a>3.2.4. CLASS values</h3><p>CLASS fields appear in resource records.  The following CLASS mnemonics<br>and values are defined:</p><p>IN              1 the Internet</p><p>CS              2 the CSNET class (Obsolete - used only for examples in some obsolete RFCs)</p><p>CH              3 the CHAOS class</p><p>HS              4 Hesiod [Dyer 87]</p><h3 id="3-2-5-QCLASS-values"><a href="#3-2-5-QCLASS-values" class="headerlink" title="3.2.5. QCLASS values"></a>3.2.5. QCLASS values</h3><p>QCLASS fields appear in the question section of a query.  QCLASS values are a superset of CLASS values; every CLASS is a valid QCLASS.  In addition to CLASS values, the following QCLASSes are defined:</p><ul><li><div class="code-wrapper"><pre><code class="hljs">          255 any class</code></pre></div></li></ul><h2 id="3-3-Standard-RRs-标准-RR"><a href="#3-3-Standard-RRs-标准-RR" class="headerlink" title="3.3. Standard RRs(标准 RR)"></a>3.3. Standard RRs(标准 RR)</h2><p>The following RR definitions are expected to occur, at least potentially, in all classes.  In particular, NS, SOA, CNAME, and PTR will be used in all classes, and have the same format in all classes. Because their RDATA format is known, all domain names in the RDATA section of these RRs may be compressed.</p><p><domain-name> is a domain name represented as a series of labels, and terminated by a label with zero length.  <character-string> is a single length octet followed by that number of characters.  <character-string> is treated as binary information, and can be up to 256 characters in length (including the length octet).</p><h3 id="3-3-1-CNAME-RDATA-format"><a href="#3-3-1-CNAME-RDATA-format" class="headerlink" title="3.3.1. CNAME RDATA format"></a>3.3.1. CNAME RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                     CNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>CNAME           A <domain-name> which specifies the canonical or primary name for the owner.  The owner name is an alias.</p><p>CNAME RRs cause no additional section processing, but name servers may choose to restart the query at the canonical name in certain cases.  See the description of name server logic in [RFC-1034] for details.</p><h3 id="3-3-2-HINFO-RDATA-format"><a href="#3-3-2-HINFO-RDATA-format" class="headerlink" title="3.3.2. HINFO RDATA format"></a>3.3.2. HINFO RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">/                      CPU                      /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">/                       OS                      /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>CPU             A <character-string> which specifies the CPU type.</p><p>OS              A <character-string> which specifies the operating<br>                system type.</p><p>Standard values for CPU and OS can be found in [RFC-1010].</p><p>HINFO records are used to acquire general information about a host.  The main use is for protocols such as FTP that can use special procedures when talking between machines or operating systems of the same type.</p><h3 id="3-3-3-MB-RDATA-format-EXPERIMENTAL"><a href="#3-3-3-MB-RDATA-format-EXPERIMENTAL" class="headerlink" title="3.3.3. MB RDATA format (EXPERIMENTAL)"></a>3.3.3. MB RDATA format (EXPERIMENTAL)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                   MADNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>MADNAME         A <domain-name> which specifies a host which has the specified mailbox.</p><p>MB records cause additional section processing which looks up an A type RRs corresponding to MADNAME.</p><h3 id="3-3-4-MD-RDATA-format-Obsolete"><a href="#3-3-4-MD-RDATA-format-Obsolete" class="headerlink" title="3.3.4. MD RDATA format (Obsolete)"></a>3.3.4. MD RDATA format (Obsolete)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                   MADNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>MADNAME         A <domain-name> which specifies a host which has a mail agent for the domain which should be able to deliver mail for the domain.</p><p>MD records cause additional section processing which looks up an A type record corresponding to MADNAME.</p><p>MD is obsolete.  See the definition of MX and [RFC-974] for details of the new scheme.  The recommended policy for dealing with MD RRs found in a master file is to reject them, or to convert them to MX RRs with a preference of 0.</p><h3 id="3-3-5-MF-RDATA-format-Obsolete"><a href="#3-3-5-MF-RDATA-format-Obsolete" class="headerlink" title="3.3.5. MF RDATA format (Obsolete)"></a>3.3.5. MF RDATA format (Obsolete)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                   MADNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>MADNAME         A <domain-name> which specifies a host which has a mail agent for the domain which will accept mail for forwarding to the domain.</p><p>MF records cause additional section processing which looks up an A type record corresponding to MADNAME.</p><p>MF is obsolete.  See the definition of MX and [RFC-974] for details ofw the new scheme.  The recommended policy for dealing with MD RRs found in a master file is to reject them, or to convert them to MX RRs with a preference of 10.</p><h3 id="3-3-6-MG-RDATA-format-EXPERIMENTAL"><a href="#3-3-6-MG-RDATA-format-EXPERIMENTAL" class="headerlink" title="3.3.6. MG RDATA format (EXPERIMENTAL)"></a>3.3.6. MG RDATA format (EXPERIMENTAL)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                   MGMNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>MGMNAME         A <domain-name> which specifies a mailbox which is a member of the mail group specified by the domain name.</p><p>MG records cause no additional section processing.</p><h3 id="3-3-7-MINFO-RDATA-format-EXPERIMENTAL"><a href="#3-3-7-MINFO-RDATA-format-EXPERIMENTAL" class="headerlink" title="3.3.7. MINFO RDATA format (EXPERIMENTAL)"></a>3.3.7. MINFO RDATA format (EXPERIMENTAL)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">/                    RMAILBX                    /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">/                    EMAILBX                    /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>RMAILBX         A <domain-name> which specifies a mailbox which is responsible for the mailing list or mailbox.  If this domain name names the root, the owner of the MINFO RR is responsible for itself.  Note that many existing mailing lists use a mailbox X-request for the RMAILBX field of mailing list X, e.g., Msgroup-request for Msgroup.  This field provides a more general mechanism.</p><p>EMAILBX         A <domain-name> which specifies a mailbox which is to receive error messages related to the mailing list or mailbox specified by the owner of the MINFO RR (similar to the ERRORS-TO: field which has been proposed).  If this domain name names the root, errors should be returned to the sender of the message.</p><p>MINFO records cause no additional section processing.  Although these records can be associated with a simple mailbox, they are usually used with a mailing list.</p><p>3.3.8. MR RDATA format (EXPERIMENTAL)</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                   NEWNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>NEWNAME         A <domain-name> which specifies a mailbox which is the proper rename of the specified mailbox.</p><p>MR records cause no additional section processing.  The main use for MR is as a forwarding entry for a user who has moved to a different mailbox.</p><h3 id="3-3-9-MX-RDATA-format"><a href="#3-3-9-MX-RDATA-format" class="headerlink" title="3.3.9. MX RDATA format"></a>3.3.9. MX RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">|                  PREFERENCE                   |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>/                   EXCHANGE                    /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>PREFERENCE      A 16 bit integer which specifies the preference given to this RR among others at the same owner.  Lower values are preferred.</p><p>EXCHANGE        A <domain-name> which specifies a host willing to act as a mail exchange for the owner name.</p><p>MX records cause type A additional section processing for the host specified by EXCHANGE.  The use of MX RRs is explained in detail in [RFC-974].</p><h3 id="3-3-10-NULL-RDATA-format-EXPERIMENTAL"><a href="#3-3-10-NULL-RDATA-format-EXPERIMENTAL" class="headerlink" title="3.3.10. NULL RDATA format (EXPERIMENTAL)"></a>3.3.10. NULL RDATA format (EXPERIMENTAL)</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                  &lt;anything&gt;                   /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>Anything at all may be in the RDATA field so long as it is 65535 octets or less.</p><p>NULL records cause no additional section processing.  NULL RRs are not allowed in master files.  NULLs are used as placeholders in some experimental extensions of the DNS.</p><h3 id="3-3-11-NS-RDATA-format"><a href="#3-3-11-NS-RDATA-format" class="headerlink" title="3.3.11. NS RDATA format"></a>3.3.11. NS RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                   NSDNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>NSDNAME         A <domain-name> which specifies a host which should be authoritative for the specified class and domain.</p><p>NS records cause both the usual additional section processing to locate a type A record, and, when used in a referral, a special search of the zone in which they reside for glue information.</p><p>The NS RR states that the named host should be expected to have a zone starting at owner name of the specified class.  Note that the class may not indicate the protocol family which should be used to communicate with the host, although it is typically a strong hint.  For example, hosts which are name servers for either Internet (IN) or Hesiod (HS) class information are normally queried using IN class protocols.</p><h3 id="3-3-12-PTR-RDATA-format"><a href="#3-3-12-PTR-RDATA-format" class="headerlink" title="3.3.12. PTR RDATA format"></a>3.3.12. PTR RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">/                   PTRDNAME                    /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>PTRDNAME        A <domain-name> which points to some location in the domain name space.</p><p>PTR records cause no additional section processing.  These RRs are used in special domains to point to some other location in the domain space. These records are simple data, and don’t imply any special processing similar to that performed by CNAME, which identifies aliases.  See the description of the IN-ADDR.ARPA domain for an example.</p><h3 id="3-3-13-SOA-RDATA-format"><a href="#3-3-13-SOA-RDATA-format" class="headerlink" title="3.3.13. SOA RDATA format"></a>3.3.13. SOA RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                     MNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">/                     RNAME                     /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                    SERIAL                     |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                    REFRESH                    |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                     RETRY                     |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                    EXPIRE                     |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                    MINIMUM                    |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>MNAME           The <domain-name> of the name server that was the original or primary source of data for this zone.</p><p>RNAME           A <domain-name> which specifies the mailbox of the person responsible for this zone.</p><p>SERIAL          The unsigned 32 bit version number of the original copy of the zone.  Zone transfers preserve this value.  This value wraps and should be compared using sequence space arithmetic.</p><p>REFRESH         A 32 bit time interval before the zone should be refreshed.</p><p>RETRY           A 32 bit time interval that should elapse before a failed refresh should be retried.</p><p>EXPIRE          A 32 bit time value that specifies the upper limit on the time interval that can elapse before the zone is no longer authoritative.</p><p>MINIMUM         The unsigned 32 bit minimum TTL field that should be exported with any RR from this zone.</p><p>SOA records cause no additional section processing.</p><p>All times are in units of seconds.</p><p>Most of these fields are pertinent only for name server maintenance operations.  However, MINIMUM is used in all query operations that retrieve RRs from a zone.  Whenever a RR is sent in a response to a query, the TTL field is set to the maximum of the TTL field from the RR and the MINIMUM field in the appropriate SOA.  Thus MINIMUM is a lower bound on the TTL field for all RRs in a zone.  Note that this use of MINIMUM should occur when the RRs are copied into the response and not when the zone is loaded from a master file or via a zone transfer.  The reason for this provison is to allow future dynamic update facilities to change the SOA RR with known semantics.</p><h3 id="3-3-14-TXT-RDATA-format"><a href="#3-3-14-TXT-RDATA-format" class="headerlink" title="3.3.14. TXT RDATA format"></a>3.3.14. TXT RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">/                   TXT-DATA                    /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>TXT-DATA        One or more <character-string>s.</p><p>TXT RRs are used to hold descriptive text.  The semantics of the text depends on the domain where it is found.</p><h2 id="3-4-Internet-specific-RRs-互联网特定的-RR"><a href="#3-4-Internet-specific-RRs-互联网特定的-RR" class="headerlink" title="3.4. Internet specific RRs(互联网特定的 RR)"></a>3.4. Internet specific RRs(互联网特定的 RR)</h2><h3 id="3-4-1-A-RDATA-format"><a href="#3-4-1-A-RDATA-format" class="headerlink" title="3.4.1. A RDATA format"></a>3.4.1. A RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">|                    ADDRESS                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>ADDRESS         A 32 bit Internet address.</p><p>Hosts that have multiple Internet addresses will have multiple A records.</p><p>A records cause no additional section processing.  The RDATA section of an A line in a master file is an Internet address expressed as four decimal numbers separated by dots without any imbedded spaces (e.g., “10.2.0.52” or “192.0.5.6”).</p><h3 id="3-4-2-WKS-RDATA-format"><a href="#3-4-2-WKS-RDATA-format" class="headerlink" title="3.4.2. WKS RDATA format"></a>3.4.2. WKS RDATA format</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">|                    ADDRESS                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|       PROTOCOL        |                       |<br><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+                       |<br>|                                               |<br>/                   &lt;BIT MAP&gt;                   /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>ADDRESS         An 32 bit Internet address</p><p>PROTOCOL        An 8 bit IP protocol number</p><p><BIT MAP>       A variable length bit map.  The bit map must be a multiple of 8 bits long.</p><p>The WKS record is used to describe the well known services supported by a particular protocol on a particular internet address.  The PROTOCOL field specifies an IP protocol number, and the bit map has one bit per port of the specified protocol.  The first bit corresponds to port 0, the second to port 1, etc.  If the bit map does not include a bit for a protocol of interest, that bit is assumed zero.  The appropriate values and mnemonics for ports and protocols are specified in [RFC-1010].</p><p>For example, if PROTOCOL=TCP (6), the 26th bit corresponds to TCP port 25 (SMTP).  If this bit is set, a SMTP server should be listening on TCP port 25; if zero, SMTP service is not supported on the specified address.</p><p>The purpose of WKS RRs is to provide availability information for servers for TCP and UDP.  If a server supports both TCP and UDP, or has multiple Internet addresses, then multiple WKS RRs are used.</p><p>WKS RRs cause no additional section processing.</p><p>In master files, both ports and protocols are expressed using mnemonics or decimal numbers.</p><h2 id="3-5-IN-ADDR-ARPA-domain-IN-ADDR-ARPA-域名"><a href="#3-5-IN-ADDR-ARPA-domain-IN-ADDR-ARPA-域名" class="headerlink" title="3.5. IN-ADDR.ARPA domain(IN-ADDR.ARPA 域名)"></a>3.5. IN-ADDR.ARPA domain(IN-ADDR.ARPA 域名)</h2><p>The Internet uses a special domain to support gateway location and Internet address to host mapping.  Other classes may employ a similar strategy in other domains.  The intent of this domain is to provide a guaranteed method to perform host address to host name mapping, and to facilitate queries to locate all gateways on a particular network in the Internet.<br><em>互联网使用特殊的域来支持网关位置和互联网地址到主机的映射。 其他类可能在其他领域采用类似的策略。 该域的目的是提供一种有保证的方法来执行主机地址到主机名的映射，并方便查询以定位 Internet 中特定网络上的所有网关。</em></p><p>Note that both of these services are similar to functions that could be performed by inverse queries; the difference is that this part of the domain name space is structured according to address, and hence can guarantee that the appropriate data can be located without an exhaustive search of the domain space.<br><em>请注意，这两种服务都类似于可以通过反向查询执行的功能； 不同之处在于，这部分域名空间是根据地址构建的，因此可以保证无需穷举搜索域名空间即可找到适当的数据。</em></p><p>The domain begins at IN-ADDR.ARPA and has a substructure which follows the Internet addressing structure.<br><em>该域从 IN-ADDR.ARPA 开始，并具有遵循 Internet 寻址结构的子结构。</em></p><p>Domain names in the IN-ADDR.ARPA domain are defined to have up to four labels in addition to the IN-ADDR.ARPA suffix.  Each label represents one octet of an Internet address, and is expressed as a character string for a decimal value in the range 0-255 (with leading zeros omitted except in the case of a zero octet which is represented by a single zero).<br><em>IN-ADDR.ARPA 域中的域名定义为除了 IN-ADDR.ARPA 后缀之外最多还有四个标签。 每个标签代表互联网地址的一个八位位组，并表示为 0-255 范围内的十进制值的字符串（除了用单个零表示的零八位位组的情况之外，省略前导零）。</em></p><p>Host addresses are represented by domain names that have all four labels specified.  Thus data for Internet address 10.2.0.52 is located at domain name 52.0.2.10.IN-ADDR.ARPA.  The reversal, though awkward to read, allows zones to be delegated which are exactly one network of address space.  For example, 10.IN-ADDR.ARPA can be a zone containing data for the ARPANET, while 26.IN-ADDR.ARPA can be a separate zone for MILNET.  Address nodes are used to hold pointers to primary host names in the normal domain space.<br><em>主机地址由指定了所有四个标签的域名表示。 因此，互联网地址 10.2.0.52 的数据位于域名 52.0.2.10.IN-ADDR.ARPA 处。 这种逆转虽然读起来很困难，但允许对恰好是一个地址空间网络的区域进行委派。 例如，10.IN-ADDR.ARPA 可以是包含 ARPANET 数据的区域，而 26.IN-ADDR.ARPA 可以是 MILNET 的单独区域。 地址节点用于保存指向正常域空间中主主机名的指针。</em></p><p>Network numbers correspond to some non-terminal nodes at various depths in the IN-ADDR.ARPA domain, since Internet network numbers are either 1, 2, or 3 octets.  Network nodes are used to hold pointers to the primary host names of gateways attached to that network.  Since a gateway is, by definition, on more than one network, it will typically have two or more network nodes which point at it.  Gateways will also have host level pointers at their fully qualified addresses.<br><em>网络号对应于 IN-ADDR.ARPA 域中不同深度的一些非终端节点，因为互联网网络号是 1、2 或 3 个八位位组。 网络节点用于保存指向连接到该网络的网关的主要主机名的指针。 由于根据定义，网关位于多个网络上，因此它通常有两个或多个指向它的网络节点。 网关还将在其完全限定地址处拥有主机级指针。</em></p><p>Both the gateway pointers at network nodes and the normal host pointers at full address nodes use the PTR RR to point back to the primary domain names of the corresponding hosts.<br><em>网络节点上的网关指针和全地址节点上的普通主机指针都使用PTR RR来指向对应主机的主域名。</em></p><p>For example, the IN-ADDR.ARPA domain will contain information about the ISI gateway between net 10 and 26, an MIT gateway from net 10 to MIT’s net 18, and hosts A.ISI.EDU and MULTICS.MIT.EDU.  Assuming that ISI gateway has addresses 10.2.0.22 and 26.0.0.103, and a name MILNET-GW.ISI.EDU, and the MIT gateway has addresses 10.0.0.77 and 18.10.0.4 and a name GW.LCS.MIT.EDU, the domain database would contain:<br><em>例如，IN-ADDR.ARPA 域将包含有关网络 10 和 26 之间的 ISI 网关、从网络 10 到 MIT 的网络 18 的 MIT 网关以及主机 A.ISI.EDU 和 MULTICS.MIT.EDU 的信息。 假设 ISI 网关的地址为 10.2.0.22 和 26.0.0.103，名称为 MILNET-GW.ISI.EDU，MIT 网关的地址为 10.0.0.77 和 18.10.0.4，名称为 GW.LCS.MIT.EDU，则 域数据库将包含：</em></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">10</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.           PTR MILNET-GW<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">10</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.           PTR GW<span class="hljs-selector-class">.LCS</span><span class="hljs-selector-class">.MIT</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">18</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.           PTR GW<span class="hljs-selector-class">.LCS</span><span class="hljs-selector-class">.MIT</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">26</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.           PTR MILNET-GW<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">22.0</span>.<span class="hljs-number">2.10</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.    PTR MILNET-GW<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">103.0</span>.<span class="hljs-number">0.26</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.   PTR MILNET-GW<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">77.0</span>.<span class="hljs-number">0.10</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.    PTR GW<span class="hljs-selector-class">.LCS</span><span class="hljs-selector-class">.MIT</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">4.0</span>.<span class="hljs-number">10.18</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.    PTR GW<span class="hljs-selector-class">.LCS</span><span class="hljs-selector-class">.MIT</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">103.0</span>.<span class="hljs-number">3.26</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.   PTR A<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">6.0</span>.<span class="hljs-number">0.10</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.     PTR MULTICS<span class="hljs-selector-class">.MIT</span><span class="hljs-selector-class">.EDU</span>.<br></code></pre></td></tr></table></figure><p>Thus a program which wanted to locate gateways on net 10 would originate a query of the form QTYPE=PTR, QCLASS=IN, QNAME=10.IN-ADDR.ARPA.  It would receive two RRs in response:<br><em>因此，想要定位网络 10 上的网关的程序将发起 QTYPE=PTR、QCLASS=IN、QNAME=10.IN-ADDR.ARPA 形式的查询。 它将收到两个 RR 响应：</em></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">10</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.           PTR MILNET-GW<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br><span class="hljs-number">10</span><span class="hljs-selector-class">.IN-ADDR</span><span class="hljs-selector-class">.ARPA</span>.           PTR GW<span class="hljs-selector-class">.LCS</span><span class="hljs-selector-class">.MIT</span><span class="hljs-selector-class">.EDU</span>.<br></code></pre></td></tr></table></figure><p>The program could then originate QTYPE=A, QCLASS=IN queries for MILNET-GW.ISI.EDU. and GW.LCS.MIT.EDU. to discover the Internet addresses of these gateways.<br><em>然后，程序可以为 MILNET-GW.ISI.EDU 发起 QTYPE=A、QCLASS=IN 查询。 和 GW.LCS.MIT.EDU。 发现这些网关的互联网地址。</em></p><p>A resolver which wanted to find the host name corresponding to Internet host address 10.0.0.6 would pursue a query of the form QTYPE=PTR, QCLASS=IN, QNAME=6.0.0.10.IN-ADDR.ARPA, and would receive:<br><em>想要查找与 Internet 主机地址 10.0.0.6 相对应的主机名的解析器将执行 QTYPE=PTR、QCLASS=IN、QNAME=6.0.0.10.IN-ADDR.ARPA 形式的查询，并会收到：</em></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">6.0.0.10</span>.IN-ADDR.ARPA.     PTR MULTICS.MIT.EDU.<br></code></pre></td></tr></table></figure><p>Several cautions apply to the use of these services:<br><em>使用这些服务时需要注意一些注意事项：</em></p><ul><li>Since the IN-ADDR.ARPA special domain and the normal domain for a particular host or gateway will be in different zones, the possibility exists that that the data may be inconsistent.</li></ul><p>   <em>由于IN-ADDR.ARPA特殊域和特定主机或网关的普通域位于不同的区域，因此存在数据不一致的可能性。</em></p><ul><li>Gateways will often have two names in separate domains, only one of which can be primary.</li></ul><p>   <em>网关通常在不同的域中有两个名称，其中只有一个可以是主名称。</em></p><ul><li>Systems that use the domain database to initialize their routing tables must start with enough gateway information to guarantee that they can access the appropriate name server.</li></ul><p>   <em>使用域数据库初始化其路由表的系统必须以足够的网关信息开始，以保证它们可以访问适当的名称服务器。</em></p><ul><li>The gateway data only reflects the existence of a gateway in a manner equivalent to the current HOSTS.TXT file.  It doesn’t  replace the dynamic availability information from GGP or EGP.</li></ul><p>   <em>网关数据仅以与当前HOSTS.TXT文件等效的方式反映网关的存在。 它不会取代来自 GGP 或 EGP 的动态可用性信息。</em></p><h2 id="3-6-Defining-new-types-classes-and-special-namespaces"><a href="#3-6-Defining-new-types-classes-and-special-namespaces" class="headerlink" title="3.6. Defining new types, classes, and special namespaces"></a>3.6. Defining new types, classes, and special namespaces</h2><p>The previously defined types and classes are the ones in use as of the date of this memo.  New definitions should be expected.  This section makes some recommendations to designers considering additions to the existing facilities.  The mailing list <a href="mailto:&#x4e;&#65;&#77;&#x45;&#x44;&#x52;&#x4f;&#80;&#x50;&#x45;&#82;&#83;&#x40;&#83;&#x52;&#x49;&#x2d;&#78;&#x49;&#x43;&#x2e;&#x41;&#82;&#80;&#x41;">&#x4e;&#65;&#77;&#x45;&#x44;&#x52;&#x4f;&#80;&#x50;&#x45;&#82;&#83;&#x40;&#83;&#x52;&#x49;&#x2d;&#78;&#x49;&#x43;&#x2e;&#x41;&#82;&#80;&#x41;</a> is the forum where general discussion of design issues takes place.</p><p>In general, a new type is appropriate when new information is to be added to the database about an existing object, or we need new data formats for some totally new object.  Designers should attempt to define types and their RDATA formats that are generally applicable to all classes, and which avoid duplication of information.  New classes are appropriate when the DNS is to be used for a new protocol, etc which requires new class-specific data formats, or when a copy of the existing name space is desired, but a separate management domain is necessary.</p><p>New types and classes need mnemonics for master files; the format of the master files requires that the mnemonics for type and class be disjoint.</p><p>TYPE and CLASS values must be a proper subset of QTYPEs and QCLASSes respectively.</p><p>The present system uses multiple RRs to represent multiple values of a type rather than storing multiple values in the RDATA section of a single RR.  This is less efficient for most applications, but does keep RRs shorter.  The multiple RRs assumption is incorporated in some experimental work on dynamic update methods.</p><p>The present system attempts to minimize the duplication of data in the database in order to insure consistency.  Thus, in order to find the address of the host for a mail exchange, you map the mail domain name to a host name, then the host name to addresses, rather than a direct mapping to host address.  This approach is preferred because it avoids the opportunity for inconsistency.</p><p>In defining a new type of data, multiple RR types should not be used to create an ordering between entries or express different formats for equivalent bindings, instead this information should be carried in the body of the RR and a single type used.  This policy avoids problems with caching multiple types and defining QTYPEs to match multiple types.</p><p>For example, the original form of mail exchange binding used two RR types one to represent a “closer” exchange (MD) and one to represent a “less close” exchange (MF).  The difficulty is that the presence of one RR type in a cache doesn’t convey any information about the other because the query which acquired the cached information might have used a QTYPE of MF, MD, or MAILA (which matched both).  The redesigned service used a single type (MX) with a “preference” value in the RDATA section which can order different RRs.  However, if any MX RRs are found in the cache, then all should be there.</p><h1 id="4-MESSAGES"><a href="#4-MESSAGES" class="headerlink" title="4.  MESSAGES"></a>4.  MESSAGES</h1><h2 id="4-1-Format"><a href="#4-1-Format" class="headerlink" title="4.1.  Format"></a>4.1.  Format</h2><p>All communications inside of the domain protocol are carried in a single format called a message.  The top level format of message is divided into 5 sections (some of which are empty in certain cases) shown below:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------------------+</span><br><span class="hljs-section">|        Header       |</span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">|       Question      | the question for the name server</span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">|        Answer       | RRs answering the question</span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">|      Authority      | RRs pointing toward an authority</span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">|      Additional     | RRs holding additional information</span><br><span class="hljs-section">+---------------------+</span><br></code></pre></td></tr></table></figure><p>The header section is always present.  The header includes fields that specify which of the remaining sections are present, and also specify whether the message is a query or a response, a standard query or some other opcode, etc.</p><p>The names of the sections after the header are derived from their use in standard queries.  The question section contains fields that describe a question to a name server.  These fields are a query type (QTYPE), a query class (QCLASS), and a query domain name (QNAME).  The last three sections have the same format: a possibly empty list of concatenated resource records (RRs).  The answer section contains RRs that answer the question; the authority section contains RRs that point toward an authoritative name server; the additional records section contains RRs which relate to the query, but are not strictly answers for the question.</p><h3 id="4-1-1-Header-section-format"><a href="#4-1-1-Header-section-format" class="headerlink" title="4.1.1. Header section format"></a>4.1.1. Header section format</h3><p>The header contains the following fields:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">                                1  1  1  1  1  1</span><br><span class="hljs-section">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                      ID                       |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    QDCOUNT                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    ANCOUNT                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    NSCOUNT                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    ARCOUNT                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>ID              A 16 bit identifier assigned by the program that generates any kind of query.  This identifier is copied the corresponding reply and can be used by the requester to match up replies to outstanding queries.</p><p>QR              A one bit field that specifies whether this message is a query (0), or a response (1).</p><p>OPCODE          A four bit field that specifies kind of query in this message.  This value is set by the originator of a query and copied into the response.  The values are:</p><div class="code-wrapper"><pre><code class="hljs">            0                 a standard query (QUERY)            1               an inverse query (IQUERY)            2                a server status request (STATUS)            3-15            reserved for future use</code></pre></div><p>AA              Authoritative Answer - this bit is valid in responses, and specifies that the responding name server is an authority for the domain name in question section.</p><div class="code-wrapper"><pre><code class="hljs">            Note that the contents of the answer section may have multiple owner names because of aliases.  The AA bit corresponds to the name which matches the query name, or the first owner name in the answer section.</code></pre></div><p>TC              TrunCation - specifies that this message was truncated due to length greater than that permitted on the transmission channel.</p><p>RD              Recursion Desired - this bit may be set in a query and is copied into the response.  If RD is set, it directs the name server to pursue the query recursively. Recursive query support is optional.</p><p>RA              Recursion Available - this be is set or cleared in a response, and denotes whether recursive query support is available in the name server.</p><p>Z               Reserved for future use.  Must be zero in all queries and responses.</p><p>RCODE           Response code - this 4 bit field is set as part of responses.  The values have the following interpretation:</p><div class="code-wrapper"><pre><code class="hljs">            0               No error condition            1               Format error - The name server was unable to interpret the query.            2               Server failure - The name server was unable to process this query due to a problem with the name server.            3               Name Error - Meaningful only for responses from an authoritative name server, this code signifies that the domain name referenced in the query does not exist.            4               Not Implemented - The name server does not support the requested kind of query.            5               Refused - The name server refuses to perform the specified operation for policy reasons.  For example, a name server may not wish to provide the information to the particular requester, or a name server may not wish to perform a particular operation (e.g., zone transfer) for particular data.            6-15            Reserved for future use.</code></pre></div><p>QDCOUNT         an unsigned 16 bit integer specifying the number of entries in the question section.</p><p>ANCOUNT         an unsigned 16 bit integer specifying the number of resource records in the answer section.</p><p>NSCOUNT         an unsigned 16 bit integer specifying the number of name server resource records in the authority records section.</p><p>ARCOUNT         an unsigned 16 bit integer specifying the number of resource records in the additional records section.</p><h3 id="4-1-2-Question-section-format"><a href="#4-1-2-Question-section-format" class="headerlink" title="4.1.2. Question section format"></a>4.1.2. Question section format</h3><p>The question section is used to carry the “question” in most queries, i.e., the parameters that define what is being asked.  The section contains QDCOUNT (usually 1) entries, each of the following format:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">                                1  1  1  1  1  1</span><br><span class="hljs-section">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                                               |<br>/                     QNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                     QTYPE                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                     QCLASS                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>QNAME           a domain name represented as a sequence of labels, where each label consists of a length octet followed by that number of octets.  The domain name terminates with the zero length octet for the null label of the root.  Note that this field may be an odd number of octets; no padding is used.</p><p>QTYPE           a two octet code which specifies the type of the query. The values for this field include all codes valid for a TYPE field, together with some more general codes which can match more than one type of RR.</p><p>QCLASS          a two octet code that specifies the class of the query. For example, the QCLASS field is IN for the Internet.</p><h3 id="4-1-3-Resource-record-format"><a href="#4-1-3-Resource-record-format" class="headerlink" title="4.1.3. Resource record format"></a>4.1.3. Resource record format</h3><p>The answer, authority, and additional sections all share the same format: a variable number of resource records, where the number of records is specified in the corresponding count field in the header. Each resource record has the following format:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">                                1  1  1  1  1  1</span><br><span class="hljs-section">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                                               |<br>/                                               /<br>/                      NAME                     /<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                      TYPE                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                     CLASS                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                      TTL                      |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                   RDLENGTH                    |<br><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--|<br>/                     RDATA                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>where:</p><p>NAME            a domain name to which this resource record pertains. </p><p>TYPE            two octets containing one of the RR type codes.  This field specifies the meaning of the data in the RDATA field.</p><p>CLASS           two octets which specify the class of the data in the RDATA field.</p><p>TTL             a 32 bit unsigned integer that specifies the time interval (in seconds) that the resource record may be cached before it should be discarded.  Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached.</p><p>RDLENGTH        an unsigned 16 bit integer that specifies the length in octets of the RDATA field.</p><p>RDATA           a variable length string of octets that describes the resource.  The format of this information varies according to the TYPE and CLASS of the resource record. For example, the if the TYPE is A and the CLASS is IN, the RDATA field is a 4 octet ARPA Internet address.</p><h3 id="4-1-4-Message-compression"><a href="#4-1-4-Message-compression" class="headerlink" title="4.1.4.  Message compression"></a>4.1.4.  Message compression</h3><p>In order to reduce the size of messages, the domain system utilizes a compression scheme which eliminates the repetition of domain names in a message.  In this scheme, an entire domain name or a list of labels at the end of a domain name is replaced with a pointer to a prior occurance of the same name.</p><p>The pointer takes the form of a two octet sequence:</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">| 1  1|                OFFSET                   |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>The first two bits are ones.  This allows a pointer to be distinguished from a label, since the label must begin with two zero bits because labels are restricted to 63 octets or less.  (The 10 and 01 combinations are reserved for future use.)  The OFFSET field specifies an offset from the start of the message (i.e., the first octet of the ID field in the domain header).  A zero offset specifies the first byte of the ID field, etc.</p><p>The compression scheme allows a domain name in a message to be represented as either:</p><ul><li><p>a sequence of labels ending in a zero octet</p></li><li><p>a pointer</p></li><li><p>a sequence of labels ending with a pointer</p></li></ul><p>Pointers can only be used for occurances of a domain name where the format is not class specific.  If this were not the case, a name server or resolver would be required to know the format of all RRs it handled. As yet, there are no such cases, but they may occur in future RDATA formats.</p><p>If a domain name is contained in a part of the message subject to a length field (such as the RDATA section of an RR), and compression is used, the length of the compressed name is used in the length calculation, rather than the length of the expanded name.</p><p>Programs are free to avoid using pointers in messages they generate, although this will reduce datagram capacity, and may cause truncation. However all programs are required to understand arriving messages that contain pointers.</p><p>For example, a datagram might need to use the domain names F.ISI.ARPA, FOO.F.ISI.ARPA, ARPA, and the root.  Ignoring the other fields of the message, these domain names might be represented as:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>20 |<span class="hljs-string">           1           </span>|<span class="hljs-string">           F           </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>22 |<span class="hljs-string">           3           </span>|<span class="hljs-string">           I           </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>24 |<span class="hljs-string">           S           </span>|<span class="hljs-string">           I           </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>26 |<span class="hljs-string">           4           </span>|<span class="hljs-string">           A           </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>28 |<span class="hljs-string">           R           </span>|<span class="hljs-string">           P           </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>30 |<span class="hljs-string">           A           </span>|<span class="hljs-string">           0           </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br><br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>40 |<span class="hljs-string">           3           </span>|<span class="hljs-string">           F           </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>42 |<span class="hljs-string">           O           </span>|<span class="hljs-string">           O           </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>44 |<span class="hljs-string"> 1  1</span>|<span class="hljs-string">                20                       </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br><br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>64 |<span class="hljs-string"> 1  1</span>|<span class="hljs-string">                26                       </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br><br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br>92 |<span class="hljs-string">           0           </span>|<span class="hljs-string">                       </span>|<br>   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br></code></pre></td></tr></table></figure><p>The domain name for F.ISI.ARPA is shown at offset 20.  The domain name FOO.F.ISI.ARPA is shown at offset 40; this definition uses a pointer to concatenate a label for FOO to the previously defined F.ISI.ARPA.  The domain name ARPA is defined at offset 64 using a pointer to the ARPA component of the name F.ISI.ARPA at 20; note that this pointer relies on ARPA being the last label in the string at 20.  The root domain name is defined by a single octet of zeros at 92; the root domain name has no labels.</p><h2 id="4-2-Transport"><a href="#4-2-Transport" class="headerlink" title="4.2.  Transport"></a>4.2.  Transport</h2><p>The DNS assumes that messages will be transmitted as datagrams or in a byte stream carried by a virtual circuit.  While virtual circuits can be used for any DNS activity, datagrams are preferred for queries due to their lower overhead and better performance.  Zone refresh activities must use virtual circuits because of the need for reliable transfer.</p><p>The Internet supports name server access using TCP [RFC-793] on server port 53 (decimal) as well as datagram access using UDP [RFC-768] on UDP port 53 (decimal).</p><h3 id="4-2-1-UDP-usage"><a href="#4-2-1-UDP-usage" class="headerlink" title="4.2.1. UDP usage"></a>4.2.1. UDP usage</h3><p>Messages sent using UDP user server port 53 (decimal).</p><p>Messages carried by UDP are restricted to 512 bytes (not counting the IP or UDP headers).  Longer messages are truncated and the TC bit is set in the header.</p><p>UDP is not acceptable for zone transfers, but is the recommended method for standard queries in the Internet.  Queries sent using UDP may be lost, and hence a retransmission strategy is required.  Queries or their responses may be reordered by the network, or by processing in name servers, so resolvers should not depend on them being returned in order.</p><p>The optimal UDP retransmission policy will vary with performance of the Internet and the needs of the client, but the following are recommended:</p><ul><li><p>The client should try other servers and server addresses before repeating a query to a specific address of a server.</p></li><li><p>The retransmission interval should be based on prior statistics if possible.  Too aggressive retransmission can easily slow responses for the community at large.  Depending on how well connected the client is to its expected servers, the minimum retransmission interval should be 2-5 seconds.</p></li></ul><p>More suggestions on server selection and retransmission policy can be found in the resolver section of this memo.</p><h3 id="4-2-2-TCP-usage"><a href="#4-2-2-TCP-usage" class="headerlink" title="4.2.2. TCP usage"></a>4.2.2. TCP usage</h3><p> Messages sent over TCP connections use server port 53 (decimal).  The message is prefixed with a two byte length field which gives the message length, excluding the two byte length field.  This length field allows the low-level processing to assemble a complete message before beginning to parse it.</p><p>Several connection management policies are recommended:</p><ul><li><p>The server should not block other activities waiting for TCP data.</p></li><li><p>The server should support multiple connections.</p></li><li><p>The server should assume that the client will initiate connection closing, and should delay closing its end of the connection until all outstanding client requests have been satisfied.</p></li><li><p>If the server needs to close a dormant connection to reclaim resources, it should wait until the connection has been idle for a period on the order of two minutes.  In particular, the server should allow the SOA and AXFR request sequence (which begins a refresh operation) to be made on a single connection. Since the server would be unable to answer queries anyway, a unilateral close or reset may be used instead of a graceful close.</p></li></ul><h1 id="5-MASTER-FILES"><a href="#5-MASTER-FILES" class="headerlink" title="5. MASTER FILES"></a>5. MASTER FILES</h1><p>Master files are text files that contain RRs in text form.  Since the contents of a zone can be expressed in the form of a list of RRs a master file is most often used to define a zone, though it can be used to list a cache’s contents.  Hence, this section first discusses the format of RRs in a master file, and then the special considerations when a master file is used to create a zone in some name server.</p><h2 id="5-1-Format"><a href="#5-1-Format" class="headerlink" title="5.1. Format"></a>5.1. Format</h2><p>The format of these files is a sequence of entries.  Entries are predominantly line-oriented, though parentheses can be used to continue a list of items across a line boundary, and text literals can contain CRLF within the text.  Any combination of tabs and spaces act as a delimiter between the separate items that make up an entry.  The end of any line in the master file can end with a comment.  The comment starts with a “;” (semicolon).</p><p>The following entries are defined:</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">&lt;blank&gt;<span class="hljs-meta">[&lt;comment&gt;]</span><br><br>$ORIGIN &lt;domain-name&gt; <span class="hljs-meta">[&lt;comment&gt;]</span><br><br>$INCLUDE &lt;file-name&gt; <span class="hljs-meta">[&lt;domain-name&gt;]</span> <span class="hljs-meta">[&lt;comment&gt;]</span><br><br>&lt;domain-name&gt;&lt;rr&gt; <span class="hljs-meta">[&lt;comment&gt;]</span><br><br>&lt;blank&gt;&lt;rr&gt; <span class="hljs-meta">[&lt;comment&gt;]</span><br></code></pre></td></tr></table></figure><p>Blank lines, with or without comments, are allowed anywhere in the file.</p><p>Two control entries are defined: $ORIGIN and $INCLUDE.  $ORIGIN is followed by a domain name, and resets the current origin for relative domain names to the stated name.  $INCLUDE inserts the named file into the current file, and may optionally specify a domain name that sets the relative domain name origin for the included file.  $INCLUDE may also have a comment.  Note that a $INCLUDE entry never changes the relative origin of the parent file, regardless of changes to the relative origin made within the included file.</p><p>The last two forms represent RRs.  If an entry for an RR begins with a blank, then the RR is assumed to be owned by the last stated owner.  If an RR entry begins with a <domain-name>, then the owner name is reset.</p><p><rr> contents take one of the following forms:</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-meta">[&lt;TTL&gt;]</span> <span class="hljs-meta">[&lt;class&gt;]</span> &lt;<span class="hljs-class"><span class="hljs-keyword">type</span>&gt; &lt;RDATA&gt;</span><br><br><span class="hljs-meta">[&lt;class&gt;]</span> <span class="hljs-meta">[&lt;TTL&gt;]</span> &lt;<span class="hljs-class"><span class="hljs-keyword">type</span>&gt; &lt;RDATA&gt;</span><br></code></pre></td></tr></table></figure><p>The RR begins with optional TTL and class fields, followed by a type and RDATA field appropriate to the type and class.  Class and type use the standard mnemonics, TTL is a decimal integer.  Omitted class and TTL values are default to the last explicitly stated values.  Since type and class mnemonics are disjoint, the parse is unique.  (Note that this order is different from the order used in examples and the order used in the actual RRs; the given order allows easier parsing and defaulting.)</p><p><domain-name>s make up a large share of the data in the master file.<br>The labels in the domain name are expressed as character strings and separated by dots.  Quoting conventions allow arbitrary characters to be stored in domain names.  Domain names that end in a dot are called absolute, and are taken as complete.  Domain names which do not end in a dot are called relative; the actual domain name is the concatenation of the relative part with an origin specified in a $ORIGIN, $INCLUDE, or as an argument to the master file loading routine.  A relative name is an error when no origin is available.</p><p><character-string> is expressed in one or two ways: as a contiguous set of characters without interior spaces, or as a string beginning with a “and ending with a “.  Inside a “ delimited string any character can occur, except for a “ itself, which must be quoted using \ (back slash).</p><p>Because these files are text files several special encodings are necessary to allow arbitrary data to be loaded.  In particular:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">                <span class="hljs-keyword">of</span> the root.<br><br>@               A free standing @ <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> denote the <span class="hljs-keyword">current</span> origin.<br><br>\X              <span class="hljs-keyword">where</span> X <span class="hljs-keyword">is</span> <span class="hljs-keyword">any</span> <span class="hljs-type">character</span> other than a digit (<span class="hljs-number">0</span><span class="hljs-number">-9</span>), <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> <span class="hljs-keyword">quote</span> that <span class="hljs-type">character</span> so that its special meaning does <span class="hljs-keyword">not</span> apply.  <span class="hljs-keyword">For</span> example, &quot;\.&quot; can be used <span class="hljs-keyword">to</span> place a dot <span class="hljs-type">character</span> <span class="hljs-keyword">in</span> a label.<br><br>\DDD            <span class="hljs-keyword">where</span> <span class="hljs-keyword">each</span> D <span class="hljs-keyword">is</span> a digit <span class="hljs-keyword">is</span> the octet corresponding <span class="hljs-keyword">to</span> the <span class="hljs-type">decimal</span> number described <span class="hljs-keyword">by</span> DDD.  The resulting octet <span class="hljs-keyword">is</span> assumed <span class="hljs-keyword">to</span> be <span class="hljs-type">text</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> checked <span class="hljs-keyword">for</span> special meaning.<br><br>( )             Parentheses are used <span class="hljs-keyword">to</span> <span class="hljs-keyword">group</span> data that crosses a <span class="hljs-type">line</span> boundary.  <span class="hljs-keyword">In</span> effect, <span class="hljs-type">line</span> terminations are <span class="hljs-keyword">not</span> recognized <span class="hljs-keyword">within</span> parentheses.<br><br>;               Semicolon <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> <span class="hljs-keyword">start</span> a <span class="hljs-keyword">comment</span>; the remainder <span class="hljs-keyword">of</span> the <span class="hljs-type">line</span> <span class="hljs-keyword">is</span> ignored.<br></code></pre></td></tr></table></figure><h2 id="5-2-Use-of-master-files-to-define-zones"><a href="#5-2-Use-of-master-files-to-define-zones" class="headerlink" title="5.2. Use of master files to define zones"></a>5.2. Use of master files to define zones</h2><p>When a master file is used to load a zone, the operation should be suppressed if any errors are encountered in the master file.  The rationale for this is that a single error can have widespread consequences.  For example, suppose that the RRs defining a delegation have syntax errors; then the server will return authoritative name errors for all names in the subzone (except in the case where the subzone is also present on the server).</p><p>Several other validity checks that should be performed in addition to insuring that the file is syntactically correct:</p><ol><li><p>All RRs in the file should have the same class.</p></li><li><p>Exactly one SOA RR should be present at the top of the zone.</p></li><li><p>If delegations are present and glue information is required, it should be present.</p></li><li><p>Information present outside of the authoritative nodes in the zone should be glue information, rather than the result of an origin or similar error.</p></li></ol><h2 id="5-3-Master-file-example"><a href="#5-3-Master-file-example" class="headerlink" title="5.3. Master file example"></a>5.3. Master file example</h2><p>The following is an example file which might be used to define the ISI.EDU zone.and is loaded with an origin of ISI.EDU:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dns">@   <span class="hljs-keyword">IN</span>  <span class="hljs-keyword">SOA</span>     VENERA      Action\.domains (<br>                                 <span class="hljs-number">20</span>     <span class="hljs-comment">; SERIAL</span><br>                                 <span class="hljs-number">7200</span>   <span class="hljs-comment">; REFRESH</span><br>                                 <span class="hljs-number">600</span>    <span class="hljs-comment">; RETRY</span><br>                                 <span class="hljs-number">3600000</span><span class="hljs-comment">; EXPIRE</span><br>                                 <span class="hljs-number">60</span>)    <span class="hljs-comment">; MINIMUM</span><br><br>        <span class="hljs-keyword">NS</span>      <span class="hljs-keyword">A</span>.ISI.EDU.<br>        <span class="hljs-keyword">NS</span>      VENERA<br>        <span class="hljs-keyword">NS</span>      VAXA<br>        <span class="hljs-keyword">MX</span>      <span class="hljs-number">10</span>      VENERA<br>        <span class="hljs-keyword">MX</span>      <span class="hljs-number">20</span>      VAXA<br><br><span class="hljs-keyword">A</span>       <span class="hljs-keyword">A</span>       <span class="hljs-number">26.3.0.103</span><br><br>VENERA  <span class="hljs-keyword">A</span>       <span class="hljs-number">10.1.0.52</span><br>        <span class="hljs-keyword">A</span>       <span class="hljs-number">128.9.0.32</span><br><br>VAXA    <span class="hljs-keyword">A</span>       <span class="hljs-number">10.2.0.27</span><br>        <span class="hljs-keyword">A</span>       <span class="hljs-number">128.9.0.33</span><br><br><br><span class="hljs-meta">$INCLUDE</span> &lt;SUBSYS&gt;ISI-MAILBOXES.<span class="hljs-keyword">TXT</span><br></code></pre></td></tr></table></figure><p>Where the file <SUBSYS>ISI-MAILBOXES.TXT is:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">MOE     MB      A<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br>LARRY   MB      A<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br>CURLEY  MB      A<span class="hljs-selector-class">.ISI</span><span class="hljs-selector-class">.EDU</span>.<br>STOOGES MG      MOE<br>        MG      LARRY<br>        MG      CURLEY<br></code></pre></td></tr></table></figure><p>Note the use of the \ character in the SOA RR to specify the responsible person mailbox “<a href="mailto:&#x41;&#99;&#x74;&#105;&#111;&#x6e;&#46;&#100;&#111;&#109;&#x61;&#x69;&#110;&#x73;&#x40;&#x45;&#46;&#73;&#x53;&#x49;&#46;&#69;&#68;&#x55;">&#x41;&#99;&#x74;&#105;&#111;&#x6e;&#46;&#100;&#111;&#109;&#x61;&#x69;&#110;&#x73;&#x40;&#x45;&#46;&#73;&#x53;&#x49;&#46;&#69;&#68;&#x55;</a>“.</p><h1 id="6-NAME-SERVER-IMPLEMENTATION"><a href="#6-NAME-SERVER-IMPLEMENTATION" class="headerlink" title="6. NAME SERVER IMPLEMENTATION"></a>6. NAME SERVER IMPLEMENTATION</h1><h2 id="6-1-Architecture"><a href="#6-1-Architecture" class="headerlink" title="6.1. Architecture"></a>6.1. Architecture</h2><p>The optimal structure for the name server will depend on the host operating system and whether the name server is integrated with resolver operations, either by supporting recursive service, or by sharing its database with a resolver.  This section discusses implementation considerations for a name server which shares a database with a resolver, but most of these concerns are present in any name server.</p><h3 id="6-1-1-Control"><a href="#6-1-1-Control" class="headerlink" title="6.1.1. Control"></a>6.1.1. Control</h3><p>A name server must employ multiple concurrent activities, whether they are implemented as separate tasks in the host’s OS or multiplexing inside a single name server program.  It is simply not acceptable for a name server to block the service of UDP requests while it waits for TCP data for refreshing or query activities.  Similarly, a name server should not attempt to provide recursive service without processing such requests in parallel, though it may choose to serialize requests from a single client, or to regard identical requests from the same client as duplicates.  A name server should not substantially delay requests while it reloads a zone from master files or while it incorporates a newly refreshed zone into its database.</p><h3 id="6-1-2-Database"><a href="#6-1-2-Database" class="headerlink" title="6.1.2. Database"></a>6.1.2. Database</h3><p>While name server implementations are free to use any internal data structures they choose, the suggested structure consists of three major parts:</p><ul><li><p>A “catalog” data structure which lists the zones available to this server, and a “pointer” to the zone data structure.  The main purpose of this structure is to find the nearest ancestor zone, if any, for arriving standard queries.</p></li><li><p>Separate data structures for each of the zones held by the name server.</p></li><li><p>A data structure for cached data. (or perhaps separate caches for different classes)</p></li></ul><p>All of these data structures can be implemented an identical tree structure format, with different data chained off the nodes in different parts: in the catalog the data is pointers to zones, while in the zone and cache data structures, the data will be RRs.  In designing the tree framework the designer should recognize that query processing will need to traverse the tree using case-insensitive label comparisons; and that in real data, a few nodes have a very high branching factor (100-1000 or more), but the vast majority have a very low branching factor (0-1).</p><p>One way to solve the case problem is to store the labels for each node in two pieces: a standardized-case representation of the label where all ASCII characters are in a single case, together with a bit mask that denotes which characters are actually of a different case.  The branching factor diversity can be handled using a simple linked list for a node until the branching factor exceeds some threshold, and transitioning to a hash structure after the threshold is exceeded.  In any case, hash structures used to store tree sections must insure that hash functions and procedures preserve the casing conventions of the DNS.</p><p>The use of separate structures for the different parts of the database is motivated by several factors:</p><ul><li><p>The catalog structure can be an almost static structure that need change only when the system administrator changes the zones supported by the server.  This structure can also be used to store parameters used to control refreshing activities.</p></li><li><p>The individual data structures for zones allow a zone to be replaced simply by changing a pointer in the catalog.  Zone refresh operations can build a new structure and, when complete, splice it into the database via a simple pointer replacement.  It is very important that when a zone is refreshed, queries should not use old and new data simultaneously.</p></li><li><p>With the proper search procedures, authoritative data in zones will always “hide”, and hence take precedence over, cached data.</p></li><li><p>Errors in zone definitions that cause overlapping zones, etc., may cause erroneous responses to queries, but problem determination is simplified, and the contents of one “bad” zone can’t corrupt another.</p></li><li><p>Since the cache is most frequently updated, it is most vulnerable to corruption during system restarts.  It can also become full of expired RR data.  In either case, it can easily be discarded without disturbing zone data.</p></li></ul><p>A major aspect of database design is selecting a structure which allows the name server to deal with crashes of the name server’s host.  State information which a name server should save across system crashes includes the catalog structure (including the state of refreshing for each zone) and the zone data itself.</p><h3 id="6-1-3-Time"><a href="#6-1-3-Time" class="headerlink" title="6.1.3. Time"></a>6.1.3. Time</h3><p>Both the TTL data for RRs and the timing data for refreshing activities depends on 32 bit timers in units of seconds.  Inside the database, refresh timers and TTLs for cached data conceptually “count down”, while data in the zone stays with constant TTLs.</p><p>A recommended implementation strategy is to store time in two ways:  as a relative increment and as an absolute time.  One way to do this is to use positive 32 bit numbers for one type and negative numbers for the other.  The RRs in zones use relative times; the refresh timers and cache data use absolute times.  Absolute numbers are taken with respect to some known origin and converted to relative values when placed in the response to a query.  When an absolute TTL is negative after conversion to relative, then the data is expired and should be ignored.</p><h2 id="6-2-Standard-query-processing"><a href="#6-2-Standard-query-processing" class="headerlink" title="6.2. Standard query processing"></a>6.2. Standard query processing</h2><p>The major algorithm for standard query processing is presented in [RFC-1034].</p><p>When processing queries with QCLASS=*, or some other QCLASS which matches multiple classes, the response should never be authoritative unless the server can guarantee that the response covers all classes.</p><p>When composing a response, RRs which are to be inserted in the additional section, but duplicate RRs in the answer or authority sections, may be omitted from the additional section.</p><p>When a response is so long that truncation is required, the truncation should start at the end of the response and work forward in the datagram.  Thus if there is any data for the authority section, the answer section is guaranteed to be unique.</p><p>The MINIMUM value in the SOA should be used to set a floor on the TTL of data distributed from a zone.  This floor function should be done when the data is copied into a response.  This will allow future dynamic update protocols to change the SOA MINIMUM field without ambiguous semantics.</p><h2 id="6-3-Zone-refresh-and-reload-processing"><a href="#6-3-Zone-refresh-and-reload-processing" class="headerlink" title="6.3. Zone refresh and reload processing"></a>6.3. Zone refresh and reload processing</h2><p>In spite of a server’s best efforts, it may be unable to load zone data from a master file due to syntax errors, etc., or be unable to refresh a zone within the its expiration parameter.  In this case, the name server should answer queries as if it were not supposed to possess the zone.</p><p>If a master is sending a zone out via AXFR, and a new version is created during the transfer, the master should continue to send the old version if possible.  In any case, it should never send part of one version and part of another.  If completion is not possible, the master should reset the connection on which the zone transfer is taking place.</p><h2 id="6-4-Inverse-queries-Optional"><a href="#6-4-Inverse-queries-Optional" class="headerlink" title="6.4. Inverse queries (Optional)"></a>6.4. Inverse queries (Optional)</h2><p>Inverse queries are an optional part of the DNS.  Name servers are not required to support any form of inverse queries.  If a name server receives an inverse query that it does not support, it returns an error response with the “Not Implemented” error set in the header.  While inverse query support is optional, all name servers must be at least able to return the error response.</p><h3 id="6-4-1-The-contents-of-inverse-queries-and-responses"><a href="#6-4-1-The-contents-of-inverse-queries-and-responses" class="headerlink" title="6.4.1. The contents of inverse queries and responses."></a>6.4.1. The contents of inverse queries and responses.</h3><p>Inverse queries reverse the mappings performed by standard query operations; while a standard query maps a domain name to a resource, an inverse query maps a resource to a domain name.  For example, a standard query might bind a domain name to a host address; the corresponding inverse query binds the host address to a domain name.</p><p>Inverse queries take the form of a single RR in the answer section of the message, with an empty question section.  The owner name of the query RR and its TTL are not significant.  The response carries questions in the question section which identify all names possessing the query RR WHICH THE NAME SERVER KNOWS.  Since no name server knows about all of the domain name space, the response can never be assumed to be complete.  Thus inverse queries are primarily useful for database management and debugging activities.  Inverse queries are NOT an acceptable method of mapping host addresses to host names; use the IN-ADDR.ARPA domain instead.</p><p>Where possible, name servers should provide case-insensitive comparisons for inverse queries.  Thus an inverse query asking for an MX RR of “Venera.isi.edu” should get the same response as a query for “VENERA.ISI.EDU”; an inverse query for HINFO RR “IBM-PC UNIX” should produce the same result as an inverse query for “IBM-pc unix”.  However, this cannot be guaranteed because name servers may possess RRs that contain character strings but the name server does not know that the data is character.</p><p>When a name server processes an inverse query, it either returns:</p><ol><li><p>zero, one, or multiple domain names for the specified resource as QNAMEs in the question section</p></li><li><p>an error code indicating that the name server doesn’t support inverse mapping of the specified resource type.</p></li></ol><p>When the response to an inverse query contains one or more QNAMEs, the owner name and TTL of the RR in the answer section which defines the inverse query is modified to exactly match an RR found at the first QNAME.</p><p>RRs returned in the inverse queries cannot be cached using the same mechanism as is used for the replies to standard queries.  One reason for this is that a name might have multiple RRs of the same type, and only one would appear.  For example, an inverse query for a single address of a multiply homed host might create the impression that only one address existed.</p><h3 id="6-4-2-Inverse-query-and-response-example"><a href="#6-4-2-Inverse-query-and-response-example" class="headerlink" title="6.4.2. Inverse query and response example"></a>6.4.2. Inverse query and response example</h3><p>The overall structure of an inverse query for retrieving the domain name that corresponds to Internet address 10.1.0.52 is shown below:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                +-----------------------------------------+<br>  Header        |<span class="hljs-string">          OPCODE=IQUERY, ID=997          </span>|<br>                +-----------------------------------------+<br> Question       |<span class="hljs-string">                 &lt;empty&gt;                 </span>|<br>                +-----------------------------------------+<br>  Answer        |<span class="hljs-string">        &lt;anyname&gt; A IN 10.1.0.52         </span>|<br>                +-----------------------------------------+<br> Authority      |<span class="hljs-string">                 &lt;empty&gt;                 </span>|<br>                +-----------------------------------------+<br>Additional      |<span class="hljs-string">                 &lt;empty&gt;                 </span>|<br>                +-----------------------------------------+<br></code></pre></td></tr></table></figure><p>This query asks for a question whose answer is the Internet style address 10.1.0.52.  Since the owner name is not known, any domain name can be used as a placeholder (and is ignored).  A single octet of zero, signifying the root, is usually used because it minimizes the length of the message.  The TTL of the RR is not significant.<br>The response to this query might be:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                +-----------------------------------------+<br>  Header        |<span class="hljs-string">         OPCODE=RESPONSE, ID=997         </span>|<br>                +-----------------------------------------+<br> Question       |<span class="hljs-string">QTYPE=A, QCLASS=IN, QNAME=VENERA.ISI.EDU </span>|<br>                +-----------------------------------------+<br>  Answer        |<span class="hljs-string">  VENERA.ISI.EDU  A IN 10.1.0.52         </span>|<br>                +-----------------------------------------+<br> Authority      |<span class="hljs-string">                 &lt;empty&gt;                 </span>|<br>                +-----------------------------------------+<br>Additional      |<span class="hljs-string">                 &lt;empty&gt;                 </span>|<br>                +-----------------------------------------+<br></code></pre></td></tr></table></figure><p>Note that the QTYPE in a response to an inverse query is the same as the TYPE field in the answer section of the inverse query.  Responses to inverse queries may contain multiple questions when the inverse is not unique.  If the question section in the response is not empty, then the RR in the answer section is modified to correspond to be an exact copy of an RR at the first QNAME.</p><h3 id="6-4-3-Inverse-query-processing"><a href="#6-4-3-Inverse-query-processing" class="headerlink" title="6.4.3. Inverse query processing"></a>6.4.3. Inverse query processing</h3><p>Name servers that support inverse queries can support these operations through exhaustive searches of their databases, but this becomes impractical as the size of the database increases.  An alternative approach is to invert the database according to the search key.</p><p>For name servers that support multiple zones and a large amount of data, the recommended approach is separate inversions for each zone.  When a particular zone is changed during a refresh, only its inversions need to be redone.</p><p>Support for transfer of this type of inversion may be included in future versions of the domain system, but is not supported in this version.</p><h2 id="6-5-Completion-queries-and-responses"><a href="#6-5-Completion-queries-and-responses" class="headerlink" title="6.5. Completion queries and responses"></a>6.5. Completion queries and responses</h2><p>The optional completion services described in RFC-882 and RFC-883 have been deleted.  Redesigned services may become available in the future.</p><h1 id="7-RESOLVER-IMPLEMENTATION-解析器实现"><a href="#7-RESOLVER-IMPLEMENTATION-解析器实现" class="headerlink" title="7. RESOLVER IMPLEMENTATION(解析器实现)"></a>7. RESOLVER IMPLEMENTATION(解析器实现)</h1><p>The top levels of the recommended resolver algorithm are discussed in [RFC-1034].  This section discusses implementation details assuming the database structure suggested in the name server implementation section of this memo.</p><h2 id="7-1-Transforming-a-user-request-into-a-query-将用户请求转换为查询"><a href="#7-1-Transforming-a-user-request-into-a-query-将用户请求转换为查询" class="headerlink" title="7.1. Transforming a user request into a query(将用户请求转换为查询)"></a>7.1. Transforming a user request into a query(将用户请求转换为查询)</h2><p>The first step a resolver takes is to transform the client’s request, stated in a format suitable to the local OS, into a search specification for RRs at a specific name which match a specific QTYPE and QCLASS. Where possible, the QTYPE and QCLASS should correspond to a single type and a single class, because this makes the use of cached data much simpler.  The reason for this is that the presence of data of one type in a cache doesn’t confirm the existence or non-existence of data of other types, hence the only way to be sure is to consult an authoritative source.  If QCLASS=* is used, then authoritative answers won’t be available.</p><p>Since a resolver must be able to multiplex multiple requests if it is to perform its function efficiently, each pending request is usually represented in some block of state information.  This state block will typically contain:</p><ul><li><p>A timestamp indicating the time the request began. The timestamp is used to decide whether RRs in the database can be used or are out of date.  This timestamp uses the absolute time format previously discussed for RR storage in zones and caches.  Note that when an RRs TTL indicates a relative time, the RR must be timely, since it is part of a zone.  When the RR has an absolute time, it is part of a cache, and the TTL of the RR is compared against the timestamp for the start of the request.</p><p>Note that using the timestamp is superior to using a current time, since it allows RRs with TTLs of zero to be entered in the cache in the usual manner, but still used by the current request, even after intervals of many seconds due to system load, query retransmission timeouts, etc.</p></li><li><p>Some sort of parameters to limit the amount of work which will be performed for this request.</p><p>The amount of work which a resolver will do in response to a client request must be limited to guard against errors in the database, such as circular CNAME references, and operational problems, such as network partition which prevents the resolver from accessing the name servers it needs.  While local limits on the number of times a resolver will retransmit  a particular query to a particular name server address are essential, the resolver should have a global per-request counter to limit work on a single request.  The counter should be set to some initial value and decremented whenever the resolver performs any action (retransmission timeout, retransmission, etc.)  If the counter passes zero, the request is terminated with a temporary error.</p><p>Note that if the resolver structure allows one request to start others in parallel, such as when the need to access a name server for one request causes a parallel resolve for the name server’s addresses, the spawned request should be started with a lower counter.  This prevents circular references in the database from starting a chain reaction of resolver activity.</p></li><li><p>The SLIST data structure discussed in [RFC-1034].</p><p>This structure keeps track of the state of a request if it must wait for answers from foreign name servers.</p></li></ul><h2 id="7-2-Sending-the-queries-发送查询"><a href="#7-2-Sending-the-queries-发送查询" class="headerlink" title="7.2. Sending the queries(发送查询)"></a>7.2. Sending the queries(发送查询)</h2><p>As described in [RFC-1034], the basic task of the resolver is to formulate a query which will answer the client’s request and direct that query to name servers which can provide the information.  The resolver will usually only have very strong hints about which servers to ask, in the form of NS RRs, and may have to revise the query, in response to CNAMEs, or revise the set of name servers the resolver is asking, in response to delegation responses which point the resolver to name servers closer to the desired information.  In addition to the information requested by the client, the resolver may have to call upon its own services to determine the address of name servers it wishes to contact.</p><p>In any case, the model used in this memo assumes that the resolver is multiplexing attention between multiple requests, some from the client, and some internally generated.  Each request is represented by some state information, and the desired behavior is that the resolver transmit queries to name servers in a way that maximizes the probability that the request is answered, minimizes the time that the request takes, and avoids excessive transmissions.  The key algorithm uses the state information of the request to select the next name server address to query, and also computes a timeout which will cause the next action should a response not arrive.  The next action will usually be a transmission to some other server, but may be a temporary error to the client.</p><p>The resolver always starts with a list of server names to query (SLIST). This list will be all NS RRs which correspond to the nearest ancestor zone that the resolver knows about.  To avoid startup problems, the resolver should have a set of default servers which it will ask should it have no current NS RRs which are appropriate.  The resolver then adds to SLIST all of the known addresses for the name servers, and may start parallel requests to acquire the addresses of the servers when the resolver has the name, but no addresses, for the name servers.</p><p>To complete initialization of SLIST, the resolver attaches whatever history information it has to the each address in SLIST.  This will usually consist of some sort of weighted averages for the response time of the address, and the batting average of the address (i.e., how often the address responded at all to the request).  Note that this information should be kept on a per address basis, rather than on a per name server basis, because the response time and batting average of a particular server may vary considerably from address to address.  Note also that this information is actually specific to a resolver address / server address pair, so a resolver with multiple addresses may wish to keep separate histories for each of its addresses.  Part of this step must deal with addresses which have no such history; in this case an expected round trip time of 5-10 seconds should be the worst case, with lower estimates for the same local network, etc.</p><p>Note that whenever a delegation is followed, the resolver algorithm reinitializes SLIST.</p><p>The information establishes a partial ranking of the available name server addresses.  Each time an address is chosen and the state should be altered to prevent its selection again until all other addresses have been tried.  The timeout for each transmission should be 50-100% greater than the average predicted value to allow for variance in response.</p><p>Some fine points:</p><ul><li><p>The resolver may encounter a situation where no addresses are available for any of the name servers named in SLIST, and where the servers in the list are precisely those which would normally be used to look up their own addresses.  This situation typically occurs when the glue address RRs have a smaller TTL than the NS RRs marking delegation, or when the resolver caches the result of a NS search.  The resolver should detect this condition and restart the search at the next ancestor zone, or alternatively at the root.</p></li><li><p>If a resolver gets a server error or other bizarre response from a name server, it should remove it from SLIST, and may wish to schedule an immediate transmission to the next candidate server address.</p></li></ul><h2 id="7-3-Processing-responses-处理回复"><a href="#7-3-Processing-responses-处理回复" class="headerlink" title="7.3. Processing responses(处理回复)"></a>7.3. Processing responses(处理回复)</h2><p>The first step in processing arriving response datagrams is to parse the response.  This procedure should include:<br><em>处理到达的响应数据报的第一步是解析响应。 该程序应包括：</em></p><ul><li>Check the header for reasonableness.  Discard datagrams which are queries when responses are expected.</li></ul><p>   <em>检查应答头是否合理。 当收到应答时,丢弃作为查询的数据报。</em></p><ul><li>Parse the sections of the message, and insure that all RRs are correctly formatted.</li></ul><p>   <em>解析消息的各个部分，并确保所有 RR 的格式正确</em></p><ul><li>As an optional step, check the TTLs of arriving data looking for RRs with excessively long TTLs.  If a RR has an excessively long TTL, say greater than 1 week, either discard the whole response, or limit all TTLs in the response to 1 week.</li></ul><p>   <em>作为可选步骤，检查到达数据的 TTL，查找 TTL 过长的 RR。 如果 RR 的 TTL 过长（例如超过 1 周），则要么丢弃整个响应，要么将响应中的所有 TTL 限制为 1 周。</em></p><p>The next step is to match the response to a current resolver request. The recommended strategy is to do a preliminary matching using the ID field in the domain header, and then to verify that the question section corresponds to the information currently desired.  This requires that the transmission algorithm devote several bits of the domain ID field to a request identifier of some sort.  This step has several fine points:<br><em>下一步是将响应与当前解析器请求进行匹配。 推荐的策略是使用域标头中的 ID 字段进行初步匹配，然后验证问题部分是否对应于当前所需的信息。 这要求传输算法将域 ID 字段的几个位用于某种请求标识符。 这一步有几个要点：</em></p><ul><li>Some name servers send their responses from different addresses than the one used to receive the query.  That is, a resolver cannot rely that a response will come from the same address which it sent the corresponding query to.  This name server bug is typically encountered in UNIX systems.</li></ul><p>   <em>一些名称服务器接收和应答的地址不一致的。 也就是说，解析器不能认为响应一定来自其将查询发送到的同一地址。 此名称服务器错误通常在 UNIX 系统中遇到。</em></p><ul><li>If the resolver retransmits a particular request to a name server it should be able to use a response from any of the transmissions.  However, if it is using the response to sample the round trip time to access the name server, it must be able to determine which transmission matches the response (and keep transmission times for each outgoing message), or only calculate round trip times based on initial transmissions.</li></ul><p>   <em>如果解析器将特定请求重新传输到名称服务器，它应该能够使用来自任何传输的响应。 但是，如果它使用响应来采样访问名称服务器的往返时间，则它必须能够确定哪个传输与响应匹配（并保留每个传出消息的传输时间），或者仅根据 初始传输。</em></p><ul><li>A name server will occasionally not have a current copy of a zone which it should have according to some NS RRs.  The resolver should simply remove the name server from the current SLIST, and continue.</li></ul><p>   <em>名称服务器有时不会拥有根据某些 NS RR 应该拥有的区域的当前副本。 解析器应该简单地从当前 SLIST 中删除名称服务器，然后继续。</em></p><h2 id="7-4-Using-the-cache"><a href="#7-4-Using-the-cache" class="headerlink" title="7.4. Using the cache"></a>7.4. Using the cache</h2><p>In general, we expect a resolver to cache all data which it receives in responses since it may be useful in answering future client requests. However, there are several types of data which should not be cached:<br><em>一般来说，我们期望解析器缓存它在响应中收到的所有数据，因为它可能有助于回答未来的客户端请求。 但是，有几种类型的数据不应该被缓存：</em></p><ul><li>When several RRs of the same type are available for a particular owner name, the resolver should either cache them all or none at all.  When a response is truncated, and a resolver doesn’t know whether it has a complete set, it should not cache a possibly partial set of RRs.</li></ul><p>   <em>当同一类型的多个 RR 可用于特定所有者名称时，解析器应该缓存所有这些 RR，或者根本不缓存它们。 当响应被截断，并且解析器不知道它是否具有完整的 RR 集时，它不应该缓存可能部分的 RR 集。</em></p><ul><li>Cached data should never be used in preference to authoritative data, so if caching would cause this to happen the data should not be cached.</li></ul><p>   <em>决不应该优先使用缓存数据而不是权威数据，因此如果缓存会导致这种情况发生，则不应缓存数据。</em></p><ul><li>The results of an inverse query should not be cached.</li></ul><p>   <em>不应缓存反向查询的结果。</em></p><ul><li>The results of standard queries where the QNAME contains “*” labels if the data might be used to construct wildcards.  The reason is that the cache does not necessarily contain existing RRs or zone boundary information which is necessary to restrict the application of the wildcard RRs.</li></ul><p>   <em>如果数据可用于构造通配符，则 QNAME 包含“</em>”标签的标准查询的结果。 原因是缓存不一定包含限制通配符RR的应用所必需的现有RR或区域边界信息。*</p><ul><li>RR data in responses of dubious reliability.  When a resolver receives unsolicited responses or RR data other than that requested, it should discard it without caching it.  The basic implication is that all sanity checks on a packet should be performed before any of it is cached.</li></ul><p>   <em>可靠性可疑的 RR 数据响应。 当解析器收到未经请求的响应或请求之外的 RR 数据时，它应该丢弃它而不缓存它。 基本含义是，应在缓存任何数据包之前对数据包执行所有健全性检查。</em></p><p>In a similar vein, when a resolver has a set of RRs for some name in a response, and wants to cache the RRs, it should check its cache for already existing RRs.  Depending on the circumstances, either the data in the response or the cache is preferred, but the two should never be combined.  If the data in the response is from authoritative data in the answer section, it is always preferred.<br><em>类似地，当解析器具有响应中某个名称的一组 RR，并且想要缓存这些 RR 时，它应该检查其缓存中是否存在已存在的 RR。 根据具体情况，可选择应答数据或缓存数据，但决不能将两者结合起来。 如果回复中的数据来自答案中的权威数据</em></p><h1 id="8-MAIL-SUPPORT-邮件支持"><a href="#8-MAIL-SUPPORT-邮件支持" class="headerlink" title="8. MAIL SUPPORT(邮件支持)"></a>8. MAIL SUPPORT(邮件支持)</h1><p>The domain system defines a standard for mapping mailboxes into domain names, and two methods for using the mailbox information to derive mail routing information.  The first method is called mail exchange binding and the other method is mailbox binding.  The mailbox encoding standard and mail exchange binding are part of the DNS official protocol, and are the recommended method for mail routing in the Internet.  Mailbox binding is an experimental feature which is still under development and subject to change.</p><p>The mailbox encoding standard assumes a mailbox name of the form “<local-part>@<mail-domain>“.  While the syntax allowed in each of these sections varies substantially between the various mail internets, the preferred syntax for the ARPA Internet is given in [RFC-822].</p><p>The DNS encodes the <local-part> as a single label, and encodes the <mail-domain> as a domain name.  The single label from the <local-part> is prefaced to the domain name from <mail-domain> to form the domain name corresponding to the mailbox.  Thus the mailbox <a href="mailto:&#x48;&#79;&#x53;&#84;&#x4d;&#x41;&#83;&#x54;&#x45;&#x52;&#x40;&#83;&#x52;&#73;&#x2d;&#x4e;&#73;&#x43;&#46;&#x41;&#82;&#80;&#x41;">&#x48;&#79;&#x53;&#84;&#x4d;&#x41;&#83;&#x54;&#x45;&#x52;&#x40;&#83;&#x52;&#73;&#x2d;&#x4e;&#73;&#x43;&#46;&#x41;&#82;&#80;&#x41;</a> is mapped into the domain name HOSTMASTER.SRI-NIC.ARPA.  If the <local-part> contains dots or other special characters, its  representation in a master file will require the use of backslash quoting to ensure that the domain name is properly encoded.  For example, the mailbox <a href="mailto:&#x41;&#99;&#116;&#105;&#111;&#110;&#46;&#x64;&#111;&#109;&#97;&#x69;&#x6e;&#x73;&#64;&#x49;&#83;&#73;&#46;&#69;&#x44;&#85;">&#x41;&#99;&#116;&#105;&#111;&#110;&#46;&#x64;&#111;&#109;&#97;&#x69;&#x6e;&#x73;&#64;&#x49;&#83;&#73;&#46;&#69;&#x44;&#85;</a> would be represented as Action.domains.ISI.EDU.</p><h2 id="8-1-Mail-exchange-binding-邮件交换绑定"><a href="#8-1-Mail-exchange-binding-邮件交换绑定" class="headerlink" title="8.1. Mail exchange binding(邮件交换绑定)"></a>8.1. Mail exchange binding(邮件交换绑定)</h2><p>Mail exchange binding uses the <mail-domain> part of a mailbox specification to determine where mail should be sent.  The <local-part> is not even consulted.  [RFC-974] specifies this method in detail, and should be consulted before attempting to use mail exchange support.</p><p>One of the advantages of this method is that it decouples mail destination naming from the hosts used to support mail service, at the cost of another layer of indirection in the lookup function.  However, the addition layer should eliminate the need for complicated “%”, “!”, etc encodings in <local-part>.</p><p>The essence of the method is that the <mail-domain> is used as a domain name to locate type MX RRs which list hosts willing to accept mail for <mail-domain>, together with preference values which rank the hosts according to an order specified by the administrators for <mail-domain>.</p><p>In this memo, the <mail-domain> ISI.EDU is used in examples, together with the hosts VENERA.ISI.EDU and VAXA.ISI.EDU as mail exchanges for ISI.EDU.  If a mailer had a message for <a href="mailto:&#77;&#x6f;&#x63;&#x6b;&#97;&#112;&#101;&#x74;&#114;&#x69;&#115;&#64;&#x49;&#x53;&#73;&#x2e;&#x45;&#x44;&#x55;">&#77;&#x6f;&#x63;&#x6b;&#97;&#112;&#101;&#x74;&#114;&#x69;&#115;&#64;&#x49;&#x53;&#73;&#x2e;&#x45;&#x44;&#x55;</a>, it would route it by looking up MX RRs for ISI.EDU.  The MX RRs at ISI.EDU name VENERA.ISI.EDU and VAXA.ISI.EDU, and type A queries can find the host addresses.</p><h2 id="8-2-Mailbox-binding-Experimental-邮箱绑定（实验）"><a href="#8-2-Mailbox-binding-Experimental-邮箱绑定（实验）" class="headerlink" title="8.2. Mailbox binding (Experimental) (邮箱绑定（实验）)"></a>8.2. Mailbox binding (Experimental) (邮箱绑定（实验）)</h2><p>In mailbox binding, the mailer uses the entire mail destination specification to construct a domain name.  The encoded domain name for the mailbox is used as the QNAME field in a QTYPE=MAILB query.</p><p>Several outcomes are possible for this query:</p><ol><li><p>The query can return a name error indicating that the mailbox does not exist as a domain name.</p><p>In the long term, this would indicate that the specified mailbox doesn’t exist.  However, until the use of mailbox binding is universal, this error condition should be interpreted to mean that the organization identified by the global part does not support mailbox binding.  The appropriate procedure is to revert to exchange binding atthis point.</p></li><li><p>The query can return a Mail Rename (MR) RR.</p><p>The MR RR carries new mailbox specification in its RDATA field.  The mailer should replace the old mailbox with the new one and retry the operation.</p></li><li><p>The query can return a MB RR.</p><p>The MB RR carries a domain name for a host in its RDATA field.  The mailer should deliver the message to that host via whatever protocol is applicable, e.g., b,SMTP.</p></li><li><p>The query can return one or more Mail Group (MG) RRs.</p><p>This condition means that the mailbox was actually a mailing list or mail group, rather than a single mailbox.  Each MG RR has a RDATA field that identifies a mailbox that is a member of the group.  The mailer should deliver a copy of the message to each member.</p></li><li><p>The query can return a MB RR as well as one or more MG RRs.</p><p>This condition means the the mailbox was actually a mailing list.  The mailer can either deliver the message to the host specified by the MB RR, which will in turn do the delivery to all members, or the mailer can use the MG RRs to do the expansion itself.</p></li></ol><p>In any of these cases, the response may include a Mail Information (MINFO) RR.  This RR is usually associated with a mail group, but is legal with a MB.  The MINFO RR identifies two mailboxes.  One of these identifies a responsible person for the original mailbox name.  This mailbox should be used for requests to be added to a mail group, etc. The second mailbox name in the MINFO RR identifies a mailbox that should receive error messages for mail failures.  This is particularly appropriate for mailing lists when errors in member names should be reported to a person other than the one who sends a message to the list.</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/22-rfc1035/"/>
    <url>/2023/08/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/22-rfc1035/</url>
    
    <content type="html"><![CDATA[<h1 id="1-此备忘录的状态"><a href="#1-此备忘录的状态" class="headerlink" title="1.此备忘录的状态"></a>1.此备忘录的状态</h1><p>本RFC描述了域系统和协议的详细信息，并假定读者熟悉本文档中讨论的概念。<br>伴随RFC，“域名-概念和设施” [RFC-1034]。</p><p>域系统是功能和数据类型（它们是正式协议）和功能和数据类型（仍处于试验阶段）的混合体。由于域系统是有意扩展的，因此应始终在官方协议之外的系统部分中期待新的数据类型和实验行为。官方协议部分包括标准查询，响应和Internet类RR数据格式（例如主机地址）。自从上一个RFC设置以来，几个定义已更改，因此一些以前的定义已过时。</p><p>这些RFC中清楚地标记了实验性或过时的功能，因此应谨慎使用这些信息。</p><p>特别提醒读者，不要依赖示例中出现的最新或完整的值，因为它们的目的主要是教学目的。该备忘录的分发是无限的。</p><h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p>域名的目的是提供一种资源命名机制，以使名称可以在不同的主机，网络，协议族，互联网和管理组织中使用。</p><p>从用户的角度来看，域名可用作本地代理（称为解析器）的参数，该代理检索与域名关联的信息。因此，用户可能会要求提供与特定域名相关联的主机地址或邮件信息。为了使用户能够请求特定类型的信息，会将适当的查询类型与域名一起传递给解析器。对于用户来说，域树是一个单一的信息空间；解析器负责向用户隐藏名称服务器之间的数据分布。</p><p>从解析器的角度来看，构成域空间的数据库分布在各种名称服务器之间。域空间的不同部分存储在不同的名称服务器中，尽管特定的数据项将冗余存储在两个或多个名称服务器中。解析器从至少一台名称服务器的知识开始。当解析器处理用户查询时，它会向已知的名称服务器询问信息。作为回报，解析器将接收所需的信息或将其引荐给另一个名称服务器。使用这些引用，解析程序可以了解其他名称服务器的身份和内容。解析程序负责通过咨询其他服务器中的冗余数据库来处理域空间的分配并处理名称服务器故障的影响。</p><p>名称服务器管理两种数据。第一种数据存放在称为区域的集中；每个区域都是特定数据库的完整数据库<br>域空间的“修剪”子树。此数据称为权威数据。名称服务器会定期检查以确保其区域是最新的，如果不是，则获取更新区域的新副本。</p><p>来自本地或其他名称服务器中存储的主文件。第二种数据是由本地解析器获取的缓存数据。此数据可能不完整，但是当重复访问非本地数据时，可以提高检索过程的性能。缓存的数据最终会被超时机制丢弃。</p><p>此功能结构隔离了解析器中的用户界面，故障恢复和分发问题，并隔离了名称服务器中的数据库更新和刷新问题。</p><h2 id="2-2-常用配置"><a href="#2-2-常用配置" class="headerlink" title="2.2 常用配置"></a>2.2 常用配置</h2><p>主机可以通过多种方式参与域名系统，具体取决于主机是否运行检索信息的程序<br>来自域系统的域名服务器，用于回答来自其他主机的查询的域名服务器，或两种功能的各种组合。最简单，也可能是最典型的配置如下所示：</p><div class="code-wrapper"><pre><code class="hljs">             本地主机                          |  外部主机                                               |+---------+               +----------+         |  +--------+|         | 用户 请求     |          |   请求  |  |        ||  用户   |--------------&gt;|          |---------|-&gt;| 外部   ||  程序   |               |  解析器  |         |  |  Name  ||         |&lt;--------------|          |&lt;--------|--| Server ||         | 用户 应答     |          |  应答   |  |        |+---------+               +----------+         |  +--------+                            |     A            |               添加缓存     |     | references |                            V     |            |                          +----------+         |                          |  缓存    |         |                          +----------+         |                          </code></pre></div><p>用户程序通过解析器与域名空间交互；用户查询和用户响应的格式特定于主机及其操作系统。用户查询通常是操作系统调用，而解析程序及其缓存将是主机操作系统的一部分。能力较弱的主机可能选择将解析器实现为与需要其服务的每个程序链接的子例程。解析程序使用通过查询外部名称服务器和本地缓存获取的信息来回答用户查询。</p><p>请注意，解析器可能必须对几个不同的外部名称服务器进行几个查询才能回答特定的用户查询，因此，用户查询的解析可能涉及多个网络访问和任意数量的时间。对外部名称服务器的查询和相应的响应具有描述的标准格式</p><p>在本备忘录中，可能是数据报。</p><p>根据其功能，名称服务器可以是专用计算机上的独立程序，也可以是大型分时主机上的一个或多个进程。一个简单的配置可能是：</p><div class="code-wrapper"><pre><code class="hljs">             Local Host                        |  Foreign                                               |  +---------+                                  | /         /|                                  |+---------+ |             +----------+         |  +--------+|         | |             |          |responses|  |        ||         | |             |   Name   |---------|-&gt;|Foreign ||  Master |--------------&gt;|  Server  |         |  |Resolver||  files  | |             |          |&lt;--------|--|        ||         |/              |          | queries |  +--------++---------+               +----------+         |</code></pre></div><p>在这里，主要名称服务器通过从其本地文件系统中读取主文件来获取有关一个或多个区域的信息，并回答有关来自外部解析器的那些区域的查询。</p><p>DNS要求多个区域服务器冗余地支持所有区域。指定的辅助服务器可以使用DNS的区域传输协议来获取区域并从主服务器检查更新。该配置如下所示：</p><div class="code-wrapper"><pre><code class="hljs">             Local Host                        |  Foreign                                               |  +---------+                                  | /         /|                                  |+---------+ |             +----------+         |  +--------+|         | |             |          |responses|  |        ||         | |             |   Name   |---------|-&gt;|Foreign ||  Master |--------------&gt;|  Server  |         |  |Resolver||  files  | |             |          |&lt;--------|--|        ||         |/              |          | queries |  +--------++---------+               +----------+         |                            A     |maintenance |  +--------+                            |     +------------|-&gt;|        |                            |      queries     |  |Foreign |                            |                  |  |  Name  |                            +------------------|--| Server |                         maintenance responses |  +--------+</code></pre></div><p>在这种配置中，名称服务器会定期与外部名称服务器建立虚拟电路，以获取区域的副本或检查现有副本是否已更改。为这些维护活动发送的消息采用与查询和响应相同的形式，但是消息顺序有所不同。</p><p>支持域名系统各个方面的主机中的信息流如下所示：</p><div class="code-wrapper"><pre><code class="hljs">             Local Host                        |  Foreign                                               |+---------+               +----------+         |  +--------+|         | user queries  |          |queries  |  |        ||  User   |--------------&gt;|          |---------|-&gt;|Foreign || Program |               | Resolver |         |  |  Name  ||         |&lt;--------------|          |&lt;--------|--| Server ||         | user responses|          |responses|  |        |+---------+               +----------+         |  +--------+                            |     A            |            cache additions |     | references |                            V     |            |                          +----------+         |                          |  Shared  |         |                          | database |         |                          +----------+         |                            A     |            |  +---------+     refreshes |     | references | /         /|               |     V            |+---------+ |             +----------+         |  +--------+|         | |             |          |responses|  |        ||         | |             |   Name   |---------|-&gt;|Foreign ||  Master |--------------&gt;|  Server  |         |  |Resolver||  files  | |             |          |&lt;--------|--|        ||         |/              |          | queries |  +--------++---------+               +----------+         |                            A     |maintenance |  +--------+                            |     +------------|-&gt;|        |                            |      queries     |  |Foreign |                            |                  |  |  Name  |                            +------------------|--| Server |                         maintenance responses |  +--------+</code></pre></div><p>共享数据库保存本地名称服务器和解析器的域空间数据。共享数据库的内容通常是由名称服务器的定期刷新操作维护的权威数据和来自先前解析程序请求的缓存数据的混合。域数据的结构以及名称服务器和解析程序之间同步的必要性暗示了此数据库的一般特征，但实际格式取决于本地实现者。</p><p>还可以定制信息流，以便一组主机一起行动以优化活动。有时这样做是为了减轻负担<br>功能强大的主机，这样他们就不必实施完整的解析程序。这对于希望最大程度地减少所需新网络代码量的PC或主机而言是合适的。在集中式缓存具有较高命中率的前提下，该方案还可以允许一组主机共享少量缓存，而不必维护大量单独的缓存。无论哪种情况，解析器都将由存根解析器代替，存根解析器充当位于一个或多个已知执行该服务的名称服务器中的递归服务器中的解析器的前端：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs gherkin">               Local Hosts                     |<span class="hljs-string">  Foreign</span><br><span class="hljs-string">                                               </span>|<br>+---------+                                    |<span class="hljs-string"></span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> responses                          </span>|<br>|<span class="hljs-string"> Stub    </span>|<span class="hljs-string">&lt;--------------------+              </span>|<br>|<span class="hljs-string"> Resolver</span>|<span class="hljs-string">                     </span>|<span class="hljs-string">              </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">----------------+    </span>|<span class="hljs-string">              </span>|<br>+---------+ recursive      |<span class="hljs-string">    </span>|<span class="hljs-string">              </span>|<br>            queries        |<span class="hljs-string">    </span>|<span class="hljs-string">              </span>|<br>                           V    |<span class="hljs-string">              </span>|<br>+---------+ recursive     +----------+         |<span class="hljs-string">  +--------+</span><br><span class="hljs-string"></span>|<span class="hljs-string">         </span>|<span class="hljs-string"> queries       </span>|<span class="hljs-string">          </span>|<span class="hljs-string">queries  </span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>|<span class="hljs-string"> Stub    </span>|<span class="hljs-string">--------------&gt;</span>|<span class="hljs-string"> Recursive</span>|<span class="hljs-string">---------</span>|<span class="hljs-string">-&gt;</span>|<span class="hljs-string">Foreign </span>|<br>|<span class="hljs-string"> Resolver</span>|<span class="hljs-string">               </span>|<span class="hljs-string"> Server   </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">  Name  </span>|<br>|<span class="hljs-string">         </span>|<span class="hljs-string">&lt;--------------</span>|<span class="hljs-string">          </span>|<span class="hljs-string">&lt;--------</span>|<span class="hljs-string">--</span>|<span class="hljs-string"> Server </span>|<br>+---------+ responses     |<span class="hljs-string">          </span>|<span class="hljs-string">responses</span>|<span class="hljs-string">  </span>|<span class="hljs-string">        </span>|<br>                          +----------+         |<span class="hljs-string">  +--------+</span><br><span class="hljs-string">                          </span>|<span class="hljs-string">  Central </span>|<span class="hljs-string">         </span>|<br>                          |<span class="hljs-string">   cache  </span>|<span class="hljs-string">         </span>|<br>                          +----------+         |<br></code></pre></td></tr></table></figure><p>无论如何，请注意，为了确保可靠性，始终会复制域组件。</p><h2 id="2-3-约定"><a href="#2-3-约定" class="headerlink" title="2.3 约定"></a>2.3 约定</h2><p>域系统具有处理低级但基本问题的几种约定。尽管实现者可以在自己的系统内随意违反这些约定，但他必须在从其他主机观察到的所有行为中遵守这些约定。</p><h3 id="2-3-1-首先名称语法"><a href="#2-3-1-首先名称语法" class="headerlink" title="2.3.1 首先名称语法"></a>2.3.1 首先名称语法</h3><p>DNS规范试图在构造域名的规则中尽可能通用。这个想法是，任何现有对象的名称都可以用最少的更改就可以表示为域名。</p><p>但是，在为对象分配域名时，审慎的用户将选择一个既要满足域系统规则又要满足该对象的任何现有规则的名称，无论这些规则是由现有程序发布还是隐含。</p><p>例如，命名邮件域时，用户应同时满足此备忘录的规则和RFC-822中的规则。创建新的主机名时，应遵循HOSTS.TXT的旧规则。这样可以避免将旧软件转换为使用域名时出现问题。</p><p>以下语法将减少许多使用域名的应用程序（例如邮件，TELNET）的问题。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;domain&gt;</span> :: = <span class="hljs-params">&lt;subdomain&gt;</span> | <span class="hljs-string">&quot; &quot;</span><br><br><span class="hljs-params">&lt;subdomain&gt;</span> :: = <span class="hljs-params">&lt;label&gt;</span> | <span class="hljs-params">&lt;subdomain&gt;</span><span class="hljs-string">&quot;.&quot;</span> <span class="hljs-params">&lt;标签&gt;</span><br><br><span class="hljs-params">&lt;label&gt;</span> :: = <span class="hljs-params">&lt;letter&gt;</span> [[<span class="hljs-params">&lt;ldh-str&gt;</span>] <span class="hljs-params">&lt;let-dig&gt;</span>]<br><br><span class="hljs-params">&lt;ldh-str&gt;</span> :: = <span class="hljs-params">&lt;let-dig-hyp&gt;</span> | <span class="hljs-params">&lt;let-dig-hyp&gt;</span> <span class="hljs-params">&lt;ldh-str&gt;</span><br><br><span class="hljs-params">&lt;let-dig-hyp&gt;</span> :: = <span class="hljs-params">&lt;let-dig&gt;</span> “-”<br><br><span class="hljs-params">&lt;let-dig&gt;</span> :: = <span class="hljs-params">&lt;letter&gt;</span> | <span class="hljs-params">&lt;数字&gt;</span><br><br><span class="hljs-params">&lt;字母&gt;</span> :: = <span class="hljs-number">52</span>个字母字符A到Z中的任何一个（大写）和a到z中的小写<br><br><span class="hljs-params">&lt;digit&gt;</span> :: =十个数字<span class="hljs-number">0</span>到<span class="hljs-number">9</span>中的任何一个<br></code></pre></td></tr></table></figure><p>请注意，虽然域名中允许使用大小写字母，但大小写没有任何意义。就是说，具有相同拼写但大小写不同的两个名称应视为相同。</p><p>标签必须遵循ARPANET主机名的规则。它们必须以字母开头，以字母或数字结尾，并且仅以字母，数字和连字符作为内部字符。长度上也有一些限制。标签不得超过63个字符。</p><p>例如，以下字符串标识Internet中的主机：</p><p>A.ISI.EDU XX.LCS.MIT.EDU SRI-NIC.ARPA</p><h3 id="2-3-2。数据传输顺序"><a href="#2-3-2。数据传输顺序" class="headerlink" title="2.3.2。数据传输顺序"></a>2.3.2。数据传输顺序</h3><p>本文档中描述的报头和数据的传输顺序解析为八位位组级别。每当图表显示</p><p>一组八位位组，这些八位位组的传输顺序是用英语阅读它们的正常顺序。例如，在下图中，八位位组按照其编号顺序进行传输。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code"> 0                   1</span><br><span class="hljs-section"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|       1       |       2       |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|       3       |       4       |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|       5       |       6       |</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure><p>每当八位位组代表数字量时，图中最左边的位就是高阶或最高有效位。即，标记为0的位是最高有效位。例如，下图表示值170（十进制）。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section"> 0 1 2 3 4 5 6 7</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+</span><br><span class="hljs-section">|1 0 1 0 1 0 1 0|</span><br><span class="hljs-section">+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure><p>同样，每当一个多字节的字段代表一个数字量时，整个字段的最左位就是最高有效位。传输多字节的数量时，最重要的字节首先传输。</p><h3 id="2-3-3-角色案例"><a href="#2-3-3-角色案例" class="headerlink" title="2.3.3 角色案例"></a>2.3.3 角色案例</h3><p>对于正式协议中DNS的所有部分，字符串之间的所有比较（例如标签，域名等）均不区分大小写。目前，此规则在整个域系统中均有效，无一例外。但是，除当前用法外，将来可能需要在名称中使用完整的二进制八位位组功能，因此应避免尝试以7位ASCII存储域名或使用特殊字节来终止标签等。</p><p>当数据进入域系统时，应尽可能保留其原始大小写。在某些情况下，这是无法做到的。例如，如果将两个RR存储在数据库中，一个存储在x.y，一个存储在X.Y，则它们实际上存储在数据库的同一位置，因此将仅保留一个大小写。基本规则是，只有在使用数据定义数据库中的结构时才可以忽略大小写，并且以不区分大小写的方式进行比较时，两个名称是相同的。</p><p>区分大小写的数据的丢失必须最小化。因此，虽然x.y和X.Y的数据都可以存储在x.y或X.Y的单个位置下，但是a.x和B.X的数据永远不会存储在A.x，A.X，b.x或b.X的下面。通常，这保留了域名的第一个标签的大小写，但是强制内部节点标签标准化。</p><p>如果系统管理员区分大小写，则将数据输入到域数据库中的系统管理员应注意以区分大小写的方式表示他们提供给域系统的数据。域系统中的数据分发系统将确保保留一致的表示形式。</p><h3 id="2-3-4-大小限制"><a href="#2-3-4-大小限制" class="headerlink" title="2.3.4 大小限制"></a>2.3.4 大小限制</h3><p>DNS中的各种对象和参数都有大小限制。它们在下面列出。有些可以轻松更改，而其他则更基础。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm">标签 不超过<span class="hljs-number">63</span>个八位位组<br><br>名称 不超过<span class="hljs-number">255</span>个八位字节<br><br><span class="hljs-symbol">TTL</span> 有符号<span class="hljs-number">32</span>位数字的<span class="hljs-meta">TTL</span>正值。<br><br><span class="hljs-symbol">UDP</span>消息 不超过<span class="hljs-number">512</span>个八位位组<br></code></pre></td></tr></table></figure><p>#3 域名空间和RR定义</p><h2 id="3-1-命名空间定义"><a href="#3-1-命名空间定义" class="headerlink" title="3.1 命名空间定义"></a>3.1 命名空间定义</h2><p>消息中的域名是由一系列标签表示的。每个标签第一个字节表示该标签后字符个数。每个域名以零字节结尾。长度字段的高位两位必须为零，长度字段的其余六位将标签限制为63个八位位组或更少。</p><p>为了简化实施，域名的总长度（即，标签八位字节和标签长度八位字节）被限制为255个八位字节或更少。</p><p>尽管标签可以包含组成标签的八位字节中的任何8位值，但强烈建议标签遵循本备忘录中其他地方描述的首选语法，该语法与现有主机命名约定兼容。名称服务器和解析器必须以不区分大小写的方式（即A = a）比较标签，并假设ASCII的奇偶校验为零。非字母代码必须完全匹配。</p><h2 id="3-2-RR定义"><a href="#3-2-RR定义" class="headerlink" title="3.2  RR定义"></a>3.2  RR定义</h2><h3 id="3-2-1-格式"><a href="#3-2-1-格式" class="headerlink" title="3.2.1 格式"></a>3.2.1 格式</h3><p>所有RR具有相同的顶级格式，如下所示：</p><div class="code-wrapper"><pre><code class="hljs">                                1  1  1  1  1  1  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+|                                               |/                                               //                      NAME                     /|                                               |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+|                      TYPE                     |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+|                     CLASS                     |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+|                      TTL                      ||                                               |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+|                   RDLENGTH                    |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|/                     RDATA                     //                                               /+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre></div><p>在哪里：</p><p>命名所有者名称，即此资源记录所属的节点的名称。</p><p>TYPE包含RR TYPE代码之一的两个八位位组。</p><p>CLASS包含RR CLASS代码之一的两个八位位组。</p><p>TTL一个32位带符号整数，它指定在再次查询信息源之前可以缓存资源记录的时间间隔。零值被解释为表示RR仅可用于进行中的事务，不应缓存。例如，SOA记录始终以零TTL分发，以禁止缓存。零值也可以用于易失性数据。</p><p>RDLENGTH一个无符号的16位整数，它指定RDATA字段的八位字节长度。</p><p>RDATA是描述资源的八位字节的可变长度字符串。此信息的格式根据资源记录的类型和类别而有所不同。</p><h3 id="3-2-2-TYPE值"><a href="#3-2-2-TYPE值" class="headerlink" title="3.2.2  TYPE值"></a>3.2.2  TYPE值</h3><p>TYPE字段用于资源记录中。请注意，这些类型是QTYPE的子集。</p><p>TYPE的值和含义</p><p>1主机地址</p><p>NS 2权威名称服务器</p><p>MD 3邮件目的地（已淘汰-使用MX）</p><p>MF 4邮件转发器（已淘汰-使用MX）</p><p>CNAME 5别名的规范名称</p><p>SOA 6标志着授权区域的开始</p><p>MB 7一个邮箱域名（EXPERIMENTAL）</p><p>MG 8邮件组成员（EXPERIMENTAL）</p><p>MR 9邮件重命名域名（EXPERIMENTAL）</p><p>空10空RR（EXPERIMENTAL）</p><p>WKS 11众所周知的服务描述</p><p>PTR 12域名指针</p><p>HINFO 13主机信息</p><p>MINFO 14邮箱或邮件列表信息</p><p>MX 15邮件交换</p><p>TXT 16文字字串</p><h3 id="3-2-3。-QTYPE值"><a href="#3-2-3。-QTYPE值" class="headerlink" title="3.2.3。 QTYPE值"></a>3.2.3。 QTYPE值</h3><p>QTYPE字段出现在查询的问题部分。 QTYPES是TYPE的超集，因此所有TYPE都是有效的QTYPE。此外，还定义了以下QTYPE：</p><p>AXFR 252要求转移整个区域</p><p>MAILB 253请求与邮箱相关的记录（MB，MG或MR）</p><p>MAILA 254要求邮件代理RR（已淘汰-请参阅MX）</p><ul><li>255所有记录的请求</li></ul><h3 id="3-2-4。类别值"><a href="#3-2-4。类别值" class="headerlink" title="3.2.4。类别值"></a>3.2.4。类别值</h3><p>CLASS字段出现在资源记录中。以下CLASS助记符<br>和值定义：</p><p>IN 1互联网</p><p>CS 2 CSNET类（作废-仅用于某些作废的RFC中的示例）</p><p>CH 3 CHAOS类</p><p>HS 4 Hesiod [Dyer 87]</p><h3 id="3-2-5。-QCLASS值"><a href="#3-2-5。-QCLASS值" class="headerlink" title="3.2.5。 QCLASS值"></a>3.2.5。 QCLASS值</h3><p>QCLASS字段出现在查询的问题部分。 QCLASS值是CLASS值的超集；每个CLASS都是有效的QCLASS。除了CLASS值，还定义了以下QCLASS：</p><ul><li>255个任何班级</li></ul><h2 id="3-3。标准RR"><a href="#3-3。标准RR" class="headerlink" title="3.3。标准RR"></a>3.3。标准RR</h2><p>预期至少在所有类别中都会出现以下RR定义。特别是，NS，SOA，CNAME和PTR将在所有类中使用，并且在所有类中具有相同的格式。因为它们的RDATA格式是已知的，所以可以压缩这些RR的RDATA部分中的所有域名。</p><p><domain-name>是表示为一系列标签的域名，并以长度为零的标签终止。 <character-string>是一个单字节长度的八位位组，后跟该数量的字符。 <character-string>被视为二进制信息，并且最大长度为256个字符（包括长度八位位组）。</p><h3 id="3-3-1。-CNAME-RDATA格式"><a href="#3-3-1。-CNAME-RDATA格式" class="headerlink" title="3.3.1。 CNAME RDATA格式"></a>3.3.1。 CNAME RDATA格式</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ CNAME ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>CNAME一个<domain-name>，它指定所有者的规范名称或主名称。所有者名称是别名。</p><p>CNAME RR不会引起任何其他节处理，但是在某些情况下，名称服务器可以选择以规范名称重新启动查询。有关详细信息，请参见[RFC-1034]中名称服务器逻辑的描述。</p><h3 id="3-3-2。-HINFO-RDATA格式"><a href="#3-3-2。-HINFO-RDATA格式" class="headerlink" title="3.3.2。 HINFO RDATA格式"></a>3.3.2。 HINFO RDATA格式</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/                      中央处理器                      /+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/操作系统/+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>CPU一个<character-string>，它指定CPU类型。</p><p>OS A <character-string>指定操作<br>                系统类型。</p><p>可在[RFC-1010]中找到CPU和OS的标准值。</p><p>HINFO记录用于获取有关主机的常规信息。主要用途是用于诸如FTP之类的协议，当它们在相同类型的机器或操作系统之间进行交谈时，可以使用特殊的过程。</p><h3 id="3-3-3。-MB-RDATA格式（EXPERIMENTAL）"><a href="#3-3-3。-MB-RDATA格式（EXPERIMENTAL）" class="headerlink" title="3.3.3。 MB RDATA格式（EXPERIMENTAL）"></a>3.3.3。 MB RDATA格式（EXPERIMENTAL）</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ MADNAME ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>MADNAME一个<domain-name>，它指定具有指定邮箱的主机。</p><p>MB记录引起附加的节处理，该节查找与MADNAME对应的A型RR。</p><h3 id="3-3-4。-MD-RDATA格式（已淘汰）"><a href="#3-3-4。-MD-RDATA格式（已淘汰）" class="headerlink" title="3.3.4。 MD RDATA格式（已淘汰）"></a>3.3.4。 MD RDATA格式（已淘汰）</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ MADNAME ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>MADNAME一个<domain-name>，它指定一个主机，该主机具有该域的邮件代理，该代理应该能够为该域传递邮件。</p><p>MD记录引起附加的节处理，该节查找与MADNAME对应的A类型记录。</p><p>MD已过时。有关新方案的详细信息，请参见MX和[RFC-974]的定义。处理主文件中找到的MD RR的推荐策略是拒绝它们，或将它们转换为优先级0的MX RR。</p><h3 id="3-3-5。-MF-RDATA格式（已淘汰）"><a href="#3-3-5。-MF-RDATA格式（已淘汰）" class="headerlink" title="3.3.5。 MF RDATA格式（已淘汰）"></a>3.3.5。 MF RDATA格式（已淘汰）</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ MADNAME ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>MADNAME一个<domain-name>，它指定一个主机，该主机具有该域的邮件代理，它将接受邮件以转发到该域。</p><p>MF记录引起附加的节处理，该节查找与MADNAME对应的A类型记录。</p><p>MF已过时。有关新方案的详细信息，请参见MX和[RFC-974]的定义。建议处理主文件中的MD RR的建议策略是拒绝它们，或将它们转换为优先级为10的MX RR。</p><h3 id="3-3-6。-MG-RDATA格式（EXPERIMENTAL）"><a href="#3-3-6。-MG-RDATA格式（EXPERIMENTAL）" class="headerlink" title="3.3.6。 MG RDATA格式（EXPERIMENTAL）"></a>3.3.6。 MG RDATA格式（EXPERIMENTAL）</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ MGMNAME ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>MGMNAME一个<domain-name>，它指定一个邮箱，该邮箱是由域名指定的邮件组的成员。</p><p>MG记录不会导致任何其他部分的处理。</p><h3 id="3-3-7。-MINFO-RDATA格式（EXPERIMENTAL）"><a href="#3-3-7。-MINFO-RDATA格式（EXPERIMENTAL）" class="headerlink" title="3.3.7。 MINFO RDATA格式（EXPERIMENTAL）"></a>3.3.7。 MINFO RDATA格式（EXPERIMENTAL）</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ RMAILBX /+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ EMAILBX /+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>RMAILBX一个<domain-name>，它指定一个负责邮件列表或邮箱的邮箱。如果此域名为根名称，则MINFO RR的所有者自行负责。请注意，许多现有的邮件列表将邮箱X请求用于邮件列表X的RMAILBX字段，例如，Msgroup的Msgroup请求。该字段提供了更通用的机制。</p><p>EMAILBX一个<domain-name>，它指定一个邮箱，该邮箱将接收与MINFO RR所有者指定的邮件列表或邮箱相关的错误消息（类似于已建议的ERRORS-TO：字段）。如果该域名为根命名，则应将错误返回给邮件的发件人。</p><p>MINFO记录不会导致任何其他节处理。尽管这些记录可以与一个简单的邮箱相关联，但它们通常与邮件列表一起使用。</p><p>3.3.8。 MR RDATA格式（实验性）</p><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/                   新名字                     ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>NEWNAME一个<domain-name>，它指定一个邮箱，该邮箱是指定邮箱的正确重命名。</p><p>MR记录不会导致其他部分的处理。 MR的主要用途是作为已移至其他邮箱的用户的转发条目。</p><h3 id="3-3-9。-MX-RDATA格式"><a href="#3-3-9。-MX-RDATA格式" class="headerlink" title="3.3.9。 MX RDATA格式"></a>3.3.9。 MX RDATA格式</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|偏好|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/                   交换                    ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>优先级一个16位整数，指定在同一所有者中的此RR之间的优先级。较低的值是优选的。</p><p>EXCHANGE &lt;域名&gt;指定一个愿意充当所有者名称的邮件交换的主机。</p><p>MX记录导致类型EXCHANGE指定的主机的另一节处理。 [RFC-974]中详细说明了MX RR的使用。</p><h3 id="3-3-10。-NULL-RDATA格式（EXPERIMENTAL）"><a href="#3-3-10。-NULL-RDATA格式（EXPERIMENTAL）" class="headerlink" title="3.3.10。 NULL RDATA格式（EXPERIMENTAL）"></a>3.3.10。 NULL RDATA格式（EXPERIMENTAL）</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ &lt;任何内容&gt; ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>只要它不超过65535个八位位组，任何内容都可以在RDATA字段中。</p><p>NULL记录不会导致任何其他节处理。主文件中不允许使用NULL RR。在DNS的某些实验性扩展中，NULL用作占位符。</p><h3 id="3-3-11。-NS-RDATA格式"><a href="#3-3-11。-NS-RDATA格式" class="headerlink" title="3.3.11。 NS RDATA格式"></a>3.3.11。 NS RDATA格式</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ NSDNAME ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>NSDNAME一个<domain-name>，它指定对指定的类和域具有权威性的主机。</p><p>NS记录不仅导致通常的附加节处理来定位A类型的记录，而且还导致在引用中使用时对它们所在的区域进行特殊搜索以获取胶合信息。</p><p>NS RR指出，应该期望命名主机具有一个从指定类的所有者名称开始的区域。请注意，该类可能不指示应用于与主机进行通信的协议系列，尽管通常是一个很强的提示。例如，通常使用IN类协议查询作为Internet（IN）或Hesiod（HS）类信息的名称服务器的主机。</p><h3 id="3-3-12。-PTR-RDATA格式"><a href="#3-3-12。-PTR-RDATA格式" class="headerlink" title="3.3.12。 PTR RDATA格式"></a>3.3.12。 PTR RDATA格式</h3><div class="code-wrapper"><pre><code class="hljs">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+/                   PTRDNAME                    /+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre></div><p>PTRDNAME 是一个指向某个域名位置的 &lt;域名&gt;。</p><p>PTR记录不会导致任何其他节处理。这些RR用于特殊域中，以指向域空间中的其他位置。这些记录是简单的数据，并不意味着与CNAME识别别名的任何特殊处理类似。有关示例，请参见IN-ADDR.ARPA域的描述。</p><h3 id="3-3-13。-SOA-RDATA格式"><a href="#3-3-13。-SOA-RDATA格式" class="headerlink" title="3.3.13。 SOA RDATA格式"></a>3.3.13。 SOA RDATA格式</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>/                     MNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">/                     RNAME                     /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                    SERIAL                     |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                    REFRESH                    |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                     RETRY                     |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                    EXPIRE                     |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                    MINIMUM                    |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>在哪里：</p><p>MNAME名称服务器的&lt;域名&gt;，它是该区域的原始数据或主要数据源。</p><p>RNAME一个<domain-name>，它指定负责此区域的人员的邮箱。</p><p>SERIAL区域的原始副本的无符号32位版本号。区域传输会保留此值。该值包含在内，应使用序列空间算法进行比较。</p><p>刷新应该刷新区域之前的32位时间间隔。</p><p>重试应尝试重试失败之前应经过的32位时间间隔。</p><p>EXPIRE一个32位的时间值，它指定区域不再具有权威性之前可以经过的时间间隔的上限。</p><p>MINIMUM应该从此区域与任何RR一起导出的无符号32位最小TTL字段。</p><p>SOA记录不会导致任何其他节处理。</p><p>所有时间均以秒为单位。</p><p>这些字段中的大多数仅与名称服务器维护操作相关。但是，MINIMUM用于所有从区域检索RR的查询操作。每当响应查询而发送RR时，TTL字段都将设置为相应SOA中RR和MINIMUM字段中TTL字段的最大值。因此，MINIMUM是区域中所有RR的TTL字段的下限。请注意，当将RR复制到响应中时，应使用MINIMUM，而不是从主文件或通过区域传输加载区域时，应使用MINIMUM。该证明的原因是允许将来的动态更新工具以已知的语义来更改SOA RR。</p><h3 id="3-3-14。-TXT-RDATA格式"><a href="#3-3-14。-TXT-RDATA格式" class="headerlink" title="3.3.14。 TXT RDATA格式"></a>3.3.14。 TXT RDATA格式</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+/ TXT数据/+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>TXT-DATA一个或多个<character-string>。</p><p>TXT RR用于保存描述性文本。文本的语义取决于找到文本的域。</p><h2 id="3-4。特定于互联网的RR"><a href="#3-4。特定于互联网的RR" class="headerlink" title="3.4。特定于互联网的RR"></a>3.4。特定于互联网的RR</h2><h3 id="3-4-1。-RDATA格式"><a href="#3-4-1。-RDATA格式" class="headerlink" title="3.4.1。 RDATA格式"></a>3.4.1。 RDATA格式</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|地址|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>地址32位Internet地址。</p><p>具有多个Internet地址的主机将具有多个A记录。</p><p>A记录不会导致任何其他节处理。主文件中A行的RDATA部分是一个Internet地址，用四个十进制数字表示，这些数字用点分隔，没有任何嵌入的空格（例如“ 10.2.0.52”或“ 192.0.5.6”）。</p><h3 id="3-4-2。-WKS-RDATA格式"><a href="#3-4-2。-WKS-RDATA格式" class="headerlink" title="3.4.2。 WKS RDATA格式"></a>3.4.2。 WKS RDATA格式</h3><div class="code-wrapper"><pre><code class="hljs">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|地址|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|协议| |+-+-+-+-+-+-+-+-+ || |/ &lt;位图&gt; ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>地址32位互联网地址</p><p>协议8位IP协议号</p><p>&lt;位图&gt;可变长度位图。位图必须是8位长的倍数。</p><p>WKS记录用于描述特定Internet地址上特定协议支持的众所周知的服务。 PROTOCOL字段指定IP协议编号，并且位图在指定协议的每个端口上只有一位。第一位对应于端口0，第二位对应于端口1，依此类推。如果位图不包含感兴趣协议的位，则假定该位为零。 [RFC-1010]中指定了端口和协议的适当值和助记符。</p><p>例如，如果PROTOCOL = TCP（6），则第26位对应于TCP端口25（SMTP）。如果设置了此位，则SMTP服务器应在TCP端口25上侦听；否则，请在SMTP服务器上侦听。如果为零，则指定的地址不支持SMTP服务。</p><p>WKS RR的目的是为TCP和UDP提供服务器的可用性信息。如果服务器同时支持TCP和UDP或具有多个Internet地址，则使用多个WKS RR。</p><p>WKS RR不会导致任何其他部分的处理。</p><p>在主文件中，端口和协议都使用助记符或十进制数字表示。</p><h2 id="3-5-IN-ADDR-ARPA-域"><a href="#3-5-IN-ADDR-ARPA-域" class="headerlink" title="3.5 IN-ADDR.ARPA 域"></a>3.5 IN-ADDR.ARPA 域</h2><p>Internet使用特殊的域来支持网关位置和Internet地址到主机的映射。其他类别可以在其他领域中采用类似的策略。该域的目的是提供一种保证的方法，以执行主机地址到主机名的映射，并简化查询以定位Internet中特定网络上的所有网关。</p><p>请注意，这两个服务都类似于可以通过逆向查询执行的功能。区别在于，域名空间的这部分是根据地址构造的，因此可以保证可以找到适当的数据，而无需详尽搜索域名空间。</p><p>该域始于IN-ADDR.ARPA，并具有遵循Internet寻址结构的子结构。</p><p>除后缀IN-ADDR.ARPA外，IN-ADDR.ARPA域中的域名还定义为最多具有四个标签。每个标签代表一个Internet地址的一个八位位组，并表示为字符串，表示范围为0-255的十进制值（除了零位八位位组（由单个零表示）以外，省略了前导零）。</p><p>主机地址由指定了所有四个标签的域名表示。因此，Internet地址10.2.0.52的数据位于域名52.0.2.10.IN-ADDR.ARPA。反向读取虽然很尴尬，但允许委派区域，而这些区域正是地址空间的一个网络。例如，10.IN-ADDR.ARPA可以是包含ARPANET数据的区域，而26.IN-ADDR.ARPA可以是MILNET的单独区域。地址节点用于在正常域空间中保存指向主要主机名的指针。</p><p>网络号对应于IN-ADDR.ARPA域中各个深度的一些非终端节点，因为Internet网络号是1个，2个或3个八位位组。网络节点用于保存指向连接到该网络的网关的主要主机名的指针。根据定义，由于网关位于多个网络上，因此网关通常将具有指向该网关的两个或多个网络节点。网关还将在其完全限定的地址处具有主机级别的指针。</p><p>网络节点上的网关指针和全地址节点上的普通主机指针都使用PTR RR指向相应主机的主域名。</p><p>例如，IN-ADDR.ARPA域将包含有关网络10和26之间的ISI网关，从网络10到MIT的网络18的MIT网关以及主机A.ISI.EDU和MULTICS.MIT.EDU的信息。假设ISI网关的地址为10.2.0.22和26.0.0.103，名称为MILNET-GW.ISI.EDU，而MIT网关的地址为10.0.0.77和18.10.0.4，名称为GW.LCS.MIT.EDU，则域数据库将包含：</p><div class="code-wrapper"><pre><code class="hljs">10.IN-ADDR.ARPA。 PTR MILNET-GW.ISI.EDU。10.IN-ADDR.ARPA。 PTR GW.LCS.MIT.EDU。18，IN-ADDR.ARPA PTR GW.LCS.MIT.EDU。26.ADDR.ARPA PTR MILNET-GW.ISI.EDU。22.0.2.10.IN-ADDR.ARPA。 PTR MILNET-GW.ISI.EDU。103.0.0.26.IN-ADDR.ARPA。 PTR MILNET-GW.ISI.EDU。77.0.0.10.IN-ADDR.ARPA。 PTR GW.LCS.MIT.EDU。4.0.10.18.IN-ADDR.ARPA。 PTR GW.LCS.MIT.EDU。103.0.3.26.IN-ADDR.ARPA。 PTR A.ISI.EDU。6.0.0.10.IN-ADDR.ARPA。 PTR MULTICS.MIT.EDU。</code></pre></div><p>因此，想要在网络10上定位网关的程序将发出以下形式的查询：QTYPE = PTR，QCLASS = IN，QNAME = 10.IN-ADDR.ARPA。它将收到两个RR作为回应：</p><div class="code-wrapper"><pre><code class="hljs">10.IN-ADDR.ARPA。 PTR MILNET-GW.ISI.EDU。10.IN-ADDR.ARPA。 PTR GW.LCS.MIT.EDU。</code></pre></div><p>然后，程序可以针对MILNET-GW.ISI.EDU发起QTYPE = A，QCLASS = IN查询。和GW.LCS.MIT.EDU。发现这些网关的Internet地址。</p><p>想要查找与Internet主机地址10.0.0.6相对应的主机名的解析器将执行以下形式的查询：QTYPE = PTR，QCLASS = IN，QNAME = 6.0.0.10.IN-ADDR.ARPA，并将收到：</p><div class="code-wrapper"><pre><code class="hljs">6.0.0.10.IN-ADDR.ARPA。 PTR MULTICS.MIT.EDU。</code></pre></div><p>使用这些服务时应注意以下几点：<br>   -由于IN-ADDR.ARPA专用域和特定主机或网关的普通域将位于不同的区域，因此存在数据不一致的可能性。</p><p>   -网关通常在单独的域中具有两个名称，其中只有一个可以是主要的。</p><p>   -使用域数据库初始化其路由表的系统必须以足够的网关信息开头，以确保它们可以访问适当的名称服务器。</p><p>   -网关数据仅以与当前HOSTS.TXT文件等效的方式反映网关的存在。它不会替代GGP或EGP中的动态可用性信息。</p><h2 id="3-6。定义新类型，类和特殊名称空间"><a href="#3-6。定义新类型，类和特殊名称空间" class="headerlink" title="3.6。定义新类型，类和特殊名称空间"></a>3.6。定义新类型，类和特殊名称空间</h2><p>先前定义的类型和类别是截至本备忘录发布之日为止正在使用的类型和类别。应该有新的定义。本节向考虑添加现有设施的设计人员提出一些建议。邮件列表<a href="mailto:&#x4e;&#x41;&#x4d;&#x45;&#68;&#x52;&#x4f;&#80;&#x50;&#x45;&#x52;&#x53;&#x40;&#x53;&#82;&#x49;&#45;&#x4e;&#73;&#67;&#46;&#65;&#82;&#80;&#x41;">&#x4e;&#x41;&#x4d;&#x45;&#68;&#x52;&#x4f;&#80;&#x50;&#x45;&#x52;&#x53;&#x40;&#x53;&#82;&#x49;&#45;&#x4e;&#73;&#67;&#46;&#65;&#82;&#80;&#x41;</a>是讨论设计问题的论坛。</p><p>通常，当要将有关现有对象的新信息添加到数据库中时，或者对于某些全新对象，我们需要新的数据格式时，使用新类型是合适的。设计人员应尝试定义通常适用于所有类的类型及其RDATA格式，并避免信息重复。当将DNS用于新协议等需要新的特定于类的数据格式时，或者需要复制现有名称空间但需要单独的管理域时，则使用新类是合适的。</p><p>新的类型和类需要用于主文件的助记符。主文件的格式要求类型和类的助记符不相交。</p><p>TYPE和CLASS值必须分别是QTYPE和QCLASS的适当子集。</p><p>本系统使用多个RR来表示一种类型的多个值，而不是将多个值存储在单个RR的RDATA部分中。对于大多数应用而言，这效率较低，但确实使RR较短。多个RR假设已纳入有关动态更新方法的一些实验工作中。</p><p>本系统试图最小化数据库中数据的重复以确保一致性。因此，为了找到用于邮件交换的主机地址，您可以将邮件域名映射到主机名，然后将主机名映射到地址，而不是直接映射到主机地址。此方法是首选方法，因为它避免了出现不一致的机会。</p><p>在定义新的数据类型时，不应使用多种RR类型在条目之间创建顺序或为等效绑定表达不同格式，而应在RR主体中携带此信息，并使用一种类型。此策略避免了缓存多个类型和定义QTYPE以匹配多个类型的问题。</p><p>例如，邮件交换绑定的原始形式使用两种RR类型，一种代表“更紧密”的交换（MD），一种代表“较不紧密”的交换（MF）。困难在于，在缓存中存在一种RR类型不会传达有关另一种RR的任何信息，因为获取缓存信息的查询可能使用了MF，MD或MAILA（两者都匹配）的QTYPE。重新设计的服务在RDATA部分中使用了具有“首选项”值的单一类型（MX），可以对不同的RR进行排序。但是，如果在缓存中找到任何MX RR，则所有RR都应该存在。</p><p>＃4.讯息</p><h2 id="4-1。格式"><a href="#4-1。格式" class="headerlink" title="4.1。格式"></a>4.1。格式</h2><p>域协议内部的所有通信均以一种称为消息的单一格式进行。邮件的顶级格式分为5个部分（某些情况下某些部分为空），如下所示：</p><div class="code-wrapper"><pre><code class="hljs">+ --------------------- +|标头|+ --------------------- +|问题名称服务器的问题+ --------------------- +|回答|驻地代表回答问题+ --------------------- +|权威|指向授权机构的RR+ --------------------- +|附加| RR拥有其他信息+ --------------------- +</code></pre></div><p>标头部分始终存在。标头包含指定剩余部分中的哪些部分存在的字段，还指定消息是查询还是响应，标准查询还是其他一些操作码等。</p><p>标头后面的节的名称是从它们在标准查询中的使用派生的。问题部分包含描述名称服务器问题的字段。这些字段是查询类型（QTYPE），查询类（QCLASS）和查询域名（QNAME）。最后三个部分具有相同的格式：串联资源记录（RR）的列表可能为空。答案部分包含回答问题的RR。权限部分包含指向权威名称服务器的RR；其他记录部分包含与查询相关的RR，但它们并不是严格的问题答案。</p><h3 id="4-1-1。标头节格式"><a href="#4-1-1。标头节格式" class="headerlink" title="4.1.1。标头节格式"></a>4.1.1。标头节格式</h3><p>标头包含以下字段：</p><div class="code-wrapper"><pre><code class="hljs">                                1 1 1 1 1 1  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| ID |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| QR |操作码| AA | TC | RD | RA | Z | RCODE |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| QDCOUNT |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| ANCOUNT |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| NSCOUNT |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|帐户|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>ID由程序分配的16位标识符，该标识符生成任何类型的查询。该标识符被复制为相应的答复，并且请求者可以使用该标识符来匹配对未完成查询的答复。</p><p>QR一位字段，指定此消息是查询（0）还是响应（1）。</p><p>OPCODE一个四位字段，用于指定此消息中的查询类型。此值由查询的发起者设置并复制到响应中。值是：</p><div class="code-wrapper"><pre><code class="hljs">            0标准查询（QUERY）            1反向查询（IQUERY）            2服务器状态请求（STATUS）            3-15保留以备将来使用</code></pre></div><p>AA权威答案-此位在响应中有效，并指定响应名称服务器是“问题”部分中的域名的授权机构。</p><div class="code-wrapper"><pre><code class="hljs">            注意，由于别名，答案部分的内容可能具有多个所有者名称。 AA位对应于与查询名称匹配的名称，或对应于答案部分中的第一个所有者名称。</code></pre></div><p>TC TrunCation-指定此消息由于长度大于传输信道上允许的长度而被截断。</p><p>要求RD递归-可以在查询中设置此位，并将其复制到响应中。如果设置了RD，它将指示名称服务器以递归方式进行查询。递归查询支持是可选的。</p><p>RA递归可用-可以在响应中设置或清除它，并表示名称服务器中是否提供递归查询支持。</p><p>Z保留供将来使用。在所有查询和响应中必须为零。</p><p>RCODE响应代码-这4位字段设置为响应的一部分。这些值具有以下解释：</p><div class="code-wrapper"><pre><code class="hljs">            0无错误条件            1格式错误-名称服务器无法解释查询。            2服务器故障-由于名称服务器问题，名称服务器无法处理此查询。            3名称错误-仅对来自权威名称服务器的响应有意义，此代码表示查询中引用的域名不存在。            4未实现-名称服务器不支持所请求的查询类型。            5拒绝-名称服务器由于策略原因拒绝执行指定的操作。例如，名称服务器可能不希望将信息提供给特定请求者，或者名称服务器可能不希望对特定数据执行特定操作（例如，区域传送）。            6-15保留以备将来使用。</code></pre></div><p>QDCOUNT一个无符号的16位整数，指定问题部分中的条目数。</p><p>ANCOUNT一个无符号的16位整数，用于指定答案部分中的资源记录数。</p><p>NSCOUNT一个无符号的16位整数，用于在授权记录部分中指定名称服务器资源记录的数量。</p><p>ARCOUNT一个无符号的16位整数，用于指定其他记录部分中的资源记录数。</p><h3 id="4-1-2。问题部分格式"><a href="#4-1-2。问题部分格式" class="headerlink" title="4.1.2。问题部分格式"></a>4.1.2。问题部分格式</h3><p>问题部分用于在大多数查询中携带“问题”，即定义所要询问内容的参数。该部分包含QDCOUNT（通常为1）条目，每种格式如下：</p><div class="code-wrapper"><pre><code class="hljs">                                1 1 1 1 1 1  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| |/ QNAME ////+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| QTYPE |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| QCLASS |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>在哪里：</p><p>QNAME以标签序列表示的域名，其中每个标签由一个长度八位位组和随后的那个八位位组数组成。域名以零长度的八位位组结尾，表示根的空标签。请注意，此字段可能是奇数个八位位组；不使用填充。</p><p>QTYPE是两个八位字节的代码，用于指定查询的类型。该字段的值包括对TYPE字段有效的所有代码，以及一些更通用的代码，这些代码可以匹配一种以上的RR。</p><p>QCLASS是两个八位字节的代码，用于指定查询的类。例如，对于Internet，QCLASS字段是IN。</p><h3 id="4-1-3。资源记录格式"><a href="#4-1-3。资源记录格式" class="headerlink" title="4.1.3。资源记录格式"></a>4.1.3。资源记录格式</h3><p>答案，权限和其他部分均共享相同的格式：可变数量的资源记录，其中记录的数量在标头的相应计数字段中指定。每个资源记录具有以下格式：<br>                                    1 1 1 1 1 1<br>      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    | |<br>    ///<br>    /                      名称                     /<br>    | |<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    | TYPE |<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    |类|<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    | TTL |<br>    | |<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br>    | RDLENGTH |<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ ||<br>    / RDATA /<br>    ///<br>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>在哪里：</p><p>命名此资源记录所属的域名。</p><p>TYPE包含RR类型代码之一的两个八位位组。此字段在RDATA字段中指定数据的含义。</p><p>CLASS两个八位字节，用于指定RDATA字段中数据的类别。</p><p>TTL一个32位无符号整数，指定在应丢弃资源记录之前可以缓存资源记录的时间间隔（以秒为单位）。零值被解释为表示RR仅可用于进行中的事务，不应缓存。</p><p>RDLENGTH一个无符号的16位整数，它指定RDATA字段的八位字节长度。</p><p>RDATA是描述资源的八位字节的可变长度字符串。此信息的格式根据资源记录的类型和类别而有所不同。例如，如果TYPE为A，CLASS为IN，则RDATA字段为4个八位字节的ARPA Internet地址。</p><h3 id="4-1-4-消息压缩"><a href="#4-1-4-消息压缩" class="headerlink" title="4.1.4 消息压缩"></a>4.1.4 消息压缩</h3><p>为了减小消息的大小，域名系统利用一种压缩方案消除了消息中重复的域名。在此方案中，整个域名或域名末尾的标签列表将替换为指向先前相同名称的指针。</p><p>指针采用两个字节序列的形式：</p><div class="code-wrapper"><pre><code class="hljs">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+| 1  1|                OFFSET                   |+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre></div><p>前两位是1。这允许将指针与标签区分开，因为标签必须限制为63个字节或更少，所以标签必须以两个零位开头。 （保留10和01的组合以供将来使用。）OFFSET字段指定距消息开头的偏移量（即，域标头中ID字段的第一个字节）。零偏移量指定ID字段的第一个字节，依此类推。</p><p>压缩方案允许将消息中的域名表示为：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>以零结尾的标签序列<br><br><span class="hljs-bullet">- </span>指针<br><br><span class="hljs-bullet">- </span>以指针结尾的一系列标签<br></code></pre></td></tr></table></figure><p>指针只能用于格式不特定于类的域名的出现。如果不是这种情况，则将需要名称服务器或解析器知道其处理的所有RR的格式。到目前为止，还没有这种情况，但是它们可能会以将来的RDATA格式出现。</p><p>如果域名的一部分包含在消息中，该消息受长度字段的约束（例如RR的RDATA部分），并且使用了压缩，则在长度计算中使用压缩名称的长度，而不是长度扩展名的名称。</p><p>程序可以随意避免在它们生成的消息中使用指针，尽管这会减少数据报的容量，并可能导致截断。但是，所有程序都必须了解包含指针的到达消息。</p><p>例如，数据报可能需要使用域名F.ISI.ARPA，FOO.F.ISI.ARPA，ARPA和根。忽略消息的其他字段，这些域名可能表示为：</p><div class="code-wrapper"><pre><code class="hljs">   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+20 |           1           |           F           |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+22 |           3           |           I           |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+24 |           S           |           I           |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+26 |           4           |           A           |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+28 |           R           |           P           |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+30 |           A           |           0           |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+40 |           3           |           F           |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+42 |           O           |           O           |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+44 | 1  1|                20                       |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+64 | 1  1|                26                       |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+92 |           0           |                       |   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code></pre></div><p>F.ISI.ARPA的域名显示在偏移量20处。FOO.F.ISI.ARPA的域名显示在偏移量40处；而FOO.F.ISI.ARPA的域名显示在偏移量40处。此定义使用指针将FOO的标签连接到先前定义的F.ISI.ARPA。域名ARPA在20处使用指向名称F.ISI.ARPA的ARPA组件的指针在偏移量64处定义；请注意，该指针依赖于ARPA，它是字符串中位于20的最后一个标签。根域名由单个零位八位字节（在92处）定义；根域名没有标签。</p><h2 id="4-2。运输"><a href="#4-2。运输" class="headerlink" title="4.2。运输"></a>4.2。运输</h2><p>DNS假定消息将作为数据报或虚拟电路承载的字节流进行传输。尽管虚拟电路可用于任何DNS活动，但数据报由于其较低的开销和更好的性能而被查询首选。区域刷新活动必须使用虚拟电路，因为需要可靠的传输。</p><p>Internet支持使用服务器端口53上的TCP [RFC-793]（十进制）访问名称服务器，以及使用UDP端口53上的UDP [RFC-768]进行数据报访问（十进制）。</p><p>4.2.1。 UDP使用</p><p>使用UDP用户服务器端口53（十进制）发送的消息。</p><p>UDP携带的消息被限制为512字节（不计算IP或UDP标头）。较长的消息将被截断，并且标头中的TC位置1。</p><p>区域传输不接受UDP，但建议将UDP用于Internet中的标准查询。使用UDP发送的查询可能会丢失，因此需要重传策略。查询或它们的响应可以通过网络或在名称服务器中进行处理来重新排序，因此解析器不应依赖于它们按顺序返回。</p><p>最佳的UDP重传策略将随着Internet的性能和客户端的需求而变化，但是建议以下内容：</p><p>   -在重复查询服务器的特定地址之前，客户端应尝试其他服务器和服务器地址。</p><p>   -如果可能，重传间隔应基于先前的统计数据。过于激进的重新传输很容易使整个社区的响应速度变慢。根据客户端与预期服务器的连接程度，最小重传间隔应为2-5秒。</p><p>有关服务器选择和重传策略的更多建议，可以在本备忘录的“解析器”部分中找到。</p><h3 id="4-2-2。-TCP使用"><a href="#4-2-2。-TCP使用" class="headerlink" title="4.2.2。 TCP使用"></a>4.2.2。 TCP使用</h3><p> 通过TCP连接发送的消息使用服务器端口53（十进制）。该消息的前缀为两个字节的长度字段，该字段给出了消息的长度，但不包括两个字节的长度字段。此长度字段允许低级处理在开始解析之前组装完整的消息。</p><p>建议使用几种连接管理策略：</p><p>   -服务器不应阻止其他活动等待TCP数据。</p><p>   -服务器应支持多个连接。</p><p>   -服务器应假定客户端将启动连接关闭，并应延迟关闭其连接结束，直到满足所有未完成的客户端请求为止。</p><p>   -如果服务器需要关闭休眠的连接以回收资源，则应等待直到该连接空闲两分钟左右的时间。特别是，服务器应允许在单个连接上进行SOA和AXFR请求序列（开始刷新操作）。由于服务器仍然无法回答查询，因此可以使用单边关闭或重置来代替正常关闭。</p><p>＃5.主文件</p><p>主文件是包含文本格式的RR的文本文件。由于可以用RR列表的形式来表示区域的内容，因此尽管可以将其用于列出高速缓存的内容，但最常使用主文件来定义区域。因此，本节首先讨论主文件中RR的格式，然后讨论使用主文件在某个名称服务器中创建区域时的特殊注意事项。</p><h2 id="5-1。格式"><a href="#5-1。格式" class="headerlink" title="5.1。格式"></a>5.1。格式</h2><p>这些文件的格式是一个输入序列。条目主要面向行，尽管可以使用括号在行边界上延续项目列表，并且文本文字可以在文本内包含CRLF。制表符和空格的任何组合都可作为构成条目的各个项目之间的分隔符。主文件中任何行的结尾都可以以注释结尾。注释以“;”开头。 （分号）。</p><p>定义了以下条目：</p><div class="code-wrapper"><pre><code class="hljs">&lt;空白&gt; [&lt;评论&gt;]$ ORIGIN &lt;域名&gt; [&lt;注释&gt;]$ INCLUDE &lt;文件名&gt; [&lt;域名&gt;] [&lt;注释&gt;]&lt;域名&gt; &lt;rr&gt; [&lt;注释&gt;]&lt;空白&gt; &lt;rr&gt; [&lt;注释&gt;]</code></pre></div><p>文件中的任何位置都允许带有或不带注释的空行。</p><p>定义了两个控件条目：$ ORIGIN和$ INCLUDE。 $ ORIGIN后跟一个域名，并将相对域名的当前来源重置为所述名称。 $ INCLUDE将命名文件插入当前文件，并且可以选择指定一个域名，该域名设置包含文件的相对域名起源。 $ INCLUDE也可能有评论。请注意，$ INCLUDE条目永远不会更改父文件的相对原点，而不管对包含文件中相对原点的更改如何。</p><p>最后两种形式代表RR。如果RR的条目以空白开头，则假定该RR由最后声明的所有者拥有。如果RR条目以<domain-name>开头，那么将重置所有者名称。</p><p><rr>内容采用以下形式之一：</p><div class="code-wrapper"><pre><code class="hljs">[&lt;TTL&gt;] [&lt;class&gt;] &lt;类型&gt; &lt;RDATA&gt;[&lt;class&gt;] [&lt;TTL&gt;] &lt;类型&gt; &lt;RDATA&gt;</code></pre></div><p>RR以可选的TTL和类字段开头，然后是适合于该类型和类的类型和RDATA字段。类和类型使用标准助记符，TTL是十进制整数。默认情况下，遗漏的class和TTL值为默认值。由于类型和类助记符是不相交的，因此解析是唯一的。 （请注意，此顺序不同于示例中使用的顺序和实际RR中使用的顺序；给定的顺序使解析和默认设置更为容易。）</p><p><domain-name>构成了主文件中大部分数据。<br>域名中的标签表示为字符串，并用点分隔。引用约定允许将任意字符存储在域名中。以点结尾的域名称为绝对域名，它们被视为完整域名。不以点结尾的域名称为相对域名；实际域名是相对部分与$ ORIGIN，$ INCLUDE中指定的原点或作为主文件加载例程的参数的串联。如果没有可用的原语，则相对名称是错误的。</p><p><character-string>用一种或两种方式表示：连续的字符集，不带内部空格，或表示为以“开始”并以“结束”的字符串。在“定界字符串中，除了”本身，任何字符都可以出现，必须使用\（反斜杠）将其引起来。</p><p>由于这些文件是文本文件，因此需要使用几种特殊的编码来加载任意数据。特别是：</p><div class="code-wrapper"><pre><code class="hljs">            的根。</code></pre></div><p>@自由站立@表示当前原点。</p><p>\ X，其中X是数字（0-9）以外的任何字符，用于引用该字符，因此其特殊含义不适用。例如， ”\。”可用于在标签中放置点字符。</p><p>\ DDD，其中每个D是一个数字，是与DDD描述的十进制数字相对应的八位字节。假定生成的八位位组是文本，并且不检查其特殊含义。</p><p>（）括号用于对跨越线边界的数据进行分组。实际上，括号内的行不被识别。</p><p>;分号用于发表评论；该行的其余部分将被忽略。</p><p>5.2。使用主文件定义区域</p><p>使用主文件加载区域时，如果在主文件中遇到任何错误，则应禁止该操作。这样做的理由是，单个错误可能会导致广泛的后果。例如，假设定义委托的RR有语法错误；那么服务器将为子区域中的所有名称返回权威名称错误（服务器上也存在子区域的情况除外）。</p><p>除了确保文件在语法上正确之外，还应该执行其他几个有效性检查：</p><p>   1.文件中的所有RR应该具有相同的类。</p><p>   2.在区域的顶部应该恰好有一个SOA RR。</p><p>   3.如果存在委托并且需要粘合信息，则应该存在。</p><p>   4.区域中权威节点之外的信息应该是粘合信息，而不是起源或类似错误的结果。</p><p>5.3。主文件示例</p><p>以下是一个示例文件，该文件可用于定义ISI.EDU区域，并加载了ISI.EDU的来源：</p><p>@ IN SOA VENERA Action \ .domains（<br>                                 20;序列号<br>                                 7200;刷新<br>                                 600;重试<br>                                 3600000;到期<br>                                 60）;最低限度</p><div class="code-wrapper"><pre><code class="hljs">    NS A.ISI.EDU。    NS VENERA    NS VAXA    MX 10 VENERA    MX 20 VAXA</code></pre></div><p>A A 26.3.0.103</p><p>VENERA A 10.1.0.52<br>        一个128.9.0.32</p><p>瓦克斯A 10.2.0.27<br>        一个128.9.0.33</p><p>$ INCLUDE <SUBSYS> ISI-MAILBOXES.TXT</p><p>文件<SUBSYS> ISI-MAILBOXES.TXT是：</p><div class="code-wrapper"><pre><code class="hljs">教育部MB A.ISI.EDU。拉里·MB A.ISI.EDU。科利MB A.ISI.EDU。STOOGES MG MOE        拉里        MG库里</code></pre></div><p>请注意，在SOA RR中使用\字符来指定负责人的邮箱“ <a href="mailto:&#x41;&#x63;&#116;&#105;&#111;&#x6e;&#46;&#100;&#111;&#x6d;&#97;&#x69;&#x6e;&#x73;&#x40;&#x45;&#46;&#x49;&#83;&#73;&#x2e;&#x45;&#x44;&#85;">&#x41;&#x63;&#116;&#105;&#111;&#x6e;&#46;&#100;&#111;&#x6d;&#97;&#x69;&#x6e;&#x73;&#x40;&#x45;&#46;&#x49;&#83;&#73;&#x2e;&#x45;&#x44;&#85;</a>”。</p><p>＃6.名称服务器的实现</p><h2 id="6-1。建筑学"><a href="#6-1。建筑学" class="headerlink" title="6.1。建筑学"></a>6.1。建筑学</h2><p>名称服务器的最佳结构将取决于主机操作系统，以及名称服务器是否与解析程序操作集成在一起（通过支持递归服务或通过与解析程序共享其数据库）。本节讨论与解析器共享数据库的名称服务器的实现注意事项，但是大多数这些担忧都存在于任何名称服务器中。</p><p>6.1.1。控制</p><p>名称服务器必须采用多个并发活动，无论这些活动是在主机OS中作为单独的任务实现还是在单个名称服务器程序中进行多路复用。名称服务器在等待TCP数据刷新或查询活动时阻止UDP请求的服务是完全不可接受的。类似地，尽管名称服务器可以选择序列化来自单个客户端的请求，或将来自相同客户端的相同请求视为重复，但也不应尝试在不并行处理此类请求的情况下尝试提供递归服务。名称服务器从主文件重新加载区域或将新刷新的区域合并到数据库中时，名称服务器不应实质上延迟请求。</p><h3 id="6-1-2。数据库"><a href="#6-1-2。数据库" class="headerlink" title="6.1.2。数据库"></a>6.1.2。数据库</h3><p>尽管名称服务器实现可以自由使用他们选择的任何内部数据结构，但建议的结构包括三个主要部分：</p><p>   -“目录”数据结构，该数据结构列出了该服务器可用的区域，以及指向该区域数据结构的“指针”。该结构的主要目的是找到最接近的祖先区域（如果有的话），以到达标准查询。</p><p>   -名称服务器所保留的每个区域的单独数据结构。</p><p>   -用于缓存数据的数据结构。 （或者可能为不同的类使用单独的缓存）</p><p>所有这些数据结构都可以用相同的树结构格式实现，不同部分的节点之间链接的数据不同：目录中的数据是指向区域的指针，而在区域和缓存数据结构中，数据将是RR。在设计树框架时，设计人员应认识到查询处理将需要使用不区分大小写的标签比较来遍历树。并且在实际数据中，少数节点具有很高的分支因子（100-1000或更高），但是绝大多数节点的分支因子非常低（0-1）。</p><p>解决大小写问题的一种方法是将每个节点的标签存储为两部分：标签的标准化大小写表示，其中所有ASCII字符都在一种情况下，以及位掩码，该掩码表示哪些字符实际上是一个字符。不同的情况。可以使用节点的简单链接列表来处理分支因子多样性，直到分支因子超过某个阈值为止，并在超过阈值之后过渡到哈希结构。无论如何，用于存储树部分的哈希结构必须确保哈希函数和过程保留DNS的大小写约定。</p><p>对数据库的不同部分使用单独的结构是出于以下几个因素的推动：</p><p>   -目录结构可以是几乎静态的结构，仅当系统管理员更改服务器支持的区域时才需要更改。此结构也可以用于存储用于控制刷新活动的参数。</p><p>   -区域的各个数据结构允许简单地通过更改目录中的指针来替换区域。区域刷新操作可以构建新的结构，完成后，可以通过简单的指针替换将其拼接到数据库中。刷新区域非常重要，查询不应同时使用旧数据和新数据。</p><p>   -通过适当的搜索过程，区域中的权威数据将始终“隐藏”，因此优先于缓存的数据。</p><p>   -导致重叠区域等的区域定义错误可能会导致对查询的错误响应，但是问题确定得以简化，并且一个“不良”区域的内容不会破坏另一个区域。</p><p>   -由于高速缓存的更新频率最高，因此在重新启动系统时最容易受到损坏。它还可能充满已过期的RR数据。无论哪种情况，都可以很容易地将其丢弃而不会干扰区域数据。</p><p>数据库设计的一个主要方面是选择一种结构，该结构允许名称服务器处理名称服务器主机的崩溃问题。名称服务器应在系统崩溃时保存的状态信息包括目录结构（包括每个区域的刷新状态）和区域数据本身。</p><h3 id="6-1-3。时间"><a href="#6-1-3。时间" class="headerlink" title="6.1.3。时间"></a>6.1.3。时间</h3><p>RR的TTL数据和刷新活动的定时数据都取决于以秒为单位的32位计时器。在数据库内部，高速缓存的数据的刷新计时器和TTL在概念上是“递减计数”，而区域中的数据则保持不变的TTL。</p><p>推荐的实施策略是以两种方式存储时间：相对增量和绝对时间。一种方法是对一种类型使用正32位数字，对另一种类型使用负数。区域中的RR使用相对时间；刷新计时器和缓存数据使用绝对时间。绝对数是相对于某些已知原点的，并在放入查询的响应中时转换为相对值。转换为相对值后，如果绝对TTL为负，则数据过期，应将其忽略。</p><h2 id="6-2。标准查询处理"><a href="#6-2。标准查询处理" class="headerlink" title="6.2。标准查询处理"></a>6.2。标准查询处理</h2><p>[RFC-1034]中介绍了标准查询处理的主要算法。</p><p>当使用QCLASS = *或其他与多个类匹配的QCLASS处理查询时，除非服务器可以保证该响应涵盖所有类，否则响应绝不应该是权威的。</p><p>编写响应时，可以在附加部分中省略要插入到附加部分中的RR，但是在应答或授权部分中重复的RR。</p><p>当响应太长而需要截断时，截断应从响应的结尾开始，并在数据报中继续进行。因此，如果权限部分有任何数据，则保证答案部分是唯一的。</p><p>SOA中的MINIMUM值应用于设置从区域分发的数据的TTL的下限。当将数据复制到响应中时，应执行该下限功能。这将允许将来的动态更新协议在没有歧义语义的情况下更改SOA MINIMUM字段。</p><h2 id="6-3。区域刷新和重新加载处理"><a href="#6-3。区域刷新和重新加载处理" class="headerlink" title="6.3。区域刷新和重新加载处理"></a>6.3。区域刷新和重新加载处理</h2><p>尽管服务器已尽力而为，但由于语法错误等原因，它可能无法从主文件加载区域数据，或者无法刷新其到期参数内的区域。在这种情况下，名称服务器应该回答查询，好像它不应该拥有该区域一样。</p><p>如果主服务器正在通过AXFR发送区域，并且在传输期间创建了新版本，则主服务器应尽可能继续发送旧版本。无论如何，它绝不应该发送一个版本的一部分而发送另一个版本的一部分。如果无法完成，则主机应重置进行区域传输的连接。</p><h2 id="6-4。逆查询（可选）"><a href="#6-4。逆查询（可选）" class="headerlink" title="6.4。逆查询（可选）"></a>6.4。逆查询（可选）</h2><p>反向查询是DNS的可选部分。不需要名称服务器支持任何形式的反向查询。如果名称服务器收到它不支持的反向查询，则它将返回错误响应，并在标头中设置“未实现”错误。尽管反向查询支持是可选的，但所有名称服务器都必须至少能够返回错误响应。</p><h3 id="6-4-1。反向查询和响应的内容。"><a href="#6-4-1。反向查询和响应的内容。" class="headerlink" title="6.4.1。反向查询和响应的内容。"></a>6.4.1。反向查询和响应的内容。</h3><p>逆查询逆向由标准查询操作执行的映射。标准查询将域名映射到资源，而反向查询将资源映射到域名。例如，标准查询可能会将域名绑定到主机地址。相应的反向查询将主机地址绑定到域名。</p><p>反向查询在消息的答案部分采用单个RR的形式，而问题部分为空。查询RR的所有者名称及其TTL不重要。响应在“问题”部分带有问题，这些问题标识拥有查询RR的所有名称，其中“名称服务器知道”。由于没有名称服务器知道所有域名空间，因此永远不能假定响应是完整的。因此，反向查询主要用于数据库管理和调试活动。反向查询不是将主机地址映射到主机名的可接受方法。请改用IN-ADDR.ARPA域。</p><p>在可能的情况下，名称服务器应为反向查询提供不区分大小写的比较。因此，要求MX RR为“ Venera.isi.edu”的反向查询应获得与对“ VENERA.ISI.EDU”的查询相同的响应。 HINFO RR“ IBM-PC UNIX”的反向查询应产生与“ IBM-pc unix”的反向查询相同的结果。但是，这不能保证，因为名称服务器可能拥有包含字符串的RR，但是名称服务器不知道数据是字符。</p><p>当名称服务器处理反向查询时，它将返回：</p><p>   1.在问题部分中以QNAME的形式指定资源的零个，一个或多个域名</p><p>   2.错误代码，指示名称服务器不支持指定资源类型的反向映射。</p><p>当对反向查询的响应包含一个或多个QNAME时，定义反向查询的答案部分中RR的所有者名称和TTL被修改为与第一个QNAME上找到的RR完全匹配。</p><p>反向查询中返回的RR不能使用与对标准查询的答复相同的机制进行缓存。这样做的一个原因是，一个名称可能具有多个相同类型的RR，并且只会出现一个。例如，对多宿主主机的单个地址进行反向查询可能会给人留下只有一个地址存在的印象。</p><h3 id="6-4-2。反向查询和响应示例"><a href="#6-4-2。反向查询和响应示例" class="headerlink" title="6.4.2。反向查询和响应示例"></a>6.4.2。反向查询和响应示例</h3><p>检索与Internet地址10.1.0.52对应的域名的反向查询的总体结构如下所示：</p><div class="code-wrapper"><pre><code class="hljs">                     + ----------------------------------------- +       标头| OPCODE = IQUERY，ID = 997 |                     + ----------------------------------------- +      问题&lt;空&gt; |                     + ----------------------------------------- +       回答| &lt;任何名称&gt; A IN 10.1.0.52 |                     + ----------------------------------------- +      权威| &lt;空&gt; |                     + ----------------------------------------- +     附加| &lt;空&gt; |                     + ----------------------------------------- +</code></pre></div><p>该查询询问一个问题，其答案是Internet样式地址10.1.0.52。由于所有者名称未知，因此任何域名都可以用作占位符（并且会被忽略）。通常使用单个八位字节（表示根）为零，因为它可以最大程度地减少消息的长度。 RR的TTL不重要。<br>该查询的响应可能是：</p><div class="code-wrapper"><pre><code class="hljs">                     + ----------------------------------------- +       标头| OPCODE =响应，ID = 997 |                     + ----------------------------------------- +      问题| QTYPE = A，QCLASS = IN，QNAME = VENERA.ISI.EDU |                     + ----------------------------------------- +       回答| VENERA.ISI.EDU A IN 10.1.0.52 |                     + ----------------------------------------- +      权威| &lt;空&gt; |                     + ----------------------------------------- +     附加| &lt;空&gt; |                     + ----------------------------------------- +</code></pre></div><p>请注意，对反向查询的响应中的QTYPE与反向查询的答案部分中的TYPE字段相同。当逆查询不是唯一的时，对逆查询的响应可能包含多个问题。如果响应中的问题部分不为空，则将答案部分中的RR修改为对应于第一个QNAME上RR的精确副本。</p><h3 id="6-4-3。逆查询处理"><a href="#6-4-3。逆查询处理" class="headerlink" title="6.4.3。逆查询处理"></a>6.4.3。逆查询处理</h3><p>支持反向查询的名称服务器可以通过详尽搜索其数据库来支持这些操作，但是随着数据库大小的增加，这变得不切实际。另一种方法是根据搜索关键字反转数据库。</p><p>对于支持多个区域和大量数据的名称服务器，建议的方法是为每个区域分别进行反转。在刷新期间更改特定区域时，只需重做其反转。</p><p>域系统的将来版本中可能包含对这种类型的反转的传输的支持，但此版本不支持。</p><h2 id="6-5。完成查询和响应"><a href="#6-5。完成查询和响应" class="headerlink" title="6.5。完成查询和响应"></a>6.5。完成查询和响应</h2><p>RFC-882和RFC-883中描述的可选完成服务已删除。重新设计的服务可能会在将来提供。</p><p>＃7.解析器的实现</p><p>在[RFC-1034]中讨论了推荐的解析器算法的顶层。本部分讨论了实现细节，并假定本备忘录的名称服务器实现部分中建议的数据库结构为建议。</p><h2 id="7-1。将用户请求转换为查询"><a href="#7-1。将用户请求转换为查询" class="headerlink" title="7.1。将用户请求转换为查询"></a>7.1。将用户请求转换为查询</h2><p>解析器采取的第一步是将客户的请求（以适合于本地OS的格式表示）转换为以特定名称匹配特定QTYPE和QCLASS的RR的搜索规范。在可能的情况下，QTYPE和QCLASS应该对应于一个单一的类型和一个单一的类，因为这使缓存数据的使用更加简单。这样做的原因是，高速缓存中一种类型的数据的存在并不能确认其他类型的数据的存在或不存在，因此要确保的唯一方法是咨询权威人士。如果使用QCLASS = *，那么权威性的答案将不可用。</p><p>由于解析程序要想有效地执行其功能，必须能够复用多个请求，因此每个待处理的请求通常以状态信息的某些块表示。此状态块通常包含：</p><p>   -指示请求开始时间的时间戳。时间戳用于确定数据库中的RR是否可以使用或已过期。此时间戳使用先前讨论的绝对时间格式在区域和缓存中存储RR。请注意，当RRs TTL指示相对时间时，由于它是区域的一部分，因此RR必须及时。当RR具有绝对时间时，它是缓存的一部分，并且将RR的TTL与请求开始的时间戳进行比较。</p><div class="code-wrapper"><pre><code class="hljs"> 请注意，使用时间戳优于使用当前时间，因为使用时间戳可以将TTL为零的RR以通常的方式输入到缓存中，但即使由于系统负载而间隔了几秒钟之后，当前请求仍会使用它，查询重传超时等。</code></pre></div><p>   -某种参数，用于限制将为此请求执行的工作量。</p><div class="code-wrapper"><pre><code class="hljs"> 必须限制解析器响应客户端请求所做的工作量，以防止数据库中的错误（例如，循环的CNAME引用）和操作问题（例如，网络分区，阻止解析器访问其名称服务器）需求。虽然本地限制解析器将特定查询重新发送到特定名称服务器地址的次数非常重要，但解析器应具有全局的每个请求计数器，以限制单个请求的工作。计数器应设置为某个初始值，并在解析器执行任何操作（重传超时，重传等）时递减。如果计数器传递零，则请求将因临时错误而终止。 请注意，如果解析程序结构允许一个请求并行启动其他请求，例如当需要访问一个名称服务器的请求导致对名称服务器的地址进行并行解析时，则应使用较低的计数器启动产生的请求。这样可以防止数据库中的循环引用启动解析程序活动的链式反应。</code></pre></div><p>   -在[RFC-1034]中讨论的SLIST数据结构。</p><div class="code-wrapper"><pre><code class="hljs"> 如果必须等待外部名称服务器的答复，则此结构会跟踪请求的状态。</code></pre></div><h2 id="7-2。发送查询"><a href="#7-2。发送查询" class="headerlink" title="7.2。发送查询"></a>7.2。发送查询</h2><p>如[RFC-1034]中所述，解析程序的基本任务是制定一个查询，该查询将回答客户端的请求，并将该查询定向到可以提供信息的名称服务器。解析程序通常只会以NS RR的形式非常强烈地提示要询问哪些服务器，并且可能必须修改响应于CNAME的查询，或修改解析程序正在查询的名称服务器集，以响应委派响应，该响应指向解析器指向更接近所需信息的名称服务器。除了客户端请求的信息之外，解析器可能还必须调用其自身的服务来确定其希望联系的名称服务器的地址。</p><p>无论如何，本备忘录中使用的模型都假定解析器在多个请求之间进行多路复用，其中一些请求来自客户端，有些内部生成。每个请求都由一些状态信息表示，并且所需的行为是解析程序以使请求得到答复的可能性最大，使请求花费的时间最小化并避免过多传输的方式将查询发送到名称服务器。密钥算法使用请求的状态信息来选择要查询的下一个名称服务器地址，并且还计算超时，如果响应未到达，该超时将导致下一个操作。下一步操作通常是传输到其他服务器，但可能是客户端的暂时错误。</p><p>解析程序始终以要查询的服务器名称列表（SLIST）开头。此列表将是所有NS RR，它们对应于解析器知道的最接近的祖先区域。为避免启动问题，解析器应具有一组默认服务器，如果没有合适的当前NS RR，它将询问。然后，解析器将名称服务器的所有已知地址添加到SLIST中，并且当解析器具有名称服务器的名称但没有地址时，解析器可能会开始并行请求以获取服务器的地址。</p><p>为了完成SLIST的初始化，解析器会将其具有的所有历史记录信息附加到SLIST中的每个地址。这通常包括地址响应时间的某种加权平均值和地址的击球平均值（即，地址对请求的响应频率）。请注意，此信息应按每个地址保存，而不是按每个名称服务器保存，因为特定服务器的响应时间和平均击球率可能因地址而异。还请注意，此信息实际上特定于解析器地址/服务器地址对，因此具有多个地址的解析器可能希望为其每个地址保留单独的历史记录。此步骤的一部分必须处理没有此类历史记录的地址；在这种情况下，预期的5-10秒的往返时间应该是最坏的情况，而对于相同的本地网络等的估算值则较低。</p><p>请注意，只要遵循委托，解析程序算法就会重新初始化SLIST。</p><p>该信息将建立可用名称服务器地址的部分排名。每次选择一个地址，都应更改状态以防止再次选择它，直到尝试了所有其他地址。每次传输的超时应比平均预测值大50-100％，以允许响应发生变化。</p><p>一些要点：</p><p>   -解析程序可能会遇到以下情况：对于SLIST中命名的任何名称服务器，没有地址可用，并且列表中的服务器正是通常用于查找其自身地址的服务器。这种情况通常发生在以下情况：胶水地址RR的TTL小于NS RR的标记委托，或者解析器缓存NS搜索的结果。解析器应检测到这种情况，并在下一个祖先区域或根目录处重新开始搜索。</p><p>   -如果解析程序从名称服务器收到服务器错误或其他奇怪的响应，则应将其从SLIST中删除，并可能希望安排立即传输到下一个候选服务器地址。</p><h2 id="7-3。处理回应"><a href="#7-3。处理回应" class="headerlink" title="7.3。处理回应"></a>7.3。处理回应</h2><p>处理到达的响应数据报的第一步是解析响应。此过程应包括：</p><p>   -检查标题是否合理。当期望响应时，丢弃作为查询的数据报。</p><p>   -解析消息的各个部分，并确保所有RR的格式正确。</p><p>   -作为可选步骤，检查到达数据的TTL，以查找TTL过长的RR。如果RR的TTL太长（例如大于1周），则丢弃整个响应，或将响应中的所有TTL限制为1周。</p><p>下一步是使响应与当前的解析器请求匹配。推荐的策略是使用域标头中的ID字段进行初步匹配，然后验证问题部分是否与当前所需的信息相对应。这要求传输算法将域ID字段的几位专用于某种请求标识符。此步骤有几个要点：</p><p>   -一些名称服务器从不同于用于接收查询的地址的地址发送响应。也就是说，解析器不能依靠响应来自与它发送相应查询到的地址相同的地址。在UNIX系统中通常会遇到此名称服务器错误。</p><p>   -如果解析器将特定请求重新传输到名称服务器，则它应该能够使用来自任何传输的响应。但是，如果它使用响应来采样访问名称服务器的往返时间，则它必须能够确定与该响应匹配的传输（并保持每个传出消息的传输时间），或者仅基于以下时间来计算往返时间初始传输。</p><p>   -根据某些NS RR，名称服务器有时将不具有其应具有的区域的当前副本。解析程序应仅从当前SLIST中删除名称服务器，然后继续。</p><h2 id="7-4。使用缓存"><a href="#7-4。使用缓存" class="headerlink" title="7.4。使用缓存"></a>7.4。使用缓存</h2><p>通常，我们希望解析器缓存其在响应中接收到的所有数据，因为它可能对回答将来的客户端请求很有用。但是，有几种类型的数据不应该被缓存：</p><p>   -当特定所有者名称的多个相同类型的RR可用时，解析器应全部缓存或完全不缓存它们。当响应被截断并且解析器不知道它是否具有完整集时，它不应缓存可能的部分RR集。</p><p>   -永远不要优先使用缓存的数据来代替权威数据，因此，如果缓存会导致这种情况发生，则不应缓存数据。</p><p>   -反向查询的结果不应被缓存。</p><p>   -如果数据可能用于构造通配符，则QNAME包含“ *”标签的标准查询的结果。原因是高速缓存不一定包含现有的RR或区域边界信息，而这是限制通配RR的应用所必需的。</p><p>   -可疑可靠性响应中的RR数据。当解析程序收到请求之外的未经请求的响应或RR数据时，应将其丢弃而不进行缓存。基本含义是，应先对数据包进行所有完整性检查，然后再对其进行缓存。</p><p>同样，当解析程序在响应中具有一组用于某些名称的RR，并且想要缓存RR时，它应检查其缓存中是否已存在RR。根据情况，响应或高速缓存中的数据是首选，但决不要将两者结合在一起。如果响应中的数据来自答案部分中的权威数据，则总是首选。</p><p>＃8.邮件支持</p><p>域系统定义了将邮箱映射到域名的标准，以及两种使用邮箱信息导出邮件路由信息的方法。第一种方法称为邮件交换绑定，另一种方法称为邮箱绑定。邮箱编码标准和邮件交换绑定是DNS官方协议的一部分，是Internet中邮件路由的推荐方法。邮箱绑定是一项实验性功能，目前仍在开发中，并且可能会发生变化。</p><p>邮箱编码标准假定邮箱名称的格式为“ &lt;本地部分&gt; @ &lt;邮件域&gt;”。尽管这些部分中的每个部分中允许的语法在各种邮件Internet之间都有很大的不同，但ARPA Internet的首选语法在[RFC-822]中给出。</p><p>DNS将<local-part>编码为单个标签，并将<mail-domain>编码为域名。 <local-part>中的单个标签以<mail-domain>中的域名开头，以形成与邮箱相对应的域名。因此，邮箱<a href="mailto:&#72;&#79;&#83;&#84;&#77;&#65;&#x53;&#84;&#69;&#82;&#x40;&#83;&#x52;&#x49;&#45;&#x4e;&#73;&#x43;&#46;&#65;&#82;&#x50;&#65;">&#72;&#79;&#83;&#84;&#77;&#65;&#x53;&#84;&#69;&#82;&#x40;&#83;&#x52;&#x49;&#45;&#x4e;&#73;&#x43;&#46;&#65;&#82;&#x50;&#65;</a>被映射到域名HOSTMASTER.SRI-NIC.ARPA。如果<local-part>包含点或其他特殊字符，则其在主文件中的表示形式将需要使用反斜杠引号来确保域名正确编码。例如，邮箱<a href="mailto:&#x41;&#x63;&#116;&#x69;&#x6f;&#x6e;&#46;&#100;&#x6f;&#109;&#x61;&#105;&#110;&#x73;&#64;&#x49;&#83;&#73;&#46;&#x45;&#68;&#x55;">&#x41;&#x63;&#116;&#x69;&#x6f;&#x6e;&#46;&#100;&#x6f;&#109;&#x61;&#105;&#110;&#x73;&#64;&#x49;&#83;&#73;&#46;&#x45;&#68;&#x55;</a>将表示为Action \ .domains.ISI.EDU。</p><h2 id="8-1。邮件交换绑定"><a href="#8-1。邮件交换绑定" class="headerlink" title="8.1。邮件交换绑定"></a>8.1。邮件交换绑定</h2><p>邮件交换绑定使用邮箱规范的<mail-domain>部分来确定应将邮件发送到的位置。甚至没有参考<local-part>。 [RFC-974]详细指定了此方法，在尝试使用邮件交换支持之前应进行咨询。</p><p>此方法的优点之一是，它使邮件目标名称与用于支持邮件服务的主机脱钩，但代价是查找功能中需要另外一层间接层。但是，加法层应避免在<local-part>中使用复杂的“％”，“！”等编码。</p><p>该方法的本质是将<mail-domain>用作域名来查找类型MX RR，该MX RR列出愿意接受<mail-domain>的邮件的主机，以及根据主机对主机进行排序的优先级值由管理员为<mail-domain>指定。</p><p>在本备忘录中，示例中将<mail-domain> ISI.EDU与主机VENERA.ISI.EDU和VAXA.ISI.EDU一起用作ISI.EDU的邮件交换。如果邮件发给<a href="mailto:&#x4d;&#111;&#99;&#x6b;&#97;&#112;&#101;&#116;&#114;&#x69;&#115;&#64;&#73;&#x53;&#73;&#x2e;&#x45;&#x44;&#x55;">&#x4d;&#111;&#99;&#x6b;&#97;&#112;&#101;&#116;&#114;&#x69;&#115;&#64;&#73;&#x53;&#73;&#x2e;&#x45;&#x44;&#x55;</a>的邮件，它将通过查找ISI.EDU的MX RR进行路由。 ISI.EDU上的MX RR分别名为VENERA.ISI.EDU和VAXA.ISI.EDU，类型为A的查询可以找到主机地址。</p><h2 id="8-2。邮箱绑定（实验性）"><a href="#8-2。邮箱绑定（实验性）" class="headerlink" title="8.2。邮箱绑定（实验性）"></a>8.2。邮箱绑定（实验性）</h2><p>在邮箱绑定中，邮件程序使用整个邮件目标规范来构造域名。邮箱的编码域名在QTYPE = MAILB查询中用作QNAME字段。</p><p>此查询可能有几种结果：</p><p>   1.查询可能返回名称错误，表明邮箱不存在为域名。</p><div class="code-wrapper"><pre><code class="hljs">  从长远来看，这将表明指定的邮箱不存在。但是，在普遍使用邮箱绑定之前，应将此错误条件解释为意味着由全局部分标识的组织不支持邮箱绑定。适当的过程是此时恢复交换绑定。</code></pre></div><p>   2.查询可以返回邮件重命名（MR）RR。</p><div class="code-wrapper"><pre><code class="hljs">  MR RR在其RDATA字段中带有新的邮箱规范。邮件程序应将旧邮箱替换为新邮箱，然后重试该操作。</code></pre></div><p>   3.查询可以返回MB RR。</p><div class="code-wrapper"><pre><code class="hljs">  MB RR在其RDATA字段中携带主机的域名。邮件程序应该通过任何适用的协议（例如b，SMTP）将邮件传递到该主机。</code></pre></div><p>   4.查询可以返回一个或多个邮件组（MG）RR。</p><div class="code-wrapper"><pre><code class="hljs">  这种情况意味着该邮箱实际上是一个邮件列表或邮件组，而不是单个邮箱。每个MG RR都有一个RDATA字段，用于标识作为该组成员的邮箱。邮件发送者应将邮件的副本发送给每个成员。</code></pre></div><p>   5.查询可以返回MB RR以及一个或多个MG RR。</p><div class="code-wrapper"><pre><code class="hljs">  这种情况意味着该邮箱实际上是一个邮件列表。邮件程序可以将消息传递到MB RR所指定的主机，该主机进而将邮件传递给所有成员，或者邮件程序可以使用MG RR自己进行扩展。</code></pre></div><p>在任何这些情况下，响应都可以包括邮件信息（MINFO）RR。此RR通常与邮件组相关联，但对于MB合法。 MINFO RR标识两个邮箱。其中之一标识原始邮箱名称的负责人。此邮箱应用于添加到邮件组等的请求。MINFO RR中的第二个邮箱名称标识一个应接收有关邮件故障的错误消息的邮箱。当成员姓名的错误应报告给向列表发送消息的人以外的其他人时，这尤其适用于邮寄列表。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>99windows下常用目录</title>
    <link href="/2023/05/26/04DevOps/99windows%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/05/26/04DevOps/99windows%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li>临时文件目录<br>  C:\Users\wanghaibin\AppData\Local\Temp</li><li>hosts文件目录<br>  C:\Windows\System32\drivers\etc</li></ul>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unbound_subnet请求分析</title>
    <link href="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <url>/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>测试请求命令如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></div></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">root@whb-dev-1eaf52c0a</span> <span class="hljs-string">packaging</span>]<span class="hljs-comment"># ./dig @127.0.0.1  -p 10054  www.baidu.com. +subnet=182.61.128.241</span><br><br><span class="hljs-string">;</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">DiG</span> <span class="hljs-number">9.11</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">@127.0.0.1</span> <span class="hljs-string">-p</span> <span class="hljs-number">10054</span> <span class="hljs-string">www.baidu.com.</span> <span class="hljs-string">+subnet=182.61.128.241</span><br><span class="hljs-string">;</span> <span class="hljs-string">(1</span> <span class="hljs-string">server</span> <span class="hljs-string">found)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">global options:</span> <span class="hljs-string">+cmd</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">Got answer:</span><br><span class="hljs-string">;;</span> <span class="hljs-string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="hljs-attr">opcode:</span> <span class="hljs-string">QUERY,</span> <span class="hljs-attr">status:</span> <span class="hljs-string">NOERROR,</span> <span class="hljs-attr">id:</span> <span class="hljs-number">24481</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">flags:</span> <span class="hljs-string">qr</span> <span class="hljs-string">rd</span> <span class="hljs-string">ra;</span> <span class="hljs-attr">QUERY:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">ANSWER:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">AUTHORITY:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">ADDITIONAL:</span> <span class="hljs-number">1</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">OPT PSEUDOSECTION:</span><br><span class="hljs-string">;</span> <span class="hljs-attr">EDNS: version:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-string">flags:;</span> <span class="hljs-attr">udp:</span> <span class="hljs-number">1232</span><br><span class="hljs-string">;</span> <span class="hljs-attr">CLIENT-SUBNET:</span> <span class="hljs-number">182.61</span><span class="hljs-number">.128</span><span class="hljs-number">.241</span><span class="hljs-string">/32/27</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">QUESTION SECTION:</span><br><span class="hljs-string">;www.baidu.com.</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">ANSWER SECTION:</span><br><span class="hljs-string">www.baidu.com.</span><span class="hljs-number">1200</span><span class="hljs-string">IN</span><span class="hljs-string">CNAME</span><span class="hljs-string">www.a.shifen.com.</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">14.119</span><span class="hljs-number">.104</span><span class="hljs-number">.254</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">14.119</span><span class="hljs-number">.104</span><span class="hljs-number">.189</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">Query time:</span> <span class="hljs-number">762</span> <span class="hljs-string">msec</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">SERVER:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-comment">#10054(127.0.0.1)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">WHEN:</span> <span class="hljs-string">Tue</span> <span class="hljs-string">May</span> <span class="hljs-number">09</span> <span class="hljs-number">09</span><span class="hljs-string">:29:16</span> <span class="hljs-string">CST</span> <span class="hljs-number">2023</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">MSG SIZE  rcvd:</span> <span class="hljs-number">113</span><br><br>[<span class="hljs-string">root@whb-dev-1eaf52c0a</span> <span class="hljs-string">packaging</span>]<span class="hljs-comment"># ./dig @127.0.0.1  -p 10054  www.baidu.com. +subnet=0.0.0.0</span><br><br><span class="hljs-string">;</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">DiG</span> <span class="hljs-number">9.11</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">@127.0.0.1</span> <span class="hljs-string">-p</span> <span class="hljs-number">10054</span> <span class="hljs-string">www.baidu.com.</span> <span class="hljs-string">+subnet=0.0.0.0</span><br><span class="hljs-string">;</span> <span class="hljs-string">(1</span> <span class="hljs-string">server</span> <span class="hljs-string">found)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">global options:</span> <span class="hljs-string">+cmd</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">Got answer:</span><br><span class="hljs-string">;;</span> <span class="hljs-string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="hljs-attr">opcode:</span> <span class="hljs-string">QUERY,</span> <span class="hljs-attr">status:</span> <span class="hljs-string">NOERROR,</span> <span class="hljs-attr">id:</span> <span class="hljs-number">44788</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">flags:</span> <span class="hljs-string">qr</span> <span class="hljs-string">rd</span> <span class="hljs-string">ra;</span> <span class="hljs-attr">QUERY:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">ANSWER:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">AUTHORITY:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">ADDITIONAL:</span> <span class="hljs-number">1</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">OPT PSEUDOSECTION:</span><br><span class="hljs-string">;</span> <span class="hljs-attr">EDNS: version:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-string">flags:;</span> <span class="hljs-attr">udp:</span> <span class="hljs-number">1232</span><br><span class="hljs-string">;</span> <span class="hljs-attr">CLIENT-SUBNET:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/32/24</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">QUESTION SECTION:</span><br><span class="hljs-string">;www.baidu.com.</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">ANSWER SECTION:</span><br><span class="hljs-string">www.baidu.com.</span><span class="hljs-number">1200</span><span class="hljs-string">IN</span><span class="hljs-string">CNAME</span><span class="hljs-string">www.a.shifen.com.</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">180.101</span><span class="hljs-number">.50</span><span class="hljs-number">.188</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">180.101</span><span class="hljs-number">.50</span><span class="hljs-number">.242</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">Query time:</span> <span class="hljs-number">977</span> <span class="hljs-string">msec</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">SERVER:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-comment">#10054(127.0.0.1)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">WHEN:</span> <span class="hljs-string">Tue</span> <span class="hljs-string">May</span> <span class="hljs-number">09</span> <span class="hljs-number">09</span><span class="hljs-string">:29:27</span> <span class="hljs-string">CST</span> <span class="hljs-number">2023</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">MSG SIZE  rcvd:</span> <span class="hljs-number">113</span><br><br>[<span class="hljs-string">root@whb-dev-1eaf52c0a</span> <span class="hljs-string">packaging</span>]<span class="hljs-comment"># ./dig @127.0.0.1  -p 10054  www.baidu.com.</span><br><br><span class="hljs-string">;</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">DiG</span> <span class="hljs-number">9.11</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">@127.0.0.1</span> <span class="hljs-string">-p</span> <span class="hljs-number">10054</span> <span class="hljs-string">www.baidu.com.</span><br><span class="hljs-string">;</span> <span class="hljs-string">(1</span> <span class="hljs-string">server</span> <span class="hljs-string">found)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">global options:</span> <span class="hljs-string">+cmd</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">Got answer:</span><br><span class="hljs-string">;;</span> <span class="hljs-string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="hljs-attr">opcode:</span> <span class="hljs-string">QUERY,</span> <span class="hljs-attr">status:</span> <span class="hljs-string">NOERROR,</span> <span class="hljs-attr">id:</span> <span class="hljs-number">1793</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">flags:</span> <span class="hljs-string">qr</span> <span class="hljs-string">rd</span> <span class="hljs-string">ra;</span> <span class="hljs-attr">QUERY:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">ANSWER:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">AUTHORITY:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">ADDITIONAL:</span> <span class="hljs-number">1</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">OPT PSEUDOSECTION:</span><br><span class="hljs-string">;</span> <span class="hljs-attr">EDNS: version:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-string">flags:;</span> <span class="hljs-attr">udp:</span> <span class="hljs-number">1232</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">QUESTION SECTION:</span><br><span class="hljs-string">;www.baidu.com.</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">ANSWER SECTION:</span><br><span class="hljs-string">www.baidu.com.</span><span class="hljs-number">1200</span><span class="hljs-string">IN</span><span class="hljs-string">CNAME</span><span class="hljs-string">www.a.shifen.com.</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">180.101</span><span class="hljs-number">.50</span><span class="hljs-number">.242</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">180.101</span><span class="hljs-number">.50</span><span class="hljs-number">.188</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">Query time:</span> <span class="hljs-number">19</span> <span class="hljs-string">msec</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">SERVER:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-comment">#10054(127.0.0.1)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">WHEN:</span> <span class="hljs-string">Tue</span> <span class="hljs-string">May</span> <span class="hljs-number">09</span> <span class="hljs-number">09</span><span class="hljs-string">:29:31</span> <span class="hljs-string">CST</span> <span class="hljs-number">2023</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">MSG SIZE  rcvd:</span> <span class="hljs-number">101</span><br><br>[<span class="hljs-string">root@whb-dev-1eaf52c0a</span> <span class="hljs-string">packaging</span>]<span class="hljs-comment"># ./dig @127.0.0.1  -p 10054  www.baidu.com. +subnet=43.225.211.37</span><br><br><span class="hljs-string">;</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">DiG</span> <span class="hljs-number">9.11</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">@127.0.0.1</span> <span class="hljs-string">-p</span> <span class="hljs-number">10054</span> <span class="hljs-string">www.baidu.com.</span> <span class="hljs-string">+subnet=43.225.211.37</span><br><span class="hljs-string">;</span> <span class="hljs-string">(1</span> <span class="hljs-string">server</span> <span class="hljs-string">found)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">global options:</span> <span class="hljs-string">+cmd</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">Got answer:</span><br><span class="hljs-string">;;</span> <span class="hljs-string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="hljs-attr">opcode:</span> <span class="hljs-string">QUERY,</span> <span class="hljs-attr">status:</span> <span class="hljs-string">NOERROR,</span> <span class="hljs-attr">id:</span> <span class="hljs-number">40316</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">flags:</span> <span class="hljs-string">qr</span> <span class="hljs-string">rd</span> <span class="hljs-string">ra;</span> <span class="hljs-attr">QUERY:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">ANSWER:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">AUTHORITY:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">ADDITIONAL:</span> <span class="hljs-number">1</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">OPT PSEUDOSECTION:</span><br><span class="hljs-string">;</span> <span class="hljs-attr">EDNS: version:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-string">flags:;</span> <span class="hljs-attr">udp:</span> <span class="hljs-number">1232</span><br><span class="hljs-string">;</span> <span class="hljs-attr">CLIENT-SUBNET:</span> <span class="hljs-number">43.225</span><span class="hljs-number">.211</span><span class="hljs-number">.37</span><span class="hljs-string">/32/22</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">QUESTION SECTION:</span><br><span class="hljs-string">;www.baidu.com.</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">ANSWER SECTION:</span><br><span class="hljs-string">www.baidu.com.</span><span class="hljs-number">1200</span><span class="hljs-string">IN</span><span class="hljs-string">CNAME</span><span class="hljs-string">www.a.shifen.com.</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">182.61</span><span class="hljs-number">.200</span><span class="hljs-number">.6</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">182.61</span><span class="hljs-number">.200</span><span class="hljs-number">.7</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">Query time:</span> <span class="hljs-number">89</span> <span class="hljs-string">msec</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">SERVER:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-comment">#10054(127.0.0.1)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">WHEN:</span> <span class="hljs-string">Tue</span> <span class="hljs-string">May</span> <span class="hljs-number">09</span> <span class="hljs-number">09</span><span class="hljs-string">:29:40</span> <span class="hljs-string">CST</span> <span class="hljs-number">2023</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">MSG SIZE  rcvd:</span> <span class="hljs-number">113</span><br><br>[<span class="hljs-string">root@whb-dev-1eaf52c0a</span> <span class="hljs-string">packaging</span>]<span class="hljs-comment"># ./dig @127.0.0.1  -p 10054  www.baidu.com. +subnet=1.225.211.37</span><br><br><span class="hljs-string">;</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">DiG</span> <span class="hljs-number">9.11</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-string">&lt;&lt;&gt;&gt;</span> <span class="hljs-string">@127.0.0.1</span> <span class="hljs-string">-p</span> <span class="hljs-number">10054</span> <span class="hljs-string">www.baidu.com.</span> <span class="hljs-string">+subnet=1.225.211.37</span><br><span class="hljs-string">;</span> <span class="hljs-string">(1</span> <span class="hljs-string">server</span> <span class="hljs-string">found)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">global options:</span> <span class="hljs-string">+cmd</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">Got answer:</span><br><span class="hljs-string">;;</span> <span class="hljs-string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="hljs-attr">opcode:</span> <span class="hljs-string">QUERY,</span> <span class="hljs-attr">status:</span> <span class="hljs-string">NOERROR,</span> <span class="hljs-attr">id:</span> <span class="hljs-number">25463</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">flags:</span> <span class="hljs-string">qr</span> <span class="hljs-string">rd</span> <span class="hljs-string">ra;</span> <span class="hljs-attr">QUERY:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">ANSWER:</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-attr">AUTHORITY:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-attr">ADDITIONAL:</span> <span class="hljs-number">1</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">OPT PSEUDOSECTION:</span><br><span class="hljs-string">;</span> <span class="hljs-attr">EDNS: version:</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-string">flags:;</span> <span class="hljs-attr">udp:</span> <span class="hljs-number">1232</span><br><span class="hljs-string">;</span> <span class="hljs-attr">CLIENT-SUBNET:</span> <span class="hljs-number">1.225</span><span class="hljs-number">.211</span><span class="hljs-number">.37</span><span class="hljs-string">/32/12</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">QUESTION SECTION:</span><br><span class="hljs-string">;www.baidu.com.</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">ANSWER SECTION:</span><br><span class="hljs-string">www.baidu.com.</span><span class="hljs-number">1200</span><span class="hljs-string">IN</span><span class="hljs-string">CNAME</span><span class="hljs-string">www.a.shifen.com.</span><br><span class="hljs-string">www.a.shifen.com.</span><span class="hljs-number">30</span><span class="hljs-string">IN</span><span class="hljs-string">CNAME</span><span class="hljs-string">www.wshifen.com.</span><br><span class="hljs-string">www.wshifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">119.63</span><span class="hljs-number">.197</span><span class="hljs-number">.151</span><br><span class="hljs-string">www.wshifen.com.</span><span class="hljs-number">300</span><span class="hljs-string">IN</span><span class="hljs-string">A</span><span class="hljs-number">119.63</span><span class="hljs-number">.197</span><span class="hljs-number">.139</span><br><br><span class="hljs-string">;;</span> <span class="hljs-attr">Query time:</span> <span class="hljs-number">552</span> <span class="hljs-string">msec</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">SERVER:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-comment">#10054(127.0.0.1)</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">WHEN:</span> <span class="hljs-string">Tue</span> <span class="hljs-string">May</span> <span class="hljs-number">09</span> <span class="hljs-number">09</span><span class="hljs-string">:29:46</span> <span class="hljs-string">CST</span> <span class="hljs-number">2023</span><br><span class="hljs-string">;;</span> <span class="hljs-attr">MSG SIZE  rcvd:</span> <span class="hljs-number">139</span><br></code></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>通过上述结果知道一共做了5次dig查询</p><table><thead><tr><th>次数</th><th>携带subnet信息</th><th>耗时(msec)</th><th>分析说明</th></tr></thead><tbody><tr><td>1</td><td>+subnet=182.61.128.241</td><td>762</td><td>耗时较长说明做了递归查询</td></tr><tr><td>2</td><td>+subnet=0.0.0.0</td><td>977</td><td></td></tr><tr><td>3</td><td>无</td><td>19</td><td>耗时较短说明没有做递归查询直接命中</td></tr><tr><td>4</td><td>+subnet=43.225.211.37</td><td>89</td><td></td></tr><tr><td>5</td><td>+subnet=1.225.211.37</td><td>552</td><td></td></tr></tbody></table><h2 id="第一个请求分析"><a href="#第一个请求分析" class="headerlink" title="第一个请求分析"></a>第一个请求分析</h2><ol><li><p>dig 向本地的10054端口 发起A记录查询</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-0.png" class=""></li><li><p>unbound向权威 192.58.128.30 发起ns请求查询<br>其中192.58.128.30为unbound配置文件中指定的root.hints文件中配置的13个根地址信息。此请求可以获取到最新的13个根配置数据信息</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-1.png" class=""></li><li><p>收到权威NS请求应答数据，包含13个根的NS信息，Additional 信息中包含27条记录信息，分别是13条A记录，13条AAAA记录和1条subnet信息</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-2.png" class=""><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-3.png" class=""></li><li><p>发起递归查询com的A记录查询</p></li></ol><p>携带subnet信息向13个根中的某一个(192.33.4.13)发起 com 的A记录查询</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-4.png" class=""><ol start="5"><li><p>获取到com A记录查询结果<br>返回获取到的com的A的查询结果，返回com的13个ns信息，在Additional包含27条记录，其中13条com的A记录记过，13条AAAA记录结果和1条原始subnet信息</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-5.png" class=""></li><li><p>向com结果中某一个地址发起(192.54.112.30) baidu.com的A记录查询<br>查询时携带客户端subnet信息</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-6.png" class=""></li><li><p>获取到baidu.com的A记录结果</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-7.png" class=""><p>从结果中可以看到baidu.com返回的subnet为0</p></li><li><p>向baidu.com某个地址发起查询<a href="http://www.baidu.com/">www.baidu.com</a> 的A记录查询<br>发起查询时携带subnet记录信息</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-8.png" class=""></li><li><p>获取到cname的结果<a href="http://www.a.shifen.com/">www.a.shifen.com</a><br>返回携带subnet信息，scope mask为0</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-9.png" class=""></li><li><p>向某个com地址发起 shifen.com 的A记录查询<br>查询时携带客户端subnet信息</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-10.png" class=""></li><li><p>获取shifen.com的A记录查询结果</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-11.png" class=""></li><li><p>向某个 shifen.com 地址发起 a.shifen.com 的A记录查询</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-12.png" class=""></li><li><p>获取到a.shifen.com 的A记录查询结果</p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-13.png" class=""></li><li><p>根据a.shifen.com的结果向180.76.76.95发起<a href="http://www.a.shifen.com的a记录查询/">www.a.shifen.com的A记录查询</a></p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-14.png" class=""></li><li><p>获取到<a href="http://www.a.shifen.com的a记录查询结果/">www.a.shifen.com的A记录查询结果</a></p><img src="/2023/05/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound_subnet%E8%AF%B7%E6%B1%82%E5%88%86%E6%9E%90/1-15.png" class=""><p>获取到<a href="http://www.a.shifen.com的结果,且scope/">www.a.shifen.com的结果，且scope</a> mask为27</p></li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li>当用户请求携带subnet信息时, 递归查询时也会携带用户的subnet信息</li><li>当用户请求携带subnet信息时，结果有cname时, unbound做cname递归查询解析时仍然会携带客户端传递的cname信息</li></ul>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dns</tag>
      
      <tag>unbound</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nm 目标文件格式分析《转》</title>
    <link href="/2023/04/26/04DevOps/26nm%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/26/04DevOps/26nm%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>本文章转载自 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html</a></p><p>nm 命令显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库。如果文件没有包含符号信息，nm 命令报告该情况，但不把它解释为出错条件。 nm 命令缺省情况下报告十进制符号表示法下的数字值。</p><figure class="highlight sqf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs sqf"><br>$nm myProgrammer<br><span class="hljs-number">08049</span>f28 d <span class="hljs-variable">_DYNAMIC</span><br><span class="hljs-number">08049</span>ff4 d <span class="hljs-variable">_GLOBAL_OFFSET_TABLE_</span><br><span class="hljs-number">080484</span>dc R <span class="hljs-variable">_IO_stdin_used</span><br>         w <span class="hljs-variable">_Jv_RegisterClasses</span><br><span class="hljs-number">08049</span>f18 d <span class="hljs-variable">__CTOR_END__</span><br><span class="hljs-number">08049</span>f14 d <span class="hljs-variable">__CTOR_LIST__</span><br><span class="hljs-number">08049</span>f20 D <span class="hljs-variable">__DTOR_END__</span><br><span class="hljs-number">08049</span>f1c d <span class="hljs-variable">__DTOR_LIST__</span><br><span class="hljs-number">080485</span>e0 r <span class="hljs-variable">__FRAME_END__</span><br><span class="hljs-number">08049</span>f24 d <span class="hljs-variable">__JCR_END__</span><br><span class="hljs-number">08049</span>f24 d <span class="hljs-variable">__JCR_LIST__</span><br><span class="hljs-number">0804</span>a014 A <span class="hljs-variable">__bss_start</span><br><span class="hljs-number">0804</span>a00c D <span class="hljs-variable">__data_start</span><br><span class="hljs-number">08048490</span> t <span class="hljs-variable">__do_global_ctors_aux</span><br><span class="hljs-number">08048360</span> t <span class="hljs-variable">__do_global_dtors_aux</span><br><span class="hljs-number">0804</span>a010 D <span class="hljs-variable">__dso_handle</span><br>         w <span class="hljs-variable">__gmon_start__</span><br><span class="hljs-number">08048482</span> T <span class="hljs-variable">__i686</span>.get_pc_thunk.bx<br><span class="hljs-number">08049</span>f14 d <span class="hljs-variable">__init_array_end</span><br><span class="hljs-number">08049</span>f14 d <span class="hljs-variable">__init_array_start</span><br><span class="hljs-number">08048480</span> T <span class="hljs-variable">__libc_csu_fini</span><br><span class="hljs-number">08048410</span> T <span class="hljs-variable">__libc_csu_init</span><br>         U <span class="hljs-variable">__libc_start_main</span>@@GLIBC_2.<span class="hljs-number">0</span><br><span class="hljs-number">0804</span>a014 A <span class="hljs-variable">_edata</span><br><span class="hljs-number">0804</span>a01c A <span class="hljs-variable">_end</span><br><span class="hljs-number">080484</span>bc T <span class="hljs-variable">_fini</span><br><span class="hljs-number">080484</span>d8 R <span class="hljs-variable">_fp_hw</span><br><span class="hljs-number">080482</span>b4 T <span class="hljs-variable">_init</span><br><span class="hljs-number">08048330</span> T <span class="hljs-variable">_start</span><br><span class="hljs-number">0804</span>a014 b completed.<span class="hljs-number">6086</span><br><span class="hljs-number">0804</span>a00c W data_start<br><span class="hljs-number">0804</span>a018 b dtor_idx.<span class="hljs-number">6088</span><br><span class="hljs-number">080483</span>c0 t frame_dummy<br><span class="hljs-number">080483</span>e4 T main<br>         U printf@@GLIBC_2.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这些包含可执行代码的段称为正文段。同样地，数据段包含了不可执行的信息或数据。另一种类型的段，称为 BSS 段，它包含以符号数据开头的块。对于 nm 命令列出的每个符号，它们的值使用十六进制来表示（缺省行为），并且在该符号前面加上了一个表示符号类型的编码字符。</p><p>可以将目标文件中所包含的不同的部分划分为段。段可以包含可执行代码、符号名称、初始数据值和许多其他类型的数据。有关这些类型的数据的详细信息，可以阅读 UNIX 中 nm 的 man 页面，其中按照该命令输出中的字符编码分别对每种类型进行了描述。</p><h1 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h1><hr><ul><li>-a或–debug-syms：显示所有的符号，包括debugger-only symbols。  </li><li>-B：等同于–format=bsd，用来兼容MIPS的nm。  </li><li>-C或–demangle：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</li><li>–no-demangle：默认的选项，不需要将低级符号名解析成用户级名。</li><li>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。  </li><li>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。  </li><li>-g或–extern-only：仅显示外部符号。  </li><li>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。  </li><li>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。  </li><li>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。  </li><li>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。  </li><li>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。  </li><li>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。  </li><li>–target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。  </li><li>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</li><li>–defined-only:仅显示定义的符号。  </li><li>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。 </li><li>-V或–version：显示nm的版本号。  </li><li>–help：显示nm的选项。</li></ul><h1 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h1><hr><p>对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的。</p><ul><li><p>A  该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</p></li><li><p>B  该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。</p></li><li><p>C  该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。    </p></li><li><p>D  该符号位于初始化数据段中。一般来说，分配到data section中。</p><div class="code-wrapper"><pre><code class="hljs">  例如：定义全局int baud_table[5] = &#123;9600, 19200, 38400, 57600, 115200&#125;，会分配到初始化数据段中。</code></pre></div></li><li><p>G  该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。</p></li><li><p>I  该符号是对另一个符号的间接引用。     </p></li><li><p>N  该符号是一个debugging符号。         </p></li><li><p>R  该符号位于只读数据区。</p><ul><li>例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。</li><li>值得注意的是，如果在一个函数中定义const char *test = “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。 </li></ul></li><li><p>S  符号位于非初始化数据区，用于small object。</p></li><li><p>T  该符号位于代码区text section。       </p></li><li><p>U  该符号在当前文件中是未定义的，即该符号的定义在别的文件中。<br>  例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。</p></li><li><p>V  该符号是一个weak object。       </p></li><li><p>W  The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.       </p></li><li><p>?  该符号类型没有定义</p></li></ul><p><em>库或对象名</em><br>如果您指定了 -A 选项，则 nm 命令只报告与该文件有关的或者库或者对象名。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><hr><ol><li>寻找特殊标识</li></ol><p>有时会碰到一个编译了但没有链接的代码，那是因为它缺失了标识符；这种情况，可以用nm和objdump、readelf命令来查看程序的符号表；所有这些命令做的工作基本一样；</p><p>比如连接器报错有未定义的标识符；大多数情况下，会发生在库的缺失或企图链接一个错误版本的库的时候；浏览目标代码来寻找一个特殊标识符的引用::</p><div class="code-wrapper"><pre><code class="hljs">nm -uCA *.o | grep foo</code></pre></div><p>-u选项限制了每个目标文件中未定义标识符的输出。-A选项用于显示每个标识符的文件名信息；对于C++代码，常用的还有-C选项，它也为解码这些标识符；</p><p>.. note::</p><div class="code-wrapper"><pre><code class="hljs">objdump、readld命令可以完成同样的任务。等效命令为：$objdump  -t$readelf -s</code></pre></div><ol start="2"><li><p>列出 a.out 对象文件的静态和外部符::</p><p> $nm -e a.out</p></li><li><p>以十六进制显示符号大小和值并且按值排序符号::</p><p> $nm -xv a.out</p></li><li><p>显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象::</p><p> $nm -X64 /usr/lib/libc.a</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unbound配置说明</title>
    <link href="/2023/04/14/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/04/14/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="stub-zone和forward-zone区别"><a href="#stub-zone和forward-zone区别" class="headerlink" title="stub zone和forward zone区别"></a>stub zone和forward zone区别</h1><p>相同点:</p><ul><li>两者配置很相似，都是向上游请求接收到的特定域名的请求数据</li></ul><p>不同点:</p><ul><li>stub 会修改接收到的原始DNS请求包中的<code>RD 标记为0</code>，从而向上游请求时上游server不会返回递归结果，forward不会修改原始标记<code>RD</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dns</tag>
      
      <tag>unbound</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unbound源码修改---rbtree用法总结</title>
    <link href="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E4%BD%BF%E7%94%A8rbtree/"/>
    <url>/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E4%BD%BF%E7%94%A8rbtree/</url>
    
    <content type="html"><![CDATA[<p>unbound中大量使用rbtree, 相关用法如下</p><ul><li><p>定义rbtree存储节点数据结构</p><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">struct ipset_domain_node &#123;<br>    rbnode_type node<span class="hljs-comment">;</span><br>    char * domain<span class="hljs-comment">;</span><br>    char * name<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br><br>struct ipset_env &#123;<br>    void* mnl<span class="hljs-comment">;</span><br><br>    int v4_enabled<span class="hljs-comment">;</span><br>    int v6_enabled<span class="hljs-comment">;</span><br><br>    const char *name_v4<span class="hljs-comment">;</span><br>    const char *name_v6<span class="hljs-comment">;</span><br>    rbtree_type * domain_tree<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>定义节点比较函数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//文件间定义</span><br><span class="hljs-built_in">int</span> ipset<span class="hljs-constructor">_domain_cmp(<span class="hljs-params">const</span> <span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">left</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">right</span>)</span>;<br><br><span class="hljs-comment">// c文件中实现</span><br><span class="hljs-built_in">int</span> ipset<span class="hljs-constructor">_domain_cmp(<span class="hljs-params">const</span> <span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">left</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">right</span>)</span> &#123;<br>    return strcmp(((<span class="hljs-keyword">struct</span> ipset_domain_node*)left)-&gt;domain,<br>            ((<span class="hljs-keyword">struct</span> ipset_domain_node*)right)-&gt;domain);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改<code>util/fptr_wlist.c</code> 中的 <code>fptr_whitelist_rbtree_cmp</code>函数<br>增加新增的比较函数判定</p><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E4%BD%BF%E7%94%A8rbtree/rbtree_0.png" class=""></li><li><p>创建rbtree</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">rbtree_type<span class="hljs-operator"> * </span>domain_tree = rbtree<span class="hljs-constructor">_create(&amp;<span class="hljs-params">ipset_domain_cmp</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>插入节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">static void ipset_add_node(rbtree_type * tree, const char * domain,<br>        const char * setname) &#123;<br>    struct ipset_domain_node * <span class="hljs-keyword">node</span><span class="hljs-title">= (struct</span> ipset_domain_node *)calloc(<span class="hljs-number">1</span>,<br>            sizeof(struct ipset_domain_node));<br>    if(<span class="hljs-attr">NULL=</span>=domain || <span class="hljs-attr">NULL=</span>=setname) &#123;<br>        return;<br>    &#125;<br>    if(domain[strlen(domain)-<span class="hljs-number">1</span>] != &#x27;.&#x27;) &#123;<br>        char tmp[BUFF_LEN] = &#123;<span class="hljs-number">0</span>&#125;;<br>        snprintf(tmp, BUFF_LEN, <span class="hljs-string">&quot;%s.&quot;</span>, domain);<br>        <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;domain</span> =  strdup(tmp);<br>    &#125; else &#123;<br>        <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;domain</span> =  strdup(domain);<br>    &#125;<br>    <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;name</span> = strdup(setname);<br>    <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;node</span>.key = <span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">    rbtree_insert</span>(tree, &amp;<span class="hljs-keyword">node</span><span class="hljs-title">-&gt;node</span>);                                     <br>&#125;                                                                                <br>  <br></code></pre></td></tr></table></figure></li><li><p>查询节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">if(domain_tree) &#123;<br>     struct ipset_domain_node key, *<span class="hljs-keyword">node</span><span class="hljs-title">;</span><br><span class="hljs-title">     key</span>.domain = (char*)qname;<br>     key.node.key = &amp;key;<br>     <span class="hljs-keyword">node</span> <span class="hljs-title">= (struct</span> ipset_domain_node*)rbtree_search(domain_tree, &amp;key);<br>     if(<span class="hljs-keyword">node</span><span class="hljs-title">) &#123;</span><br><span class="hljs-title">         setname</span> = <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;name</span>;<br>         verbose(VERB_ALGO, <span class="hljs-string">&quot;ipset find qname=%s, setname=%s&quot;</span>,                <br>                 qname, <span class="hljs-keyword">node</span><span class="hljs-title">-&gt;name</span>);                                          <br>     &#125;                                                                        <br> &#125;           <br></code></pre></td></tr></table></figure></li><li><p>清理时树节点遍历删除</p><ul><li>定义树清理时的遍历清理函数<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xl">static void ipset_del_node(rbnode_type* x, void* ATTR_UNUSED(arg)) &#123;<br>   struct ipset_domain_node* v = (struct ipset_domain_node*)x;<br>   <span class="hljs-function"><span class="hljs-title">verbose</span>(VERB_ALGO, &quot;ipset free domain=%s, <span class="hljs-keyword">name</span>=%s&quot;, v-&gt;</span><span class="hljs-function"><span class="hljs-title">domain</span>, v-&gt;</span><span class="hljs-keyword">name</span>);<br>   <span class="hljs-function"><span class="hljs-title">free</span>(v-&gt;</span>domain);<br>   <span class="hljs-function"><span class="hljs-title">free</span>(v-&gt;</span><span class="hljs-keyword">name</span>);<br>   free(v);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>清理树时调用循环处理函数<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">traverse<span class="hljs-constructor">_postorder(<span class="hljs-params">domain_tree</span>, <span class="hljs-params">ipset_del_node</span>, NULL)</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>dns</tag>
      
      <tag>unbound</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unbound源码修改---配置文件增加变量</title>
    <link href="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/"/>
    <url>/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>unbound配置文件增加新的变量大概经过以下4个步骤即可</p><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 在util/config<span class="hljs-emphasis">_file.h的struct config_</span>file中增加变量名<br><span class="hljs-bullet">2.</span> 在util/config<span class="hljs-emphasis">_file.c中初始化相关变量并解析</span><br><span class="hljs-emphasis">3. 在util/configparser.y中增加对应的变量赋值语句</span><br><span class="hljs-emphasis">4. 在util/configlexer.lex 中引用上一步中的变量</span><br></code></pre></td></tr></table></figure><h1 id="在util-config-file-h-的struct-config-file中增加变量名"><a href="#在util-config-file-h-的struct-config-file中增加变量名" class="headerlink" title="在util/config_file.h 的struct config_file中增加变量名"></a>在<code>util/config_file.h</code> 的<code>struct config_file</code>中增加变量名</h1><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_0.png" class=""><h1 id="在-util-config-file-c-中初始化相关变量并解析"><a href="#在-util-config-file-c-中初始化相关变量并解析" class="headerlink" title="在 util/config_file.c 中初始化相关变量并解析"></a>在 <code>util/config_file.c</code> 中初始化相关变量并解析</h1><ul><li><p>在<code>config_create</code> 函数中初始化变量</p><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_1.png" class=""><ul><li>在 <code>config_create_forlib</code> 函数中初始化变量<br>如果变量在libunbound库中使用则需要在config_create_forlib中也初始化相关变量.<img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_4.png" class=""></li></ul></li><li><p>在 <code>config_get_option</code> 函数中获取到配置文件中信息到变量中</p><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_2.png" class=""><ul><li>在 <code>config_set_option</code> 函数中设置配置文件中的变量内容<br>如果变量在 libunbound 或 remote 控制中可用的话也需要在此函数中进行进行</li></ul></li><li><p>在 <code>config_delete</code> 函数中释放申请的字符串资源</p><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_3.png" class=""></li></ul><h1 id="在-util-configparser-y-中增加对应的变量赋值语句"><a href="#在-util-configparser-y-中增加对应的变量赋值语句" class="headerlink" title="在 util/configparser.y 中增加对应的变量赋值语句"></a>在 <code>util/configparser.y</code> 中增加对应的变量赋值语句</h1><ul><li><p>%token 部分增加自动生成变量</p><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_5.png" class=""></li><li><p>在分组变量内增加新的变量</p></li></ul><p>注意下图的分组格式</p><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_6.png" class=""><p>下图为在ipset模块contents中增加新的变量</p><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_7.png" class=""><ul><li>增加自动变量判定逻辑<br>关联token中的VAR_IPSET_NAME_DOMAIN和 ipset_name_domain<img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_8.png" class=""></li></ul><h1 id="在-util-configlexer-lex-中引用上一步中的变量"><a href="#在-util-configlexer-lex-中引用上一步中的变量" class="headerlink" title="在 util/configlexer.lex 中引用上一步中的变量"></a>在 <code>util/configlexer.lex</code> 中引用上一步中的变量</h1><img src="/2023/04/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F/cf_add_9.png" class="">]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>dns</tag>
      
      <tag>unbound</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ipset与iptables</title>
    <link href="/2023/04/11/04DevOps/25ipset%E4%B8%8Eiptables/"/>
    <url>/2023/04/11/04DevOps/25ipset%E4%B8%8Eiptables/</url>
    
    <content type="html"><![CDATA[<p>ipset和iptables是两个独立的Linux内核组件，但它们可以协同工作，共同实现Linux系统上的网络安全功能。</p><p>具体来说，ipset是用于管理大规模IP地址集合的内核模块，可用于在Linux系统上创建、修改和删除多个IP地址集。而iptables是Linux上的一种防火墙框架，它允许管理员在网络数据包传输前、中、后的不同阶段对其进行过滤、修改、转发等操作。</p><p>ipset和iptables可以互相协作，使得iptables防火墙规则可以更高效地处理大规模的IP地址集合。通常情况下，iptables规则是基于多个IP地址进行拦截和过滤，而当IP地址的数量特别大时，使用iptables单独处理这些地址可能会导致性能问题。为了解决这个问题，管理员可以使用ipset来创建和管理大规模IP地址集合。然后，通过iptables规则，请参考指定这些IP集合，使管理员可以更加高效、简洁的定义规则。</p><p>使用ipset与iptables的组合可以实现比基于iptables的规则更高效、灵活的网络安全策略。</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unbound源码分析</title>
    <link href="/2023/04/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/10/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/unbound%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="初始化核心流程"><a href="#初始化核心流程" class="headerlink" title="初始化核心流程"></a>初始化核心流程</h2><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">main---------------------------------------unbound<span class="hljs-selector-class">.c</span>    <span class="hljs-comment">// 程序入口</span><br>    run_daemon-----------------------------unbound<span class="hljs-selector-class">.c</span>    <span class="hljs-comment">// 启动守护服务</span><br>        daemon_open_shared_ports-------unbound<span class="hljs-selector-class">.c</span>    <span class="hljs-comment">// 打开监听端口</span><br>        daemon_fork------------------------daemon<span class="hljs-selector-class">.c</span>     <span class="hljs-comment">// 启动服务</span><br>                daemon_create_workers----------daemon<span class="hljs-selector-class">.c</span>     <span class="hljs-comment">// 创建工作线程对象和资源</span><br>                        worker_create--------------worker<span class="hljs-selector-class">.c</span>     <span class="hljs-comment">// 创建各个工作线程对象，每个对象负责部分部分临时端口数据</span><br><span class="hljs-comment">// 的接收和发送</span><br>                worker_init--------------------worker<span class="hljs-selector-class">.c</span>     <span class="hljs-comment">// 工作线程初始化，worker_start_accept，</span><br>                        worker_start_accept--------worker<span class="hljs-selector-class">.c</span>     <span class="hljs-comment">// 启动监听并accept</span><br>                        worker_handle_request------worker<span class="hljs-selector-class">.c</span>     <span class="hljs-comment">// 请求处理函数</span><br>                        tube_setup_bg_listen-------util/tube<span class="hljs-selector-class">.c</span>  <span class="hljs-comment">// 管理命令后台监听服务</span><br>                daemon_start_others(daemon)---------daemon<span class="hljs-selector-class">.c</span>    <span class="hljs-comment">// 启动非主线程的其他工作线程</span><br>                        thread_start--------------------daemon<span class="hljs-selector-class">.c</span>    <span class="hljs-comment">//线程工作函数</span><br>                                worker_work(worker)---------wroker<span class="hljs-selector-class">.c</span>    <span class="hljs-comment">// 工作线程进入工作循环</span><br>                worker_work(daemon-&gt;workers<span class="hljs-selector-attr">[0]</span>)-----worker<span class="hljs-selector-class">.c</span>   <span class="hljs-comment">// 启动主工作线程循环处理事件，大家都监听udp端口进行数据循环处理</span><br></code></pre></td></tr></table></figure><h2 id="工作线程循环处理事件"><a href="#工作线程循环处理事件" class="headerlink" title="工作线程循环处理事件"></a>工作线程循环处理事件</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">main<span class="hljs-params">---------daemon/unbound</span>.c<br>    run_daemon<span class="hljs-params">---------daemon/unbound</span>.c<br>        daemon_fork <span class="hljs-params">--------------daemon/daemon</span>.c<br>            worker_work<span class="hljs-params">-----worker</span>.c<br>                comm_base_dispatch<span class="hljs-params">----------util/netevent</span>.c<br>                    ub_event_base_dispatch<span class="hljs-params">-------util/ub_event</span>.c   <span class="hljs-string">//</span> 事件封装<br>                        event_base_dispatch<span class="hljs-params">------util/mini_event</span>.c <span class="hljs-string">//</span> 进入while事件循环处理过程 《事件处理可替换为libevent》<br>                            handle_select<span class="hljs-params">--------util/mini_event</span>.c  <span class="hljs-string">//</span> 调用selec阻塞等待事件并回调处理函数<br></code></pre></td></tr></table></figure><h2 id="开启端口监听过程"><a href="#开启端口监听过程" class="headerlink" title="开启端口监听过程"></a>开启端口监听过程</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">main<span class="hljs-params">---------------------------------------unbound</span>.c    <span class="hljs-string">//</span> 程序入口<br>    run_daemon<span class="hljs-params">-----------------------------unbound</span>.c    <span class="hljs-string">//</span> 启动守护服务<br>        daemon_open_shared_ports<span class="hljs-params">-------unbound</span>.c    <span class="hljs-string">//</span> 打开监听端口<br>            listening_ports_open<span class="hljs-params">-------services/listen_dnsport</span>.c <span class="hljs-string">//</span>开启端口监听<br>                ports_create_<span class="hljs-keyword">if</span><span class="hljs-params">--------services/listen_dnsport</span>.c <br>                    。。。。<span class="hljs-params">--------services/listen_dnsport</span>.c<br>                     make_sock<span class="hljs-params">--------services/listen_dnsport</span>.c   <span class="hljs-string">//</span>创建tcp和udp端口监听句柄到<br>                   port_insert<span class="hljs-params">--------services/listen_dnsport</span>.c   <span class="hljs-string">//</span>将创建的端口监听对象加入到daemon-&gt;ports中,在《tcp 及udp事件处理回调函数的设置》中将ports加入到事件循环中<br></code></pre></td></tr></table></figure><h2 id="tcp-及udp事件处理回调函数的设置"><a href="#tcp-及udp事件处理回调函数的设置" class="headerlink" title="tcp 及udp事件处理回调函数的设置"></a>tcp 及udp事件处理回调函数的设置</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xl">worker_init-------------------------------daemon/worker.c<br>    listen_create(ports, worker_handle_request)-------------------------services/listen_dnsport.c <span class="hljs-comment">// 创建监听对象,并设置监听回调函数为 worker_handle_request</span><br>    comm_point_create_udp_ancil-------util/netevent.c             <span class="hljs-comment">// 创建udp通信辅助事件， 配置文件中的interface-automatic 设置为yes则调用此函数</span><br><span class="hljs-function"><span class="hljs-title">c</span>-&gt;</span>callback = callback; <span class="hljs-comment">// 设置udp回调函数</span><br>            <span class="hljs-function"><span class="hljs-title">c</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">ev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">ev</span> = ub_event_new(xxx, comm_point_udp_ancil_callback)   // 创建事件管理对象，和c关联, 在 comm_point_udp_ancil_callback 中回调到c-&gt;</span>callback函数 worker_handle_request<br>            ub_event_add() -------------util/netevent.c              <span class="hljs-comment">// 将udp句柄加入事件监听循环中</span><br>                event_add---------------util/mini_event.c           <span class="hljs-comment">// 加入监听队列</span><br>        comm_point_create_udp-------------util/netevent.c             <span class="hljs-comment">// 创建udp事件</span><br>            <span class="hljs-function"><span class="hljs-title">c</span>-&gt;</span>callback = callback; <span class="hljs-comment">// 设置udp回调函数</span><br>            <span class="hljs-function"><span class="hljs-title">c</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">ev</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">ev</span> = ub_event_new(xxx, comm_point_udp_callback)   // 创建事件管理对象，和c关联, comm_point_udp_callback中会回调到c-&gt;</span>callback函数<br>            ub_event_add() -------------util/netevent.c              <span class="hljs-comment">// 将udp句柄加入事件监听循环中</span><br>                event_add---------------util/mini_event.c           <span class="hljs-comment">// 加入监听队列</span><br><br>        comm_point_create_tcp---------------util/netevent.c       <span class="hljs-comment">// 创建tcp事件</span><br>            <span class="hljs-function"><span class="hljs-title">c</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">ev</span>-&gt;</span>ev = = ub_event_new(comm_point_tcp_accept_callback) <span class="hljs-comment">// 设置tcp accept请求回调处理函数</span><br>            ub_event_add()------------util/netevent.c              <span class="hljs-comment">// 将udp句柄加入事件监听循环中</span><br>             .....<br></code></pre></td></tr></table></figure><h2 id="客户端udp请求处理过程"><a href="#客户端udp请求处理过程" class="headerlink" title="客户端udp请求处理过程"></a>客户端udp请求处理过程</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">worker_handle_request-------daemon/worker.c           <span class="hljs-comment">// udp请求处理回调函数</span><br>    mesh_new_client-------------services/mesh.c           <span class="hljs-comment">// 创建来自客户端的新查询</span><br>        mesh_run()--------------services/mesh.c           <span class="hljs-comment">// 遍历所有模块进行数据处理，如subnetcache、validator、iterator</span><br>(*<span class="hljs-function"><span class="hljs-title">mesh</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">mods</span>.<span class="hljs-built_in">mod</span>[mstate-&gt;</span><span class="hljs-function"><span class="hljs-title">s</span>.curmod]-&gt;</span><span class="hljs-function"><span class="hljs-title">operate</span>)(&amp;mstate-&gt;</span><span class="hljs-function"><span class="hljs-title">s</span>, ev, mstate-&gt;</span>s.curmod, e);  <span class="hljs-comment">// 回调各个模块的operate函数，如subnetmod_operate、iterator_operate</span><br>          <br></code></pre></td></tr></table></figure><h3 id="iterator-处理过程"><a href="#iterator-处理过程" class="headerlink" title="iterator 处理过程"></a>iterator 处理过程</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">iter_operate  ----------------------<span class="hljs-keyword">iterator</span>/<span class="hljs-keyword">iterator</span>.c <span class="hljs-comment">// 递归处理入口函数</span><br>process_request-----------------<span class="hljs-keyword">iterator</span>/<span class="hljs-keyword">iterator</span>.c <span class="hljs-comment">// 请求处理主要入口点</span><br>iter_handle-----------------<span class="hljs-keyword">iterator</span>/<span class="hljs-keyword">iterator</span>.c <span class="hljs-comment">// 循环状态机，当前线程根据状态进行forward等查询，直到获取结果并返回信息</span><br></code></pre></td></tr></table></figure><h4 id="iterator查询结果缓存过程"><a href="#iterator查询结果缓存过程" class="headerlink" title="iterator查询结果缓存过程"></a>iterator查询结果缓存过程</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">mesh_run</span><span class="hljs-params">()</span></span>--------------services/mesh<span class="hljs-selector-class">.c</span> <br>iter_operate--------------------iterator/iterator<span class="hljs-selector-class">.c</span><br>iter_dns_store----------------iterator/iter_util<span class="hljs-selector-class">.c</span> <span class="hljs-comment">// iter封装的存储接口</span><br>dns_cache_store-----------services/cache/dns<span class="hljs-selector-class">.c</span> <span class="hljs-comment">// 全局可用存储接口，根据参数决定是否只存储rrset或rrset和msg都存储</span><br>dns_cache_store_msg---services/cache/dns<span class="hljs-selector-class">.c</span> <span class="hljs-comment">// rrset和msg都存储接口</span><br></code></pre></td></tr></table></figure><h2 id="remote-远程请求accept设置过程"><a href="#remote-远程请求accept设置过程" class="headerlink" title="remote 远程请求accept设置过程"></a>remote 远程请求accept设置过程</h2><p>只有线程序号为0的主线程进行accept请求处理，其他未业务请求</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">worker_start_accept<span class="hljs-params">--------worker</span>.c     <span class="hljs-string">//</span> 启动监听并accept<br>    daemon_remote_start_accept<span class="hljs-params">--------daemon/remote</span>.c     <span class="hljs-string">//</span> 根据配置的地址列表进行监听处理<br>        comm_point_start_listening<span class="hljs-params">------util/netevent</span>.c   <span class="hljs-string">//</span><br></code></pre></td></tr></table></figure><h2 id="remote-control-服务端启动流程"><a href="#remote-control-服务端启动流程" class="headerlink" title="remote control 服务端启动流程"></a>remote control 服务端启动流程</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">worker_init<span class="hljs-params">--------------------------------worker</span>.c     <span class="hljs-string">//</span> 工作线程初始化，worker_start_accept，<br>worker_start_accept<span class="hljs-params">--------------------worker</span>.c     <span class="hljs-string">//</span> 启动监听并accept<br>daemon_remote_start_accept<span class="hljs-params">-------daemon/remote</span>.c <span class="hljs-string">//</span> 在线程0中启动 remote_control 相关监听<br>handle_req<span class="hljs-params">------------------daemon/remote</span>.c  <span class="hljs-string">//</span> 启动处理请求处理过程<br>execute_cmd <span class="hljs-params">------------daemon/remote</span>.c  <span class="hljs-string">//</span> 处理具体的请求<br></code></pre></td></tr></table></figure><h2 id="耗时相关代码"><a href="#耗时相关代码" class="headerlink" title="耗时相关代码"></a>耗时相关代码</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">daemon_forkdaemon/daemon.c<br>daemon_setup_modules daemon/daemon.c<br>modstack_setup    services/modstack.c<br>modstack_desetup<br>fptr_whitelist_mod_deinit<br>(*stack-&gt;mod[i]-&gt;deinit)(env, i);<br>subnetmod_deinit    edns-subnet/subnetmod.c<br>slabhash_delete  util<span class="hljs-regexp">/storage/</span>slabhash.c   <span class="hljs-regexp">//</span> 此函数修改为自定义的qy_slabhash_delete函数, 实际耗时可能在此处<br>lruhash_deleteutil<span class="hljs-regexp">/storage/</span>lruhash.c<br>bin_delete               util<span class="hljs-regexp">/storage/</span>lruhash.c<br></code></pre></td></tr></table></figure><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><h2 id="module（即插件）"><a href="#module（即插件）" class="headerlink" title="module（即插件）"></a>module（即插件）</h2><p> unbound 中的 <code>module</code> 即模块(插件)。支持以下模块</p><table><thead><tr><th>模块名</th><th>作用</th><th>其他</th></tr></thead><tbody><tr><td>validator</td><td>用于验证DNSSEC签名有效性，确保DNS解析查询结果的完整性和不可篡改性</td><td></td></tr><tr><td>respip</td><td>允许使用ACL（访问控制列表）限制哪些IP地址可以访问特定的域名 或 基于IP修改响应结果</td><td></td></tr><tr><td>pythonmod</td><td>允许以Python脚本的形式扩展Unbound功能，可以实现自定义的DNS处理逻辑</td><td></td></tr><tr><td>iterator</td><td>实现Unbound的迭代DNS解析查询功能，向远端DNS服务器递归查询所需DNS记录</td><td></td></tr><tr><td>subnet</td><td>用于配置Unbound服务器的子网访问控制策略，允许或禁止指定子网的访问</td><td></td></tr><tr><td>subnetcache</td><td>实现了支持不同子网对 DNS 解析结果进行缓存的功能。当一个请求来自于一个特定的子网时，subnetcache 模块会将 DNS 解析结果缓存下来，以便以后在该子网中的相同请求中能够快速响应</td><td>编译支持ECS时默认开启此模块</td></tr><tr><td>subnetcachedb</td><td>支持对存储数据进行加密，保护缓存数据的隐私和安全。可以与 subnetcache 模块结合使用，以提供更高效的DNS解析缓存策略</td><td></td></tr><tr><td>dns64</td><td>实现DNS64代理，将IPv4 DNS请求转换为IPv6地址并返回响应</td><td></td></tr><tr><td>rpz</td><td>实现RPZ（Responsibility Provenance Zone）功能，支持自定义DNS黑名单和白名单</td><td></td></tr><tr><td>prefetch</td><td>提前查询DNS记录，以缩短DNS响应时间，提高用户的访问速度</td><td></td></tr></tbody></table><p>这些模块可以通过配置文件中的 <code>module-config</code> 选项进行加载和配置，以实现各种不同的功能。同时，Unbound还支持许多其他模块，如dnstap模块、subnetcachedb模块、python_certgen模块等，可以根据需要选择适当的模块来实现自己的需求。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>dns</tag>
      
      <tag>unbound</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通配符和正则表达式的区别</title>
    <link href="/2023/01/16/04DevOps/24%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/01/16/04DevOps/24%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>通配符语法比正则表达式简单很多</p><ul><li>通配符一般用于文件路径名匹配</li><li>正则表达式一般用于字符串匹配</li></ul><p>所以在命令行中，与路径相关的命令，比如 cp, ls, find 等，都使用通配符；而与字符串匹配相关的命令，比如 grep，使用正则表达式。</p><p>注意：<em>在通配符和正则表达式中有其不一样的地方，在通配符中</em>可以匹配任意的0个或多个字符，而在正则表达式中他是重复之前的一个或者多个字符，不能独立使用的。比如通配符可以用*来匹配任意字符，而正则表达式不行，他只匹配任意长度的前面的字符。</p><h1 id="通配符规则"><a href="#通配符规则" class="headerlink" title="通配符规则"></a>通配符规则</h1><table><thead><tr><th>符号</th><th>内容</th></tr></thead></table><ul><li>   | 万用字元，代表 0 个或多个字元（或数字）<br>?    | 万用字元，代表『一定有』一个字母<h1 id="注解，这个最常被使用在-script-当中，视为说明！"><a href="#注解，这个最常被使用在-script-当中，视为说明！" class="headerlink" title="| 注解，这个最常被使用在 script 当中，视为说明！"></a>| 注解，这个最常被使用在 script 当中，视为说明！</h1>/    | 跳脱符号，将『特殊字元或万用字元』还原成一般字元<br>|    | 分隔两个管线命令的界定；<br>;    | 连续性命令的界定（注意！与管线命令并不相同）<br>~    | 使用者的家目录<br>$    | 亦即是变数之前需要加的变数取代值<br>&amp;    | 将指令变成背景下工作<br>!    | 逻辑运算意义上的『非』 not 的意思！<br>/    | 路径分隔的符号<blockquote><p>, &gt;&gt;    | 输出导向，分别是『取代』与『累加』<br>‘    | 单引号，不具有变数置换的功能<br>“    | 具有变数置换的功能！<br><code> </code>    | 两个『 ` 』中间为可以先执行的指令！<br>( )    | 在中间为子 shell 的起始与结束<br>[ ]    | 在中间为字元的组合<br>{ }    | 在中间为命令区块的组合！</p></blockquote></li></ul><h1 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a>正则表达式规则</h1><table><thead><tr><th>正则字符</th><th>意义与范例</th></tr></thead><tbody><tr><td>^word</td><td>待搜寻的字串(word)在行首！ <br><br> grep -n ‘^#’ regular_express.txt <br> 搜寻行首为 # 开始的那一行！</td></tr><tr><td>word$</td><td>待搜寻的字串(word)在行尾！  <br><br>  grep -n ‘!$’ regular_express.txt <br> 将行尾为 ! 的那一行列印出来！</td></tr><tr><td>.</td><td>代表『任意一个』字符，一定是一个任意字符！ <br><br> grep -n ‘e.e’ regular_express.txt <br>搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间『一定』仅有一个字元，而空白字元也是字元！</td></tr><tr><td>/</td><td>跳脱字符，将特殊符号的特殊意义去除！  <br><br>  grep -n /‘ regular_express.txt <br> 搜寻含有单引号 ‘ 的那一行！</td></tr></tbody></table><ul><li>   | 重复零个或多个的前一个 RE 字符  <br><br> grep -n ‘ess*’ regular_express.txt <br>找出含有 (es) (ess) (esss) 等等的字串，注意，因为 * 可以是 0 个，所以 es 也是符合带搜寻字串。另外，因为 * 为重复『前一个 RE 字符』的符号， 因此，在 * 之前必须要紧接着一个 RE 字符喔！例如任意字元则为 『.*』 ！<br>/{n,m/}    | 连续 n 到 m 个的『前一个 RE 字符』<br>若为 /{n/} 则是连续 n 个的前一个 RE 字符，<br>若是 /{n,/} 则是连续 n 个以上的前一个 RE 字符！  <br><br>  grep -n ‘Go/{2,3/}g’ regular_express.txt <br>在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)<br>[]    | 字元集合的 RE 特殊字符的符号  <br><br>  [list] <br>范例: grep -n ‘g[ld]’ regular_express.txt<br>搜寻含有 (gl) 或 (gd) 的那一行～,需要特别留意的是，在 [] 当中『谨代表一个待搜寻的字元』，<br>如：a[afl]y 代表搜寻的字串可以是 aay, afy, aly 亦即 [afl] 代表 a 或 f 或 l 的意思！<br><br>[ch1-ch2]<br>范例：grep -n ‘[0-9]’ regular_express.txt<br>搜寻含有任意数字的那一行！需特别留意，在字元集合 [] 中的减号 - 是有特殊意义的，他代表两个字元之间的所有连续字元！但这个连续与否与 ASCII 编码有关， 因此，您的编码需要设定正确(在 bash 当中，需要确定 LANG 与 LANGUAGE 的变数是否正确！) 例如所有大写字元则为 [A-Z]<br><br>[^]<br>范例：grep -n ‘oo[^t]’ regular_express.txt<br>搜寻的字串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时， 代表的意义是『反向选择』的意思～例如，我不要大写字元，则为[^A-Z] ～ 但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻， 却发现该档案内的所有行都被列出，为什么？因为这个 [^A-Z] 是『非大写字元』的意思， 因为每一行均有非大写字元，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小写字元， 以及双引号 (“) 等字元，所以当然符合 [^A-Z] 的搜寻！ </li></ul>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows diskpart 工具弹出顽固硬盘</title>
    <link href="/2023/01/06/04DevOps/23diskpart/"/>
    <url>/2023/01/06/04DevOps/23diskpart/</url>
    
    <content type="html"><![CDATA[<p>使用移动盘时经常弹出设备无法删除的问题, 很多时候发现是被system进程占用，所以不能通过杀掉进程id的方式来弹出设备。经验证使用系统自带的dispart工具的offline 命令可以完美弹出设备。</p><p>具体操作步骤如下：</p><h1 id="打开-diskpart-工具"><a href="#打开-diskpart-工具" class="headerlink" title="打开 diskpart 工具"></a>打开 diskpart 工具</h1><p>win+r 直接输入dispark命令， 回车弹出diskpart 操作命令行</p><img src="/2023/01/06/04DevOps/23diskpart/1.png" class=""><h1 id="选择并-offline-磁盘"><a href="#选择并-offline-磁盘" class="headerlink" title="选择并 offline 磁盘"></a>选择并 offline 磁盘</h1><figure class="highlight vala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 显示挂载的磁盘</span><br>list disk<br><span class="hljs-meta"># 选择当前要操作的磁盘</span><br>select disk <span class="hljs-number">1</span><br><span class="hljs-meta"># 脱机磁盘</span><br>offline disk<br><span class="hljs-meta"># 让当前选择的脱机磁盘上线</span><br>online disk<br></code></pre></td></tr></table></figure><p>执行完<code>offline disk</code> 命令后就可以<code>安全删除硬件并弹出媒体</code>了</p><p>操作如下:</p><img src="/2023/01/06/04DevOps/23diskpart/2.png" class="">]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离职项目交接模板</title>
    <link href="/2022/12/30/06%E6%9D%82%E9%A1%B9/00%E7%A6%BB%E8%81%8C%E9%A1%B9%E7%9B%AE%E4%BA%A4%E6%8E%A5%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/12/30/06%E6%9D%82%E9%A1%B9/00%E7%A6%BB%E8%81%8C%E9%A1%B9%E7%9B%AE%E4%BA%A4%E6%8E%A5%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="项目交接内容整理"><a href="#项目交接内容整理" class="headerlink" title="项目交接内容整理"></a>项目交接内容整理</h1><table><thead><tr><th>交接内容</th><th>交接结果</th><th>其他</th></tr></thead><tbody><tr><td>项目文档</td><td>协议说明等内容</td><td></td></tr><tr><td>项目源码地址</td><td></td><td></td></tr><tr><td>项目权限</td><td></td><td></td></tr><tr><td>编译环境</td><td></td><td>特殊说明：</td></tr><tr><td>上线步骤</td><td></td><td></td></tr><tr><td>上线注意事项</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>待完善或待完成工作内容</td><td></td><td></td></tr><tr><td>当前存在的问题及风险</td><td></td><td></td></tr></tbody></table><p><strong>至少保证程序编译后上线一次</strong></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gdb调试技巧总结</title>
    <link href="/2022/12/23/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/11gdb%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/23/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/11gdb%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>–batch</td><td>以执行命令模式运行，处理完相关命令后直接退出。不进行任何交互</td></tr><tr><td>–batch-silent</td><td>与–batch一样，但抑制所有 gdb stsdout 输出。</td></tr><tr><td>–quiet <br>-q</td><td>启动时不打印版本号信息</td></tr><tr><td>–eval-command=COMMAND<br> -ex</td><td>执行单个 GDB 命令。<br/>可以多次使用,且可以与 –command 结合使用。</td></tr><tr><td>–command=FILE<br>-x FILE</td><td>从 FILE 执行 GDB 命令。</td></tr><tr><td>–directory=DIR</td><td>在 DIR 中搜索源文件。</td></tr><tr><td>–pid=PID<br>-p PID</td><td>附加到正在运行的进程 PID。</td></tr></tbody></table><h1 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>set pagination off <br> set height 0</td><td>gdb就全部输出，无翻页选项</td></tr><tr><td>thread apply all</td><td>将命令应用于所有线程, 后跟要执行的命令，如 <font color="ff0000">bt full</font></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h1><ul><li>打印运行进程的所有线程的堆栈信息<figure class="highlight dsconfig"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 输出进程号为1234的进程的所有线程堆栈信息</span><br><span class="hljs-string">gdb</span> -<span class="hljs-string">q</span> <span class="hljs-built_in">--batch</span> <span class="hljs-built_in">--ex</span> <span class="hljs-string">&quot;set height 0&quot;</span> -<span class="hljs-string">ex</span> <span class="hljs-string">&quot;thread apply all bt full&quot;</span>  -<span class="hljs-string">p</span> <span class="hljs-string">1234</span><br></code></pre></td></tr></table></figure></li><li>直接数据core文件中的所有线程的堆栈信息<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-comment"># 输出二进制文件路径为proc_file，且core文件为xxx.core 的所有线程堆栈信息</span><br><span class="hljs-string">gdb</span> -<span class="hljs-string">q</span> <span class="hljs-built_in">--batch</span> <span class="hljs-built_in">--ex</span> <span class="hljs-string">&quot;set height 0&quot;</span> -<span class="hljs-string">ex</span> <span class="hljs-string">&quot;thread apply all bt full&quot;</span>  <span class="hljs-string">proc_file</span> <span class="hljs-string">xxx</span>.<span class="hljs-string">core</span><br></code></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell常用方法总结</title>
    <link href="/2022/11/30/04DevOps/22shell%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/11/30/04DevOps/22shell%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="特殊符号说明"><a href="#特殊符号说明" class="headerlink" title="特殊符号说明"></a>特殊符号说明</h1><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>$$</td><td>Shell本身的PID（ProcessID，即脚本运行的当前进程ID号）</td></tr><tr><td>$!</td><td>Shell最后运行的后台Process的PID(后台运行的最后一个进程的[进程ID]</td></tr><tr><td>$?</td><td>最后运行的命令的结束代码（返回值）即执行上一个指令的返回值 (显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误)</td></tr><tr><td>$$</td><td>显示shell使用的当前选项，与set命令功能相同</td></tr><tr><td>$*</td><td>所有参数列表。如”$*“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数，此选项参数可超过9个。</td></tr><tr><td>$@</td><td>所有参数列表。如”$@“用「”」括起来的情况、以”$1” “2 “ … “ 2” … “2”…”n” 的形式输出所有参数。</td></tr><tr><td>$*</td><td>跟$@类似，但是可以当作数组用</td></tr><tr><td>$#</td><td>添加到Shell的参数个数</td></tr><tr><td>$0</td><td>Shell本身的文件名</td></tr><tr><td>$1～$n</td><td>添加到Shell的各参数值。$1是第1参数、$2是第2参数…</td></tr></tbody></table><h1 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h1><h2 id="文件比较运算符"><a href="#文件比较运算符" class="headerlink" title="文件比较运算符"></a>文件比较运算符</h2><table><thead><tr><th>操作符</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>-e filename</td><td>如果 filename 存在，则为真</td><td>[ -e /var/log/syslog ]</td></tr><tr><td>-b filename</td><td>如果 filename 存在且为块文件则为真</td><td></td></tr><tr><td>-d filename</td><td>如果 filename 为目录，则为真</td><td>[ -d /tmp/mydir ]</td></tr><tr><td>-f filename</td><td>如果 filename 为常规文件，则为真</td><td>[ -f /usr/bin/grep ]</td></tr><tr><td>-L filename</td><td>如果 filename 为符号链接，则为真</td><td>[ -L /usr/bin/grep ]</td></tr><tr><td>-r filename</td><td>如果 filename 可读，则为真</td><td>[ -r /var/log/syslog ]</td></tr><tr><td>-w filename</td><td>如果 filename 可写，则为真</td><td>[ -w /var/mytmp.txt ]</td></tr><tr><td>-c filename</td><td>如果filename存在且为字符型特殊文件则为真。</td><td>[ -c /var/mytmp]</td></tr><tr><td>-x filename</td><td>如果 filename 可执行，则为真</td><td>[ -L /usr/bin/grep ]</td></tr><tr><td>-s filename</td><td>若文件ilename存在且至少有一个字符则为真</td><td></td></tr><tr><td>filename1 -nt filename2</td><td>如果 filename1 比 filename2 新，则为真</td><td>[ /tmp/install/etc/services -nt /etc/services ]</td></tr><tr><td>filename1 -ot filename2</td><td>如果 filename1 比 filename2 旧，则为真</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><table><thead><tr><th>操作符</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>-z string</td><td>如果 string 长度为零，则为真</td><td>[ -z “$myvar” ]</td></tr><tr><td>-n string</td><td>如果 string 长度非零，则为真</td><td>[ -n “$myvar” ]</td></tr><tr><td>string1 = string2</td><td>如果 string1 与 string2 相同，则为真</td><td>[ “$myvar” = “one two three” ]</td></tr><tr><td>string1 != string2</td><td>如果 string1 与 string2 不同，则为真</td><td>[ “$myvar” != “one two three” ]</td></tr></tbody></table><h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><table><thead><tr><th>操作符</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>num1 -eq num2</td><td>等于</td><td>[ 3 -eq $mynum ]</td></tr><tr><td>num1 -ne num2</td><td>不等于</td><td>[ 3 -ne $mynum ]</td></tr><tr><td>num1 -lt num2</td><td>小于</td><td>[ 3 -lt $mynum ]</td></tr><tr><td>num1 -le num2</td><td>小于或等于</td><td>[ 3 -le $mynum ]</td></tr><tr><td>num1 -gt num2</td><td>大于</td><td>[ 3 -gt $mynum ]</td></tr><tr><td>num1 -ge num2</td><td>大于或等于</td><td>[ 3 -ge $mynum ]</td></tr></tbody></table><h2 id="与-amp-amp"><a href="#与-amp-amp" class="headerlink" title="|| 与 &amp;&amp;"></a>|| 与 &amp;&amp;</h2><p>&amp;&amp;左边的命令（命令1）<strong>返回真(即返回0，成功被执行）</strong>后，&amp;&amp;右边的命令（命令2）才能够被执行；换句话说，“如果这个命令执行成功&amp;&amp;那么执行这个命令”</p><p>||则与&amp;&amp;相反。如果||左边的命令（command1）未执行成功，那么就执行||右边的命令（command2）；或者换句话说，“如果这个命令执行失败了||那么就执行这个命令。</p><table><thead><tr><th>脚本内容</th><th>输出</th></tr></thead><tbody><tr><td>app() {<br/>    return 0<br/>}<br/>app &amp;&amp; echo “3”</td><td>3</td></tr><tr><td>app() {<br/>    return 1<br/>}<br/>app || echo “3”</td><td>3</td></tr></tbody></table><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><table><thead><tr><th>操作符</th><th>解释</th><th>是否修改原始value</th></tr></thead><tbody><tr><td>${value:-word}</td><td>当变量未定义或者值为空时,返回值为word的内容,否则返回变量的值.</td><td>NO</td></tr><tr><td>${value:=word}</td><td>若变量未定义或者值为空时,在返回word的值的同时将word赋值给value</td><td>YES</td></tr><tr><td>${value:?message}</td><td>若变量以赋值的话,正常替换.否则将消息message送到标准错误输出<br>(若此替换出现在Shell程序中,那么该程序将终止运行)</td><td>NO</td></tr><tr><td>${value:+word}</td><td>若变量以赋值的话,其值才用word替换,否则不进行任何替换</td><td>NO</td></tr><tr><td>${value:offset}</td><td>从变量中提取子串,这里offset和length可以是算术表达式.</td><td>NO</td></tr><tr><td>${<code>#</code>value}</td><td>变量的字符个数</td><td>NO</td></tr><tr><td>${value#pattern}<br>${value##pattern}</td><td>去掉value中与pattern相匹配的部分,条件是value的开头与pattern相匹配<br>#与##的区别在于一个是最短匹配模式,一个是最长匹配模式.</td><td>NO</td></tr><tr><td>${value%pattern}<br>${value%%pattern}</td><td>去掉value中从尾部与pattern相匹配的部分,%与%%的区别与#与##一样</td><td>NO</td></tr><tr><td>${value/pattern/string}<br>${value//pattern/string}</td><td>进行变量内容的替换,把与pattern匹配的部分替换为string的内容,/与//的区别与上同</td><td>NO</td></tr></tbody></table><h2 id="判定变量是否是数值"><a href="#判定变量是否是数值" class="headerlink" title="判定变量是否是数值"></a>判定变量是否是数值</h2><p>使用<code>-z &quot;$&#123;p//[0-9]/&#125;&quot; </code> 判定变量是否是数值。原理为<code>//[0-9]/</code> 是一种字符串替换方式，将 <code>p</code> 变量中的数字(0到9)全部替换为空字符串，然后再判断(-z )替换后的字符串是否为空。如果 <code>p</code> 是空字符串或者只由数字组成，则条件为真，返回 true；</p><p>其中<code>$&#123;p//[0-9]/&#125;</code>没有修改原始变量 <code>p</code> 的值，因为在 shell 中使用类似的字符串操作符都是返回一个新的字符串，而没有修改原字符串的值.</p><p>示例如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">p=<span class="hljs-string">&quot;1234&quot;</span><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;p//[0-9]/&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;num=<span class="hljs-variable">$p</span>&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;string&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>读取数组 格式是：${array_name[index]}</li><li>获取数组中的所有元素：使用@ 或 * 可以获取数组中的所有元素，</li><li>获取数组的长度：获取数组长度的方法与获取字符串长度的方法相同<h2 id="遍历循环方法"><a href="#遍历循环方法" class="headerlink" title="遍历循环方法"></a>遍历循环方法</h2>有3中方法遍历<h3 id="标准的for循环"><a href="#标准的for循环" class="headerlink" title="标准的for循环"></a>标准的for循环</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;创建一个数组&quot;</span><br>array=( <span class="hljs-string">&quot;A&quot;</span> B C D 1 2 3 <span class="hljs-string">&quot;4&quot;</span> )<br><br><span class="hljs-comment">#$&#123;#array[@]&#125;获取数组长度用于循环</span><br><span class="hljs-keyword">for</span>(( i=0;i&lt;<span class="hljs-variable">$&#123;#array[@]&#125;</span>;i++)) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[i]&#125;</span>;<br><span class="hljs-keyword">done</span>;<br></code></pre></td></tr></table></figure><h3 id="for-…-in循环方法"><a href="#for-…-in循环方法" class="headerlink" title="for … in循环方法"></a>for … in循环方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;创建一个数组&quot;</span><br>array=( <span class="hljs-string">&quot;A&quot;</span> B C D 1 2 3 <span class="hljs-string">&quot;4&quot;</span> )<br><br><span class="hljs-comment">#也可以写成for element in $&#123;array[*]&#125;</span><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;array[@]&#125;</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$element</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure><h3 id="While循环法"><a href="#While循环法" class="headerlink" title="While循环法"></a>While循环法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;创建一个数组&quot;</span><br>array=( <span class="hljs-string">&quot;A&quot;</span> B C D 1 2 3 <span class="hljs-string">&quot;4&quot;</span> )<br><br>i=0<br><span class="hljs-comment">#当变量（下标）小于数组长度时进入循环体</span><br><span class="hljs-keyword">while</span> [ <span class="hljs-variable">$i</span> -lt <span class="hljs-variable">$&#123;#array[@]&#125;</span> ]<br><span class="hljs-keyword">do</span>  <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;array[$i]&#125;</span>  <br>    <span class="hljs-comment">#按下标打印数组元素</span><br>    <span class="hljs-built_in">let</span> i++  <br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="将文件内容加载到数组中"><a href="#将文件内容加载到数组中" class="headerlink" title="将文件内容加载到数组中"></a>将文件内容加载到数组中</h2><p>文件的内容以空格为分隔每个数组元素</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>file=<span class="hljs-string">&quot;./test_file.log&quot;</span><br>array=(`cat <span class="hljs-variable">$&#123;file&#125;</span> `)<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;array[@]&#125;</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;line=<span class="hljs-variable">$&#123;line&#125;</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>test_file.log内容如下</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">aaa mm<br><span class="hljs-keyword">bbbb </span>cccc<br>ddd2<br></code></pre></td></tr></table></figure><p>结果输出为</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">line</span>=aaa<br><span class="hljs-attr">line</span>=mm<br><span class="hljs-attr">line</span>=bbbb<br><span class="hljs-attr">line</span>=cccc<br><span class="hljs-attr">line</span>=ddd2<br></code></pre></td></tr></table></figure><h1 id="实用语句"><a href="#实用语句" class="headerlink" title="实用语句"></a>实用语句</h1><ul><li><p>杀掉除今天和pid=1的所有/bin/bash进程</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">ps -eo pid,lstart,cmd |<span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;/bin/bash&quot;</span> |<span class="hljs-keyword">grep</span> -v <span class="hljs-string">&quot;$(date +&#x27;%b %e&#x27;)&quot;</span> |<span class="hljs-keyword">grep</span> -v <span class="hljs-string">&#x27;^ *1 &#x27;</span> |awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> |xargs -r <span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure></li><li><p>遍历目录下所有文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">directory=<span class="hljs-string">&quot;./example_directory&quot;</span>  <span class="hljs-comment"># Replace with your directory path</span><br><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$directory</span>&quot;</span>/*; <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File: <span class="hljs-variable">$file</span>&quot;</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>遍历多行变量的每一行数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 定义一个多行变量</span><br>multi_line=<span class="hljs-string">&quot;apple</span><br><span class="hljs-string">banana</span><br><span class="hljs-string">orange&quot;</span><br><br><span class="hljs-comment"># 使用while循环遍历多行变量的每一行数据</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;遍历多行变量的每一行数据：&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$multi_line</span>&quot;</span> | <span class="hljs-keyword">while</span> IFS= <span class="hljs-built_in">read</span> -r line; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>按行读取文件，并处理每行的IP地址</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 文件路径</span><br><span class="hljs-attribute">file</span>=<span class="hljs-string">&quot;/path/to/file.txt&quot;</span><br><span class="hljs-comment"># 初始化计数器</span><br><span class="hljs-attribute">count</span>=0<br><br><span class="hljs-comment"># IFS为指定分隔符(Internal Field Separator)</span><br><span class="hljs-keyword">while</span> IFS= read -r<span class="hljs-built_in"> ip; </span><span class="hljs-keyword">do</span><br>    echo <span class="hljs-string">&quot;处理IP地址: <span class="hljs-variable">$ip</span>&quot;</span><br># 计数器递增<br>    <span class="hljs-attribute">count</span>=$((count+1))<br>done &lt; <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p>当执行ssh 命令时while read文件会执行一次就中断，可以使用下面的方式循环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># 文件路径</span><br>file=<span class="hljs-string">&quot;./m&quot;</span><br><br>cmd=<span class="hljs-string">&quot;ps -eLF|grep mmm |grep -v \&quot;grep\&quot; |grep -v \&quot;ppp\&quot; |wc -l&quot;</span><br><span class="hljs-comment">#cmd=&quot;ps -ef|grep mmm|grep -v \&quot;grep\&quot; |grep -v \&quot;ppp\&quot; |awk &#x27;&#123;print \$2&#125;&#x27;&quot;</span><br>ips=$(cat <span class="hljs-variable">$&#123;file&#125;</span>)<br><span class="hljs-keyword">for</span> ip <span class="hljs-keyword">in</span> <span class="hljs-variable">$ips</span><br><span class="hljs-keyword">do</span><br>    ret=`ssh root@<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;ip&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;cmd&#125;</span>&quot;</span>`<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;处理IP地址:<span class="hljs-variable">$&#123;ip&#125;</span>, thread=<span class="hljs-variable">$&#123;ret&#125;</span>&quot;</span><br>    <span class="hljs-comment"># 计数器递增</span><br>    <span class="hljs-comment">#count=$((count+1))</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>errno说明</title>
    <link href="/2022/11/18/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/10errno%E8%AF%B4%E6%98%8E/"/>
    <url>/2022/11/18/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/10errno%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>目前已知errno号最大133,分别定义与<code>/usr/include/asm-generic/errno-base.h</code>和 <code>/usr/include/asm-generic/errno.h</code></p><h1 id="errno说明"><a href="#errno说明" class="headerlink" title="errno说明"></a>errno说明</h1><table><thead><tr><th>errno号</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>Success</td></tr><tr><td>1</td><td>Operation not permitted</td></tr><tr><td>2</td><td>No such file or directory</td></tr><tr><td>3</td><td>No such process</td></tr><tr><td>4</td><td>Interrupted system call</td></tr><tr><td>5</td><td>Input/output error</td></tr><tr><td>6</td><td>No such device or address</td></tr><tr><td>7</td><td>Argument list too long</td></tr><tr><td>8</td><td>Exec format error</td></tr><tr><td>9</td><td>Bad file descriptor</td></tr><tr><td>10</td><td>No child processes</td></tr><tr><td>11</td><td>Resource temporarily unavailable</td></tr><tr><td>12</td><td>Cannot allocate memory</td></tr><tr><td>13</td><td>Permission denied</td></tr><tr><td>14</td><td>Bad address</td></tr><tr><td>15</td><td>Block device required</td></tr><tr><td>16</td><td>Device or resource busy</td></tr><tr><td>17</td><td>File exists</td></tr><tr><td>18</td><td>Invalid cross-device link</td></tr><tr><td>19</td><td>No such device</td></tr><tr><td>20</td><td>Not a directory</td></tr><tr><td>21</td><td>Is a directory</td></tr><tr><td>22</td><td>Invalid argument</td></tr><tr><td>23</td><td>Too many open files in system</td></tr><tr><td>24</td><td>Too many open files</td></tr><tr><td>25</td><td>Inappropriate ioctl for device</td></tr><tr><td>26</td><td>Text file busy</td></tr><tr><td>27</td><td>File too large</td></tr><tr><td>28</td><td>No space left on device</td></tr><tr><td>29</td><td>Illegal seek</td></tr><tr><td>30</td><td>Read-only file system</td></tr><tr><td>31</td><td>Too many links</td></tr><tr><td>32</td><td>Broken pipe</td></tr><tr><td>33</td><td>Numerical argument out of domain</td></tr><tr><td>34</td><td>Numerical result out of range</td></tr><tr><td>35</td><td>Resource deadlock avoided</td></tr><tr><td>36</td><td>File name too long</td></tr><tr><td>37</td><td>No locks available</td></tr><tr><td>38</td><td>Function not implemented</td></tr><tr><td>39</td><td>Directory not empty</td></tr><tr><td>40</td><td>Too many levels of symbolic links</td></tr><tr><td>41</td><td>Unknown error 41</td></tr><tr><td>42</td><td>No message of desired type</td></tr><tr><td>43</td><td>Identifier removed</td></tr><tr><td>44</td><td>Channel number out of range</td></tr><tr><td>45</td><td>Level 2 not synchronized</td></tr><tr><td>46</td><td>Level 3 halted</td></tr><tr><td>47</td><td>Level 3 reset</td></tr><tr><td>48</td><td>Link number out of range</td></tr><tr><td>49</td><td>Protocol driver not attached</td></tr><tr><td>50</td><td>No CSI structure available</td></tr><tr><td>51</td><td>Level 2 halted</td></tr><tr><td>52</td><td>Invalid exchange</td></tr><tr><td>53</td><td>Invalid request descriptor</td></tr><tr><td>54</td><td>Exchange full</td></tr><tr><td>55</td><td>No anode</td></tr><tr><td>56</td><td>Invalid request code</td></tr><tr><td>57</td><td>Invalid slot</td></tr><tr><td>58</td><td>Unknown error 58</td></tr><tr><td>59</td><td>Bad font file format</td></tr><tr><td>60</td><td>Device not a stream</td></tr><tr><td>61</td><td>No data available</td></tr><tr><td>62</td><td>Timer expired</td></tr><tr><td>63</td><td>Out of streams resources</td></tr><tr><td>64</td><td>Machine is not on the network</td></tr><tr><td>65</td><td>Package not installed</td></tr><tr><td>66</td><td>Object is remote</td></tr><tr><td>67</td><td>Link has been severed</td></tr><tr><td>68</td><td>Advertise error</td></tr><tr><td>69</td><td>Srmount error</td></tr><tr><td>70</td><td>Communication error on send</td></tr><tr><td>71</td><td>Protocol error</td></tr><tr><td>72</td><td>Multihop attempted</td></tr><tr><td>73</td><td>RFS specific error</td></tr><tr><td>74</td><td>Bad message</td></tr><tr><td>75</td><td>Value too large for defined data type</td></tr><tr><td>76</td><td>Name not unique on network</td></tr><tr><td>77</td><td>File descriptor in bad state</td></tr><tr><td>78</td><td>Remote address changed</td></tr><tr><td>79</td><td>Can not access a needed shared library</td></tr><tr><td>80</td><td>Accessing a corrupted shared library</td></tr><tr><td>81</td><td>.lib section in a.out corrupted</td></tr><tr><td>82</td><td>Attempting to link in too many shared libraries</td></tr><tr><td>83</td><td>Cannot exec a shared library directly</td></tr><tr><td>84</td><td>Invalid or incomplete multibyte or wide character</td></tr><tr><td>85</td><td>Interrupted system call should be restarted</td></tr><tr><td>86</td><td>Streams pipe error</td></tr><tr><td>87</td><td>Too many users</td></tr><tr><td>88</td><td>Socket operation on non-socket</td></tr><tr><td>89</td><td>Destination address required</td></tr><tr><td>90</td><td>Message too long</td></tr><tr><td>91</td><td>Protocol wrong type for socket</td></tr><tr><td>92</td><td>Protocol not available</td></tr><tr><td>93</td><td>Protocol not supported</td></tr><tr><td>94</td><td>Socket type not supported</td></tr><tr><td>95</td><td>Operation not supported</td></tr><tr><td>96</td><td>Protocol family not supported</td></tr><tr><td>97</td><td>Address family not supported by protocol</td></tr><tr><td>98</td><td>Address already in use</td></tr><tr><td>99</td><td>Cannot assign requested address</td></tr><tr><td>100</td><td>Network is down</td></tr><tr><td>101</td><td>Network is unreachable</td></tr><tr><td>102</td><td>Network dropped connection on reset</td></tr><tr><td>103</td><td>Software caused connection abort</td></tr><tr><td>104</td><td>Connection reset by peer</td></tr><tr><td>105</td><td>No buffer space available</td></tr><tr><td>106</td><td>Transport endpoint is already connected</td></tr><tr><td>107</td><td>Transport endpoint is not connected</td></tr><tr><td>108</td><td>Cannot send after transport endpoint shutdown</td></tr><tr><td>109</td><td>Too many references: cannot splice</td></tr><tr><td>110</td><td>Connection timed out</td></tr><tr><td>111</td><td>Connection refused</td></tr><tr><td>112</td><td>Host is down</td></tr><tr><td>113</td><td>No route to host</td></tr><tr><td>114</td><td>Operation already in progress</td></tr><tr><td>115</td><td>Operation now in progress</td></tr><tr><td>116</td><td>Stale file handle</td></tr><tr><td>117</td><td>Structure needs cleaning</td></tr><tr><td>118</td><td>Not a XENIX named type file</td></tr><tr><td>119</td><td>No XENIX semaphores available</td></tr><tr><td>120</td><td>Is a named type file</td></tr><tr><td>121</td><td>Remote I/O error</td></tr><tr><td>122</td><td>Disk quota exceeded</td></tr><tr><td>123</td><td>No medium found</td></tr><tr><td>124</td><td>Wrong medium type</td></tr><tr><td>125</td><td>Operation canceled</td></tr><tr><td>126</td><td>Required key not available</td></tr><tr><td>127</td><td>Key has expired</td></tr><tr><td>128</td><td>Key has been revoked</td></tr><tr><td>129</td><td>Key was rejected by service</td></tr><tr><td>130</td><td>Owner died</td></tr><tr><td>131</td><td>State not recoverable</td></tr><tr><td>132</td><td>Operation not possible due to RF-kill</td></tr><tr><td>133</td><td>Memory page has hardware error</td></tr><tr><td>134</td><td>Unknown error 134</td></tr><tr><td>135</td><td>Unknown error 135</td></tr></tbody></table><h1 id="获取测试程序"><a href="#获取测试程序" class="headerlink" title="获取测试程序"></a>获取测试程序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">135</span>; ++i) &#123;<br>        errno = i;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4d |\t%s\n&quot;</span>,i,<span class="hljs-built_in">strerror</span>(errno));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见问题处理方法</title>
    <link href="/2022/11/10/04DevOps/100%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%A4%84%E7%90%86/"/>
    <url>/2022/11/10/04DevOps/100%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="rm-删除时报错’Argument-list-too-long’"><a href="#rm-删除时报错’Argument-list-too-long’" class="headerlink" title="rm 删除时报错’Argument list too long’"></a>rm 删除时报错’Argument list too long’</h3><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#替换rm -rf  命令，改用xargs 即可</span><br><span class="hljs-built_in">ls</span> | xargs <span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span><br></code></pre></td></tr></table></figure><h3 id="清理-var-log-journal-下的内容"><a href="#清理-var-log-journal-下的内容" class="headerlink" title="清理 /var/log/journal 下的内容"></a>清理 /var/log/journal 下的内容</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 如何判断占用了多少空间</span><br><span class="hljs-keyword">journalctl </span>--<span class="hljs-keyword">disk-usage</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># 清理目录数据的阈值为500M</span><br><span class="hljs-keyword">journalctl </span>--vacuum-size=<span class="hljs-number">500</span>M<br></code></pre></td></tr></table></figure><h3 id="ulimit-值超出允许范围导致无法登陆操作系统"><a href="#ulimit-值超出允许范围导致无法登陆操作系统" class="headerlink" title="ulimit 值超出允许范围导致无法登陆操作系统"></a>ulimit 值超出允许范围导致无法登陆操作系统</h3><p>一般在/etc/security/limits.conf文件中设置各种限制值。</p><p><font color=red> 但是请注意，如果你在文件中设置，你可能设置的值超出范围，导致不可预知的后果，例如无法登陆操作系统。</font></p><p>下面这个对open files的限制就是一个例子，它不识别unlimited，是一个有限的值。<br>所以如果你在/etc/security/limits.conf中设置了</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>soft    nofile  unlimited<br><span class="hljs-bullet">* </span>hard    nofile  unlimited<br></code></pre></td></tr></table></figure><p>那就完蛋了，因为你接下来的进程将登陆不了系统了。<br>我们最好先使用ulimit命令验证一下你将要设置的值是否合法。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@root ~]# ulimit -n <span class="hljs-number">1024000000</span><br>-bash: ulimi<span class="hljs-variable">t:</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span> cannot modify limi<span class="hljs-variable">t:</span> Operation not permitted<br>[root@root ~]# ulimit -n <span class="hljs-number">9999999999</span><br>-bash: ulimi<span class="hljs-variable">t:</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span> cannot modify limi<span class="hljs-variable">t:</span> Operation not permitted<br>[root@root ~]# ulimit -n <span class="hljs-number">9999999</span><br>-bash: ulimi<span class="hljs-variable">t:</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span> cannot modify limi<span class="hljs-variable">t:</span> Operation not permitted<br>[root@root ~]# ulimit -n <span class="hljs-number">999999</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcpdump实用方法总结</title>
    <link href="/2022/11/10/04DevOps/21tcpdump%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/11/10/04DevOps/21tcpdump%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>要用tcpdump 抓包，一定要切换到<code>root</code>账户，只有<code>root</code>才有权限将网卡变更为<code>混杂模式</code>。</p><p>tcpdump可以分为三大部分内容，第一是<code>选项</code>，第二是<code>过滤表达式</code>，第三是<code>输出信息</code></p><p>基本格式为 <code>tcpdump 选项 &#39;过滤表达式&#39;</code></p><h1 id="实用选项参数说明"><a href="#实用选项参数说明" class="headerlink" title="实用选项参数说明"></a>实用选项参数说明</h1><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>即interface，指定要监听的网卡名,默认为eth0，内核版本&gt;2.2时可用<code>any</code>指定所有网卡</td></tr><tr><td>-w</td><td>指定dump出的内容(原始网络包)存储的文件</td></tr><tr><td>-nn</td><td>tcpdump遇到协议号或端口号时，不要将这些号码转换成对应的协议名称或端口名称。如，众所周知21端口是FTP端口，我们希望显示21，而非tcpdump自作聪明的将它显示成FTP</td></tr><tr><td>-X</td><td>需要把协议头和包内容都原原本本的显示出来（tcpdump会以16进制和ASCII的形式显示），这在进行协议分析时是绝对的利器。</td></tr><tr><td>-c</td><td>设置要抓的包的个数</td></tr><tr><td>-e</td><td>增加以太网帧头部信息输出</td></tr><tr><td>-l</td><td>使得输出变为行缓冲，只要发现行符号就输出，否则只能等缓冲区满才输出</td></tr><tr><td>-t</td><td>输出时不打印时间戳</td></tr><tr><td>-v</td><td>输出更详细的信息，增加tos值、ttl值、ID值、总长度、校验值等</td></tr><tr><td>-F</td><td>指定过滤表达式所在的文件</td></tr><tr><td>-r</td><td>读取-w生成的原始网络包文件</td></tr><tr><td>-B</td><td>缓冲区空间大小,单位KB, 出现<code>packets dropped by kernel</code> 时修改此参数</td></tr></tbody></table><h1 id="表达式说明"><a href="#表达式说明" class="headerlink" title="表达式说明"></a>表达式说明</h1><p>tcpdump 的表达式是 <code>pcap-filter</code> 的过滤表达式，可通过 <code>man 7 pcap-filter</code> 查看细节</p><p>过滤器表达式由一个或多个<code>原语</code>组成。<code>原语</code>通常是由前面有一个或多个<code>限定词</code>的 <code>id(名称或数字)</code>组成。<br><code>限定词</code>有以下三种不同的类型：</p><table><thead><tr><th>类型</th><th>说明</th><th>常用类型</th><th>默认值</th><th>示例</th></tr></thead><tbody><tr><td>type</td><td>type限定词说明<code>id(名称或数字)</code>的类型</td><td>host, net , port , portrange</td><td>host</td><td>‘host foo’<br>‘net 128.3’<br>‘port 20’<br>‘portrange 6000-6008’</td></tr><tr><td>dir</td><td>dir 限定词指定id 特定传输方向</td><td>src, dst, src or dst, src and dst,<br /> ra, ta,  addr1,  addr2, addr3,  and  addr4.</td><td>src or dst</td><td>‘src foo’<br /> ‘dst net 128.3’,<br />‘src or dst port ftp-data’</td></tr><tr><td>proto</td><td>proto 限定词将匹配限制为特定协议</td><td>ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp and udp.</td><td>和type一致的所有可用协议<br />‘src foo’ means ‘(ip or arp or rarp) src foo’<br />‘port 53’ means ‘(tcp or udp) port 53’<br />‘net bar’ means ‘(ip or arp or rarp) net bar’</td><td>‘ether src foo’<br /> ‘arp net 128.3’<br /> ‘tcp port 21’<br /> ‘udp portrange 7000-7009’<br /> ‘wlan addr2 0:2:3:4:5:6’</td></tr></tbody></table><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">host</span>：指定主机名或IP地址，例如’host roclinux.cn’或’host <span class="hljs-number">202.112.18.34</span>′<br><span class="hljs-attribute">net</span> ：指定网络段，例如’arp net <span class="hljs-number">128</span>.<span class="hljs-number">3</span>′或’dst net <span class="hljs-number">128</span>.<span class="hljs-number">3</span>′<br><span class="hljs-attribute">portrange</span>：指定端口区域，例如’src or dst portrange <span class="hljs-number">6000</span>-<span class="hljs-number">6008</span>′<br><br><span class="hljs-attribute">ether</span> fddi tr wlan ppp slip link 均为 链路层协议<br></code></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><h3 id="抓特定来源的包"><a href="#抓特定来源的包" class="headerlink" title="抓特定来源的包"></a>抓特定来源的包</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 只抓发向10.101.101.101且端口号为53的包，并将抓到的包写入到bind.cap文件中</span><br> <span class="hljs-attribute">tcpdump</span> &#x27;dst <span class="hljs-number">10.101.101.101</span> and port <span class="hljs-number">53</span>&#x27; -w bind.cap<br></code></pre></td></tr></table></figure><h3 id="抓取192-168-1-123收到和发送的所有的icmp的包"><a href="#抓取192-168-1-123收到和发送的所有的icmp的包" class="headerlink" title="抓取192.168.1.123收到和发送的所有的icmp的包"></a>抓取192.168.1.123收到和发送的所有的icmp的包</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">tcpdump -i eth1 <span class="hljs-string">&#x27;host 192.168.1.123 and icmp &#x27;</span> -w <span class="hljs-regexp">/tmp/</span>xxx.cap<br></code></pre></td></tr></table></figure><h3 id="抓取helios-与-hot-或者与-ace-之间通信的数据包"><a href="#抓取helios-与-hot-或者与-ace-之间通信的数据包" class="headerlink" title="抓取helios 与 hot 或者与 ace 之间通信的数据包"></a>抓取helios 与 hot 或者与 ace 之间通信的数据包</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tcpdump</span> <span class="hljs-string">&#x27;host helios and (hot or ace)&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="抓取主机210-27-48-1-和主机210-27-48-2-或210-27-48-3的通信"><a href="#抓取主机210-27-48-1-和主机210-27-48-2-或210-27-48-3的通信" class="headerlink" title="抓取主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信"></a>抓取主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcpdump</span> &#x27;host <span class="hljs-number">210.27.48.1</span> and (<span class="hljs-number">210.27.48.2</span> or <span class="hljs-number">210.27.48.3</span> )&#x27;<br></code></pre></td></tr></table></figure><h3 id="抓取ace与任何其他主机之间通信的IP-数据包-但不包括与helios之间的数据包"><a href="#抓取ace与任何其他主机之间通信的IP-数据包-但不包括与helios之间的数据包" class="headerlink" title="抓取ace与任何其他主机之间通信的IP 数据包, 但不包括与helios之间的数据包."></a>抓取ace与任何其他主机之间通信的IP 数据包, 但不包括与helios之间的数据包.</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tcpdump</span> <span class="hljs-string">&#x27;ip host ace and not helios&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="抓取主机210-27-48-1除了和主机210-27-48-2之外所有主机通信的ip包，使用命令："><a href="#抓取主机210-27-48-1除了和主机210-27-48-2之外所有主机通信的ip包，使用命令：" class="headerlink" title="抓取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令："></a>抓取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包，使用命令：</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcpdump</span> &#x27;ip host <span class="hljs-number">210.27.48.1</span> and ! <span class="hljs-number">210.27.48.2</span>&#x27;<br></code></pre></td></tr></table></figure><h3 id="获取使用ftp端口和ftp数据端口的网络包"><a href="#获取使用ftp端口和ftp数据端口的网络包" class="headerlink" title="获取使用ftp端口和ftp数据端口的网络包"></a>获取使用ftp端口和ftp数据端口的网络包</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">tcpdump</span> &#x27;port ftp or ftp-<span class="hljs-class"><span class="hljs-keyword">data</span>&#x27;</span><br></code></pre></td></tr></table></figure><p><code>/etc/services</code>存储着所有知名服务和传输层端口的对应关系。这个对应关系是由IANA组织来全权负责管理，<a href="http://www.iana.org/assignments/port-numbers">http://www.iana.org/assignments/port-numbers</a> 通过Web方式查到。</p><h3 id="抓取网卡上特定端口上的http数据包"><a href="#抓取网卡上特定端口上的http数据包" class="headerlink" title="抓取网卡上特定端口上的http数据包"></a>抓取网卡上特定端口上的http数据包</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcpdump</span> -i &lt;interface&gt; port &lt;port&gt; and tcp and &#x27;tcp[((tcp[<span class="hljs-number">12</span>:<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0</span>xf<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">2</span>):<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>x<span class="hljs-number">47455420</span>&#x27; -s <span class="hljs-number">0</span> -A -w &lt;output_file.pcap&gt;<br><br><span class="hljs-attribute">tcpdump</span> -i any port <span class="hljs-number">80</span> and tcp and &#x27;tcp[((tcp[<span class="hljs-number">12</span>:<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0</span>xf<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">2</span>):<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>x<span class="hljs-number">47455420</span>&#x27; -s <span class="hljs-number">0</span> -A -w output.pcap<br><br></code></pre></td></tr></table></figure><p>‘tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420’ 是一个 BPF 过滤器，用于匹配 HTTP 数据包。<br>0x47455420 是 ‘GET ‘ 的十六进制表示。该过滤器将匹配所有包含以 ‘GET’ 开头的 HTTP 请求的数据包</p><h3 id="获取roclinux-cn和baidu-com之间建立TCP三次握手中第一个网络包，即带有SYN标记位的网络包，另外，目的主机不能是qiyi-com"><a href="#获取roclinux-cn和baidu-com之间建立TCP三次握手中第一个网络包，即带有SYN标记位的网络包，另外，目的主机不能是qiyi-com" class="headerlink" title="获取roclinux.cn和baidu.com之间建立TCP三次握手中第一个网络包，即带有SYN标记位的网络包，另外，目的主机不能是qiyi.com"></a>获取roclinux.cn和baidu.com之间建立TCP三次握手中第一个网络包，即带有SYN标记位的网络包，另外，目的主机不能是qiyi.com</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">tcpdump</span> <span class="hljs-string">&#x27;tcp[tcpflags] &amp; tcp-syn != 0 and not dst host qiyi.com&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="打印IP包长超过576字节的网络包"><a href="#打印IP包长超过576字节的网络包" class="headerlink" title="打印IP包长超过576字节的网络包"></a>打印IP包长超过576字节的网络包</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcpdump</span> &#x27;ip[<span class="hljs-number">2</span>:<span class="hljs-number">2</span>] &lt; <span class="hljs-number">576</span>&#x27;<br></code></pre></td></tr></table></figure><h3 id="打印广播包或多播包，同时数据链路层不是通过以太网媒介进行的。"><a href="#打印广播包或多播包，同时数据链路层不是通过以太网媒介进行的。" class="headerlink" title="打印广播包或多播包，同时数据链路层不是通过以太网媒介进行的。"></a>打印广播包或多播包，同时数据链路层不是通过以太网媒介进行的。</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcpdump</span> &#x27;ether[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">1</span> = <span class="hljs-number">0</span> and ip[<span class="hljs-number">16</span>] &lt;= <span class="hljs-number">224</span>&#x27;<br></code></pre></td></tr></table></figure><h2 id="回放"><a href="#回放" class="headerlink" title="回放"></a>回放</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">tcpdump -r xxx.<span class="hljs-built_in">cap</span><br></code></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="使用-i-any-抓取所有网卡数据包时有下图中的-Frame-length-is-less-than-captured-length-错误"><a href="#使用-i-any-抓取所有网卡数据包时有下图中的-Frame-length-is-less-than-captured-length-错误" class="headerlink" title="使用-i any 抓取所有网卡数据包时有下图中的 Frame length is less than captured length 错误"></a>使用-i any 抓取所有网卡数据包时有下图中的 Frame length is less than captured length 错误</h2><img src="/2022/11/10/04DevOps/21tcpdump%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/err_01.png" class=""><p>因为tcpdump抓包时，如果-i选项指定为一个网卡地址，那么抓取的数据包数据链路层是以太网头部；如果指定any，则以太网头部将被替换为linux cooked capture头部，见上图。</p><p>tcpdump抓包时可以通过 -y 选项来指定data link type，不过测试发现 -i 选项指定 any 时，不支持抓获的包的data link type 为以太网 :</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">[root@whb~]<span class="hljs-comment">#  tcpdump -i any -w test.pcap -y EN10MB</span><br>tcpdump: EN10MB <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> one <span class="hljs-keyword">of</span> the DLTs supported <span class="hljs-keyword">by</span> <span class="hljs-built_in">this</span> device<br>[root@whb~]<span class="hljs-comment"># tcpdump -i eth1 -w test.pcap -y EN10MB</span><br>tcpdump: data link type EN10MB<br>tcpdump: WARNING: eth1: <span class="hljs-literal">no</span> IPv4 address assigned<br>tcpdump: listening <span class="hljs-literal">on</span> eth1, link-type EN10MB (Ethernet), capture size <span class="hljs-number">65535</span> bytes<br></code></pre></td></tr></table></figure><p>出现这个错误也将导致tcprewrite等改包工具失效，因为包的格式有错误。需要转换<br>转换方式待确定</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/aios/p/9545378.html">https://www.cnblogs.com/aios/p/9545378.html</a></p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lex使用</title>
    <link href="/2022/10/21/04DevOps/20lex%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/21/04DevOps/20lex%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Lex代表词法分析器(Lexical Analyzar)。</p><p>Lex读取输入源将匹配的字符串转换为标志(token)，匹配的方式是使用正则表达式。每个匹配的模式(pattern)都对应一个动作(action)，一般情况下，动作是返回一个标志，代表匹配的字符串。</p><p>Lex的限制。Lex不能识别嵌套的结构(如括号)，因为处理嵌套结构需要一个栈，而lex没有。对此的处理使用yacc来实现。</p><h2 id="正则表达式概述"><a href="#正则表达式概述" class="headerlink" title="正则表达式概述"></a>正则表达式概述</h2><table><thead><tr><th>关键词</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任何字符(除了新行符)</td></tr><tr><td>\n</td><td>新行符(newline)</td></tr></tbody></table><ul><li>   | 匹配0个或多个前面模式的拷贝</li></ul><ul><li>   | 匹配一个或多个前面模式的拷贝<br>?    | 匹配0个或1个前面模式的拷贝<br>^    | 匹配行开头<br>$    | 匹配行尾<br>a&#124;b    | a或b<br>(ab)+    | 匹配一个或多个ab的拷贝<br>“a+b”    |匹配a+b<br>[]    | 匹配集合里的任意字符</li></ul><p>字符的特殊含义：字符”-“在字符集里两个字符之间时代表一个范围。字符”^”在字符集里作为首字符，表示”反”含义。</p><h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p>如果有多个模式匹配同一个串，则使用匹配最长的模式；若匹配长度也相同，则使用位于前面的模式。</p><h1 id="Lex文件格式"><a href="#Lex文件格式" class="headerlink" title="Lex文件格式"></a>Lex文件格式</h1><p>Lex输入文件分为三个部分，使用%%来分隔每个部分。格式如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span> definitions <span class="hljs-string">...</span><br>%% <br><span class="hljs-string">...</span> rules <span class="hljs-string">...</span><br>%% <br><span class="hljs-string">...</span> subroutines <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>第一个%%是必须的，在它后面是规则部分。如果不定义任何规则，缺省的动作是匹配任何文本并拷贝到输出。缺省的输入和输出是stdin和stdout。</p><h1 id="第一部分-定义"><a href="#第一部分-定义" class="headerlink" title="第一部分 定义"></a>第一部分 定义</h1><p>这部分的C代码被拷贝到生成的C文件的头部，C代码必须用<code>&quot;%&#123;&quot;</code>和 <code>&quot;%&#125;&quot;</code>包括起来。该部分还可定义简单的匹配模式，这些定义可以在后面的规则部分使用。如：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">digit [<span class="hljs-number">0</span><span class="hljs-number">-9</span>]<br>letter [<span class="hljs-symbol">A</span>-<span class="hljs-symbol">Za</span>-z]<br><span class="hljs-comment">%&#123;</span><br>int count;<br><span class="hljs-comment">%&#125;</span><br><span class="hljs-comment">%%</span><br><span class="hljs-comment">/* match identifier */</span><br>&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)* count++;<br><span class="hljs-comment">%%</span><br></code></pre></td></tr></table></figure><p>在规则部分使用定义的模式必须用<code>&#123;&#125;</code>括起来，以示区别。</p><h1 id="第二部分-规则"><a href="#第二部分-规则" class="headerlink" title="第二部分 规则"></a>第二部分 规则</h1><p>规则中的每个模式必须开始于一行的第一列。之后是空白符(空格、制表符、新行符)和对应的动作。动作可以是一个简单的C语句或使用{}包括的多个语句。</p><p>文件中第一列没有内容的行都原样的拷贝到生成的C文件中。这个特性可以在lex文件中插入注释。如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino">%%<br><span class="hljs-comment">/* match everything except newline */</span><br>. ECHO;<br><span class="hljs-comment">/* match newline */</span><br>\n ECHO;<br>%%<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">yywrap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">yylex</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义了两个模式：”.”和”\n”。</p><p>lex本身定义了一些宏和变量。ECHO是一个宏，该宏的典型实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ECHO fwrite(yytext, yyleng, 1, yyout)</span><br></code></pre></td></tr></table></figure><h1 id="第三部分-定义函数"><a href="#第三部分-定义函数" class="headerlink" title="第三部分 定义函数"></a>第三部分 定义函数</h1><p>定义main函数和其他处理函数。</p><h1 id="lex的常用变量和函数-宏"><a href="#lex的常用变量和函数-宏" class="headerlink" title="lex的常用变量和函数(宏)"></a>lex的常用变量和函数(宏)</h1><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>int yylex( void )</td><td>Lex的入口，返回标志（token）</td></tr><tr><td>char *yytext</td><td>指向匹配的串（null结尾）</td></tr><tr><td>yyleng</td><td>匹配串的长度</td></tr><tr><td>yylval</td><td>对应标志（token）的值</td></tr><tr><td>int yywrap( void )</td><td>输入结束时调用，返回1表示结束，0表示还有数据处理</td></tr><tr><td>FILE *yyout</td><td>输出文件，缺省是stdout</td></tr><tr><td>FILE *yyin</td><td>输入文件，缺省是stdin</td></tr><tr><td>INITIAL</td><td>开始状态</td></tr><tr><td>BEGIN condition</td><td>切换开始状态</td></tr><tr><td>ECHO</td><td>输出匹配串</td></tr></tbody></table><p>一些lex的实现提供变量yylineno。</p><h1 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h1><h2 id="处理引号"><a href="#处理引号" class="headerlink" title="处理引号"></a>处理引号</h2><p>以双引号包围的字符串在程序中很常见，如何匹配它们呢？</p><p>简单的方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">%&#123;<br>char *yylval;<br><span class="hljs-comment">#include &lt;string.h&gt;</span><br>%&#125;<br>%%<br>\&quot;[^<span class="hljs-string">&quot;\n]*[&quot;</span>\n] &#123;<br>yylval = strdup(yytext+1);<br><span class="hljs-keyword">if</span> (yylval[yyleng-2] != <span class="hljs-string">&#x27;&quot;&#x27;</span>)<br>    warning(<span class="hljs-string">&quot;improperly terminated string&quot;</span>);<br><span class="hljs-keyword">else</span><br>    yylval[yyleng-2] = 0;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;found &#x27;%s&#x27;\n&quot;</span>, yylval);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述方法不能处理串中的转义字符如 \n 和 \ 等。要加上这些功能，如下处理：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lsl">%&#123;<br>char buf[<span class="hljs-number">100</span>];<br>char *s;<br>%&#125;<br>%x STRING<br>%%<br>\<span class="hljs-string">&quot;            &#123; BEGIN STRING; s = buf; &#125;</span><br><span class="hljs-string">&lt;STRING&gt;<span class="hljs-subst">\\</span>n   &#123; *s++ = &#x27;<span class="hljs-subst">\n</span>&#x27;; &#125;</span><br><span class="hljs-string">&lt;STRING&gt;<span class="hljs-subst">\\</span>t   &#123; *s++ = &#x27;<span class="hljs-subst">\t</span>&#x27;; &#125;</span><br><span class="hljs-string">&lt;STRING&gt;<span class="hljs-subst">\\</span><span class="hljs-subst">\&quot;</span>   &#123; *s++ = &#x27;<span class="hljs-subst">\&quot;</span>&#x27;; &#125;</span><br><span class="hljs-string">&lt;STRING&gt;<span class="hljs-subst">\&quot;</span>    &#123; *s = 0;</span><br><span class="hljs-string">BEGIN 0;</span><br><span class="hljs-string">printf(&quot;</span>found &#x27;%s&#x27;\n<span class="hljs-string">&quot;, buf);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&lt;STRING&gt;<span class="hljs-subst">\n</span>    &#123; printf(&quot;</span>invalid <span class="hljs-type">string</span><span class="hljs-string">&quot;); exit(1); &#125;</span><br><span class="hljs-string">&lt;STRING&gt;.     &#123; *s++ = *yytext; &#125;</span><br></code></pre></td></tr></table></figure><p>在定义部分定义了一个独占的开始符STRING，当执行了<code>BEGIN 开始符</code>后，lex进入该独占符模式，lex只匹配以该独占符开头的模式，直到另一个BEGIN开始执行为止。</p><h2 id="处理保留字"><a href="#处理保留字" class="headerlink" title="处理保留字"></a>处理保留字</h2><p>如果程序中有大量的保留字要处理，比较好的方法是写一个函数来查看一个字符串是一个变量还是保留字。而不是定义一堆标志。如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;letter&#125;(&#123;letter&#125;<span class="hljs-pattern-match">|&#123;digit&#125;)<span class="hljs-operator">*</span>  &#123;</span><br><span class="hljs-pattern-match"><span class="hljs-built_in">int</span> i;</span><br><span class="hljs-pattern-match"><span class="hljs-keyword">if</span> ((i = res<span class="hljs-constructor">Word(<span class="hljs-params">yytext</span>)</span>) != 0)</span><br><span class="hljs-pattern-match">    return (i);</span><br><span class="hljs-pattern-match">yylval.id = sym<span class="hljs-constructor">Lookup(<span class="hljs-params">yytext</span>)</span>;</span><br><span class="hljs-pattern-match">return (<span class="hljs-constructor">IDENTIFIER</span>);</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指定core文件生成位置</title>
    <link href="/2022/08/15/04DevOps/19%E6%8C%87%E5%AE%9Acore%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E4%BD%8D%E7%BD%AE/"/>
    <url>/2022/08/15/04DevOps/19%E6%8C%87%E5%AE%9Acore%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>针对各个程序可能产生core文件的问题，可以采用设置系统统一的core文件目录，所有程序均将core文件生成到指定目录的方式，具体方法如下：</p><h2 id="1-创建存放core文件的目录并添加写入权限"><a href="#1-创建存放core文件的目录并添加写入权限" class="headerlink" title="1. 创建存放core文件的目录并添加写入权限"></a>1. 创建存放core文件的目录并添加写入权限</h2><p>以root用户执行如下命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs jboss-cli">mkdir <span class="hljs-string">/corefile</span><br>chown -R root<span class="hljs-function">:xmail</span> <span class="hljs-string">/corefile</span> <span class="hljs-comment">#改变目录属组为xmail组</span><br>chmod g+w <span class="hljs-string">/corefile</span> <span class="hljs-comment">#赋予属组用户写权限</span><br></code></pre></td></tr></table></figure><h2 id="2-打开所有用户下的-ulimit-c-unlimited"><a href="#2-打开所有用户下的-ulimit-c-unlimited" class="headerlink" title="2. 打开所有用户下的 ulimit -c unlimited"></a>2. 打开所有用户下的 ulimit -c unlimited</h2><p>以root用户执行如下命令你个，</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>profile<br></code></pre></td></tr></table></figure><p>在文件的最后添加如下代码，确保各个用户均可产生core文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -c unlimited<br></code></pre></td></tr></table></figure><h2 id="3-将所有core文件生成路径指向固定位置"><a href="#3-将所有core文件生成路径指向固定位置" class="headerlink" title="3. 将所有core文件生成路径指向固定位置"></a>3. 将所有core文件生成路径指向固定位置</h2><p>以root用户执行如下命令，将所有生成的core文件放到/corefile/目录下，以core-命令名-pid-unix时间戳来命名产生的core文件，其中/corefile目录需所有用户均有写入权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-string">&quot;/tmp/core-%e-%p-%t&quot;</span> &gt;<span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_pattern<br>echo <span class="hljs-string">&quot;1&quot;</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_uses_pid <br></code></pre></td></tr></table></figure><p>以下是core-后的参数列表:</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-name">%p</span> - <span class="hljs-meta">insert</span> pid <span class="hljs-meta">into</span> <span class="hljs-meta">filename</span> 添加pid<br><span class="hljs-name">%u</span> - <span class="hljs-meta">insert</span> current uid <span class="hljs-meta">into</span> <span class="hljs-meta">filename</span> 添加当前uid<br><span class="hljs-name">%g</span> - <span class="hljs-meta">insert</span> current gid <span class="hljs-meta">into</span> <span class="hljs-meta">filename</span> 添加当前gid<br><span class="hljs-name">%s</span> - <span class="hljs-meta">insert</span> signal that caused the coredump <span class="hljs-meta">into</span> the <span class="hljs-meta">filename</span> 添加导致产生core的信号<br><span class="hljs-name">%t</span> - <span class="hljs-meta">insert</span> UNIX time that the coredump occurred <span class="hljs-meta">into</span> <span class="hljs-meta">filename</span> 添加core文件生成时的unix时间<br><span class="hljs-name">%h</span> - <span class="hljs-meta">insert</span> hostname <span class="hljs-meta">where</span> the coredump happened <span class="hljs-meta">into</span> <span class="hljs-meta">filename</span> 添加主机名<br><span class="hljs-name">%e</span> - <span class="hljs-meta">insert</span> coredumping executable name <span class="hljs-meta">into</span> <span class="hljs-meta">filename</span> 添加命令名<br>nagios通过扫描core文件目录是否有新的core文件来决定是否发邮件通知<br></code></pre></td></tr></table></figure><h2 id="4-说明："><a href="#4-说明：" class="headerlink" title="4. 说明："></a>4. 说明：</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、如果系统在修改<span class="hljs-regexp">/etc/</span>profile前已经重启了一些服务，那么ulimit -c unlimited对已经在ulimit -c 为的<span class="hljs-number">0</span>的情况下启动的服务无效，<br><span class="hljs-number">2</span>、如果服务在ulimit -c unlimited情况下启动，则设置<span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_pattern即时生效<br></code></pre></td></tr></table></figure><h2 id="5-备注"><a href="#5-备注" class="headerlink" title="5. 备注"></a>5. 备注</h2><p>以下方式将core文件生成到当前目录下</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">echo <span class="hljs-string">&quot;|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e&quot;</span> &gt;<span class="hljs-regexp">/proc/s</span>ys/kernel/core_pattern  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用nginx作为上传/下载服务器</title>
    <link href="/2022/08/04/04DevOps/18nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <url>/2022/08/04/04DevOps/18nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="配置上传服务器"><a href="#配置上传服务器" class="headerlink" title="配置上传服务器"></a>配置上传服务器</h1><h2 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h2><ul><li><p>从 <a href="https://nginx.org/en/download.html">nginx官方</a>下载源码</p></li><li><p>解压、编译并安装</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">tar</span> <span class="hljs-comment">zxvf</span> <span class="hljs-comment">nginx</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">22</span><span class="hljs-string">.</span><span class="hljs-comment">0</span><span class="hljs-string">.</span><span class="hljs-comment">tar</span><span class="hljs-string">.</span><span class="hljs-comment">gz</span><br><span class="hljs-comment">cd</span> <span class="hljs-comment">nginx</span><span class="hljs-literal">-</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">22</span><span class="hljs-string">.</span><span class="hljs-comment">0</span><br><span class="hljs-comment">#</span> <span class="hljs-comment">编译</span> <span class="hljs-comment">必须指定</span> --<span class="hljs-comment">with</span><span class="hljs-literal">-</span><span class="hljs-comment">http_dav_module</span> <span class="hljs-comment">，</span>--<span class="hljs-comment">user和</span>--<span class="hljs-comment">group分别指定了运行nginx的用户和组。</span>--<span class="hljs-comment">prefix指定安装到/usr/local/nginx目录下</span><br><span class="hljs-string">.</span><span class="hljs-comment">/configure</span> --<span class="hljs-comment">prefix=/usr/local/nginx</span> --<span class="hljs-comment">user=root</span> --<span class="hljs-comment">group=root</span> --<span class="hljs-comment">with</span><span class="hljs-literal">-</span><span class="hljs-comment">http_stub_status_module</span> --<span class="hljs-comment">with</span><span class="hljs-literal">-</span><span class="hljs-comment">http_ssl_module</span> --<span class="hljs-comment">with</span><span class="hljs-literal">-</span><span class="hljs-comment">http_dav_module</span><br><span class="hljs-comment">#</span> <span class="hljs-comment">安装</span><br><span class="hljs-comment">make</span> <span class="hljs-comment">&amp;&amp;</span> <span class="hljs-comment">make</span> <span class="hljs-comment">install</span><br></code></pre></td></tr></table></figure><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>由于上一步编译安装在<code>/usr/local/nginx</code> 目录下,所以执行以下命令编辑<br><code>vim /usr/local/nginx/conf/nginx.conf</code><br>修改<code>server</code>模块内容如下</p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-comment"># 监听本地10080端口</span><br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">10081</span> default_server;<br>    <span class="hljs-attribute">listen</span>       [::]:<span class="hljs-number">10081</span> default_server; <br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-comment"># 上传最大文件尺寸为1G</span><br>    <span class="hljs-attribute">client_max_body_size</span> <span class="hljs-number">1024m</span>;<br>    <span class="hljs-attribute">location</span> / &#123;<br>    <span class="hljs-comment"># 根目录位置为安装目录下的html目录</span><br>        <span class="hljs-attribute">root</span>   html;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-attribute">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   html;<br>    &#125;<br>    <br> <span class="hljs-attribute">location</span> /myupload/ &#123;<br>    <span class="hljs-comment"># nginx数据下载时使用的临时目录</span><br>        <span class="hljs-attribute">client_body_temp_path</span> /root/upload/tmp <span class="hljs-number">1</span>;<br>        <span class="hljs-comment"># 文件的上传目录，nginx服务用户要有写的权限</span><br>     <span class="hljs-attribute">alias</span> /root/upload/;<br>        <span class="hljs-attribute">autoindex</span> <span class="hljs-literal">on</span>;<br>        <span class="hljs-comment"># 默认是关闭PUT功能的，添加这行开启,curl -T 时使用put上传</span><br>     <span class="hljs-attribute">dav_methods</span> PUT;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="创建依赖目录并启动nginx"><a href="#创建依赖目录并启动nginx" class="headerlink" title="创建依赖目录并启动nginx"></a>创建依赖目录并启动nginx</h2><h3 id="创建nginx上传临时目录-和存储目录"><a href="#创建nginx上传临时目录-和存储目录" class="headerlink" title="创建nginx上传临时目录 和存储目录"></a>创建nginx上传临时目录 和存储目录</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/root/u</span>pload/tmp<br><span class="hljs-comment"># 此目录权限必须和源码编译时指定的用户和组一致，否则上传失败</span><br>chown -R root:root <span class="hljs-regexp">/root/u</span>pload<br></code></pre></td></tr></table></figure><h3 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 启动命令</span><br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx<br><span class="hljs-comment"># reload命令</span><br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -s reload<br><span class="hljs-comment"># 停止</span><br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>sbin/nginx -s stop<br></code></pre></td></tr></table></figure><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>创建本地上传文件aaa.log ,执行以下命令上传文件, 将发现aaa.log 存放在/root/upload/目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -v -T aaa.log http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/myupload/</span><br></code></pre></td></tr></table></figure><h1 id="下载服务器"><a href="#下载服务器" class="headerlink" title="下载服务器"></a>下载服务器</h1><p>在上述上传服务器配置建立后，在<code>location / </code>模块下的<code>root html;</code>说明配置当前nginx的服务根目录为<code>/usr/local/nginx/html</code>。<br>可以在此目录建立一个文件下载目录的软连即可实现文件下载功能</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 下载文件的真实存储目录</span><br>mkdir -p <span class="hljs-regexp">/root/</span>downfiles/<br>cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>html<br>ln -s <span class="hljs-regexp">/root/</span>downfiles/ files<br></code></pre></td></tr></table></figure><h2 id="验证下载"><a href="#验证下载" class="headerlink" title="验证下载"></a>验证下载</h2><p>在/root/downfiles/目录下放置一个文件aaa,发起以下请求获取文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget  http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">10080</span><span class="hljs-regexp">/files/</span>aaa<br></code></pre></td></tr></table></figure><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ul><li>当直接使用/upload/替换/myupload/作为上传uri时，curl -T 会返回405错误.<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/zou-xiyuan/</span>p/<span class="hljs-number">15421375</span>.html<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>curl常用方法</title>
    <link href="/2022/08/04/04DevOps/17curl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/08/04/04DevOps/17curl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-请求数据"><a href="#1-请求数据" class="headerlink" title="1. 请求数据"></a>1. 请求数据</h3><figure class="highlight dns"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs dns">curl -v -r <span class="hljs-number">4194304</span>-<span class="hljs-number">6291455</span> &quot;http://<span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7001</span>/videos/v<span class="hljs-number">0/20190602</span>/d0/<span class="hljs-number">3d</span>/<span class="hljs-number">04</span>b40bb692090ef98c91e4027774ce59.<span class="hljs-number">265</span>ts&quot;<br></code></pre></td></tr></table></figure><h3 id="2-发送带json内容的请求"><a href="#2-发送带json内容的请求" class="headerlink" title="2. 发送带json内容的请求"></a>2. 发送带json内容的请求</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">curl</span> -v <span class="hljs-string">&quot;http://10.63.9.23/md?s=1&amp;net=1&quot;</span> -H <span class="hljs-string">&quot;host:dho.iqiyi.com&quot;</span> -H <span class="hljs-string">&quot;Content-Type:application/json&quot;</span> -X POST -d &#x27;&#123;<span class="hljs-string">&quot;ip&quot;</span>:<span class="hljs-string">&quot;10.3.0.202&quot;</span>, <span class="hljs-string">&quot;ttl&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;cross-domain&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;query&quot;</span>:[&#123;<span class="hljs-string">&quot;dn&quot;</span>:<span class="hljs-string">&quot;www.iqiyi.com.&quot;</span>,<span class="hljs-string">&quot;qtype&quot;</span>:<span class="hljs-string">&quot;a&quot;</span>&#125;]&#125;&#x27;<br></code></pre></td></tr></table></figure><h3 id="3-发送json文件"><a href="#3-发送json文件" class="headerlink" title="3. 发送json文件"></a>3. 发送json文件</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -X POST http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/api -H &quot;Content-Type: application/</span>json<span class="hljs-string">&quot; -d @sendfile.json</span><br></code></pre></td></tr></table></figure><h3 id="4-上传文件到指定位置"><a href="#4-上传文件到指定位置" class="headerlink" title="4. 上传文件到指定位置"></a>4. 上传文件到指定位置</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#上传aaa.log 文件到服务器10080服务的upload目录下</span><br>curl -v -T aaa.log http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">10080</span><span class="hljs-regexp">/upload/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理与分析</title>
    <link href="/2022/07/22/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/15%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/2022/07/22/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/15%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h1><p>如何定位分析程序中当前内存使用情况，可通过外部和内部两种方式来确定内存相关情况，</p><h2 id="外部字段分析"><a href="#外部字段分析" class="headerlink" title="外部字段分析"></a>外部字段分析</h2><p>只要知道进程的pid 即可通过命令 <code>/proc/xxxx/satatus</code> 来查看内存信息。其中xxxx为pid号.</p><p>显示的各个字段含义如下:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">VmPeak:</span> 代表当前进程运行过程中虚拟内存的峰值。<br><span class="hljs-symbol">VmSize:</span> 代表进程现在正在占用的虚拟内存。<br><span class="hljs-symbol">VmLck:</span> 代表进程已经锁住的物理内存的大小，锁住的物理内存不能交换到硬盘。<br><span class="hljs-symbol">VmPin:</span> 进程中被pin住的虚拟内存大小。<br><span class="hljs-symbol">VmHWM:</span> 进程得到分配的物理内存的峰值，应该是到目前为止的VmRSS的最大值。<br><span class="hljs-symbol">VmRSS:</span> 进程现在使用的物理内存。<br><span class="hljs-symbol">RssAnon:</span> 进程占用的物理内存中的匿名部分的大小，可以理解为RSS中除去RssFile和RssFile占用的部分。<br><span class="hljs-symbol">RssFile:</span> 进程占用的物理内存中用于文件映射的部分的大小。<br><span class="hljs-symbol">RssShmem:</span> 进程占用的物理内存中共享内存的部分的大小。<br><span class="hljs-symbol">VmData:</span> 表示进程虚拟内存中的数据段的大小。<br><span class="hljs-symbol">VmStk:</span> 表示进程虚拟内存中的堆栈段的大小。<br><span class="hljs-symbol">VmExe:</span> 表示进程虚拟内存中的代码段的大小<br><span class="hljs-symbol">VmSwap:</span> 进程占用<span class="hljs-keyword">Swap</span>的大小。<br></code></pre></td></tr></table></figure><h2 id="内部定期输出"><a href="#内部定期输出" class="headerlink" title="内部定期输出"></a>内部定期输出</h2><p>增加以下函数可以输出程序运行中当前内存的使用情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span>   <span class="hljs-comment">// mallinfo及malloc_stats依赖</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display_mallinfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> seq)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mallinfo</span> <span class="hljs-title">mi</span>;</span><br>    mi = <span class="hljs-built_in">mallinfo</span>();<br>    std::stringstream ss;<br><br>    ss &lt;&lt; <span class="hljs-string">&quot;*************************** &quot;</span> &lt;&lt; seq;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\nTotal non-mmapped bytes (arena):       &quot;</span> &lt;&lt; mi.arena;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\n# of free chunks (ordblks):            &quot;</span> &lt;&lt; mi.ordblks;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\n# of free fastbin blocks (smblks):     &quot;</span> &lt;&lt; mi.smblks;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\n# of mapped regions (hblks):           &quot;</span> &lt;&lt; mi.hblks;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\nBytes in mapped regions (hblkhd):      &quot;</span> &lt;&lt; mi.hblkhd;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\nMax. total allocated space (usmblks):  &quot;</span> &lt;&lt; mi.usmblks;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\nFree bytes held in fastbins (fsmblks): &quot;</span> &lt;&lt; mi.fsmblks;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\nTotal allocated space (uordblks):      &quot;</span> &lt;&lt; mi.uordblks;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\nTotal free space (fordblks):           &quot;</span> &lt;&lt; mi.fordblks;<br>    ss &lt;&lt; <span class="hljs-string">&quot;\nTopmost releasable block (keepcost):   &quot;</span> &lt;&lt; mi.keepcost;<br><br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;--------------------stats info(%d)---------\n&quot;</span>, seq);<br>    <span class="hljs-built_in">malloc_stats</span>();<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;%s\n&quot;</span>, ss.<span class="hljs-built_in">str</span>().<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果分析</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><br><span class="hljs-comment">--------------------stats info(0)---------</span><br>Arena <span class="hljs-number">0</span>:                                           <span class="hljs-comment"># 非mmap申请的内存区域 0 </span><br><span class="hljs-keyword">system</span> <span class="hljs-keyword">bytes</span>     =   <span class="hljs-number">59752448</span>                      <span class="hljs-comment"># glibc 向系统申请的内存大小, 单位字节                      </span><br><span class="hljs-keyword">in</span> use <span class="hljs-keyword">bytes</span>     =   <span class="hljs-number">27787856</span>                      <span class="hljs-comment"># 用户进程通过 malloc 向 glibc 申请分配的内存大小</span><br>Arena <span class="hljs-number">1</span>:                                           <span class="hljs-comment"># 非mmap申请的内存区域 1</span><br><span class="hljs-keyword">system</span> <span class="hljs-keyword">bytes</span>     =     <span class="hljs-number">135168</span><br><span class="hljs-keyword">in</span> use <span class="hljs-keyword">bytes</span>     =       <span class="hljs-number">7504</span><br>Total (incl. mmap):                                <span class="hljs-comment"># 所有内存信息(包含mmap),各个arena数值加上mmap信息</span><br><span class="hljs-keyword">system</span> <span class="hljs-keyword">bytes</span>     =   <span class="hljs-number">63369216</span>                      <span class="hljs-comment"># 包含mmap的所有内存大小, 由mmap+各个Arena累计获取</span><br><span class="hljs-keyword">in</span> use <span class="hljs-keyword">bytes</span>     =   <span class="hljs-number">31276960</span>                      <span class="hljs-comment"># 用户进程通过 malloc 向 glibc 申请分配的内存大小，由各个Arena累加获得</span><br><span class="hljs-built_in">max</span> mmap regions =          <span class="hljs-number">6</span>                      <span class="hljs-comment"># mmap 区域个数</span><br><span class="hljs-built_in">max</span> mmap <span class="hljs-keyword">bytes</span>   =    <span class="hljs-number">3481600</span>                      <span class="hljs-comment"># mmap 申请的内存字节数</span><br><br>*************************** <span class="hljs-number">0</span><br>Total non-mmapped <span class="hljs-keyword">bytes</span> (arena):       <span class="hljs-number">59887616</span>    <span class="hljs-comment"># 非mmap申请的内存字节数,等于stats info中所有的Arean的system bytes计数和(内存分配区域),包含正在使用的和空闲的</span><br><span class="hljs-comment"># of free chunks (ordblks):            12549       # 普通(即非fastbin)空闲块的数量</span><br><span class="hljs-comment"># of free fastbin blocks (smblks):     6           # fastbin空闲块的数量                                    </span><br><span class="hljs-comment"># of mapped regions (hblks):           6           # 当前使用mmap分配的块数                                    </span><br>Bytes <span class="hljs-keyword">in</span> mapped regions (hblkhd):      <span class="hljs-number">3481600</span>     <span class="hljs-comment"># 当前使用mmap分配的块中的字节数</span><br>Max. total allocated <span class="hljs-literal">space</span> (usmblks):  <span class="hljs-number">0</span>           <span class="hljs-comment"># 该字段未使用,始终为0。以前代表已分配最大空间(以字节为单位)。</span><br>Free <span class="hljs-keyword">bytes</span> held <span class="hljs-keyword">in</span> fastbins (fsmblks): <span class="hljs-number">592</span>         <span class="hljs-comment"># fastbin空闲块中的字节总数</span><br>Total allocated <span class="hljs-literal">space</span> (uordblks):      <span class="hljs-number">27794800</span>    <span class="hljs-comment"># 使用中的分配所使用的字节总数</span><br>Total free <span class="hljs-literal">space</span> (fordblks):           <span class="hljs-number">32092816</span>    <span class="hljs-comment"># 空闲块中的字节总数</span><br>Topmost releasable block (keepcost):   <span class="hljs-number">4016</span>        <span class="hljs-comment"># 堆顶部的可释放可用空间总量。这是malloc_trim理想情况下可以释放的最大字节数(即:忽略页面对齐限制等)</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//m</span>an7.org<span class="hljs-regexp">/linux/m</span>an-pages<span class="hljs-regexp">/man3/m</span>allinfo.<span class="hljs-number">3</span>.html<br>https:<span class="hljs-regexp">//</span>www.onitroad.com<span class="hljs-regexp">/jc/</span>linux<span class="hljs-regexp">/man-pages/</span>linux<span class="hljs-regexp">/man3/m</span>allinfo.<span class="hljs-number">3</span>.html<br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/dongzhiquan/</span>p/<span class="hljs-number">5621906</span>.html<br>https:<span class="hljs-regexp">//</span>www.onitroad.com<span class="hljs-regexp">/jc/</span>linux<span class="hljs-regexp">/man-pages/</span>linux<span class="hljs-regexp">/man3/m</span>alloc_trim.<span class="hljs-number">3</span>.html<br>http:<span class="hljs-regexp">//</span>www.xtaohub.com<span class="hljs-regexp">/System-Microscope/</span>how-to-use-memory.html<br>https:<span class="hljs-regexp">//</span>wenfh2020.com<span class="hljs-regexp">/2021/</span><span class="hljs-number">04</span><span class="hljs-regexp">/08/g</span>libc-memory-leak/<br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/weixin_39636610/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">113053005</span><br>https:<span class="hljs-regexp">//</span>www.modb.pro<span class="hljs-regexp">/db/</span><span class="hljs-number">237286</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openssl生成pem格式公钥私钥文件并实现RSA加解密</title>
    <link href="/2022/05/24/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/14pem%E6%A0%BC%E5%BC%8F%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <url>/2022/05/24/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/14pem%E6%A0%BC%E5%BC%8F%E5%85%AC%E9%92%A5%E7%A7%81%E9%92%A5%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0RSA%E5%8A%A0%E8%A7%A3%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="使用openssl生成pem格式私钥和公钥"><a href="#使用openssl生成pem格式私钥和公钥" class="headerlink" title="使用openssl生成pem格式私钥和公钥"></a>使用openssl生成pem格式私钥和公钥</h1><ul><li><p>生成公钥和私钥</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs autohotkey">openssl生成私钥命令： openssl genrsa -out rs<span class="hljs-built_in">a_private</span>_key.pem <span class="hljs-number">1024</span><br>openssl生成公钥命令： openssl rsa -in rs<span class="hljs-built_in">a_private</span>_key.pem -pubout -out rs<span class="hljs-built_in">a_public</span>_key.pem<br></code></pre></td></tr></table></figure><p>此时可以看到 rsa_private_key.pem 和 rsa_public_key.pem 两个文件。这时候的私钥是不能直接使用的，需要进行 pkcs8 编码。</p></li><li><p>对私钥进行pkcs8编码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">openssl</span>的pkcs<span class="hljs-number">8</span>编码命令：openssl pkcs<span class="hljs-number">8</span> -topk<span class="hljs-number">8</span> -in rsa_private_key.pem -out  pkcs<span class="hljs-number">8</span>_rsa_private_key.pem -nocrypt<br></code></pre></td></tr></table></figure></li></ul><p>此时可以看到 pkcs8_rsa_private_key.pem 文件 ,可用的密钥对已经生成好了，私钥使用pkcs8_rsa_private_key.pem，公钥采用rsa_public_key.pem。</p><h1 id="PRNG-not-seeded-解决方法"><a href="#PRNG-not-seeded-解决方法" class="headerlink" title="PRNG not seeded 解决方法"></a>PRNG not seeded 解决方法</h1><p>此问题是由于随机种子初始化问题导致的，需要在合适的位置添加以下随机代码,其中rnd_seed的内容可以设置任意字符串内容</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static const <span class="hljs-built_in">char</span> rnd_seed<span class="hljs-literal">[]</span> =                                                      <br>    <span class="hljs-string">&quot;string to make the random number generator think it has entropy&quot;</span>;<br><span class="hljs-constructor">RAND_seed(<span class="hljs-params">rnd_seed</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">rnd_seed</span>)</span>);<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/u014644574/article/details/122628383">https://blog.csdn.net/u014644574/article/details/122628383</a></li><li><a href="https://blog.csdn.net/HuiLom/article/details/23960073">https://blog.csdn.net/HuiLom/article/details/23960073</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stl严格弱序(stick weak ordering)</title>
    <link href="/2022/04/22/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/13stl%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8Fstric_weak_ordering/"/>
    <url>/2022/04/22/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/13stl%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8Fstric_weak_ordering/</url>
    
    <content type="html"><![CDATA[<p>STL有序容器对元素关键字的类型有要求，元素关键字的类型必须定义了严格弱序（stick weak ordering）</p><h1 id="什么是严格弱序"><a href="#什么是严格弱序" class="headerlink" title="什么是严格弱序"></a>什么是严格弱序</h1><h2 id="STL严格弱序条件"><a href="#STL严格弱序条件" class="headerlink" title="STL严格弱序条件"></a>STL严格弱序条件</h2><p>如果类型T满足以下Compare<br>类型 T 满足二元谓词 (BinaryPredicate) 且提供以下两个对象</p><ol><li>T类型的对象 <code>comp</code> 函数</li><li>一个等价于 !comp(a, b) &amp;&amp; !comp(b, a) 的表达式 <code>equiv(a, b)</code></li></ol><p>以下表达式必须合法有效。</p><table><thead><tr><th>表达式</th><th>返回类型</th><th>要求</th></tr></thead><tbody><tr><td>comp(a, b)</td><td>可隐式转换为 bool</td><td>建立具有下列性质的严格弱序关系<br>a. 对于所有 a，comp(a,a)==false<br>b. 若 comp(a,b)==true 则 comp(b,a)==false <br>c. 若 comp(a,b)==true 且 comp(b,c)==true 则 comp(a,c)==true</td></tr><tr><td>equiv(a, b)</td><td>bool</td><td>建立具有下列性质的等价关系<br>a. 对于所有 a，equiv(a,a)==true <br>b. 若 equiv(a,b)==true 则 equiv(b,a)==true <br>c. 若 equiv(a,b)==true 且 equiv(b,c)==true 则 equiv(a,c)==true</td></tr></tbody></table><h2 id="STL严格弱序实现方式"><a href="#STL严格弱序实现方式" class="headerlink" title="STL严格弱序实现方式"></a>STL严格弱序实现方式</h2><p>对于STL中的容器实现<code>&lt;</code>操作符，这就是一个严格弱序;而<code>&lt;=</code>不是一个严格弱序</p><p><font color='red'>在自定义比较函数(self_compare )的时候需要注意在相等时要返回false， 不能返回true.</font></p><h1 id="严格若序应用"><a href="#严格若序应用" class="headerlink" title="严格若序应用"></a>严格若序应用</h1><ul><li>标准库中的 map set multiset multiset 等都是严格弱序。</li><li>map 的 key 为自定义对象时需要重载 <code>&lt;</code> 操作符, 需注意相等时返回false。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>zh.cppreference.com<span class="hljs-regexp">/w/</span>cpp<span class="hljs-regexp">/named_req/</span>Compare<br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/River_Lethe/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">78618788</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenResty(nginx+lua)基础 (转载)</title>
    <link href="/2022/04/06/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/05others/00OpenResty(nginx+lua)%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/04/06/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/05others/00OpenResty(nginx+lua)%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本文转载自《<a href="https://www.cnblogs.com/digdeep/p/4859575.html%E3%80%8B">https://www.cnblogs.com/digdeep/p/4859575.html》</a></p><h1 id="OpenResty-介绍"><a href="#OpenResty-介绍" class="headerlink" title="OpenResty 介绍"></a>OpenResty 介绍</h1><p>OpenResty 官网：<a href="http://openresty.org/">http://openresty.org/</a></p><p>OpenResty 是一个nginx和它的各种三方模块的一个打包而成的软件平台。最重要的一点是它将lua/luajit打包了进来，使得我们可以使用lua脚本来进行web的开发。有了lua，我们可以借助于nginx的异步非阻塞的功能，达到使用 lua 异步并发访问后端的 MySQL, PostgreSQL, Memcached, Redis等等服务。特别是特有的 ngx.location.capture_multi 功能让人印象深刻，其可以达到极大的减少浏览器的http连接数量，并且可以异步并发的访问后台 Java/PHP/Python 等等接口。OpenResty 架构的web可以轻松超越Node.js的性能，并且对后端语言没有限制，你可以使用Java/PHP/Python等等各种语言。OpenResty(nginx+lua)可以替代node.js的前端渲染的功能。</p><h1 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h1><p>先安装依赖：yum install readline-devel pcre-devel openssl-devel gcc</p><p>解压： tar zxvf ngx_openresty-1.9.3.1.tar.gz</p><p>建立一个软连接：ln -s ngx_openresty-1.9.3.1 openresty</p><p>进入目录：cd openresty</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">./configure \<br>             <span class="hljs-comment">--with-cc-opt=&quot;-I/usr/local/include&quot; \</span><br>             <span class="hljs-comment">--with-ld-opt=&quot;-L/usr/local/lib&quot; \</span><br>             <span class="hljs-comment">--prefix=/opt/openresty </span><br><br>... ...<br>Configuration summary<br>  + <span class="hljs-keyword">using</span> <span class="hljs-keyword">system</span> PCRE library<br>  + <span class="hljs-keyword">using</span> <span class="hljs-keyword">system</span> OpenSSL library<br>  + md5: <span class="hljs-keyword">using</span> OpenSSL library<br>  + sha1: <span class="hljs-keyword">using</span> OpenSSL library<br>  + <span class="hljs-keyword">using</span> <span class="hljs-keyword">system</span> zlib library<br><br>  nginx path prefix: <span class="hljs-string">&quot;/opt/openresty/nginx&quot;</span><br>  nginx binary <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/opt/openresty/nginx/sbin/nginx&quot;</span><br>  nginx configuration prefix: <span class="hljs-string">&quot;/opt/openresty/nginx/conf&quot;</span><br>  nginx configuration <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/opt/openresty/nginx/conf/nginx.conf&quot;</span><br>  nginx pid <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/opt/openresty/nginx/logs/nginx.pid&quot;</span><br>  nginx error <span class="hljs-built_in">log</span> <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/opt/openresty/nginx/logs/error.log&quot;</span><br>  nginx <span class="hljs-keyword">http</span> access <span class="hljs-built_in">log</span> <span class="hljs-built_in">file</span>: <span class="hljs-string">&quot;/opt/openresty/nginx/logs/access.log&quot;</span><br>  nginx <span class="hljs-keyword">http</span> client request body temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;client_body_temp&quot;</span><br>  nginx <span class="hljs-keyword">http</span> proxy temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;proxy_temp&quot;</span><br>  nginx <span class="hljs-keyword">http</span> fastcgi temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;fastcgi_temp&quot;</span><br>  nginx <span class="hljs-keyword">http</span> uwsgi temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;uwsgi_temp&quot;</span><br>  nginx <span class="hljs-keyword">http</span> scgi temporary <span class="hljs-built_in">files</span>: <span class="hljs-string">&quot;scgi_temp&quot;</span><br></code></pre></td></tr></table></figure><p>其中 –prefix=/opt/openresty 指定了安装目录，不指定的话默认会安装到 /usr/local/openresty 目录下。</p><h2 id="编译安装：-make-amp-amp-make-install"><a href="#编译安装：-make-amp-amp-make-install" class="headerlink" title="编译安装： make &amp;&amp; make install"></a>编译安装： make &amp;&amp; make install</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span> src]<span class="hljs-meta"># cd /opt/openresty/</span><br>[root<span class="hljs-symbol">@localhost</span> openresty]<span class="hljs-meta"># ls</span><br>bin  luajit  lualib  nginx<br></code></pre></td></tr></table></figure><p>可以看到 /opt/openresty 目录下四个文件夹，其中包括了 luajit，nginx。</p><p>启动openresty: /opt/openresty/nginx/sbin/nginx -c /opt/openresty/nginx/conf/nginx.conf -p /opt/openresty/nginx/</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@localhost src]<span class="hljs-comment"># ps -elf|grep nginx</span><br>1 S root     <span class="hljs-number"> 2076 </span>   <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 80 </span> <span class="hljs-number"> 0 </span>-<span class="hljs-number"> 34999 </span>-      21:24 ?        00:00:00 nginx: master process /opt/openresty/nginx/sbin/nginx -c /opt/openresty/nginx/conf/nginx.conf -p /opt/openresty/nginx/<br>5 S nobody   <span class="hljs-number"> 2077 </span><span class="hljs-number"> 2076 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 80 </span> <span class="hljs-number"> 0 </span>-<span class="hljs-number"> 35045 </span>-      21:24 ?        00:00:00 nginx: worker process                                    <br>0 S root     <span class="hljs-number"> 2079 </span><span class="hljs-number"> 1678 </span><span class="hljs-number"> 0 </span><span class="hljs-number"> 80 </span> <span class="hljs-number"> 0 </span>- <span class="hljs-number"> 1088 </span>-      21:24 pts/1    00:00:00 grep nginx<br></code></pre></td></tr></table></figure><p>验证可以访问： curl 127.0.0.1</p><h1 id="content-by-lua-和-content-by-lua-file"><a href="#content-by-lua-和-content-by-lua-file" class="headerlink" title="content_by_lua 和 content_by_lua_file"></a>content_by_lua 和 content_by_lua_file</h1><p>nginx 如何嵌入 lua 脚本。方法就是在nginx的配置文件nginx.conf 中使用 content_by_lua 或者 cotent_by_lua_file 指令：</p><h2 id="content-by-lua-一般在很简单的lua脚本时使用："><a href="#content-by-lua-一般在很简单的lua脚本时使用：" class="headerlink" title="content_by_lua 一般在很简单的lua脚本时使用："></a>content_by_lua 一般在很简单的lua脚本时使用：</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">location /lua &#123;<br>        <span class="hljs-keyword">set</span> <span class="hljs-variable">$test</span> <span class="hljs-string">&quot;hello, world.&quot;</span>;<br>        content_by_lua &#x27;<br>                ngx.header.content_type = <span class="hljs-string">&quot;text/plain&quot;</span>;<br>                ngx.say(ngx.<span class="hljs-keyword">var</span>.<span class="hljs-keyword">test</span>);<br>        &#x27;;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问 <a href="http://localhost/lua">http://localhost/lua</a> 可以看到输出到页面的  hello, world.</p><h2 id="cotent-by-lua-file-适应于复杂的-lua-脚本，专门放入一个文件中："><a href="#cotent-by-lua-file-适应于复杂的-lua-脚本，专门放入一个文件中：" class="headerlink" title="cotent_by_lua_file 适应于复杂的 lua 脚本，专门放入一个文件中："></a>cotent_by_lua_file 适应于复杂的 lua 脚本，专门放入一个文件中：</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/lua2</span> &#123;<br>    <span class="hljs-comment">#lua_code_cache off;</span><br>    content_by_lua_file lua/hello.lua;<br>&#125;<br></code></pre></td></tr></table></figure><p>路径相对于 /opt/openresty/nginx</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@localhost lua]<span class="hljs-comment"># pwd</span><br><span class="hljs-regexp">/opt/</span>openresty<span class="hljs-regexp">/nginx/</span>lua<br>[root@localhost lua]<span class="hljs-comment"># cat hello.lua</span><br>ngx.say(<span class="hljs-string">&#x27;hello ngx_lua!!!!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>本例子中 hello.lua 只包含一句： ngx.say(‘hello ngx_lua!!!!’);</p><p>访问 /lua2 :</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">[root@localhost lua]# curl localhost/lua<br>hello ngx_lua!!!!<br></code></pre></td></tr></table></figure><p>可以看到访问成功。</p><p>在 nginx.conf 文件的 server {.. …} 中加入 lua_code_cache off; 可以方便调试lua脚本，修改lua脚本之后，不需要 reload nginx.</p><p>openresty 中的 nginx 嵌入 luajit 的原理：</p><img src="/2022/04/06/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/05others/00OpenResty(nginx+lua)%E5%9F%BA%E7%A1%80/1.png" class="" title="ngx_lua工作原理"><p>每一个nginx的进程中都嵌入了一个 luajit的虚拟机，来执行lua脚本。nginx将lua脚本的执行交给了luajit vm.</p><h1 id="ngx-lua-的指令-和-API"><a href="#ngx-lua-的指令-和-API" class="headerlink" title="ngx_lua 的指令 和 API"></a>ngx_lua 的指令 和 API</h1><h2 id="ngx访问lua指令"><a href="#ngx访问lua指令" class="headerlink" title="ngx访问lua指令"></a>ngx访问lua指令</h2><p>上面我们说到 nginx 嵌入 lua 脚本可以使用 content_by_lua 和 content_by_lua_file，它们其实是<code>指令(Directives)</code>，类似的<code>指令</code>还有很多，</p><p>具体参见：<a href="https://www.nginx.com/resources/wiki/modules/lua/#directives">https://www.nginx.com/resources/wiki/modules/lua/#directives</a></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">lu<span class="hljs-built_in">a_use</span>_default_type<br>lu<span class="hljs-built_in">a_code</span>_cache<br>lu<span class="hljs-built_in">a_regex</span>_cache_max_entries<br>lu<span class="hljs-built_in">a_regex</span>_match_limit<br>lu<span class="hljs-built_in">a_package</span>_path<br>lu<span class="hljs-built_in">a_package</span>_cpath<br>init_by_lua<br>init_by_lu<span class="hljs-built_in">a_file</span><br>init_worker_by_lua<br>init_worker_by_lu<span class="hljs-built_in">a_file</span><br>set_by_lua<br>set_by_lu<span class="hljs-built_in">a_file</span><br>content_by_lua<br>content_by_lu<span class="hljs-built_in">a_file</span><br>rewrite_by_lua<br>rewrite_by_lu<span class="hljs-built_in">a_file</span><br>access_by_lua<br>access_by_lu<span class="hljs-built_in">a_file</span><br>header_filter_by_lua<br>header_filter_by_lu<span class="hljs-built_in">a_file</span><br>body_filter_by_lua<br>body_filter_by_lu<span class="hljs-built_in">a_file</span><br>log_by_lua<br>log_by_lu<span class="hljs-built_in">a_file</span><br>lu<span class="hljs-built_in">a_need</span>_request_body<br>lu<span class="hljs-built_in">a_shared</span>_dict<br>lu<span class="hljs-built_in">a_socket</span>_connect_timeout<br>lu<span class="hljs-built_in">a_socket</span>_send_timeout<br>lu<span class="hljs-built_in">a_socket</span>_send_lowat<br>lu<span class="hljs-built_in">a_socket</span>_read_timeout<br>lu<span class="hljs-built_in">a_socket</span>_buffer_size<br>lu<span class="hljs-built_in">a_socket</span>_pool_size<br>lu<span class="hljs-built_in">a_socket</span>_keepalive_timeout<br>lu<span class="hljs-built_in">a_socket</span>_log_errors<br>lu<span class="hljs-built_in">a_ssl</span>_ciphers<br>lu<span class="hljs-built_in">a_ssl</span>_crl<br>lu<span class="hljs-built_in">a_ssl</span>_protocols<br>lu<span class="hljs-built_in">a_ssl</span>_trusted_certificate<br>lu<span class="hljs-built_in">a_ssl</span>_verify_depth<br>lu<span class="hljs-built_in">a_http10</span>_buffering<br>rewrite_by_lu<span class="hljs-built_in">a_no</span>_postpone<br>lu<span class="hljs-built_in">a_transform</span>_underscores_in_response_headers<br>lu<span class="hljs-built_in">a_check</span>_client_abort<br>lu<span class="hljs-built_in">a_max</span>_pending_timers<br>lu<span class="hljs-built_in">a_max</span>_running_timers<br></code></pre></td></tr></table></figure><p>这些指令都是 nginx 访问 lua 脚本的入口。</p><h2 id="lua-访问nginx-API"><a href="#lua-访问nginx-API" class="headerlink" title="lua 访问nginx API"></a>lua 访问nginx API</h2><p>lua脚本如何调用nginx中的函数呢？就是通过 ngx_lua 的API 。</p><p>具体介绍参见：<a href="https://www.nginx.com/resources/wiki/modules/lua/#nginx-api-for-lua">https://www.nginx.com/resources/wiki/modules/lua/#nginx-api-for-lua</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Introduction<br>ngx<span class="hljs-selector-class">.arg</span><br>ngx<span class="hljs-selector-class">.var</span><span class="hljs-selector-class">.VARIABLE</span><br>Core constants<br>HTTP method constants<br>HTTP status constants<br>NGINX log level constants<br>print<br>ngx<span class="hljs-selector-class">.ctx</span><br>ngx<span class="hljs-selector-class">.location</span><span class="hljs-selector-class">.capture</span><br>ngx<span class="hljs-selector-class">.location</span><span class="hljs-selector-class">.capture_multi</span><br>ngx<span class="hljs-selector-class">.status</span><br>ngx<span class="hljs-selector-class">.header</span><span class="hljs-selector-class">.HEADER</span><br>ngx<span class="hljs-selector-class">.resp</span><span class="hljs-selector-class">.get_headers</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.start_time</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.http_version</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.raw_header</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.get_method</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.set_method</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.set_uri</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.set_uri_args</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.get_uri_args</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.get_post_args</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.get_headers</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.set_header</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.clear_header</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.read_body</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.discard_body</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.get_body_data</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.get_body_file</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.set_body_data</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.set_body_file</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.init_body</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.append_body</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.finish_body</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.socket</span><br>ngx<span class="hljs-selector-class">.req</span><span class="hljs-selector-class">.is_internal</span><br>ngx<span class="hljs-selector-class">.exec</span><br>ngx<span class="hljs-selector-class">.redirect</span><br>ngx<span class="hljs-selector-class">.send_headers</span><br>ngx<span class="hljs-selector-class">.headers_sent</span><br>ngx<span class="hljs-selector-class">.print</span><br>ngx<span class="hljs-selector-class">.say</span><br>ngx<span class="hljs-selector-class">.log</span><br>ngx<span class="hljs-selector-class">.flush</span><br>ngx<span class="hljs-selector-class">.exit</span><br>ngx<span class="hljs-selector-class">.eof</span><br>ngx<span class="hljs-selector-class">.sleep</span><br>ngx<span class="hljs-selector-class">.escape_uri</span><br>ngx<span class="hljs-selector-class">.unescape_uri</span><br>ngx<span class="hljs-selector-class">.encode_args</span><br>ngx<span class="hljs-selector-class">.decode_args</span><br>ngx<span class="hljs-selector-class">.encode_base64</span><br>ngx<span class="hljs-selector-class">.decode_base64</span><br>ngx<span class="hljs-selector-class">.crc32_short</span><br>ngx<span class="hljs-selector-class">.crc32_long</span><br>ngx<span class="hljs-selector-class">.hmac_sha1</span><br>ngx<span class="hljs-selector-class">.md5</span><br>ngx<span class="hljs-selector-class">.md5_bin</span><br>ngx<span class="hljs-selector-class">.sha1_bin</span><br>ngx<span class="hljs-selector-class">.quote_sql_str</span><br>ngx<span class="hljs-selector-class">.today</span><br>ngx<span class="hljs-selector-class">.time</span><br>ngx<span class="hljs-selector-class">.now</span><br>ngx<span class="hljs-selector-class">.update_time</span><br>ngx<span class="hljs-selector-class">.localtime</span><br>ngx<span class="hljs-selector-class">.utctime</span><br>ngx<span class="hljs-selector-class">.cookie_time</span><br>ngx<span class="hljs-selector-class">.http_time</span><br>ngx<span class="hljs-selector-class">.parse_http_time</span><br>ngx<span class="hljs-selector-class">.is_subrequest</span><br>ngx<span class="hljs-selector-class">.re</span><span class="hljs-selector-class">.match</span><br>ngx<span class="hljs-selector-class">.re</span><span class="hljs-selector-class">.find</span><br>ngx<span class="hljs-selector-class">.re</span><span class="hljs-selector-class">.gmatch</span><br>ngx<span class="hljs-selector-class">.re</span><span class="hljs-selector-class">.sub</span><br>ngx<span class="hljs-selector-class">.re</span><span class="hljs-selector-class">.gsub</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.get</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.get_stale</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.set</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.safe_set</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.add</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.safe_add</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.replace</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.delete</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.incr</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.flush_all</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.flush_expired</span><br>ngx<span class="hljs-selector-class">.shared</span><span class="hljs-selector-class">.DICT</span><span class="hljs-selector-class">.get_keys</span><br>ngx<span class="hljs-selector-class">.socket</span><span class="hljs-selector-class">.udp</span><br>udpsock:setpeername<br>udpsock:send<br>udpsock:receive<br>udpsock:close<br>udpsock:settimeout<br>ngx<span class="hljs-selector-class">.socket</span><span class="hljs-selector-class">.tcp</span><br>tcpsock:connect<br>tcpsock:sslhandshake<br>tcpsock:send<br>tcpsock:receive<br>tcpsock:receiveuntil<br>tcpsock:close<br>tcpsock:settimeout<br>tcpsock:setoption<br>tcpsock:setkeepalive<br>tcpsock:getreusedtimes<br>ngx<span class="hljs-selector-class">.socket</span><span class="hljs-selector-class">.connect</span><br>ngx<span class="hljs-selector-class">.get_phase</span><br>ngx<span class="hljs-selector-class">.thread</span><span class="hljs-selector-class">.spawn</span><br>ngx<span class="hljs-selector-class">.thread</span><span class="hljs-selector-class">.wait</span><br>ngx<span class="hljs-selector-class">.thread</span><span class="hljs-selector-class">.kill</span><br>ngx<span class="hljs-selector-class">.on_abort</span><br>ngx<span class="hljs-selector-class">.timer</span><span class="hljs-selector-class">.at</span><br>ngx<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.debug</span><br>ngx<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.prefix</span><br>ngx<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.nginx_version</span><br>ngx<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.nginx_configure</span><br>ngx<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.ngx_lua_version</span><br>ngx<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.exiting</span><br>ngx<span class="hljs-selector-class">.worker</span><span class="hljs-selector-class">.pid</span><br>ndk<span class="hljs-selector-class">.set_var</span><span class="hljs-selector-class">.DIRECTIVE</span><br>coroutine<span class="hljs-selector-class">.create</span><br>coroutine<span class="hljs-selector-class">.resume</span><br>coroutine<span class="hljs-selector-class">.yield</span><br>coroutine<span class="hljs-selector-class">.wrap</span><br>coroutine<span class="hljs-selector-class">.running</span><br>coroutine.status<br></code></pre></td></tr></table></figure><p>其实nginx和Lua的交互开发主要就是指令和API，当然还有lua脚本的语法。<code>指令</code>是nginx访问lua的入口，<code>API</code>是lua调用nginx的函数，lua是脚本编程语言。</p><p><code>指令</code>其实很简单，所以主要就是熟悉ngx_lua的 API 和Lua语法。</p><h1 id="lua-访问-redis"><a href="#lua-访问-redis" class="headerlink" title="lua 访问 redis"></a>lua 访问 redis</h1><p>lua-resty-redis 模块：<a href="https://github.com/openresty/lua-resty-redis">https://github.com/openresty/lua-resty-redis</a> （有文档可以参考）</p><p>在nginx.conf中加入：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/redis_test</span>&#123;<br>    content_by_lua_file lua/redis_test.lua;<br>&#125;<br></code></pre></td></tr></table></figure><p>redis_test.lua 内容:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs applescript">[root@localhost lua]<span class="hljs-comment"># cat redis_test.lua</span><br><span class="hljs-keyword">local</span> redis = require <span class="hljs-string">&quot;resty.redis&quot;</span><br><span class="hljs-keyword">local</span> red = redis:new()<br><br>red:set_timeout(<span class="hljs-number">1000</span>)<br><br><span class="hljs-keyword">local</span> ok, err = red:connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>        ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">&quot;failed to connect: &quot;</span>, err)<br><span class="hljs-built_in">        return</span><br><span class="hljs-keyword">end</span><br><br>ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">&quot;set result: &quot;</span>, ok)<br><br><span class="hljs-keyword">local</span> res, err = red:<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;dog&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res <span class="hljs-keyword">then</span><br>        ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">&quot;failed to get doy: &quot;</span>, err)<br><span class="hljs-built_in">        return</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> res == ngx.null <span class="hljs-keyword">then</span><br>        ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">&quot;dog not found.&quot;</span>)<br><span class="hljs-built_in">        return</span><br><span class="hljs-keyword">end</span><br><br>ngx.<span class="hljs-built_in">say</span>(<span class="hljs-string">&quot;dog: &quot;</span>, res)<br><br>[root@localhost lua]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>访问：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@localhost <span class="hljs-keyword">lua</span>]# curl localhost/redis_test<br><span class="hljs-keyword">set</span> resul<span class="hljs-variable">t:</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">do</span><span class="hljs-variable">g:</span> <span class="hljs-keyword">an</span> animal<br>[root@localhost <span class="hljs-keyword">lua</span>]#<br></code></pre></td></tr></table></figure><p>我们看到访问成功。</p><h1 id="lua-访问mysql"><a href="#lua-访问mysql" class="headerlink" title="lua 访问mysql"></a>lua 访问mysql</h1><p>openresty的mysql模块：lua-resty-mysql :<a href="https://github.com/openresty/lua-resty-mysql%EF%BC%88%E6%9C%89%E6%96%87%E6%A1%A3%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%EF%BC%89">https://github.com/openresty/lua-resty-mysql（有文档可以参考）</a></p><p>在nginx.conf加入如下配置：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/mysql_test</span> &#123;<br>    content_by_lua_file lua/mysql_test.lua;<br>&#125;<br></code></pre></td></tr></table></figure><p>mysql_test.lua脚本内容：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs stata">[root@localhost lua]# <span class="hljs-keyword">pwd</span><br>/opt/openresty/nginx/lua<br>[root@localhost lua]# <span class="hljs-keyword">cat</span> mysql_test.lua<br><span class="hljs-keyword">local</span> mysql = require <span class="hljs-string">&quot;resty.mysql&quot;</span><br><span class="hljs-keyword">local</span> <span class="hljs-keyword">db</span>, <span class="hljs-keyword">err</span> = mysql:new()<br><br><span class="hljs-keyword">if</span> not <span class="hljs-keyword">db</span> then<br>        ngx.say(<span class="hljs-string">&quot;failed to instantiate mysql: &quot;</span>, <span class="hljs-keyword">err</span>)<br>        <span class="hljs-keyword">return</span><br>end<br><br><span class="hljs-keyword">db</span>:set_timeout(1000)<br><br><span class="hljs-keyword">local</span> ok, <span class="hljs-keyword">err</span>, errno, sqlstate = <span class="hljs-keyword">db</span>:connect&#123;<br>        host = <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>        port = 3306,<br>        database = <span class="hljs-string">&quot;ngx_lua&quot;</span>,<br>        user = <span class="hljs-string">&quot;root&quot;</span>,<br>        password=<span class="hljs-string">&quot;digdeep&quot;</span>,<br>        max_packet_size = 1024 * 1024<br>&#125;<br><br><span class="hljs-keyword">if</span> not ok then<br>        ngx.say(<span class="hljs-string">&quot;failed to connect: &quot;</span>, <span class="hljs-keyword">err</span>, <span class="hljs-string">&quot;: &quot;</span>, errno, <span class="hljs-string">&quot; &quot;</span>, sqlstate)<br>        <span class="hljs-keyword">return</span><br>end<br><br>ngx.say(<span class="hljs-string">&quot;connected to mysql.&quot;</span>)<br><br><span class="hljs-keyword">local</span> res, <span class="hljs-keyword">err</span>, errno, sqlstate = <span class="hljs-keyword">db</span>:<span class="hljs-keyword">query</span>(<span class="hljs-string">&quot;drop table if exists cats&quot;</span>)<br><span class="hljs-keyword">if</span> not res then<br>        ngx.say(<span class="hljs-string">&quot;bad result: &quot;</span>, <span class="hljs-keyword">err</span>, <span class="hljs-string">&quot;: &quot;</span>, errno, <span class="hljs-string">&quot;: &quot;</span>, sqlstate, <span class="hljs-string">&quot;.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>end<br><br>res, <span class="hljs-keyword">err</span>, errno, sqlstate = <span class="hljs-keyword">db</span>:<span class="hljs-keyword">query</span>(<span class="hljs-string">&quot;create table cats &quot;</span> .. <span class="hljs-string">&quot;(id int not null primary key auto_increment, &quot;</span><br>                                        .. <span class="hljs-string">&quot;name varchar(30))&quot;</span>)<br><span class="hljs-keyword">if</span> not res then<br>        ngx.say(<span class="hljs-string">&quot;bad result: &quot;</span>, <span class="hljs-keyword">err</span>, <span class="hljs-string">&quot;: &quot;</span>, errno, <span class="hljs-string">&quot;: &quot;</span>, sqlstate, <span class="hljs-string">&quot;.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>end<br><br>ngx.say(<span class="hljs-string">&quot;table cats created.&quot;</span>)<br><br>res, <span class="hljs-keyword">err</span>, errno, sqlstate = <span class="hljs-keyword">db</span>:<span class="hljs-keyword">query</span>(<span class="hljs-string">&quot;insert into cats(name) &quot;</span> .. <span class="hljs-string">&quot;values (\&#x27;Bob\&#x27;),(\&#x27;\&#x27;),(null)&quot;</span>)<br><span class="hljs-keyword">if</span> not res then<br>        ngx.say(<span class="hljs-string">&quot;bad request: &quot;</span>, <span class="hljs-keyword">err</span>, <span class="hljs-string">&quot;: &quot;</span>, errno, <span class="hljs-string">&quot;: &quot;</span>, sqlstate, <span class="hljs-string">&quot;.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>end<br><br>ngx.say(res.affected_rows, <span class="hljs-string">&quot; rows inserted into table cats &quot;</span>, <span class="hljs-string">&quot;(last insert id: &quot;</span>, res.insert_id, <span class="hljs-string">&quot;)&quot;</span>)<br><br>res, <span class="hljs-keyword">err</span>, errno, sqlstate = <span class="hljs-keyword">db</span>:<span class="hljs-keyword">query</span>(<span class="hljs-string">&quot;select * from cats order by id asc&quot;</span>, 10)<br><span class="hljs-keyword">if</span> not res then<br>        ngx.say(<span class="hljs-string">&quot;bad result &quot;</span>, <span class="hljs-keyword">err</span>, <span class="hljs-string">&quot;: &quot;</span>, errno, <span class="hljs-string">&quot;: &quot;</span>, sqlstate, <span class="hljs-string">&quot;.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>end<br><br><span class="hljs-keyword">local</span> cjson = require <span class="hljs-string">&quot;cjson&quot;</span><br>ngx.say(<span class="hljs-string">&quot;result: &quot;</span>, cjson.<span class="hljs-keyword">encode</span>(res))<br><br><span class="hljs-keyword">local</span> ok, <span class="hljs-keyword">err</span> = <span class="hljs-keyword">db</span>:set_keepalive(1000, 100)<br><span class="hljs-keyword">if</span> not ok then<br>        ngx.say(<span class="hljs-string">&quot;failed to set keepalive: &quot;</span>, <span class="hljs-keyword">err</span>)<br>        <span class="hljs-keyword">return</span><br>end<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[root@localhost lua]# curl localhost/mysql_test<br>connected <span class="hljs-keyword">to</span> mysql.<br><span class="hljs-keyword">table</span> cats created.<br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> inserted <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> cats (last <span class="hljs-keyword">insert</span> id: <span class="hljs-number">1</span>)<br>result: [&#123;&quot;name&quot;:&quot;Bob&quot;,&quot;id&quot;:<span class="hljs-number">1</span>&#125;,&#123;&quot;name&quot;:&quot;&quot;,&quot;id&quot;:<span class="hljs-number">2</span>&#125;,&#123;&quot;name&quot;:<span class="hljs-keyword">null</span>,&quot;id&quot;:<span class="hljs-number">3</span>&#125;]<br><br></code></pre></td></tr></table></figure><p>测试通过。</p><h1 id="lua-的-capture-和-capture-multi-子查询"><a href="#lua-的-capture-和-capture-multi-子查询" class="headerlink" title="lua 的 capture 和 capture_multi(子查询)"></a>lua 的 capture 和 capture_multi(子查询)</h1><p>capture_multi 是 openresty 一个十分强大的功能。它能极大的减少前端浏览器发送的http请求的数量，突破了浏览器对于同一个服务器并发请求数量的限制，因为他可以将前端的多个http请求减少为只要一个http请求到nginx，然后nginx使用capture_multi特性，对后端发起多个异步并发请求，然后统一将结果返回给前端。下面看一个例子：</p><p>首先在nginx.conf中加入下面的 location 配置，并且配置好 nginx 访问 php 的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /capture &#123;<br>    <span class="hljs-attribute">content_by_lua_file</span> lua/capture.lua;<br>    <span class="hljs-comment">#access_by_lua_file lua/capture.lua;</span><br>&#125;<br><br><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ \.php$</span> &#123;<br>    <span class="hljs-attribute">root</span>           html;<br>    <span class="hljs-attribute">fastcgi_pass</span>   <span class="hljs-number">127.0.0.1:9000</span>;<br>    <span class="hljs-attribute">fastcgi_index</span>  index.php;<br>    <span class="hljs-attribute">fastcgi_param</span>  SCRIPT_FILENAME  $document_root$fastcgi_script_name;<br>    <span class="hljs-attribute">include</span>        fastcgi_params;<br>&#125;<br></code></pre></td></tr></table></figure><p>capture.lua 的代码如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@localhost <span class="hljs-keyword">lua</span>]# <span class="hljs-keyword">pwd</span><br>/<span class="hljs-keyword">opt</span>/openresty/nginx/<span class="hljs-keyword">lua</span><br>[root@localhost <span class="hljs-keyword">lua</span>]# <span class="hljs-keyword">cat</span> capture.<span class="hljs-keyword">lua</span><br>local res1,res2,res3,res4 = ngx.location.capture_multi&#123;<br>        &#123;<span class="hljs-string">&quot;/mysql_test&quot;</span>, &#123;<span class="hljs-keyword">args</span>=<span class="hljs-string">&quot;t=1&amp;id=1&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;/redis_test&quot;</span>, &#123;<span class="hljs-keyword">args</span>=<span class="hljs-string">&quot;t=2&amp;id=2&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;/lua&quot;</span>, &#123;<span class="hljs-keyword">args</span>=<span class="hljs-string">&quot;t=3&amp;id=3&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;/index.php&quot;</span>, &#123;<span class="hljs-keyword">args</span>=<span class="hljs-string">&quot;t=3&amp;id=3&quot;</span>&#125;&#125;,<br>&#125;<br><br>ngx.header.content_type=<span class="hljs-string">&quot;text/plain&quot;</span><br>ngx.say(res1.body)<br>ngx.say(res2.body)<br>ngx.say(res3.body)<br>ngx.say(res4.truncated)<br>ngx.say(res4.status)<br>ngx.say(res4.header[<span class="hljs-string">&quot;Set-Cookie&quot;</span>])<br><br>--ngx.say(res4.body)<br></code></pre></td></tr></table></figure><p>index.php 代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">[root@localhost html]<span class="hljs-comment"># pwd</span><br>/opt/openresty/nginx/html<br>[root@localhost html]<span class="hljs-comment"># cat index.php</span><br><span class="hljs-meta">&lt;?php</span><br>        <span class="hljs-keyword">echo</span> phpinfo();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>访问：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs applescript">[root@localhost html]<span class="hljs-comment"># curl localhost/capture</span><br>connected <span class="hljs-keyword">to</span> mysql.<br>table cats created.<br><span class="hljs-number">3</span> rows inserted <span class="hljs-keyword">into</span> table cats (<span class="hljs-keyword">last</span> insert <span class="hljs-built_in">id</span>: <span class="hljs-number">1</span>)<br><span class="hljs-literal">result</span>: [&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Bob&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:null,<span class="hljs-string">&quot;id&quot;</span>:<span class="hljs-number">3</span>&#125;]<br><br><span class="hljs-keyword">set</span> <span class="hljs-literal">result</span>: <span class="hljs-number">1</span><br>dog: an animal<br><br>hello ngx_lua!!!!<br><br><span class="hljs-literal">false</span><br><span class="hljs-number">200</span><br>nil<br></code></pre></td></tr></table></figure><p>可以看到访问成功了。/mysql_test，/redis_test, /lua, /index.php 四个请求的结果都输出了。</p><blockquote><p>注意： ngx.location.capture_multi{… …} 中的多个异步并发请求可以是 nginx.conf 中配置的 location(比如 /mysql_test, /redis_test, /lua)，也可以不是 location配置的路径，比如 index.php 就不是。index.php 就是一个简单的后台php 脚本。当然也可以是一个 java 实现的后台接口。</p></blockquote><h1 id="openresty的缓存-lua-shared-dict"><a href="#openresty的缓存-lua-shared-dict" class="headerlink" title="openresty的缓存 lua_shared_dict"></a>openresty的缓存 lua_shared_dict</h1><p>定义一个缓存：</p><p>在nginx的配置文件 nginx.conf 的 http 端下面加入指令：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">lua_shared_dict ngx_cache <span class="hljs-number">128</span>m<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>就定义了一个 名称为 ngx_cache 大小为128m的内存用于缓存，注意该缓存是所有nginx work process所共享的。</p><p>在lua脚本中访问缓存：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">local</span> ngx_cache = ngx.shared.ngx_cache<br><span class="hljs-built_in">local</span> value = ngx_cache:<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>)<br><br><span class="hljs-built_in">local</span> succ, err, forcible = ngx_cache:set(<span class="hljs-built_in">key</span>, value, exptime)<br></code></pre></td></tr></table></figure><p>下面测试一下，首先在 nginx.conf的server端中加入：</p><div class="code-wrapper"><pre><code class="hljs">location /cache &#123;    content_by_lua_file lua/cache.lua;&#125;</code></pre></div><p>然后编写 cache.lua 脚本：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[root@localhost lua]# cat cache.lua<br><span class="hljs-keyword">local</span> redis = require &quot;resty.redis&quot;<br><span class="hljs-keyword">local</span> red = redis:<span class="hljs-built_in">new</span>()<br><br><span class="hljs-keyword">function</span> set_to_cache(key, <span class="hljs-keyword">value</span>, exptime)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exptime <span class="hljs-keyword">then</span><br>                exptime = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">local</span> ngx_cache = ngx.shared.ngx_cache<br>        <span class="hljs-keyword">local</span> succ, err, forcible = ngx_cache:<span class="hljs-keyword">set</span>(key, <span class="hljs-keyword">value</span>, exptime)<br>        <span class="hljs-keyword">return</span> succ<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> get_from_cache(key)<br>        <span class="hljs-keyword">local</span> ngx_cache = ngx.shared.ngx_cache;<br>        <span class="hljs-keyword">local</span> <span class="hljs-keyword">value</span> = ngx_cache:<span class="hljs-keyword">get</span>(key)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">value</span> = get_from_redis(key)<br>                set_to_cache(key, <span class="hljs-keyword">value</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span><br>        <span class="hljs-keyword">end</span><br><br>        ngx.say(&quot;get from cache.&quot;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> get_from_redis(key)<br>        red:set_timeout(<span class="hljs-number">1000</span>)<br><br>        <span class="hljs-keyword">local</span> ok, err = red:<span class="hljs-keyword">connect</span>(&quot;127.0.0.1&quot;, <span class="hljs-number">6379</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                ngx.say(&quot;failed to connect: &quot;, err)<br>                <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">local</span> res, err = red:<span class="hljs-keyword">get</span>(key)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res <span class="hljs-keyword">then</span><br>                ngx.say(&quot;failed to get doy: &quot;, err)<br>                <span class="hljs-keyword">return</span> ngx.<span class="hljs-keyword">null</span><br>        <span class="hljs-keyword">end</span><br><br>        ngx.say(&quot;get from redis.&quot;)<br>        <span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> set_to_redis(key, <span class="hljs-keyword">value</span>)<br>        red:set_timeout(<span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">local</span> ok, err = red:<span class="hljs-keyword">connect</span>(&quot;127.0.0.1&quot;, <span class="hljs-number">6379</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                ngx.say(&quot;failed to connect: &quot;, err)<br>                <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">local</span> ok, err = red:<span class="hljs-keyword">set</span>(key, <span class="hljs-keyword">value</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                ngx.say(&quot;failed to set to redis: &quot;, err)<br>                <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">return</span> ok<br><span class="hljs-keyword">end</span><br><br>set_to_redis(<span class="hljs-string">&#x27;dog&#x27;</span>, &quot;Bob&quot;)<br><span class="hljs-keyword">local</span> rs = get_from_cache(<span class="hljs-string">&#x27;dog&#x27;</span>)<br>ngx.say(rs)<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># curl localhost/cache</span><br><span class="hljs-keyword">get</span> <span class="hljs-keyword">from</span> redis.<br>Bob<br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># curl localhost/cache</span><br><span class="hljs-keyword">get</span> <span class="hljs-keyword">from</span> cache.<br>Bob<br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># curl localhost/cache</span><br><span class="hljs-keyword">get</span> <span class="hljs-keyword">from</span> cache.<br>Bob<br></code></pre></td></tr></table></figure><p>第一次从 redis中获取，以后每次都从cache中获取。</p><p>可以使用 ab 测试一下rps(Requests per second):</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ab</span> -n <span class="hljs-number">1000</span> -c <span class="hljs-number">100</span> -k http://<span class="hljs-number">127.0.0.1</span>/cache<br></code></pre></td></tr></table></figure><h1 id="解决缓存失效风暴-lua-resty-lock"><a href="#解决缓存失效风暴-lua-resty-lock" class="headerlink" title="解决缓存失效风暴 lua-resty-lock"></a>解决缓存失效风暴 lua-resty-lock</h1><p>缓存失效风暴是指缓存因为时间过期而失效时，会导致所有的请求都去访问 后台的redis或者mysql，而导致CPU性能即刻增长的现象。所以关键是当缓存失效时，用lock保证只有一个线程去访问后台的redis或者mysql，然后更新缓存。需要使用到 lua-resty-lock 模块的加锁、解锁功能。</p><p>lua-resty-lock 文档：<a href="https://github.com/openresty/lua-resty-lock">https://github.com/openresty/lua-resty-lock</a></p><p>首先在nginx.conf 的 http 端下面加入指令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">lua_shared_dict</span> ngx_cache <span class="hljs-number">128m</span>;     <span class="hljs-comment"># cache</span><br><span class="hljs-attribute">lua_shared_dict</span> cache_lock <span class="hljs-number">100k</span>;    <span class="hljs-comment"># lock for cache</span><br></code></pre></td></tr></table></figure><p>然后在nginx.conf的server端中加入：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/cache_lock</span> &#123;<br>    content_by_lua_file lua/cache_lock.lua;<br>&#125;<br></code></pre></td></tr></table></figure><p>cache_lock.lua代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[root@localhost lua]# cat cache_lock.lua<br><span class="hljs-keyword">local</span> redis = require &quot;resty.redis&quot;<br><span class="hljs-keyword">local</span> red = redis:<span class="hljs-built_in">new</span>()<br><span class="hljs-keyword">local</span> resty_lock = require &quot;resty.lock&quot;<br><span class="hljs-keyword">local</span> ngx_cache = ngx.shared.ngx_cache<br><br><span class="hljs-keyword">function</span> set_to_cache(key, <span class="hljs-keyword">value</span>, exptime)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> exptime <span class="hljs-keyword">then</span><br>                exptime = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">local</span> succ, err, forcible = ngx_cache:<span class="hljs-keyword">set</span>(key, <span class="hljs-keyword">value</span>, exptime)<br>        <span class="hljs-keyword">return</span> succ<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> get_from_cache(key)<br>        <span class="hljs-keyword">local</span> ngx_cache = ngx.shared.ngx_cache;<br>        <span class="hljs-keyword">local</span> <span class="hljs-keyword">value</span> = ngx_cache:<span class="hljs-keyword">get</span>(key)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">then</span>       <span class="hljs-comment">-- cache miss</span><br>                <span class="hljs-keyword">local</span> <span class="hljs-keyword">lock</span> = resty_lock:<span class="hljs-built_in">new</span>(&quot;cache_lock&quot;)<br>                <span class="hljs-keyword">local</span> elapsed, err = <span class="hljs-keyword">lock</span>:<span class="hljs-keyword">lock</span>(key)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> elapsed <span class="hljs-keyword">then</span><br>                        <span class="hljs-keyword">return</span> fail(&quot;failed to acquire the lock: &quot;, err)<br>                <span class="hljs-keyword">end</span><br><br>                <span class="hljs-keyword">value</span> = get_from_redis(key)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">then</span><br>                        <span class="hljs-keyword">local</span> ok, err = <span class="hljs-keyword">lock</span>:unlock()<br>                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                                <span class="hljs-keyword">return</span> fail(&quot;failed to unlock: &quot;, err)<br>                        <span class="hljs-keyword">end</span><br>                        ngx.say(&quot;no value found&quot;)<br>                        <span class="hljs-keyword">return</span><br>                <span class="hljs-keyword">end</span><br><br>                <span class="hljs-keyword">local</span> ok, err = ngx_cache:<span class="hljs-keyword">set</span>(key, <span class="hljs-keyword">value</span>, <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                        <span class="hljs-keyword">local</span> ok, err = <span class="hljs-keyword">lock</span>:unlock()<br>                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                                <span class="hljs-keyword">return</span> fail(&quot;failed to unlock: &quot;, err)<br>                        <span class="hljs-keyword">end</span><br>                        <span class="hljs-keyword">return</span> faile(&quot;failed to update ngx_cache: &quot;, err)<br>                <span class="hljs-keyword">end</span><br><br>                <span class="hljs-keyword">local</span> ok, err = <span class="hljs-keyword">lock</span>:unlock()<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                        <span class="hljs-keyword">return</span> faile(&quot;failed to unlock: &quot;, err)<br>                <span class="hljs-keyword">end</span><br><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span><br>        <span class="hljs-keyword">end</span><br><br>        ngx.say(&quot;get from cache.&quot;)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> get_from_redis(key)<br>        red:set_timeout(<span class="hljs-number">1000</span>)<br><br>        <span class="hljs-keyword">local</span> ok, err = red:<span class="hljs-keyword">connect</span>(&quot;127.0.0.1&quot;, <span class="hljs-number">6379</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                ngx.say(&quot;failed to connect: &quot;, err)<br>                <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">local</span> res, err = red:<span class="hljs-keyword">get</span>(key)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res <span class="hljs-keyword">then</span><br>                ngx.say(&quot;failed to get doy: &quot;, err)<br>                <span class="hljs-keyword">return</span> ngx.<span class="hljs-keyword">null</span><br>        <span class="hljs-keyword">end</span><br><br>        ngx.say(&quot;get from redis.&quot;)<br>        <span class="hljs-keyword">return</span> res<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">function</span> set_to_redis(key, <span class="hljs-keyword">value</span>)<br>        red:set_timeout(<span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">local</span> ok, err = red:<span class="hljs-keyword">connect</span>(&quot;127.0.0.1&quot;, <span class="hljs-number">6379</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                ngx.say(&quot;failed to connect: &quot;, err)<br>                <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">local</span> ok, err = red:<span class="hljs-keyword">set</span>(key, <span class="hljs-keyword">value</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>                ngx.say(&quot;failed to set to redis: &quot;, err)<br>                <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">return</span> ok<br><span class="hljs-keyword">end</span><br><br>set_to_redis(<span class="hljs-string">&#x27;dog&#x27;</span>, &quot;Bob&quot;)<br><span class="hljs-keyword">local</span> rs = get_from_cache(<span class="hljs-string">&#x27;dog&#x27;</span>)<br>ngx.say(rs)<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost lua</span>]<span class="hljs-meta"># curl localhost/cache_lock</span><br><span class="hljs-keyword">get</span> <span class="hljs-keyword">from</span> cache.<br>Bob<br>[<span class="hljs-meta">root@localhost lua</span>]<span class="hljs-meta"># curl localhost/cache_lock</span><br><span class="hljs-keyword">get</span> <span class="hljs-keyword">from</span> cache.<br>Bob<br></code></pre></td></tr></table></figure><h1 id="openresty-执行阶段"><a href="#openresty-执行阶段" class="headerlink" title="openresty 执行阶段"></a>openresty 执行阶段</h1><p>nginx的执行阶段分成了很多个阶段,所以第三方模块就可以在某个适当的阶段加入一些处理。openresty进行了简化成了7个阶段：</p><p>7个阶段的执行顺序如下：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">set<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua: 流程分支判断，判断变量初始哈<br><br>rewrite<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua: 用lua脚本实现nginx rewrite<br><br>access<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua: ip准入，是否能合法性访问，防火墙<br><br>content<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua: 内存生成<br><br>header<span class="hljs-number">_f</span>ilter<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua：过滤http头信息，增加头信息<br><br>body<span class="hljs-number">_f</span>ilter<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua: 内容大小写，内容加密<br><br>log<span class="hljs-number">_</span><span class="hljs-meta">by</span><span class="hljs-number">_</span>lua: 本地/远程记录日志<br></code></pre></td></tr></table></figure><p>但是其实我们可以只用 content_by_lua，所有功能都在该阶段完成，也是可以的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/digdeep/p/4859575.html">https://www.cnblogs.com/digdeep/p/4859575.html</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>nginx</tag>
      
      <tag>lua</tag>
      
      <tag>openresty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>systemd配置文件及管理方法</title>
    <link href="/2022/04/01/04DevOps/16systemd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <url>/2022/04/01/04DevOps/16systemd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%8A%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="systemd-配置路径"><a href="#systemd-配置路径" class="headerlink" title="systemd 配置路径"></a>systemd 配置路径</h1><p>systemd 配置文件存在于以下三个文件夹中：          </p><ul><li>/etc/systemd/system  存放系统启动的默认级别及启动的unit的软连接，优先级最高。</li><li>/run/systemd/system 系统执行过程中产生的服务脚本，优先级次之。</li><li>/usr/lib/systemd/system 存放系统上所有的启动文件。优先级最低</li></ul><h1 id="systemd文件分类"><a href="#systemd文件分类" class="headerlink" title=" systemd文件分类"></a><span id="unit"> systemd文件分类</span></h1><p>systemd的定义文件可以根据其后缀名称识别其定义的类型，可以使用systemctl -t help 查看。</p><table><thead><tr><th>文件后缀名</th><th align="center">说明</th></tr></thead><tbody><tr><td>.service</td><td align="center">定义了系统服务的启动</td></tr><tr><td>.target</td><td align="center">定义了系统启动的级别标签，systemd 没有运行级别的概念，创建标签只是为了兼容老版本。</td></tr><tr><td>.socket</td><td align="center">定义了进程通信用到的套接字，套接字与进程是分离的</td></tr><tr><td>.device</td><td align="center">定义了系统启动时内核识别的文件，systemd提供了设备的管理功能，/dev 下的设备由/etc/udev/下的配置文件与.device共同定制</td></tr><tr><td>.mount</td><td align="center">定义了系统的文件系统的挂载点</td></tr><tr><td>.snapshop</td><td align="center">系统快照</td></tr><tr><td>.swap</td><td align="center">用于标识swap设备</td></tr><tr><td>.automount</td><td align="center">文件系统的自动挂载点</td></tr><tr><td>.path</td><td align="center">用于定义文件系统中的一个文件或目录使用。常用于文件系统发生变化时，延迟激活服务。</td></tr><tr><td>.busname</td><td align="center"></td></tr><tr><td>.snapshot</td><td align="center"></td></tr><tr><td>.timer</td><td align="center"></td></tr><tr><td>.slice</td><td align="center"></td></tr><tr><td>.scope</td><td align="center"></td></tr></tbody></table><h1 id="systemd-文件内容格式"><a href="#systemd-文件内容格式" class="headerlink" title="systemd 文件内容格式"></a>systemd 文件内容格式</h1><p>通常由3段组成：分别是unit段，类型段，install段</p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># Unit段</span><br>[<span class="hljs-meta">Unit</span>]<br>xxx=<br><br><span class="hljs-meta"># 类型段</span><br>[<span class="hljs-meta">类型</span>] 如Service、Path等，和unit分类中的后缀名对应<br><br><span class="hljs-meta"># Install 段</span><br>[<span class="hljs-meta">Install</span>]<br></code></pre></td></tr></table></figure><h2 id="Unit-段"><a href="#Unit-段" class="headerlink" title="Unit 段"></a>Unit 段</h2><p>[Unit] :不属于第二个标签的定义都放在这里，或存放不属于unit类型的定义，描述信息，依赖的unit</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Description</td><td>描述信息</td></tr><tr><td>After</td><td>表明需要依赖的服务，作用决定启动顺序</td></tr><tr><td>Before</td><td>表明被依赖的服务</td></tr><tr><td>Requles</td><td>依赖到的其他unit ，强依赖，即依赖的unit启动失败。该unit不启动。</td></tr><tr><td>Wants</td><td>依赖到的其他unit，弱依赖，即依赖的unit 启动失败。该unit继续启动</td></tr><tr><td>Conflicts</td><td>定义冲突关系</td></tr></tbody></table><h2 id="类型-段："><a href="#类型-段：" class="headerlink" title="[类型] 段："></a>[类型] 段：</h2><p>类型段根据<a href="#unit">systemd文件分类</a>中定义的服务类型来确定具体的关键字，如.service文件则此段为[Service], .timer文件此段为[Timer] 等</p><h3 id="Service段-关键字说明如下"><a href="#Service段-关键字说明如下" class="headerlink" title="Service段 关键字说明如下"></a>Service段 关键字说明如下</h3><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Type</td><td>启动时关系的定义</td></tr><tr><td>RemainAfterExit</td><td>可设为”yes”或”no”(默认值)，表示当该服务的所有进程全部退出之后，是否依然将此服务视为活动(active)状态</td></tr><tr><td>PIDFile</td><td>守护进程的PID文件，必须是绝对路径。强烈建议在 Type=forking 的情况下明确设置此选项。 systemd 将会在此服务启动后从此文件中读取主守护进程的PID 。systemd 不会写入此文件，但会在此服务停止后删除它(若存在)。</td></tr><tr><td>GuessMainPID</td><td>可设为”yes”(默认值)或”no”，表示在无法明确定位该服务的主进程的情况下，systemd 是否应该猜测主进程的PID(可能不正确)。 该选项仅在设置了 Type=forking 但未设置 PIDFile= 的情况下有意义。如果PID猜测错误，那么该服务的失败检测与自动重启功能将失效。</td></tr><tr><td>EnvironmentFile</td><td>需要使用到的变量的定义文件</td></tr><tr><td>ExecStart</td><td>在启动该服务时需要执行的命令行(命令+参数)。有关命令行的更多细节可参见后文的”命令行”小节。 仅在设置了 Type=oneshot 的情况下，才可以设置任意个命令行(包括零个)，否则必须且只能设置一个命令行。 多个命令行既可以在同一个 ExecStart= 中设置，也可以通过设置多个 ExecStart= 来达到相同的效果。 如果设为一个空字符串，那么先前设置的所有命令行都将被清空。 如果不设置任何 ExecStart= 指令，那么必须确保设置了 RemainAfterExit=yes 指令。 命令行必须以一个绝对路径表示的可执行文件开始，并且其后的那些参数将依次作为”argv[1] argv[2] …”传递给被执行的进程。 如果在绝对路径前加上可选的”@”前缀，那么其后的那些参数将依次作为”argv[0] argv[1] argv[2] …”传递给被执行的进程。 如果在绝对路径前加上可选的”-“前缀，那么即使该进程以失败状态(例如非零的返回值或者出现异常)退出，也会被视为成功退出。 可以同时使用”-“与”@”前缀，且顺序任意。 如果设置了多个命令行，那么这些命令行将以其在单元文件中出现的顺序依次执行。 如果某个无”-“前缀的命令行执行失败，那么剩余的命令行将不会被执行，同时该单元将变为失败(failed)状态。 当未设置 Type=forking 时，这里设置的命令行所启动的进程将被视为该服务的主守护进程。</td></tr><tr><td>ExecReload</td><td>这是一个可选的指令，用于设置当该服务被要求重新载入配置时所执行的命令行。语法规则与 ExecStart= 完全相同。 另外，还有一个特殊的环境变量 $MAINPID 可以用于表示主进程的PID，例如可以这样使用： /bin/kill -HUP $MAINPID 注意，像上例那样，通过向守护进程发送复位信号，强制其重新加载配置文件，并不是一个好习惯。 因为这是一个异步操作，所以不适用于需要按照特定顺序重新加载配置文件的服务。 我们强烈建议将 ExecReload= 设置为一个能够确保重新加载配置文件的操作同步完成的命令行。</td></tr><tr><td>ExecStop</td><td>这是一个可选的指令，用于设置当该服务被要求停止时所执行的命令行。语法规则与 ExecStart= 完全相同。 执行完此处设置的命令行之后，该服务所有剩余的进程将会根据 KillMode= 的设置被杀死(参见 systemd.kill(5) 手册)。 如果未设置此选项，那么当此服务被停止时，该服务的所有进程都将会根据 KillMode= 的设置被立即全部杀死。 与 ExecReload= 一样，也有一个特殊的环境变量 $MAINPID 可以用于表示主进程的PID 一般来说，仅仅设置一个结束服务的命令，而不等待其完成，是不够的。 因为当此处设置的命令执行完之后，剩余的进程会被 SIGKILL 信号立即杀死，这可能会导致数据丢失。 因此，这里设置的命令必须是同步操作，而不能是异步操作。</td></tr><tr><td>ExecStopPost</td><td>这是一个可选的指令，用于设置该服务停止之后所执行的命令行。语法规则与 ExecStart= 完全相同。 无论此服务是正常停止，还是异常退出，此处的设置都适用。 RestartSec= 设定在重启服务(Restart=)前暂停多长时间。默认值是100毫秒(100ms)。 如果未指定时间单位，那么将视为以秒为单位。例如设为”20”等价于设为”20s”。</td></tr><tr><td>ExecStartPre、ExecStartPost</td><td>设置在执行 ExecStart= 之前/后执行的命令行。语法规则与 ExecStart= 完全相同。 如果设置了多个命令行，那么这些命令行将以其在单元文件中出现的顺序依次执行。 如果某个无”-“前缀的命令行执行失败，那么剩余的命令行将不会被执行，同时该单元将变为失败(failed)状态。 仅在所有无”-“前缀的 ExecStartPre= 命令全部执行成功的前提下，才会继续执行 ExecStart= 命令。 ExecStartPost= 命令仅在服务已经被成功启动之后才会运行，判断的标准基于 Type= 选项。 具体说来，对于 Type=simple 或 Type=idle 就是主进程已经成功启动；对于 Type=oneshot 来说就是主进程已经成功退出； 对于 Type=forking 来说就是初始进程已经成功退出；对于 Type=notify 来说就是已经发送了”READY=1”； 对于 Type=dbus 来说就是已经取得了 BusName= 中设置的总线名称。 注意，不可将 ExecStartPre= 用于需要长时间执行的进程。 因为所有由 ExecStartPre= 派生的子进程都会在启动 ExecStart= 服务进程之前被杀死。</td></tr><tr><td>TimeoutStartSec</td><td>设定该服务允许的最大启动时长。如果守护进程未能在限定的时长内发出”启动完毕”的信号，那么该服务将被视为启动失败，并会被关闭。 如果未指定时间单位，那么将视为以秒为单位。例如设为”20”等价于设为”20s”。设为”0”则表示永不超时。 当 Type=oneshot 时，默认值为”0”，否则默认值等于 DefaultTimeoutStartSec= 的值(参见 systemd-system.conf(5) 手册)。</td></tr><tr><td>TimeoutStopSec</td><td>设定该服务允许的最大停止时长。如果该服务未能在限定的时长内成功停止，那么将会被强制使用 SIGTERM 信号关闭， 如果依然未能在相同的时长内成功停止，那么将会被强制使用 SIGKILL 信号关闭(参见 systemd.kill(5) 手册中的 KillMode= 选项)。 如果未指定时间单位，那么将视为以秒为单位。例如设为”20”等价于设为”20s”。设为”0”则表示永不超时。 默认值等于 DefaultTimeoutStartSec= 的值(参见 systemd-system.conf(5) 手册)。</td></tr><tr><td>TimeoutSec</td><td>一个同时设置 TimeoutStartSec= 与 TimeoutStopSec= 的快捷方式。</td></tr><tr><td>Restart</td><td>当服务进程正常退出、异常退出、被杀死、超时的时候，是否重新启动该服务。 “服务进程”是指 ExecStart=, ExecStartPre=, ExecStartPost=, ExecStop=, ExecStopPost=, ExecReload= 中设置的进程。 当进程是由于 systemd 的正常操作(例如 systemctl stop restart)而被停止时，该服务不会被重新启动。 “超时”可以是看门狗的”keep-alive ping”超时，也可以是 systemct  start /reload/stop 操作超时。<br>该选项可以取下列值之一：no, on-success, on-failure, on-abnormal, on-watchdog, on-abort, always “no”(默认值)表示不会被重启。”always”表示会被无条件的重启。 “on-success”表示仅在服务进程正常退出时重启，所谓”正常退出”是指： 退出码为”0”，或者进程收到 SIGHUP, SIGINT, SIGTERM, SIGPIPE 信号并且退出码符合 SuccessExitStatus= 的设置。 “on-failure”表示仅在服务进程异常退出时重启，所谓”异常退出”是指： 退出码不为”0”，或者进程被强制杀死(包括”core dump”以及收到 SIGHUP, SIGINT, SIGTERM, SIGPIPE 之外的其他信号)， 或者进程由于看门狗或者 systemd 的操作超时而被杀死。 对于 on-failure, on-abnormal, on-abort, on-watchdog 的分别适用于哪种异常退出，见下表：<br>注意如下两个例外情况： (1) RestartPreventExitStatus= 中列出的退出码或者信号永远不会导致该服务被重启。 (2) RestartForceExitStatus= 中列出的退出码或者信号将会无条件的导致该服务被重启。 对于需要长期持续运行的守护进程，推荐设为”on-failure”以增强可用性。 对于自身可以自主选择何时退出的服务，推荐设为”on-abnormal”。</td></tr><tr><td>RestartSec</td><td></td></tr><tr><td>BusName</td><td>设置与此服务通信所使用的 D-Bus 名称。在 Type=dbus 的情况下必须明确设置此选项。</td></tr><tr><td>BusPolicy</td><td>如果设置了此项，那么 systemd 将会创建一个自定义的kdbus端点(endpoint)，并将其安装为该服务默认的总线节点(bus node)。 这个自定义的端点可以拥有它自己的策略规则。端点的名称就是其所服务的单元的名称。 端点的节点(node)将被绑定挂载到默认的总线节点的位置，这样该服务就只能通过它自己的端点访问总线。 注意，自定义端点的默认策略是’拒绝所有’，因此，你必须在 BusPolicy= 中明确的添加必要的允许策略。 这个选项的值由两部分组成：总线名+访问级别，中间以空格分隔。 访问级别必须是 see, talk, own 之一，并且 talk 隐含了 see ，而 own 隐含了 talk 与 see 。 如果对同一个总线名称多次指定了访问级别，那么将以拥有最大权限的那个为准。 例如： BusPolicy=org.freedesktop.systemd1 talk BusPolicy=org.foo.bar see 该选项仅在内核开启了kdbus(即将并入官方内核)支持的情况下有意义。</td></tr></tbody></table><p>Restart设置及对应的退出原因</p><table><thead><tr><th>Restart</th><th>no</th><th>always</th><th>on-success</th><th>on-failure</th><th>on-abnormal</th><th>on-abort</th><th>on-watchdog</th></tr></thead><tbody><tr><td>正常退出</td><td></td><td>×</td><td>×</td><td></td><td></td><td></td><td></td></tr><tr><td>退出码不为0</td><td></td><td>×</td><td></td><td>×</td><td></td><td></td><td></td></tr><tr><td>进程被强制杀死</td><td></td><td>×</td><td></td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>systemd操作超时</td><td></td><td>×</td><td></td><td>×</td><td>×</td><td></td><td></td></tr><tr><td>看门狗超时</td><td></td><td>×</td><td></td><td>×</td><td>×</td><td></td><td>×</td></tr></tbody></table><h4 id="Type-关键字说明"><a href="#Type-关键字说明" class="headerlink" title="Type 关键字说明"></a>Type 关键字说明</h4><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>simple</td><td>表示 ExecStart= 所设定的进程就是该服务的主进程。 如果此进程需要为其他进程提供服务，那么必须在该进程启动之前先建立好通信渠道(例如套接字)，以加快后继单元的启动速度</td></tr><tr><td>forking</td><td>如果设为”forking”，那么表示 ExecStart= 所设定的进程将会在启动过程中使用 fork() 系统调用。这是传统UNIX守护进程的经典做法。 也就是当所有的通信渠道都已建好、启动亦已成功之后，父进程将会退出，而子进程将作为该服务的主进程继续运行。 对于此种进程，建议同时设置 PIDFile= 选项，以帮助 systemd 准确定位该服务的主进程，进而加快后继单元的启动速度。</td></tr><tr><td>ontshot</td><td>“oneshot”(未设置 ExecStart= 时的默认值)与”simple”类似，不同之处在于该进程必须在 systemd 启动后继单元之前退出。 此种类型通常需要设置 RemainAfterExit= 选项</td></tr><tr><td>dbus</td><td>“dbus”(设置了 ExecStart= 与 BusName= 时的默认值)与”simple”类似，不同之处在于该进程需要在 D-Bus 上获得一个由 BusName= 指定的名称。 systemd 将会在启动后继单元之前，首先确保该进程已经成功的获取了指定的 D-Bus 名称。设置为此类型相当于隐含的依赖于 dbus.socket 单元</td></tr><tr><td>notify</td><td>“notify”与”simple”类似，不同之处在于该进程将会在启动完成之后通过 sd_notify(3) 之类的接口发送一个通知消息。 systemd 将会在启动后继单元之前，首先确保该进程已经成功的发送了这个消息。 如果设置为此类型，那么 NotifyAccess= 将只能设置为”all”或者”main”(默认)。 注意，目前 Type=notify 尚不能在 PrivateNetwork=yes 的情况下正常工作。</td></tr><tr><td>ldle</td><td>“idle”与”simple”类似，不同之处在于该进程将会被延迟到所有的操作都完成之后再执行。 这样可以避免控制台上的状态信息与 shell 脚本的输出混杂在一起。</td></tr></tbody></table><h3 id="Timer-段关键字说明如下"><a href="#Timer-段关键字说明如下" class="headerlink" title="Timer 段关键字说明如下"></a>Timer 段关键字说明如下</h3><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>aa</td><td>aa</td></tr></tbody></table><h3 id="Mount-段关键字说明如下"><a href="#Mount-段关键字说明如下" class="headerlink" title="Mount 段关键字说明如下"></a>Mount 段关键字说明如下</h3><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>aa</td><td>aa</td></tr></tbody></table><h2 id="Install-段："><a href="#Install-段：" class="headerlink" title="[Install] 段："></a>[Install] 段：</h2><p>服务启动或禁用时的一些选项，有以下配置选项</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Alias</td><td></td></tr><tr><td>RequlredBy</td><td>被那些unit所依赖，</td></tr><tr><td>WanteBy</td><td>被那些unit所依赖</td></tr></tbody></table><blockquote><p>注意：修改了的unit文件 需要重载。systemctl daemon-reload</p></blockquote><h1 id="管理工具systemctl"><a href="#管理工具systemctl" class="headerlink" title="管理工具systemctl"></a>管理工具systemctl</h1><p>centos7 的程序管理基本上都是由工具systemctl完成，systemctl的控制命令是固定不变的。systemd 兼容init文件夹下的启动脚本。</p><p>systemctl的管理服务通过的service的unit文件实现的。</p><p>.service 的配置文件对应的服务提供一下服务命令</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>systemctl start name.service</td><td>启动服务：</td></tr><tr><td>systemctl stop name.service</td><td>停止服务</td></tr><tr><td>systemctl restart name.service</td><td>重启服务</td></tr><tr><td>systemctl status name.service</td><td>查看状态</td></tr><tr><td>ystemctl try-restart name.service</td><td>条件式重启，即服务之前是启动的则进行重启，如果服务没有启动则不进行操作</td></tr><tr><td>systemctl reload-or-restart name.service</td><td>重载或重启，首先进行重载，如果重载不成功则进行重启</td></tr><tr><td>systemctl reload-or-try-restart name.service</td><td>重载或条件式重启:</td></tr><tr><td>systemctl unmask name.service</td><td>设置服务可以被用户设置开机启动状态</td></tr><tr><td>systemctl mask name.service</td><td>禁止服务可以被用户设置开机启动状态</td></tr><tr><td>systemctl is-active name.service</td><td>查看服务的当前激活状态<br>0 服务已经启动 <br> 非0 命令未启动</td></tr><tr><td>systemctl disable 服务名称unit</td><td>设置服务开机不启动</td></tr><tr><td>systemctl is-enabled name.service</td><td>查看服务是否开机自启</td></tr><tr><td>systemctl list-dependencies name.service</td><td>察看服务的依赖关系</td></tr><tr><td>systemctl list-depebdencies</td><td>察看服务的依赖关系</td></tr><tr><td>systemctl daemon-reload</td><td>重载服务：</td></tr><tr><td>systemctl kill 进程名</td><td>杀掉进程：</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.51cto.com/arm2012/1963238">https://blog.51cto.com/arm2012/1963238</a></li><li><a href="https://man7.org/linux/man-pages/man5/systemd.service.5.html">https://man7.org/linux/man-pages/man5/systemd.service.5.html</a></li><li><a href="https://man7.org/linux/man-pages/man1/systemd.1.html">https://man7.org/linux/man-pages/man1/systemd.1.html</a></li><li><a href="https://blog.csdn.net/yuesichiu/article/details/51485147">https://blog.csdn.net/yuesichiu/article/details/51485147</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yacc与lex</title>
    <link href="/2022/03/16/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/%E5%BE%85%E5%AE%8C%E5%96%84/yacc%E4%B8%8Elex/"/>
    <url>/2022/03/16/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/%E5%BE%85%E5%AE%8C%E5%96%84/yacc%E4%B8%8Elex/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://zhuanlan.zhihu.com/p/<span class="hljs-number">143867739</span><br><span class="hljs-attribute">https</span>://blog.csdn.net/fly_yr/article/details/<span class="hljs-number">43019601</span>?utm_medium=distribute.pc_relevant.none-task-blog-<span class="hljs-number">2</span>~default~baidujs_title~default-<span class="hljs-number">4</span>.pc_relevant_paycolumn_v<span class="hljs-number">3</span>&amp;spm=<span class="hljs-number">1001</span>.<span class="hljs-number">2101</span>.<span class="hljs-number">3001</span>.<span class="hljs-number">4242</span>.<span class="hljs-number">3</span>&amp;utm_relevant_index=<span class="hljs-number">7</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制coredump</title>
    <link href="/2022/03/11/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/%E5%BE%85%E5%AE%8C%E5%96%84/13%E6%8E%A7%E5%88%B6coredump/"/>
    <url>/2022/03/11/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/%E5%BE%85%E5%AE%8C%E5%96%84/13%E6%8E%A7%E5%88%B6coredump/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//m</span>log.club<span class="hljs-regexp">/article/</span><span class="hljs-number">230241</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rpm 常用命令及问题处理</title>
    <link href="/2022/02/11/04DevOps/15rpm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
    <url>/2022/02/11/04DevOps/15rpm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>rpm –qf 的命令全称是 <code>rpm --queryformat</code> ,格式为<code>rpm --queryformat [QUERYFMT]</code> , 其中QUERYFMT是一系列rpm查询标志，可以通过<code>rpm --querytags</code>命令查询有哪些标志可以使用.</li><li>rpm -qa 的默认格式为<code> rpm -qa --qf &#39;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;\n&#39;</code> 不带版本信息，可以使用<code>rpm -qa --qf &#39;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.%&#123;arch&#125;\n&#39;</code> 输出带版本信息的数据格式<br>// 查询包xxx.rpm依赖哪些rpm包的相信信息</li><li>rpm -qpR xxx.rpm<br>// 查询openssl-libs被哪些库依赖</li><li>rpm -e –test  openssl-libs  </li></ul><h1 id="问题及解决方法"><a href="#问题及解决方法" class="headerlink" title="问题及解决方法"></a>问题及解决方法</h1><h2 id="rpm包安装是报unpacking-of-archive-failed-cpio-lstat-错误"><a href="#rpm包安装是报unpacking-of-archive-failed-cpio-lstat-错误" class="headerlink" title="rpm包安装是报unpacking of archive failed: cpio: lstat 错误"></a>rpm包安装是报unpacking of archive failed: cpio: lstat 错误</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">第一步：使用以下命令查看rpm包需要的目录<br> rpm2cpio <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XXXX</span>.</span></span>rpm <span class="hljs-pattern-match">| cpio -idmv</span><br><span class="hljs-pattern-match">第二步：去查看对应的目录，你会发现真的存在，而且不是目录</span><br><span class="hljs-pattern-match">第三步：删掉这个目录，重新安装成功！！！！</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>定位进程被kill或创建的父进程</title>
    <link href="/2022/01/27/04DevOps/14%E5%AE%9A%E4%BD%8D%E8%BF%9B%E7%A8%8B%E8%A2%ABkill%E6%88%96%E5%88%9B%E5%BB%BA%E7%9A%84%E7%88%B6%E8%BF%9B%E7%A8%8B/"/>
    <url>/2022/01/27/04DevOps/14%E5%AE%9A%E4%BD%8D%E8%BF%9B%E7%A8%8B%E8%A2%ABkill%E6%88%96%E5%88%9B%E5%BB%BA%E7%9A%84%E7%88%B6%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>有时进程会被其他服务或监控脚本莫名其妙的kill，为了找到真正发出kill或pkill信号的进程，我们可以使用linux下的<code>audit</code>工具来捕获发出创建或kill进程的父进程信息。</p><p>审核系统(audit)包含两个主要部分：用户空间的应用程序、实用程序，以及 kernel-side 系统调用处理。Kernel 的组件从用户空间的应用程序接受系统调用，并且通过三个过滤器中的一个过滤器来进行筛选： <em>user</em>、<em>task</em> 或者 <em>exit</em>。一旦系统调用通过其中的一个过滤器，就将通过 <em>exclude</em> 过滤器进行传送，这是基于审核规则的配置，并把它传送给审核的守护程序做进一步的处理。架构图如下:</p><img src="/2022/01/27/04DevOps/14%E5%AE%9A%E4%BD%8D%E8%BF%9B%E7%A8%8B%E8%A2%ABkill%E6%88%96%E5%88%9B%E5%BB%BA%E7%9A%84%E7%88%B6%E8%BF%9B%E7%A8%8B/architecture.png" class=""><p><em>注意：审核所收集的信息量可能影响系统性能， 一般信息收集完毕后需清理规则并停止审核服务</em></p><h1 id="audit-安装部署"><a href="#audit-安装部署" class="headerlink" title="audit 安装部署"></a>audit 安装部署</h1><figure class="highlight vala"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 安装audit</span><br>yum install -y audit<br><span class="hljs-meta"># 启动audit</span><br>service auditd start<br><span class="hljs-meta"># 停止</span><br>service auditd stop<br></code></pre></td></tr></table></figure><h1 id="audit-常用命令"><a href="#audit-常用命令" class="headerlink" title="audit 常用命令"></a>audit 常用命令</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 列出当前设置的规则</span><br>auditctl -l<br><span class="hljs-comment"># 清理已经设置的规则</span><br>auditctl -D<br><span class="hljs-comment"># 添加一条规则，捕获发出kill或pkill命令或创建进程的进程信息, </span><br>auditctl -a <span class="hljs-keyword">exit</span>,always -S kill,execve<br><br></code></pre></td></tr></table></figure><h1 id="audit-日志分析示例"><a href="#audit-日志分析示例" class="headerlink" title="audit 日志分析示例"></a>audit 日志分析示例</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros">**************************<br><span class="hljs-attribute">type</span>=SYSCALL <span class="hljs-attribute">msg</span>=audit(1643192492.720:23218): <span class="hljs-attribute">arch</span>=c000003e <span class="hljs-attribute">syscall</span>=59 <span class="hljs-attribute">success</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">exit</span>=0 <span class="hljs-attribute">a0</span>=2347970 <span class="hljs-attribute">a1</span>=2346ce0 <span class="hljs-attribute">a2</span>=23467b0 <span class="hljs-attribute">a3</span>=7ffdda2a3780 <span class="hljs-attribute">items</span>=3 <span class="hljs-attribute">ppid</span>=29639 <span class="hljs-attribute">pid</span>=5554 <span class="hljs-attribute">auid</span>=4294967295 <span class="hljs-attribute">uid</span>=0 <span class="hljs-attribute">gid</span>=0 <span class="hljs-attribute">euid</span>=0 <span class="hljs-attribute">suid</span>=0 <span class="hljs-attribute">fsuid</span>=0 <span class="hljs-attribute">egid</span>=0 <span class="hljs-attribute">sgid</span>=0 <span class="hljs-attribute">fsgid</span>=0 tty=(none) <span class="hljs-attribute">ses</span>=4294967295 <span class="hljs-attribute">comm</span>=<span class="hljs-string">&quot;600_cdn_mmoonni&quot;</span> <span class="hljs-attribute">exe</span>=<span class="hljs-string">&quot;/usr/bin/bash&quot;</span> key=(<span class="hljs-literal">null</span>)<br>****************************<br><span class="hljs-attribute">type</span>=SYSCALL <span class="hljs-attribute">msg</span>=audit(1643192492.751:23269): <span class="hljs-attribute">arch</span>=c000003e <span class="hljs-attribute">syscall</span>=59 <span class="hljs-attribute">success</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">exit</span>=0 <span class="hljs-attribute">a0</span>=883430 <span class="hljs-attribute">a1</span>=87be20 <span class="hljs-attribute">a2</span>=883650 <span class="hljs-attribute">a3</span>=7ffd21c2f330 <span class="hljs-attribute">items</span>=2 <span class="hljs-attribute">ppid</span>=5554 <span class="hljs-attribute">pid</span>=5606 <span class="hljs-attribute">auid</span>=4294967295 <span class="hljs-attribute">uid</span>=0 <span class="hljs-attribute">gid</span>=0 <span class="hljs-attribute">euid</span>=0 <span class="hljs-attribute">suid</span>=0 <span class="hljs-attribute">fsuid</span>=0 <span class="hljs-attribute">egid</span>=0 <span class="hljs-attribute">sgid</span>=0 <span class="hljs-attribute">fsgid</span>=0 tty=(none) <span class="hljs-attribute">ses</span>=4294967295 <span class="hljs-attribute">comm</span>=<span class="hljs-string">&quot;pkill&quot;</span> <span class="hljs-attribute">exe</span>=<span class="hljs-string">&quot;/usr/bin/pkill&quot;</span> key=(<span class="hljs-literal">null</span>)<br><span class="hljs-attribute">type</span>=EXECVE <span class="hljs-attribute">msg</span>=audit(1643192492.751:23269): <span class="hljs-attribute">argc</span>=2 <span class="hljs-attribute">a0</span>=<span class="hljs-string">&quot;pkill&quot;</span> <span class="hljs-attribute">a1</span>=<span class="hljs-string">&quot;monit&quot;</span><br>************************<br><span class="hljs-attribute">type</span>=PATH <span class="hljs-attribute">msg</span>=audit(1643192492.752:23274): <span class="hljs-attribute">item</span>=0 <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;/usr/bin/rpm&quot;</span> <span class="hljs-attribute">inode</span>=50391106 <span class="hljs-attribute">dev</span>=08:02 <span class="hljs-attribute">mode</span>=0100755 <span class="hljs-attribute">ouid</span>=0 <span class="hljs-attribute">ogid</span>=0 <span class="hljs-attribute">rdev</span>=00:00 <span class="hljs-attribute">objtype</span>=NORMAL<br><span class="hljs-attribute">type</span>=PATH <span class="hljs-attribute">msg</span>=audit(1643192492.752:23274): <span class="hljs-attribute">item</span>=1 <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;/lib64/ld-linux-x86-64.so.2&quot;</span> <span class="hljs-attribute">inode</span>=20973072 <span class="hljs-attribute">dev</span>=08:02 <span class="hljs-attribute">mode</span>=0100755 <span class="hljs-attribute">ouid</span>=0 <span class="hljs-attribute">ogid</span>=0 <span class="hljs-attribute">rdev</span>=00:00 <span class="hljs-attribute">objtype</span>=NORMAL<br><span class="hljs-attribute">type</span>=SYSCALL <span class="hljs-attribute">msg</span>=audit(1643192492.764:23275): <span class="hljs-attribute">arch</span>=c000003e <span class="hljs-attribute">syscall</span>=62 <span class="hljs-attribute">success</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">exit</span>=0 <span class="hljs-attribute">a0</span>=2c27 <span class="hljs-attribute">a1</span>=f <span class="hljs-attribute">a2</span>=7f776e62f7b8 <span class="hljs-attribute">a3</span>=7fffd20c62c0 <span class="hljs-attribute">items</span>=0 <span class="hljs-attribute">ppid</span>=5554 <span class="hljs-attribute">pid</span>=5606 <span class="hljs-attribute">auid</span>=4294967295 <span class="hljs-attribute">uid</span>=0 <span class="hljs-attribute">gid</span>=0 <span class="hljs-attribute">euid</span>=0 <span class="hljs-attribute">suid</span>=0 <span class="hljs-attribute">fsuid</span>=0 <span class="hljs-attribute">egid</span>=0 <span class="hljs-attribute">sgid</span>=0 <span class="hljs-attribute">fsgid</span>=0 tty=(none) <span class="hljs-attribute">ses</span>=4294967295 <span class="hljs-attribute">comm</span>=<span class="hljs-string">&quot;pkill&quot;</span> <span class="hljs-attribute">exe</span>=<span class="hljs-string">&quot;/usr/bin/pkill&quot;</span> key=(<span class="hljs-literal">null</span>)<br><span class="hljs-attribute">type</span>=OBJ_PID <span class="hljs-attribute">msg</span>=audit(1643192492.764:23275): <span class="hljs-attribute">opid</span>=11303 <span class="hljs-attribute">oauid</span>=-1 <span class="hljs-attribute">ouid</span>=0 <span class="hljs-attribute">oses</span>=-1 <span class="hljs-attribute">ocomm</span>=<span class="hljs-string">&quot;monit&quot;</span><br><span class="hljs-attribute">type</span>=SYSCALL <span class="hljs-attribute">msg</span>=audit(1643192492.764:23276): <span class="hljs-attribute">arch</span>=c000003e <span class="hljs-attribute">syscall</span>=62 <span class="hljs-attribute">success</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">exit</span>=0 <span class="hljs-attribute">a0</span>=2c7e <span class="hljs-attribute">a1</span>=f <span class="hljs-attribute">a2</span>=7f776e62f7b8 <span class="hljs-attribute">a3</span>=7fffd20c62c0 <span class="hljs-attribute">items</span>=0 <span class="hljs-attribute">ppid</span>=5554 <span class="hljs-attribute">pid</span>=5606 <span class="hljs-attribute">auid</span>=4294967295 <span class="hljs-attribute">uid</span>=0 <span class="hljs-attribute">gid</span>=0 <span class="hljs-attribute">euid</span>=0 <span class="hljs-attribute">suid</span>=0 <span class="hljs-attribute">fsuid</span>=0 <span class="hljs-attribute">egid</span>=0 <span class="hljs-attribute">sgid</span>=0 <span class="hljs-attribute">fsgid</span>=0 tty=(none) <span class="hljs-attribute">ses</span>=4294967295 <span class="hljs-attribute">comm</span>=<span class="hljs-string">&quot;pkill&quot;</span> <span class="hljs-attribute">exe</span>=<span class="hljs-string">&quot;/usr/bin/pkill&quot;</span> key=(<span class="hljs-literal">null</span>)<br><span class="hljs-attribute">type</span>=OBJ_PID <span class="hljs-attribute">msg</span>=audit(1643192492.764:23276): <span class="hljs-attribute">opid</span>=11390 <span class="hljs-attribute">oauid</span>=0 <span class="hljs-attribute">ouid</span>=0 <span class="hljs-attribute">oses</span>=52555 <span class="hljs-attribute">ocomm</span>=<span class="hljs-string">&quot;jumper-monitor&quot;</span><br><span class="hljs-attribute">type</span>=SYSCALL <span class="hljs-attribute">msg</span>=audit(1643192492.764:23277): <span class="hljs-attribute">arch</span>=c000003e <span class="hljs-attribute">syscall</span>=62 <span class="hljs-attribute">success</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">exit</span>=0 <span class="hljs-attribute">a0</span>=2c7f <span class="hljs-attribute">a1</span>=f <span class="hljs-attribute">a2</span>=7f776e62f7b8 <span class="hljs-attribute">a3</span>=7fffd20c62c0 <span class="hljs-attribute">items</span>=0 <span class="hljs-attribute">ppid</span>=5554 <span class="hljs-attribute">pid</span>=5606 <span class="hljs-attribute">auid</span>=4294967295 <span class="hljs-attribute">uid</span>=0 <span class="hljs-attribute">gid</span>=0 <span class="hljs-attribute">euid</span>=0 <span class="hljs-attribute">suid</span>=0 <span class="hljs-attribute">fsuid</span>=0 <span class="hljs-attribute">egid</span>=0 <span class="hljs-attribute">sgid</span>=0 <span class="hljs-attribute">fsgid</span>=0 tty=(none) <span class="hljs-attribute">ses</span>=4294967295 <span class="hljs-attribute">comm</span>=<span class="hljs-string">&quot;pkill&quot;</span> <span class="hljs-attribute">exe</span>=<span class="hljs-string">&quot;/usr/bin/pkill&quot;</span> key=(<span class="hljs-literal">null</span>)<br><span class="hljs-attribute">type</span>=OBJ_PID <span class="hljs-attribute">msg</span>=audit(1643192492.764:23277): <span class="hljs-attribute">opid</span>=11391 <span class="hljs-attribute">oauid</span>=0 <span class="hljs-attribute">ouid</span>=0 <span class="hljs-attribute">oses</span>=52628 <span class="hljs-attribute">ocomm</span>=<span class="hljs-string">&quot;zmq-proxy-monit&quot;</span><br><span class="hljs-attribute">type</span>=SYSCALL <span class="hljs-attribute">msg</span>=audit(1643192492.764:23278): <span class="hljs-attribute">arch</span>=c000003e <span class="hljs-attribute">syscall</span>=62 <span class="hljs-attribute">success</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">exit</span>=0 <span class="hljs-attribute">a0</span>=2c8b <span class="hljs-attribute">a1</span>=f <span class="hljs-attribute">a2</span>=7f776e62f7b8 <span class="hljs-attribute">a3</span>=7fffd20c62c0 <span class="hljs-attribute">items</span>=0 <span class="hljs-attribute">ppid</span>=5554 <span class="hljs-attribute">pid</span>=5606 <span class="hljs-attribute">auid</span>=4294967295 <span class="hljs-attribute">uid</span>=0 <span class="hljs-attribute">gid</span>=0 <span class="hljs-attribute">euid</span>=0 <span class="hljs-attribute">suid</span>=0 <span class="hljs-attribute">fsuid</span>=0 <span class="hljs-attribute">egid</span>=0 <span class="hljs-attribute">sgid</span>=0 <span class="hljs-attribute">fsgid</span>=0 tty=(none) <span class="hljs-attribute">ses</span>=4294967295 <span class="hljs-attribute">comm</span>=<span class="hljs-string">&quot;pkill&quot;</span> <span class="hljs-attribute">exe</span>=<span class="hljs-string">&quot;/usr/bin/pkill&quot;</span> key=(<span class="hljs-literal">null</span>)<br><span class="hljs-attribute">type</span>=OBJ_PID <span class="hljs-attribute">msg</span>=audit(1643192492.764:23278): <span class="hljs-attribute">opid</span>=11403 <span class="hljs-attribute">oauid</span>=0 <span class="hljs-attribute">ouid</span>=0 <span class="hljs-attribute">oses</span>=52628 <span class="hljs-attribute">ocomm</span>=<span class="hljs-string">&quot;zcho-monitor&quot;</span><br><span class="hljs-attribute">type</span>=SYSCALL <span class="hljs-attribute">msg</span>=audit(1643192492.764:23279): <span class="hljs-attribute">arch</span>=c000003e <span class="hljs-attribute">syscall</span>=62 <span class="hljs-attribute">success</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">exit</span>=0 <span class="hljs-attribute">a0</span>=2c8c <span class="hljs-attribute">a1</span>=f <span class="hljs-attribute">a2</span>=7f776e62f7b8 <span class="hljs-attribute">a3</span>=7fffd20c62c0 <span class="hljs-attribute">items</span>=0 <span class="hljs-attribute">ppid</span>=5554 <span class="hljs-attribute">pid</span>=5606 <span class="hljs-attribute">auid</span>=4294967295 <span class="hljs-attribute">uid</span>=0 <span class="hljs-attribute">gid</span>=0 <span class="hljs-attribute">euid</span>=0 <span class="hljs-attribute">suid</span>=0 <span class="hljs-attribute">fsuid</span>=0 <span class="hljs-attribute">egid</span>=0 <span class="hljs-attribute">sgid</span>=0 <span class="hljs-attribute">fsgid</span>=0 tty=(none) <span class="hljs-attribute">ses</span>=4294967295 <span class="hljs-attribute">comm</span>=<span class="hljs-string">&quot;pkill&quot;</span> <span class="hljs-attribute">exe</span>=<span class="hljs-string">&quot;/usr/bin/pkill&quot;</span> key=(<span class="hljs-literal">null</span>)<br><span class="hljs-attribute">type</span>=OBJ_PID <span class="hljs-attribute">msg</span>=audit(1643192492.764:23279): <span class="hljs-attribute">opid</span>=11404 <span class="hljs-attribute">oauid</span>=0 <span class="hljs-attribute">ouid</span>=0 <span class="hljs-attribute">oses</span>=888 <span class="hljs-attribute">ocomm</span>=<span class="hljs-string">&quot;promised-monito&quot;</span><br><span class="hljs-attribute">type</span>=SYSCALL <span class="hljs-attribute">msg</span>=audit(1643192492.765:23280): <span class="hljs-attribute">arch</span>=c000003e <span class="hljs-attribute">syscall</span>=59 <span class="hljs-attribute">success</span>=<span class="hljs-literal">yes</span> <span class="hljs-attribute">exit</span>=0 <span class="hljs-attribute">a0</span>=8830d0 <span class="hljs-attribute">a1</span>=87be60 <span class="hljs-attribute">a2</span>=883650 <span class="hljs-attribute">a3</span>=7ffd21c2f350 <span class="hljs-attribute">items</span>=3 <span class="hljs-attribute">ppid</span>=5554 <span class="hljs-attribute">pid</span>=5609 <span class="hljs-attribute">auid</span>=4294967295 <span class="hljs-attribute">uid</span>=0 <span class="hljs-attribute">gid</span>=0 <span class="hljs-attribute">euid</span>=0 <span class="hljs-attribute">suid</span>=0 <span class="hljs-attribute">fsuid</span>=0 <span class="hljs-attribute">egid</span>=0 <span class="hljs-attribute">sgid</span>=0 <span class="hljs-attribute">fsgid</span>=0 tty=(none) <span class="hljs-attribute">ses</span>=4294967295 <span class="hljs-attribute">comm</span>=<span class="hljs-string">&quot;service&quot;</span> <span class="hljs-attribute">exe</span>=<span class="hljs-string">&quot;/usr/bin/bash&quot;</span> key=(<span class="hljs-literal">null</span>)<br><span class="hljs-attribute">type</span>=EXECVE <span class="hljs-attribute">msg</span>=audit(1643192492.765:23280): <span class="hljs-attribute">argc</span>=4 <span class="hljs-attribute">a0</span>=<span class="hljs-string">&quot;/bin/sh&quot;</span> <span class="hljs-attribute">a1</span>=<span class="hljs-string">&quot;/usr/sbin/service&quot;</span> <span class="hljs-attribute">a2</span>=<span class="hljs-string">&quot;monit&quot;</span> <span class="hljs-attribute">a3</span>=<span class="hljs-string">&quot;restart&quot;</span><br><span class="hljs-attribute">type</span>=CWD <span class="hljs-attribute">msg</span>=audit(1643192492.765:23280):  <span class="hljs-attribute">cwd</span>=<span class="hljs-string">&quot;/opt/soft/fast/agent/v0.0.25.e326b11&quot;</span><br></code></pre></td></tr></table></figure><p>如上例中的日志中发现promised-monito 被kill掉，从上述倒数第4行日志发现promised-monito 有收到消息, 那是谁发出的消息那，从倒数第5行日志看到<code>ppid=5554 pid=5606</code> 和<code>exe=&quot;/usr/bin/pkill&quot;</code> 可以看出是通过父进程(5554) 接收到pkill系统调用发生的。</p><p>那么5554又是哪个进程？通过执行<code>ps -ef |grep 5554</code> 发现找不到任何5554的信息，从而怀疑5554执行完相关pkill动作后就退出了，所以在日志中继续向上查找有谁创建了5554进程。通过日志发现了<code>items=3 ppid=29639 pid=5554 </code>和行尾的<code>comm=&quot;600_cdn_mmoonni&quot; exe=&quot;/usr/bin/bash&quot;</code> 说明5554是一个脚本进程，脚本的名字包含<code>600_cdn_mmoonni</code> 这个名字可能被截断了。再次通过执行<code>ps -ef |grep 29639</code> 我们发现了进程信息如下的进程信息</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>      <span class="hljs-number">7915</span> <span class="hljs-number">12188</span>  <span class="hljs-number">0</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> grep --color=auto fast<br><span class="hljs-attribute">root</span>     <span class="hljs-number">12957</span>     <span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">2021</span> ?        <span class="hljs-number">02</span>:<span class="hljs-number">26</span>:<span class="hljs-number">12</span> ./fast-updater -c cfg.json<br><span class="hljs-attribute">root</span>     <span class="hljs-number">29639</span>     <span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">2021</span> ?        <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">13</span> ./fast-agent -c cfg.json<br><br></code></pre></td></tr></table></figure><p>通过<code>29639</code> 这个信息我们在fast-agent 服务的脚本中找到了<code>600_cdn_mmoonniitt_check.sh</code> 这个脚本，并在脚本中发现了<code>pkill monit </code>这样的杀死进程的命令。由于pkill是按照模糊匹配规则对所有运行进程中包含monit的进程发送pkill 命名，从而导致了我们的promised-monito 被意外杀死从而影响了线上服务的稳定性。</p><p>审核守护程序可以在 <code>/etc/audit/auditd.conf</code> 配置文件中进行配置。这个文件包括修改审核守护进程特性的配置参数。紧跟 # 字符（<code>#</code>）的任何空行或者文本都被忽略。所有配置参数的列表以及它们的解释都可以在 audit.conf(5) 手册页中找到。</p><h1 id="配置-auditd"><a href="#配置-auditd" class="headerlink" title="配置 auditd"></a>配置 <code>auditd</code></h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">audit的默认配置文件路径为 <span class="hljs-regexp">/etc/</span>audit/auditd.conf<br>audit的默认日志路径为 <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/audit/</span>audit.log<br></code></pre></td></tr></table></figure><p>默认 <code>auditd</code> 配置应该对大多数环境都适合。但是如果您的环境符合由 <em>可控制存取保护档案</em>（CAPP）所建立的标准，这将是公共标准认证的一部分，审核守护程序必须用以下设定配置：</p><ul><li>保存审核日志文件的目录（<code>/var/log/audit/</code>）经常应该在另一个分区。这将防止其他过程耗费此目录中的空间，并且为剩余的审核守护程序提供准确的检测。</li><li><em><code>max_log_file</code></em> 参数详细说明了每个审核日志文件最少的占用空间，参数必须设定为充分利用保存审核日志文件分区所在的可用空间。</li><li><em><code>max_log_file_action</code></em> 参数决定采取何种行动，一旦到达在 *<code>max_log_file</code>*中所设定的极限，则应该设定为 <code>keep_logs</code> 防止审核日志文件被重写。</li><li><em><code>space_left</code></em> 参数明确说明磁盘中可用空间的数量，这样的话在*<code>space_left_action</code>* 参数中所设定的行动会被触发。此参数必须被设定为一个数字它会给予管理者足够的时间来回应和刷新磁盘空间。 <em><code>space_left</code></em> 价值取决于审核日志文件生成的速度。</li><li>我们推荐您采用合适的通知方法把 <em><code>space_left_action</code></em> 参数设定为<code>email</code> 或者 <code>exec</code>。</li><li><em><code>admin_space_left</code></em> 参数明确说明自由空间的绝对最小数量，为了在 <em><code>admin_space_left_action</code></em> 参数中所设定的行动会被触发，必须设定一个会给予管理者的日志行动总够空间的值。</li><li><em><code>admin_space_left_action</code></em> 参数必须设定 <code>single</code> 使系统属于单一用户模式，并且允许管理者开放一些磁盘空间。</li><li><em><code>disk_full_action</code></em> 参数明确说明当保存审核日志文件的分区没有可用空间时，应该触发行动，并且必须设定为 <code>halt</code> 或者 <code>single</code>。这保障了当审核不再记录事件时，系统也能在单一用户模式下关闭或者运行。</li><li>*<code>disk_error_action</code>*，明确说明如果保存在审核日志文件的分区检测到错误时，应该采取行动，必须设定 <code>syslog</code>、<code>single</code> 或者 <code>halt</code>，这取决于当地的安全政策有关硬件故障的处理。</li><li><em><code>flush</code></em> 配置参数必须设定为 <code>sync</code> 或者 <code>data</code>。这些参数保证所有的审核事件数据能与磁盘中的日志文件同步。</li></ul><h1 id="定义审核规则"><a href="#定义审核规则" class="headerlink" title="定义审核规则"></a>定义审核规则</h1><p>审核系统根据一组规则运行，这组规则定义了日志文件中所获取的内容。有三种类型的审核规则可以详细说明：</p><ul><li>控制规则 — 允许审核系统的行为和它的一些被修改的配置。</li><li>文件系统规则 — 也被称为文件监视，允许审核进入特定文件或者目录。</li><li>系统调用规则 — 允许记录任何指定程序所做的系统调用。</li></ul><p>审核规则可以在命令行上使用 <strong>auditctl</strong> 实用程序进行详细说明（请注意这些规则并不是在重新启动时一直有效），或者写在 <code>/etc/audit/audit.rules</code> 文件中。以下两个部分总结了定义审核规则的两个方法。</p><p><strong>使用 <code>auditctl</code>  实用程序来定义审核规则</strong></p><p><strong>注意</strong></p><p>所有与审核服务交互的命令以及审核日志文件都需要 <code>root</code> 特权。作为 <code>root </code>用户确保您执行这些命令。</p><p><code>auditctl</code> 命令允许您控制审核系统的基本功能并且限定规则来决定哪些审核项目要记录。</p><h2 id="定义控制规则"><a href="#定义控制规则" class="headerlink" title="定义控制规则"></a>定义控制规则</h2><p>以下是一些控制规则允许您修改审核系统的行为：</p><ul><li><p><code>-b</code></p><p>在 Kernel 中设定最大数量的已存在的审核缓冲区，例如：<code>~]# auditctl -b 8192</code></p></li><li><p><code>-f</code></p><p>当追踪重要错误时设定所要完成的行动，例如：<code>~]# auditctl -f 2</code>以上配置触发 kernel 恐慌以防重要错误。</p></li><li><p><code>-e</code></p><p>启动或者禁用审核系统或者锁定它的配置，例如：<code>~]# auditctl -e 2</code>以上命令锁定审核配置。</p></li><li><p><code>-r</code></p><p>设定每秒生成信息的速率，例如：<code>~]# auditctl -r 0</code>以上配置在生成信息方面不设定限制速率。</p></li><li><p><code>-s</code></p><p>报告审核系统状态，例如：<code>~]# auditctl -s AUDIT_STATUS: enabled=1 flag=2 pid=0 rate_limit=0 backlog_limit=8192 lost=259 backlog=0 </code></p></li><li><p><code>-l</code></p><p>列出所有当前装载的审核规则，例如：<code>~]# auditctl -l LIST_RULES: exit,always watch=/etc/localtime perm=wa key=time-change LIST_RULES: exit,always watch=/etc/group perm=wa key=identity LIST_RULES: exit,always watch=/etc/passwd perm=wa key=identity LIST_RULES: exit,always watch=/etc/gshadow perm=wa key=identity ⋮ </code></p></li><li><p><code>-D</code></p><p>删除所有当前装载的审核规则，例如：<code>~]# auditctl -D No rules </code></p></li></ul><h2 id="定义文件系统规则"><a href="#定义文件系统规则" class="headerlink" title="定义文件系统规则"></a>定义文件系统规则</h2><p>定义文件系统规则，使用以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">auditctl -w path_to_file -p permissions -k key_name<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><em>path_to_file</em> 是审核过的文件或者目录：</li><li><em>permissions</em> 是被记录的权限：<ul><li><code>r</code> — 读取文件或者目录。</li><li><code>w</code> — 写入文件或者目录。</li><li><code>x</code> — 运行文件或者目录。</li><li><code>a</code> — 改变在文件或者目录中的属性。</li></ul></li><li><em>key_name</em> 是可选字符串，可帮助您判定哪个规则或者哪组规则生成特定的日志项。</li></ul><p><strong>例 5.1. 文件系统规则</strong></p><p>为了定义所有的输写访问权限以及在 <code>/etc/passwd</code> 文件中每个属性更改的规则，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# auditctl -w /etc/passwd -p wa -k passwd_changes<br></code></pre></td></tr></table></figure><p>请注意以下字符串 <code>-k</code> 选项是任意的。</p><p>为了定义记录所有输写访问权限，以及在 <code>/etc/selinux/</code> 目录中所有文件属性更改的规则，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# auditctl -w /etc/selinux/ -p wa -k selinux_changes<br></code></pre></td></tr></table></figure><p>为了定义可以记录执行 <code>/sbin/insmod</code> 命令的规则，在 Linux Kernel 中插入模块，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# auditctl -w /sbin/insmod -p x -k module_insertion<br></code></pre></td></tr></table></figure><h2 id="定义系统调用规则"><a href="#定义系统调用规则" class="headerlink" title="定义系统调用规则"></a>定义系统调用规则</h2><p>为了定义系统调用规则，使用以下语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">auditctl -a action,filter -S system_call -F 输入栏=value -k key_name<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><em>action</em> 以及 <em>filter</em> 详细说明某个事件何时被记录。 <em>action</em> 可能是 <code>always</code>（经常是）或者<code>never</code>（从不是）其中之一。 <em>filter</em> 详细说明哪个 Kernel 规则匹配过滤器应用在事件中。以下是其中之一的与规则匹配的过滤器： <code>task</code>、<code>exit</code>、<code>user</code> 以及 <code>exclude</code>。如果想要更多有关这些过滤器的信息，请参考〈<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/chap-system_auditing#sec-audit_system_architecture">第 5.1 节 “审核系统架构”</a>〉的开始部分。</li><li><em>system_call</em> 通过它的名字详细说明系统调用。所有的系统调用都可以在<code>/usr/include/asm/unistd_64.h</code> 文件中找到。许多系统调用都能形成一个规则，每个都在 <code>-S</code> 选项之后详细说明。</li><li><em>field</em>=<em>value</em> 详细说明其他选项，进一步修改规则来与以特定架构、组 ID、进程 ID和其他内容为基础的事件相匹配。为了列出完整可用的输入栏类型和它们的数值，请参考 auditctl(8) 手册页。</li><li><em>key_name</em> 是可选字符串，可帮助您判定哪个规则或者哪组规则生成特定的日志项。</li></ul><p><strong>例 系统调用规则</strong></p><p>为了定义创造日志项 的规则，每次通过程序使用系统调用 <code>adjtimex</code> 或者 <code>settimeofday</code>。当系统使用 64 位架构，请执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# auditctl -a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time_change<br></code></pre></td></tr></table></figure><p>为了定义创造日志项的规则，每次由 ID 是 500 或更大的系统用户删除或者重命名文件时，使用（<code>-F auid!=4294967295</code> 选项排除没有设定登录 UID的用户），执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# auditctl -a always,exit -S unlink -S unlinkat -S rename -S renameat -F auid&gt;=500 -F auid!=4294967295 -k delete<br></code></pre></td></tr></table></figure><p>使用系统调用语法来定义文件系统也是有可能的。对于 <code>-w /etc/shadow -p wa</code> 文件系统规则来说，以下命令为模拟的系统调用创造了规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# auditctl -a always,exit -F path=/etc/shadow -F perm=wa<br></code></pre></td></tr></table></figure><h2 id="在-etc-audit-audit-rules-文件中定义持久的审核规则和控制"><a href="#在-etc-audit-audit-rules-文件中定义持久的审核规则和控制" class="headerlink" title="在 /etc/audit/audit.rules 文件中定义持久的审核规则和控制"></a>在 <code>/etc/audit/audit.rules</code> 文件中定义持久的审核规则和控制</h2><p>为了定义在重新启动时可以一直有效的审核规则，您必须把它们包含在 <code>/etc/audit/audit.rules</code> 文件中。这个文件使用相同的 <code>auditctl</code> 命令行语法来详细说明规则。任何在 # 之后的空行或者文本（<code>#</code>）可以忽略。</p><p><code>auditctl</code> 指令可以被用来读取来自指定文件的规则，使用 <code>-R</code> 选项，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# auditctl -R /usr/share/doc/audit-version/stig.rules<br></code></pre></td></tr></table></figure><h3 id="定义控制规则-1"><a href="#定义控制规则-1" class="headerlink" title="定义控制规则"></a>定义控制规则</h3><p>文件可以只包括以下的控制规则，修改审核系统的行为： <code>-b</code>、<code>-D</code>、<code>-e</code>、<code>-f</code>、或者 <code>-r</code>。如果想获取更多信息，请参考 <a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-Defining_Audit_Rules_and_Controls#bh-defining_controls_with_auditctl">“定义控制规则”一节</a>。</p><p><strong>例 5.3. 在 <code>audit.rules</code>中控制规则。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs none"># Delete all previous rules<br>-D<br><br># Set buffer size<br>-b 8192<br><br># Make the configuration immutable -- reboot is required to change audit rules<br>-e 2<br><br># Panic when a failure occurs<br>-f 2<br><br># Generate at most 100 audit messages per second<br>-r 100<br></code></pre></td></tr></table></figure><h3 id="定义文件系统和系统调用规则"><a href="#定义文件系统和系统调用规则" class="headerlink" title="定义文件系统和系统调用规则"></a>定义文件系统和系统调用规则</h3><p>使用 <code>auditctl</code> 语法定义文件系统和系统调用原则。在〈<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-Defining_Audit_Rules_and_Controls#sec-Defining_Audit_Rules_with_the_auditctl_utility">第 5.5.1 节 “使用 <strong>auditctl</strong> 实用程序来定义审核规则”</a>〉中的例子可以用以下规则文件来表示：</p><p><strong>例 5.4. 在 <code>audit.rules</code> 中的文件系统和系统调用规则</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs none">-w /etc/passwd -p wa -k passwd_changes<br>-w /etc/selinux/ -p wa -k selinux_changes<br>-w /sbin/insmod -p x -k module_insertion<br><br>-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time_change<br>-a always,exit -S unlink -S unlinkat -S rename -S renameat -F auid&gt;=500 -F auid!=4294967295 -k delete<br></code></pre></td></tr></table></figure><h3 id="预配置规则文件"><a href="#预配置规则文件" class="headerlink" title="预配置规则文件"></a>预配置规则文件</h3><p>在 <code>/usr/share/doc/audit-*version*/</code> 目录中, 根据不同的认证标准 audit 软件包提供一组预配置规则文件：</p><ul><li><code>nispom.rules</code> — 审核规则配置符合《国家行业安全程序操作运行指南》的第八章中详细说明的要求。</li><li><code>capp.rules</code> — 审核规则配置满足由 <a href="http://www.niap-ccevs.org/pp/pp_os_ca_v1.d.pdf">CAPP</a> 设定的要求，是公共标准认定的一部分。</li><li><code>lspp.rules</code> —审核规则配置满足由 <a href="http://www.commoncriteriaportal.org/files/ppfiles/lspp.pdf">LSPP</a> 设定的要求是公共标准认定的一部分。</li><li><code>stig.rules</code> — 审核规则配置满足由 STIG 所设定的要求。</li></ul><p>为了使用这些配置文件，需要创造您原始文件的备份 <code>/etc/audit/audit.rules</code> 并且复制您所选择的有关 <code>/etc/audit/audit.rules</code> 文件的配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# cp /etc/audit/audit.rules /etc/audit/audit.rules_backup<br>~]# cp /usr/share/doc/audit-version/stig.rules /etc/audit/audit.rules<br></code></pre></td></tr></table></figure><h1 id="理解审核日志文件"><a href="#理解审核日志文件" class="headerlink" title="理解审核日志文件"></a>理解审核日志文件</h1><p>默认情况下，在 <code>/var/log/audit/audit.log</code> 文件中的审核系统储存日志项；如果启用日志旋转，就可以旋转储存在同一目录中的 <code>audit.log</code> 文件。</p><p>以下的审核规则记录了每次读取或者修改 <code>/etc/ssh/sshd_config</code> 文件的尝试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">-w /etc/ssh/sshd_config -p warx -k sshd_config<br></code></pre></td></tr></table></figure><p>如果 <code>auditd</code> 守护程序在运行，就需在审核日志文件中运行以下命令创造新事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">~]# cat /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>在 <code>audit.log</code> 文件中的事件如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs none">type=SYSCALL msg=audit(1364481363.243:24287): arch=c000003e syscall=2 success=no exit=-13 a0=7fffd19c5592 a1=0 a2=7fffd19c4b50 a3=a items=1 ppid=2686 pid=3538 auid=500 uid=500 gid=500 euid=500 suid=500 fsuid=500 egid=500 sgid=500 fsgid=500 tty=pts0 ses=1 comm=&quot;cat&quot; exe=&quot;/bin/cat&quot; subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=&quot;sshd_config&quot;<br>type=CWD msg=audit(1364481363.243:24287):  cwd=&quot;/home/shadowman&quot;<br>type=PATH msg=audit(1364481363.243:24287): item=0 name=&quot;/etc/ssh/sshd_config&quot; inode=409248 dev=fd:00 mode=0100600 ouid=0 ogid=0 rdev=00:00 obj=system_u:object_r:etc_t:s0<br></code></pre></td></tr></table></figure><p>以上事件由三个记录组成（每个以 <code>type=</code> 密码作为开始），共享相同的时间戳和编号。每个记录包含好几对 <code>*name*=*value*</code> ，由空格或者逗号分开。以下是关于以上事件的详细分析：</p><h3 id="第一个记录"><a href="#第一个记录" class="headerlink" title="第一个记录"></a>第一个记录</h3><ul><li><p><code>type=SYSCALL</code></p><p><code>type</code> 输入栏包含这类记录。在这个例子中， <code>SYSCALL</code> 数值详细说明连接到 Kernel 的系统调用触发了这个记录。为了列出所有可能的类型值和它们的解释，请参考〈<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-Audit_Record_Types">第 B.2 节 “审核记录类型”</a>〉。</p></li><li><p><code>msg=audit(1364481363.243:24287):</code></p><p><code>msg</code> 输入栏记录：<code>audit(*time_stamp*:*ID*)</code> 表格中记录的时间戳和特殊 ID。如果多种记录生成为相同审核事件的一部分，那么它们可以共享相同的时间戳和 ID。Kernel 或者用户空间应用提供不同的事件特定 <code>*name*=*value*</code> 组。</p></li><li><p><code>arch=c000003e</code></p><p><code>arch</code> 输入栏包括关于系统CPU架构的信息。值 <code>c000003e</code> 是使用 16 进制表示法编码。当使用 <code>ausearch</code> 命令搜寻审核记录时, 使用 <code>-i</code> 或者 <code>--interpret</code> 选项自动转化为 16 进制值可供人读取的对等语。 <code>c000003e</code> 值被解释为 <code>x86_64</code>。</p></li><li><p><code>syscall=2</code></p><p><code>syscall</code> 输入栏记录了传输给 Kernel 的输入栏类型。值 <code>2</code> 可以与在 <code>/usr/include/asm/unistd_64.h</code> 文件中可供人读取的对等语相匹配。 在这种情况下，<code>2</code> 是 <code>open</code> 系统调用。 请注意 <strong>ausyscall</strong> 实用程序允许您把系统调用数字转换成可供人读取的对等语。 使用 <code>ausyscall --dump</code> 命令来展示所有的系统调用和它们的号码。如想要获取更多信息，请参考 ausyscall(8) 手册页。</p></li><li><p><code>success=no</code></p><p><code>success</code> 输入栏记录了系统调用是否被成功地记录在特定事件中。在这种情况下，调用不会成功。</p></li><li><p><code>exit=-13</code></p><p><code>exit</code> 输入栏包含详细说明由系统调用所返回的退出代码的值。在不同的系统调用中，值各不相同。您可以用以下命令把值解释为可供人读取的对等语：<code>ausearch --interpret --exit -13</code>（假设您的审核日志中包含的事件没有退出代码 <code>-13</code>）。</p></li><li><p><code>a0=7fffd19c5592</code>, <code>a1=0</code>, <code>a2=7fffd19c5592</code>, <code>a3=a</code></p><p><code>a0</code> 到 <code>a3</code> 输入栏记录了前四个参数，在这个事件中使用 16 进制编码系统调用。这些参数取决于使用的系统调用；它们可以通过 <strong>ausearch</strong> 实用程序来解释。</p></li><li><p><code>items=1</code></p><p><code>items</code> 输入栏包含事件中路径记录的数量。</p></li><li><p><code>ppid=2686</code></p><p><code>items</code> 输入栏记录了父进程 ID（PPID）。在这个情况下，<code>2686</code> 是 <code>bash</code> 进程的 PPID。</p></li><li><p><code>pid=3538</code></p><p><code>pid</code> 输入栏记录了进程 ID（PID）。在这个情况下，<code>3538</code> 是 <code>cat</code> 进程的 PID。</p></li><li><p><code>auid=500</code></p><p><code>auid</code> 输入栏记录了审核用户 ID，这个是 loginuid。这个ID是用户在登录时使用的并且即使当用户身份改变时，也可以通过每个进程获取该ID。（例如，通过切换用户账户，使用 <code>su - john</code>命令）。</p></li><li><p><code>uid=500</code></p><p><code>uid</code> 输入栏记录了开始分析进程的用户 ID。使用以下指令：<code>ausearch -i --uid *UID*</code>，用户 ID 就可以被解释为用户名字。在这个情况下， <code>500</code> 是 <code>shadowman</code> 的用户 ID。</p></li><li><p><code>gid=500</code></p><p><code>gid</code> 输入栏记录了开始分析进程用户的 ID组。</p></li><li><p><code>euid=500</code></p><p><code>euid</code> 输入栏记录了开始分析进程用户的有效用户 ID。</p></li><li><p><code>suid=500</code></p><p><code>suid</code> 输入栏记录了开始分析进程的用户的设置用户 ID。</p></li><li><p><code>fsuid=500</code></p><p><code>fsuid</code> 输入栏记录了开始分析进程用户的文件系统用户 ID。</p></li><li><p><code>egid=500</code></p><p><code>egid</code> 输入栏记录了开始分析进程用户的有效群组 ID。</p></li><li><p><code>sgid=500</code></p><p><code>sgid</code> 输入栏记录了开始分析进程用户的设置群组 ID。</p></li><li><p><code>fsgid=500</code></p><p><code>fsgid</code> 输入栏记录了开始分析进程的用户的文件系统群组 ID。</p></li><li><p><code>tty=pts0</code></p><p><code>tty</code> 输入栏记录了调用分析进程的终端。</p></li><li><p><code>ses=1</code></p><p><code>ses</code> 输入栏记录了调用分析进程会话的会话 ID。</p></li><li><p><code>comm=&quot;cat&quot;</code></p><p><code>comm</code> 输入栏记录了命令行的名字，它被用于调用分析进程。在这种情况下 <code>cat</code> 命令被用来触发审核事件。</p></li><li><p><code>exe=&quot;/bin/cat&quot;</code></p><p><code>exe</code> 输入栏记录了被用来调用分析进程的可执行的路径。</p></li><li><p><code>subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></p><p><code>subj</code> 输入栏记录了 SELinux 语境，运用此语境可以在执行时间中标注分析进程。</p></li><li><p><code>key=&quot;sshd_config&quot;</code></p><p><code>key</code> 输入栏记录了所有管理者定义的字符串，它与在审核日志中生成该事件的规则有关。</p></li></ul><h3 id="第二记录"><a href="#第二记录" class="headerlink" title="第二记录"></a>第二记录</h3><ul><li><p><code>type=CWD</code></p><p>在第二记录中，<code>type</code> 输入栏数值是 <code>CWD</code> — 当前工作目录。这种类型用于记录在被执行的第一记录中详细说明的触发系统调用的进程。这个记录的目的是为了记录当前进程的位置以防在相关的 PATH 记录中捕捉到相对路径。运用这个方法可以重塑绝对路径。</p></li><li><p><code>msg=audit(1364481363.243:24287)</code></p><p><code>msg</code> 输入栏持有与第一记录中的数值相同的时间戳和 ID 值。</p></li><li><p><code>cwd=&quot;/home/shadowman&quot;</code></p><p><code>cwd</code> 输入栏含有进入目录的路径，在目录中触发系统调用。</p></li></ul><h3 id="第三记录"><a href="#第三记录" class="headerlink" title="第三记录"></a>第三记录</h3><ul><li><p><code>type=PATH</code></p><p>在第三记录中， <code>type</code> 输入栏值是 <code>PATH</code>。每个审核事件包含一个 <code>PATH</code> 对于每条路径种类的记录作为一个参数，传输给系统调用。在审核事件中，只有一条路径（<code>/etc/ssh/sshd_config</code>）被用来作为参数。</p></li><li><p><code>msg=audit(1364481363.243:24287):</code></p><p><code>msg</code> 输入栏持有与第一和第二记录中的值相同的时间戳和 ID 值。</p></li><li><p><code>item=0</code></p><p><code>item</code> 输入栏表明在所有项目中，哪个项目在 <code>SYSCALL</code> 类型记录中，参考了当前记录。这个是数字是以零为基准；值 <code>0</code> 意味着它是第一项。</p></li><li><p><code>name=&quot;/etc/ssh/sshd_config&quot;</code></p><p><code>name</code> 输入栏记录了文件或者目录的所有路径，作为参数被传输给系统调用。在这种情况下，它是 <code>/etc/ssh/sshd_config</code> 文件。</p></li><li><p><code>inode=409248</code></p><p><code>inode</code> 输入栏包含索引结点数字，与记录在事件中的文件和目录有关。以下命令体现了与 <code>409248</code> 索引结点数字相关的文件和目录：<code>~]# find / -inum 409248 -print /etc/ssh/sshd_config </code></p></li><li><p><code>dev=fd:00</code></p><p><code>dev</code> 输入栏明确说明了设备的次要和主要 ID，它包含记录在事件中的文件和目录。在这种情况下，值代表 <code>/dev/fd/0</code> 设备。</p></li><li><p><code>mode=0100600</code></p><p><code>mode</code> 输入栏记录了文件和目录权限，用 16 进制表示法编码。在这种情况下，<code>0100600</code> 可以被解释为 <code>-rw-------</code>，意味着对于 <code>/etc/ssh/sshd_config</code> 文件，只有 root 用户拥有读取并且输入权限。</p></li><li><p><code>ouid=0</code></p><p><code>ouid</code> 输入栏记录了对象所有者的用户 ID。</p></li><li><p><code>ogid=0</code></p><p><code>ogid</code> 输入栏记录对象拥有者的群组 ID。</p></li><li><p><code>rdev=00:00</code></p><p><code>rdev</code> 输入栏包含记录的设备识别器只用于特殊文件。在这种情况下，正常文件是不用来作为记录文件的。</p></li><li><p><code>obj=system_u:object_r:etc_t:s0</code></p><p><code>obj</code> 输入栏记录了 SELinux 语境，运用此语境可以在执行时间中标注分析进程。</p></li></ul><p>以上分析过的审核事件是事件所包含的所有可能位置栏的一小部分。为了列出所有事件的位置栏及解释，请参考〈<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/app-Audit_Reference#sec-Audit_Events_Fields">第 B.1 节 “审核事件字段”</a>〉。为了列出所有事件类型以及解释，请参考〈<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/security_guide/sec-Audit_Record_Types">第 B.2 节 “审核记录类型”</a>〉。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/qwertyupoiuytr/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">58278349</span><br>https:<span class="hljs-regexp">//</span>access.redhat.com<span class="hljs-regexp">/documentation/</span>zh-cn<span class="hljs-regexp">/red_hat_enterprise_linux/</span><span class="hljs-number">7</span><span class="hljs-regexp">/html/</span>security_guide/sec-understanding_audit_log_files<br>https:<span class="hljs-regexp">//</span>access.redhat.com<span class="hljs-regexp">/documentation/</span>zh-cn<span class="hljs-regexp">/red_hat_enterprise_linux/</span><span class="hljs-number">7</span><span class="hljs-regexp">/html/</span>security_guide/sec-defining_audit_rules_and_controls<br>https:<span class="hljs-regexp">//</span>www.jianshu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">4</span>a7cc1944ea7<br>https:<span class="hljs-regexp">//</span>www.daimajiaoliu.com<span class="hljs-regexp">/daima/</span><span class="hljs-number">4795</span>a4ea61003fc<br>https:<span class="hljs-regexp">//</span>paper.seebug.org<span class="hljs-regexp">/1594/</span><span class="hljs-comment">#31</span><br>http:<span class="hljs-regexp">//</span>blog.chinaunix.net/uid-<span class="hljs-number">20662820</span>-id-<span class="hljs-number">5326690</span>.html<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>个人开发基本原则</title>
    <link href="/2022/01/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/00%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <url>/2022/01/07/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/00%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>不要在构造函数中注册任何回调；</li><li>不要在构造函数中把 this 传给跨线程的对象  <figure class="highlight coffeescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs coffeescript">因为在构造函数执行期间对象还没有完成初始化，如果 <span class="hljs-built_in">this</span>被泄露（<span class="hljs-built_in">escape</span>）给了其他对象（其自身创建的子对象除外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果<br></code></pre></td></tr></table></figure><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2></li><li>shared_ptr 是管理共享资源的利器，需要注意避免循环引用，通常的做法是 owner 持有指向 child 的 shared_ptr， child 持有指向 owner 的 weak_ptr。</li><li>std::bind 拷贝的是实参类型，不是形参类型</li></ul><h1 id="c"><a href="#c" class="headerlink" title="c"></a>c</h1><h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><ul><li>/usr/include/netinet/tcp.h 中的 tcp_info 获取连接的状态数据信息  </li></ul>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>typora配置标题自动添加序号</title>
    <link href="/2021/12/22/04DevOps/13typora%E9%85%8D%E7%BD%AE%E6%A0%87%E9%A2%98%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%8F%B7/"/>
    <url>/2021/12/22/04DevOps/13typora%E9%85%8D%E7%BD%AE%E6%A0%87%E9%A2%98%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<ol><li><p>依次点击以下按钮进入typora主题目录<br>文件—》偏好设置—》外观—》打开主题文件夹</p></li><li><p>在主题目录创建 base.user.css 文件</p></li><li><p>在base.user.css 文件中增加以下内容</p><figure class="highlight css"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></div></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/** initialize css counter */</span><br><span class="hljs-selector-id">#write</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h1<br>&#125;<br><br><span class="hljs-selector-tag">h1</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h2<br>&#125;<br><br><span class="hljs-selector-tag">h2</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h3<br>&#125;<br><br><span class="hljs-selector-tag">h3</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h4<br>&#125;<br><br><span class="hljs-selector-tag">h4</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h5<br>&#125;<br><br><span class="hljs-selector-tag">h5</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h6<br>&#125;<br><br><span class="hljs-comment">/** put counter result into headings */</span><br><span class="hljs-selector-id">#write</span> <span class="hljs-selector-tag">h1</span>:before &#123;<br>    counter-increment: h1;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br><br><span class="hljs-selector-id">#write</span> <span class="hljs-selector-tag">h2</span>:before &#123;<br>    counter-increment: h2;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br><br><span class="hljs-selector-id">#write</span> <span class="hljs-selector-tag">h3</span>:before,<br>h3.md-focus.md-heading:before /** override the default style for focused headings */ &#123;<br>    counter-increment: h3;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h3) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br><br><span class="hljs-selector-id">#write</span> <span class="hljs-selector-tag">h4</span>:before,<br>h4.md-focus.md-heading:before &#123;<br>    counter-increment: h4;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h3) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h4) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br><br><span class="hljs-selector-id">#write</span> <span class="hljs-selector-tag">h5</span>:before,<br>h5.md-focus.md-heading:before &#123;<br>    counter-increment: h5;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h3) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h4) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h5) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br><br><span class="hljs-selector-id">#write</span> <span class="hljs-selector-tag">h6</span>:before,<br>h6.md-focus.md-heading:before &#123;<br>    counter-increment: h6;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h3) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h4) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h5) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h6) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br><br><span class="hljs-comment">/** override the default style for focused headings */</span><br><span class="hljs-selector-id">#write</span>&gt;<span class="hljs-selector-tag">h3</span><span class="hljs-selector-class">.md-focus</span>:before,<br>#write&gt;h4.md-focus:before,<br>#write&gt;h5.md-focus:before,<br>#write&gt;h6.md-focus:before,<br>h3.md-focus:before,<br>h4.md-focus:before,<br>h5.md-focus:before,<br>h6.md-focus:before &#123;<br>    color: inherit;<br>    <span class="hljs-attribute">border</span>: inherit;<br>    <span class="hljs-attribute">border-radius</span>: inherit;<br>    <span class="hljs-attribute">position</span>: inherit;<br>    <span class="hljs-attribute">left</span>:initial;<br>    <span class="hljs-attribute">float</span>: none;<br>    <span class="hljs-attribute">top</span>:initial;<br>    <span class="hljs-attribute">font-size</span>: inherit;<br>    <span class="hljs-attribute">padding-left</span>: inherit;<br>    <span class="hljs-attribute">padding-right</span>: inherit;<br>    <span class="hljs-attribute">vertical-align</span>: inherit;<br>    <span class="hljs-attribute">font-weight</span>: inherit;<br>    <span class="hljs-attribute">line-height</span>: inherit;<br>&#125;<br><br><span class="hljs-comment">/** 侧边栏列表 */</span><br><br><span class="hljs-selector-class">.sidebar-content</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h1<br>&#125;<br> <br><span class="hljs-selector-class">.outline-h1</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h2<br>&#125;<br> <br><span class="hljs-selector-class">.outline-h2</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h3<br>&#125;<br> <br><span class="hljs-selector-class">.outline-h3</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h4<br>&#125;<br> <br><span class="hljs-selector-class">.outline-h4</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h5<br>&#125;<br> <br><span class="hljs-selector-class">.outline-h5</span> &#123;<br>    <span class="hljs-attribute">counter-reset</span>: h6<br>&#125;<br> <br><span class="hljs-selector-class">.outline-h1</span>&gt;<span class="hljs-selector-class">.outline-item</span>&gt;<span class="hljs-selector-class">.outline-label</span>:before &#123;<br>    counter-increment: h1;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br> <br><span class="hljs-selector-class">.outline-h2</span>&gt;<span class="hljs-selector-class">.outline-item</span>&gt;<span class="hljs-selector-class">.outline-label</span>:before &#123;<br>    counter-increment: h2;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br> <br><span class="hljs-selector-class">.outline-h3</span>&gt;<span class="hljs-selector-class">.outline-item</span>&gt;<span class="hljs-selector-class">.outline-label</span>:before &#123;<br>    counter-increment: h3;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h3) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br> <br><span class="hljs-selector-class">.outline-h4</span>&gt;<span class="hljs-selector-class">.outline-item</span>&gt;<span class="hljs-selector-class">.outline-label</span>:before &#123;<br>    counter-increment: h4;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h3) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h4) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br> <br><span class="hljs-selector-class">.outline-h5</span>&gt;<span class="hljs-selector-class">.outline-item</span>&gt;<span class="hljs-selector-class">.outline-label</span>:before &#123;<br>    counter-increment: h5;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h3) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h4) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h5) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br> <br><span class="hljs-selector-class">.outline-h6</span>&gt;<span class="hljs-selector-class">.outline-item</span>&gt;<span class="hljs-selector-class">.outline-label</span>:before &#123;<br>    counter-increment: h6;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(h1) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h2) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h3) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h4) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h5) <span class="hljs-string">&quot;.&quot;</span> <span class="hljs-built_in">counter</span>(h6) <span class="hljs-string">&quot;. &quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>zhuanlan.zhihu.com<span class="hljs-regexp">/p/</span><span class="hljs-number">110257979</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++11 std::bind 详解</title>
    <link href="/2021/08/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/12c11_bind%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/12/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/12c11_bind%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p> std::bind 函数定义在头文件<functional>中，是一个函数模板，它就像一个函数适配器，接受一个可调用对象（callable object），生成一个新的可调用对象来“适应”原对象的参数列表。一般而言，我们用它可以把一个原本接收N个参数的函数fn，通过绑定一些参数，返回一个接收M个（M可以大于N，但这么做没什么意义）参数的新函数。同时，使用std::bind函数还可以实现参数顺序调整等操作。</p><h2 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. 函数原型</h2><p>std::bind函数有两种函数原型，定义如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs stata">template&lt; <span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... <span class="hljs-keyword">Args</span> &gt; bind( F&amp;&amp; f, <span class="hljs-keyword">Args</span>&amp;&amp;... <span class="hljs-keyword">args</span> ); <br>template&lt; <span class="hljs-keyword">class</span> R, <span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... <span class="hljs-keyword">Args</span> &gt;  bind( F&amp;&amp; f, <span class="hljs-keyword">Args</span>&amp;&amp;... <span class="hljs-keyword">args</span> );<br></code></pre></td></tr></table></figure><p>std::bind返回一个基于f的函数对象(obj)，调用obj时参数被绑定到args上。f的参数要么被绑定到具体的值，要么被绑定到 placeholders(占位符，如_1, _2, …, _n).</p><p>其中占位符<code>_1</code>,<code>_2</code>表示，当执行obj函数时的第1,第2 … 第n个参数。</p><h2 id="3-参数及用法解释"><a href="#3-参数及用法解释" class="headerlink" title="3. 参数及用法解释"></a>3. 参数及用法解释</h2><h3 id="3-1-参数"><a href="#3-1-参数" class="headerlink" title="3.1 参数"></a>3.1 参数</h3><p>f：一个可调用对象（可以是函数对象、函数指针、函数引用、成员函数指针、数据成员指针），它的参数将被绑定到args上。<br>args：绑定参数列表，参数会被值或占位符替换，其长度必须与f接收的参数个数一致。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">调用可调用对象时，绑定参数被std::move，调用参数被std::forward，你得根据可调用对象的行为来判断std::bind返回的函数对象是否可以多次调用。<br><br>绑定参数可以是bind表达式，占位符被替换为外层的调用参数，相当于用调用参数来调用这个bind表达式，求值后用来调用外层bind表达式——我是在读源码读到一半一脸懵逼的时候才知道这件事的。这与可调用对象被std::bind以后可以再std::bind并不冲突，因为bind表达式一个是作为绑定参数，另一个是作为可调用对象。<br><br>std::bind有个重载，可以用模板参数指定bind表达式的<span class="hljs-built_in"><span class="hljs-keyword">operator</span></span>()的返回类型。<br></code></pre></td></tr></table></figure><h3 id="3-2-调用形式"><a href="#3-2-调用形式" class="headerlink" title="3.2 调用形式"></a>3.2 调用形式</h3><p>调用std::bind的一般形式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> newCallable = std::<span class="hljs-built_in">bind</span>(callable, arg_list);<br></code></pre></td></tr></table></figure><p>其中，newCallable 本身是一个可调用对象，arg_list 是一个逗号分隔的参数列表，对应给定的 callable 的参数。即，当我们调用 newCallable 时，newCallable 会调用callable，并传递给它 arg_list 中的参数。</p><h3 id="3-3-返回类型"><a href="#3-3-返回类型" class="headerlink" title="3.3 返回类型"></a>3.3 返回类型</h3><p>std::bind 的返回类型是一个函数对象,这个函数对象是一个未指定类型T的函数对象，这个函数对象的 std::is_bind_expression<T>::value == true；这个函数对象包含以下成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span> 对象成员<br> 一个由std::forward&lt;F&gt;(f)构造而来的std::decay&lt;F&gt;::type类型的对象，一个对象的每一个参数类型都是由std::forward&lt;Arg_i&gt;(arg_i)构造而来的std::decay&lt;Arg_i&gt;::type。简单来说，std::decay&lt;F&gt;::type对象保存了调用std::bind时传递过来的f参数，而若干个std::decay&lt;Arg_i&gt;::type则保存了传递过来的args参数（一个std::decay&lt;Arg_i&gt;::type保存一个args）。<br><span class="hljs-number">2.</span> 构造函数<br> 如果T的所有对象成员都是可拷贝的，则它自身也是可拷贝的；如果它的所有对象成员都是可移动构造的，则它自身也是可移动构造的。<br><span class="hljs-number">3.</span> 成员类型 result_type（从C++<span class="hljs-number">17</span>开始result_type已经被弃用）<br>·如果F是函数指针或者成员函数指针，result_type就是F的返回值类型<br>·如果F是一个拥有（或者说定义了）result_type的类类型，那么T的result_type就是F::result_type，即使result_type已经在T中被定义过<br><span class="hljs-number">4.</span> 成员函数 <span class="hljs-built_in"><span class="hljs-keyword">operator</span></span>()<br> 这是最应该了解的，因为在实际使用过程中，我们调用std::bind得到的返回值就是用来作为函数调用的。<br> bind的返回值T，假设我们这样调用：<span class="hljs-built_in">g</span>(a1, a2, a3, … ai); 此时g内部保存的std::decay&lt;F&gt;::type类型的对象将被调用, 它将会按照如下的方式来为a1, a2, …, ai 绑定值。<br> · 如果调用bind时指定的是reference_wrapper&lt;T&gt;类型的，比如在调用bind时使用了std::ref 或者 std::cref来包装args，那么调用g内部的这个对象时，对应参数会以T&amp;类型传入std::decay&lt;F&gt;::type类型的对象.<br> · 如果在创建g时，使用了嵌套的bind，即g = <span class="hljs-built_in">bind</span>(fn, args…)的参数列表args中，存在某个arg：使得std::is_bind_expression&lt;<span class="hljs-keyword">decltype</span>(arg)&gt;::value == <span class="hljs-literal">true</span>, 那么这个嵌套的bind表达式会被立即调用，其返回值会被传给ret里的_MyFun作为参数(也就是说嵌套的bind返回值会被当做ret调用时的参数)， 如果嵌套的bind里用到了占位符placeholder, 这些placeholder将会从ret的调用参数<span class="hljs-built_in">ret</span>(a1, a2, … ai)中对应位置选择.<br> · 如果在创建g时，使用了占位符placeholders, 即 g = <span class="hljs-built_in">bind</span>(fn, arg1, arg2, …, _1, _2, …), (对于_1, _2…, 有std::is_placeholder&lt;T&gt;::value != <span class="hljs-number">0</span>). 那么a1, a2, …, ai会以转发的形式forward&lt;ai&gt;(ai)传递给_MyFun, a1对应_1, a2对应_2, 以此类推.<br> 否则，ret内部保存的args，即上文提到的_Mybargs(bind调用时绑定的参数们)将被以左值的形式传给_MyFun以完成调用，这些参数和g有相同cv限定属性.<br> 如果<span class="hljs-built_in">g</span>(a1, a2, …, ai)中，有哪些ai没有匹配任何的placeholders，比如在调用bind时，placeholder只有_1, 而<span class="hljs-built_in">g</span>(a1, a2, a3), 那么a2, a3就是没有匹配的，没有被匹配的参数将被求值，但是会被丢弃。<br> 如果g被指定为<span class="hljs-built_in"><span class="hljs-keyword">volatile</span></span>(<span class="hljs-keyword">volatile</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">volatile</span>)，结果是未定义的。<br></code></pre></td></tr></table></figure><h2 id="4-类成员函数回调"><a href="#4-类成员函数回调" class="headerlink" title="4 类成员函数回调"></a>4 类成员函数回调</h2><p>在c++中，常用的回调函数场景是，在一个类A中，有一个普通成员函数a,在类B中，有一个普通成员函数b,在b中，想要回调函数a，这才是c++回调函数的正确打开方式。</p><p>先上一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br> <br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; Fun;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,Fun f)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-built_in">f</span>(a,<span class="hljs-number">2</span>);<br>        &#125;<br>&#125;;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>        cout&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;+&quot;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;a+b&lt;&lt;endl;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>        Fun fun=std::<span class="hljs-built_in">bind</span>(&amp;Test::callback,<span class="hljs-keyword">this</span>,_1,_2);<br>B b;<br>b.<span class="hljs-built_in">call</span>(<span class="hljs-number">1</span>,fun);<br>&#125;<br> <br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test test;<br>test.<span class="hljs-built_in">bind</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序中，Test类中的bind函数调用B类中的call函数，b中的call函数又反过来回调Test类中的callback函数。记住function和bind都是c++11标准函数，编译的时候要加-std=c++11。</p><p>在分析上面程序之前，先介绍一下两个辅助函数，分别是bind函数和function函数，这两个函数之前是boost函数成员，现在加入到c++11标准中，使用更加方便。</p><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>定义在头文件functional中。可以看成是对一个函数的改造器，可以借助于集合的观点来说（尽管可能没这回事），可以将bind函数看作是返回一个子函数。这个子函数可以是bind绑定的函数的子集，也可以是本身。</p><p> 一般常用语法是： newFunName=bind(oldFunName,arg_list);</p><p>bind函数返回一个新的函数对象。其中bind第一个参数是oldFunName,它是待绑定的函数名，arg_list是oldFunName的参数列表。注意，这个参数列表是旧函数的参数列表，前面提到，返回的是子函数。我们可以随便给子函数定几个参数，但是肯定不能多于bind所绑定的原函数的参数个数。举个例子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//g</span>是一个有两个参数的可调用对象<br>auto g=bind(f,a,b,_2,c,_1);<br><span class="hljs-regexp">//</span>其中f是具有<span class="hljs-number">5</span>个参数的函数<br><span class="hljs-regexp">//</span>当我们调用g(x,y)时，实际调用的是f(a,b,y,c,x)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们可能要调用f函数，并传入5个参数，但是我们现在调用g(x,y)，只要传入两个参数，同样能达到这个效果。当然，我费这么多事其实肯定不是为了省几个参数，主要还是为了将一个函数转化成一个可以作为回调的函数指针，可以看成是原函数指针的别名。</p><p>上面出现的_1，_2是它的占位符，bind最多可以使用9个占位符。这个占位符命名在std的placeholders中，使用时，要使用using std::placeholders.</p><h3 id="function函数"><a href="#function函数" class="headerlink" title="function函数"></a>function函数</h3><p> function是一个函数对象的<code>容器</code>。</p><p>如function&lt;int(int,int)&gt; fun;  fun是一个函数模板，可以接受两个int型参数，并返回一个int型参数。平时可以将它赋值给一个函数指针。</p><p>例如上面的回调函数： Fun fun=std::bind(&amp;Test::callback,this,_1,_2);</p><p>其中bind用于绑定一个Test类的callback函数，它有两个参数，在这里，因为它是一个类成员函数，中间传入一个this指针，另外两个_1和_2则是它的两个参数。bind返回一个函数指针，将它赋给fun,fun作为一个函数容器，容纳bind函数返回的临时函数指针。 这样就成功的将fun作为一个函数参数的别名，可以用于传给回调函数了。</p><p>关于bind和function函数，再举一个例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> ()&gt; fp;  <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g_fun</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    cout&lt;&lt;<span class="hljs-string">&quot;g_fun()&quot;</span>&lt;&lt;endl;  <br>&#125;  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>  </span><br><span class="hljs-class">&#123;</span>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">A_fun_static</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        cout&lt;&lt;<span class="hljs-string">&quot;A_fun_static()&quot;</span>&lt;&lt;endl;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A_fun</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        cout&lt;&lt;<span class="hljs-string">&quot;A_fun()&quot;</span>&lt;&lt;endl;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A_fun_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        cout&lt;&lt;<span class="hljs-string">&quot;A_fun_int() &quot;</span>&lt;&lt;i&lt;&lt;endl;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//非静态类成员，因为含有this指针，所以需要使用bind  </span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        fp fp1=std::<span class="hljs-built_in">bind</span>(&amp;A::A_fun,<span class="hljs-keyword">this</span>);  <br>        <span class="hljs-built_in">fp1</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init2</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function">    </span>&#123;  <br>        <span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (<span class="hljs-keyword">int</span>)&gt; fpi;  <br>        <span class="hljs-comment">//对于参数要使用占位符 std::placeholders::_1  </span><br>        fpi f=std::<span class="hljs-built_in">bind</span>(&amp;A::A_fun_int,<span class="hljs-keyword">this</span>,std::placeholders::_1);  <br>        <span class="hljs-built_in">f</span>(<span class="hljs-number">5</span>);  <br>    &#125;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-comment">//绑定到全局函数  </span><br>    fp f2=<span class="hljs-built_in">fp</span>(&amp;g_fun);  <br>    <span class="hljs-built_in">f2</span>();  <br>  <br>    <span class="hljs-comment">//绑定到类静态成员函数  </span><br>    fp f1=<span class="hljs-built_in">fp</span>(&amp;A::A_fun_static);  <br>    <span class="hljs-built_in">f1</span>();  <br>  <br>    <span class="hljs-built_in">A</span>().<span class="hljs-built_in">init</span>();  <br>    <span class="hljs-built_in">A</span>().<span class="hljs-built_in">init2</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5 注意"></a>5 注意</h2><p>如可调用 (Callable) 中描述，<font color=#ff0000><code>调用指向非静态成员函数指针或指向非静态数据成员指针时，首参数必须是引用或指针</code></font>（可以包含智能指针，如 std::shared_ptr 与 std::unique_ptr），指向将访问其成员的对象。 </p><p>所以在调用类的成员函数的时候首参必须是this</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/afei__/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">81985937</span><br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/hyp1977/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">51784520</span><br>https:<span class="hljs-regexp">//</span>en.cppreference.com<span class="hljs-regexp">/w/</span>cpp<span class="hljs-regexp">/utility/</span>functional/bind<br>https:<span class="hljs-regexp">//</span>www.cnblogs.com<span class="hljs-regexp">/jerry-fuyi/</span>p/<span class="hljs-number">12633621</span>.html<br>https:<span class="hljs-regexp">//</span>blog.csdn.net<span class="hljs-regexp">/xiexievv/</span>article<span class="hljs-regexp">/details/</span><span class="hljs-number">50517964</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unique_ptr和shared_ptr及weak_ptr的使用</title>
    <link href="/2021/08/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/11unique_ptr%E5%92%8Cshared_ptr%E5%8F%8Aweak_ptr%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/08/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/11unique_ptr%E5%92%8Cshared_ptr%E5%8F%8Aweak_ptr%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-unique-ptr"><a href="#1-unique-ptr" class="headerlink" title="1. unique_ptr"></a>1. unique_ptr</h1><h2 id="1-1-初始化方式"><a href="#1-1-初始化方式" class="headerlink" title="1.1 初始化方式"></a>1.1 初始化方式</h2><ol><li>直接初始化<figure class="highlight maxima"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">unique</span>&lt;T&gt; myPtr(<span class="hljs-built_in">new</span> T);  //ok。但不能通过隐式转换来构造，如<span class="hljs-built_in">unique</span>&lt;T&gt; myPtr = <span class="hljs-built_in">new</span> T()。因为unique_ptr构造函数被声明为<span class="hljs-built_in">explicit</span>。<br></code></pre></td></tr></table></figure></li><li>移动构造<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">unique</span>&lt;T&gt; myOtherPtr = <span class="hljs-built_in">std</span>::move(myPtr);但不允许复制构造，如<span class="hljs-built_in">unique</span>&lt;T&gt; myOther = myPtr; 因为<span class="hljs-built_in">unique</span>是个只移动类型。<br></code></pre></td></tr></table></figure></li><li>通过make_unique构造<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts">unique<span class="hljs-params">&lt;T&gt;</span> myPtr = std::make_unique<span class="hljs-params">&lt;T&gt;</span>(); <span class="hljs-comment">//C++14支持的语法。但是make_都不支持添加删除器，或者初始化列表。</span><br></code></pre></td></tr></table></figure></li><li>通过reset重置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">如std::unique_ptr up; up.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>());<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-2-指定删除器"><a href="#1-2-指定删除器" class="headerlink" title="1.2 指定删除器"></a>1.2 指定删除器</h2><ol><li><p>unique_ptr&lt;T,D&gt;  u1(p,d);删除器是unique_ptr类型的组成部分，可是普通函数指针或lambda表达式。注意，当指定删除器时需要同时指定其类型，即D不可省略。</p></li><li><p>使用默认的deleter时，unique_ptr对象和原始指针的大小是一样的。当自定义deleter时，如果deleter是函数指针，则unique_ptr对象的大小为8字节。对于函数对象的deleter，unique_ptr对象的大小依赖于存储状态的多少，无状态的函数对象（如不捕获变量的lambda表达式），其大小为4字节。</p></li></ol><h2 id="1-3-源码分析"><a href="#1-3-源码分析" class="headerlink" title="1.3 源码分析"></a>1.3 源码分析</h2><ol><li>unique_ptr的构造函数被声明为explicit，禁止隐式类型转换的行为。原因如下：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts">①可减少误将智能指针指向栈对象的情况。如unique_ptr<span class="hljs-params">&lt;int&gt;</span> ui = <span class="hljs-variable">&amp;i</span>;其中的i为栈变量。<br>②可避免将一个普通指针传递给形参为智能指针的函数。假设，如果允许将裸指针传给void foo(std::unique_ptr<span class="hljs-params">&lt;T&gt;</span>)函数，则在函数结束后会因形参超出作用域，裸指针将被delete的误操作。<br></code></pre></td></tr></table></figure></li><li>unique_ptr的拷贝构造和拷贝赋值均被声明为delete。因此无法实施拷贝和赋值操作，但可以移动构造和移动赋值。</li><li>删除器是unique_ptr类型的一部分。默认为std::default_delete，内部是通过调用delete来实现。</li><li>unique_ptr可以指向数组，并重载了operator []运算符。如unique_ptr&lt;int[]&gt; ptr(new int[10]); ptr[9]=9;但建议使用使作std::array、std::vector或std::string来代替这种原始数组。</li></ol><h2 id="1-4-常用操作"><a href="#1-4-常用操作" class="headerlink" title="1.4 常用操作"></a>1.4 常用操作</h2><ol><li>get()：返回unique_ptr中保存的裸指针</li><li>reset()：重置unique_ptr。</li><li>release()：放弃对指针的控制权，返回裸指针，并将unique_ptr自身置空。通常用来初始化另一个智能指针。</li><li>swap(q)：交换两个智能指针所指向的对象。</li></ol><h2 id="1-5-基本用法示例"><a href="#1-5-基本用法示例" class="headerlink" title="1.5  基本用法示例"></a>1.5  基本用法示例</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;vector&gt;</span><br><span class="hljs-comment">#include &lt;memory&gt;  //for smart pointer</span><br><br>using namespace std;<br><br>class Widget &#123;&#125;;<br><br><span class="hljs-regexp">//</span>返回值RVO优化：<br>unique_ptr&lt;int&gt; <span class="hljs-keyword">func</span>()<br>&#123;<br>    unique_ptr&lt;int&gt; up(new int(<span class="hljs-number">100</span>));<br>    return  up; <span class="hljs-regexp">//u</span>p是个左值，调用拷贝构造给返回值？ No。<br>                <span class="hljs-regexp">//</span>C++标准要求当RVO被允许时，要么消除拷贝，要么隐式地把std::move用在要返回的局部<br>                <span class="hljs-regexp">//</span>对象上去。这里编译器会直接在返回值位置创建up对象。因此根本不会发生拷贝构造，<br>                <span class="hljs-regexp">//u</span>nique_ptr本身也不能被拷贝构造。<br><br>    <span class="hljs-regexp">//</span>return unique_ptr&lt;int&gt;(new int(<span class="hljs-number">100</span>)); <span class="hljs-regexp">//</span>右值，被移动构造。<br>&#125;<br><br>void foo(std::unique_ptr&lt;int&gt; ptr)<br>&#123;<br>&#125;<br><br>void myDeleter(int* p)<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;invoke deleter(void* p)&quot;</span>&lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br><br>int main()<br>&#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-number">1</span>. unique_ptr的初始化<br>    <span class="hljs-regexp">//</span><span class="hljs-number">1.1</span> 通过裸指针创建unique_ptr（由于unique_ptr的构造函数是explicit的，必须使用直接初始化，不能做隐式类型转换）<br>    std::unique_ptr&lt;Widget&gt; ptr1(new Widget);      <span class="hljs-regexp">//</span>ok; 直接初始化<br>    <span class="hljs-regexp">//</span>std::unique_ptr&lt;Widget&gt; ptr1 = new Widget(); <span class="hljs-regexp">//</span>error。不能隐式将Widget*转换为unqiue_ptr&lt;Widget&gt;类型。<br><br>    std::unique_ptr&lt;int[]&gt; ptr2(new int[<span class="hljs-number">10</span>]); <span class="hljs-regexp">//</span>指向数组<br><br>    <span class="hljs-regexp">//</span><span class="hljs-number">1.2</span> 通过移动构造<br>    <span class="hljs-regexp">//</span>std::unique_ptr&lt;Widget&gt; ptr3 = ptr1;    <span class="hljs-regexp">//</span>error，unique_ptr是独占型，不能复制构造<br>    std::unique_ptr&lt;Widget&gt; ptr3 = std::move(ptr1);  <span class="hljs-regexp">//</span>ok，unique_ptr是个只移动类型，可以移动构造<br>    auto ptr4 = std::move(ptr3);     <span class="hljs-regexp">//</span>ok， ptr4为unique_ptr&lt;Widget&gt;类型<br><br>    <span class="hljs-regexp">//</span><span class="hljs-number">1.3</span> 通过std::make_unique来创建<br>    auto ptr5 = std::make_unique&lt;int&gt;(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-regexp">//</span>auto ptr6 = std::make_unique&lt;vector&lt;int&gt;&gt;(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;); <span class="hljs-regexp">//</span>error，make_unique不支持初始化列表<br>    auto initList = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    auto ptr6 = std::make_unique&lt;vector&lt;int&gt;&gt;(initList);<br><br>    <span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 传参和返回值<br>    int* px = new int(<span class="hljs-number">0</span>);<br>    <span class="hljs-regexp">//</span>foo(px); <span class="hljs-regexp">//</span>error，px无法隐式转为unique_ptr。可防止foo函数执行完毕后，px会自动释放。<br>    <span class="hljs-regexp">//</span>foo(ptr5); <span class="hljs-regexp">//</span>error，智能指针不能被拷贝。因此，可以将foo的形参声明为引用，以避免所有权转移<br>    foo(std::move(ptr5)); <span class="hljs-regexp">//</span>ok，通过移动构造<br><br>    auto ptr7 = <span class="hljs-keyword">func</span>(); <span class="hljs-regexp">//</span>移动构造<br><br>    <span class="hljs-regexp">//</span><span class="hljs-number">3</span>.常用操作<br>    std::unique_ptr&lt;Widget&gt; upw1; <span class="hljs-regexp">//</span>空的unique_ptr<br>    upw1.reset(new Widget);<br>    std::unique_ptr&lt;Widget&gt; upw2(new Widget);<br><br>    cout &lt;&lt;<span class="hljs-string">&quot;before swap...&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;upw1.get() = &quot;</span> &lt;&lt; hex &lt;&lt; upw1.get() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;upw2.get() = &quot;</span> &lt;&lt; hex &lt;&lt; upw2.get() &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;after swap...&quot;</span> &lt;&lt; endl;<br>    upw1.swap(upw2); <span class="hljs-regexp">//</span>交换指针所指的对象<br>    cout &lt;&lt; <span class="hljs-string">&quot;upw1.get() = &quot;</span> &lt;&lt; hex &lt;&lt; upw1.get() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;upw2.get() = &quot;</span> &lt;&lt; hex &lt;&lt; upw2.get() &lt;&lt; endl;<br><br>    <span class="hljs-regexp">//u</span>pw1.release(); <span class="hljs-regexp">//</span>release放弃了控制权不会释放内存，丢失了指针<br>    Widget* pw = upw1.release();<span class="hljs-regexp">//</span>放弃对指针的控制<br>    <span class="hljs-keyword">delete</span> pw; <span class="hljs-regexp">//</span>需手动删除<br><br>    <span class="hljs-keyword">if</span> (upw1) &#123;  <span class="hljs-regexp">//u</span>nique_ptr重载了operator bool()<br>        cout &lt;&lt; <span class="hljs-string">&quot;upw1 owns resourse&quot;</span> &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;upw1 lost resourse&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    upw1.reset(upw2.release()); <span class="hljs-regexp">//</span>转移所有权<br>    cout &lt;&lt; <span class="hljs-string">&quot;upw1.get() = &quot;</span> &lt;&lt; hex &lt;&lt; upw1.get() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;upw2.get() = &quot;</span> &lt;&lt; hex &lt;&lt; upw2.get() &lt;&lt; endl;<br><br>    <span class="hljs-regexp">//u</span>pw1 = nullptr; <span class="hljs-regexp">//</span>释放upw1指向的对象，并将upw1置空<br>    <span class="hljs-regexp">//u</span>pw1.reset(nullptr);<br><br>    <span class="hljs-regexp">//</span><span class="hljs-number">4</span>.unique_ptr的大小<br>    std::unique_ptr&lt;int,decltype(&amp;myDeleter)&gt; upd1(new int(<span class="hljs-number">0</span>), myDeleter); <span class="hljs-regexp">//</span>自定义删除器<br>    auto del = [](auto* p) &#123;<span class="hljs-keyword">delete</span> p; &#125;;<br>    std::unique_ptr&lt;int, decltype(del)&gt; upd2(new int(<span class="hljs-number">0</span>), del); <br>    cout &lt;&lt; sizeof(upw1) &lt;&lt; endl; <span class="hljs-regexp">//</span><span class="hljs-number">4</span>字节，默认删除器<br>    cout &lt;&lt; sizeof(upd1) &lt;&lt; endl; <span class="hljs-regexp">//</span><span class="hljs-number">8</span>字节<br>    cout &lt;&lt; sizeof(upd2) &lt;&lt; endl; <span class="hljs-regexp">//</span><span class="hljs-number">4</span>字节<br><br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-6-使用场景"><a href="#1-6-使用场景" class="headerlink" title="1.6 使用场景"></a>1.6 使用场景</h2><h3 id="1-6-1-作为工厂函数的返回类型"><a href="#1-6-1-作为工厂函数的返回类型" class="headerlink" title="1.6.1 作为工厂函数的返回类型"></a>1.6.1 作为工厂函数的返回类型</h3><p>　　1. 工厂函数负责在堆上创建对象，但是调用工厂函数的用户才会真正去使用这个对象，并且要负责这个对象生命周期的管理。所以使用unique_ptr是最好的选择。</p><p>　　2. unique_ptr转为shared_ptr很容易，作为工厂函数本身并不知道用户希望所创建的对象的所有权是专有的还是共享的，返回unique_ptr时调用者可以按照需要做变换。</p><h3 id="1-6-2-PImpl机制：（Pointer-to-Implemention）"><a href="#1-6-2-PImpl机制：（Pointer-to-Implemention）" class="headerlink" title="1.6.2 PImpl机制：（Pointer to Implemention）"></a>1.6.2 PImpl机制：（Pointer to Implemention）</h3><p>　　1. 操作方法</p><p>　　（1）将曾经放在主类中的数据成员放到实现类中去，然后通过指针间接地访问那些数据成员。此时主类中存在只有声明而没有定义的类型（也叫非完整类型），如Widget::Impl。</p><p>　　（2）在实现类中，动态分配和归还原那些原本应在主类中定义的那数据成员对象。即将这个数据成员放到实现类中定义（动态分配其内存）</p><p>　　2. 注意事项</p><p>　　（1）PImpl机制通过降低类的客户和类实现者之间的依赖性，减少了构建遍数。</p><p>　　（2）对于采用std::unique_ptr来实现的PImpl指针，须在类的头文件中声明特殊成员函数，但在实现文件中实现它们（注意，不能直接在头文件中实现，具体原因见《编程实验》中的说明）。如，必须同时声明并实现类的析构函数。再由于自定义了析构函数，编译器不再提供默认的移动构造和移动赋值函数，如果需要这些函数，则也必须在头文件中声明，并在实现类中去实现。</p><p>　　（3）上述建议仅适用于std::unique_ptr，但并不适用于std::shared_ptr。因为删除器在unique_ptr中是其类型的一部分，而在shared_ptr中则不是。声明对象时，unique_ptr<T>支持T是个非完整类型，但在析构时T必须己经是个完整的类型。unique_ptr析构时会先判断T是否为完整类型再调用delete删除其所指对象，但shared_ptr<T>则不会。</p><h3 id="16-3-场景实验"><a href="#16-3-场景实验" class="headerlink" title="16.3 场景实验"></a>16.3 场景实验</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#ifndef  _WIDGET_H_</span><br><span class="hljs-comment">#define _WIDGET_H_</span><br><span class="hljs-comment">#include &lt;memory&gt;</span><br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.传统的做法<br><span class="hljs-regexp">//</span>问题：数据成员会导致Widget.h文件必须include &lt;string&gt;<br><span class="hljs-regexp">//</span>      &lt;vector&gt;和gadget.h。当客户包含Widget.h里，会增加编译时间，而且<br><span class="hljs-regexp">//</span>      如果其中的某个头文件(如Gadget.h)发生改变，则Widget的客户必须重新编译！<br><span class="hljs-regexp">//</span>class Widget<br><span class="hljs-regexp">//</span>&#123;<br><span class="hljs-regexp">//</span>    std::string name;<br><span class="hljs-regexp">//</span>    std::vector&lt;double&gt; data;<br><span class="hljs-regexp">//</span>    Gadget g1, g2, g3;<span class="hljs-regexp">//</span> <span class="hljs-regexp">//</span>自定义类型，位于gadget.h。<br><span class="hljs-regexp">//</span>public:<br><span class="hljs-regexp">//</span>    Widget();<br><span class="hljs-regexp">//</span>&#125;;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>. 采用PImpl手法<br>class Widget<br>&#123;<br>    <span class="hljs-regexp">//</span>声明实现结构体以及指向它的指针<br>    struct Impl; <span class="hljs-regexp">//</span>注意只有声明，没实现。是个非完整类型。<br>    std::unique_ptr&lt;Impl&gt; pImpl; <span class="hljs-regexp">//</span>使用智能指针而非裸指针。这里声明一个指针非完整类型的指针。注意针对非完整<br>                                 <span class="hljs-regexp">//</span>类型，可以做的事情极其有限。由于unique_ptr中会将删除器作为其类型的一部分<br>                                 <span class="hljs-regexp">//</span>因此，但unique_ptr析构被调用时，当<span class="hljs-keyword">delete</span>其所指对象时，会先判断T是否是个完<br>                                 <span class="hljs-regexp">//</span>整类型。如果不是，则会报错。因此必须在pImpl被析构前，确保Impl被定义（即是个完整类型）<br>                                 <span class="hljs-regexp">//</span>因此，使用unique_ptr&lt;非完整类型时&gt;，必须为该类同时定义析构函数！具体原因见后面的分析。<br><br>    <span class="hljs-regexp">//</span>std::shared_ptr&lt;Impl&gt; pImpl; <span class="hljs-regexp">//</span>由于删除器不是shared_ptr类型的组成部分。当pImpl被析构时，不会判断T是否为完整类型。<br>                                   <span class="hljs-regexp">//</span>因此，不要求Widget必须自定义析构函数。<br><br>public:<br>    Widget();<br>    ~Widget(); <span class="hljs-regexp">//</span>Impl是个非完整类型，这里必须声明析构函数，并在Widget.cpp中实现它。<br>                <span class="hljs-regexp">//</span>注意，不能在该文件中实现，因为此时unique_ptr看到的Impl是个非完整类型，unique_ptr内部要求<span class="hljs-keyword">delete</span>前，其<br>                <span class="hljs-regexp">//</span>其指向的必须是个完整类的指针。<br><br>    <span class="hljs-regexp">//</span>移动构造和移动赋值（由于自定义了析构函数，所以编译器不再提供默认的移动构造和移动赋值函数，这里需手动填加）<br>    Widget(Widget&amp;&amp; rhs); <span class="hljs-regexp">//</span>只能声明，须放在.cpp中去实现。编译器会在move构造函数内抛出异常的事件中生成析构pImpl代码，<br>                          <span class="hljs-regexp">//</span>而此处Impl为非完整类型。<br>    Widget&amp; operator=(Widget&amp;&amp; rhs); <span class="hljs-regexp">//</span>只能声明，须放在.cpp中去实现。因为移动赋值pImpl时，需要先析构pImpl所指对象，但<br>                                     <span class="hljs-regexp">//</span>此时仍为非完整类型。<br><br>    <span class="hljs-regexp">//</span>让Widget支持复制操作。注意unique_ptr不可复制<br>    Widget(const Widget&amp; rhs);  <span class="hljs-regexp">//</span>仅声明<br>    Widget&amp; operator=(const Widget&amp; rhs); <span class="hljs-regexp">//</span>仅声明<br>&#125;;<br><br><span class="hljs-comment">#endif // ! _WIDGET_H_</span><br><br>Widget.h<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Widget.h&quot;</span></span><br><br><span class="hljs-comment">//将对string和vector和Gadget头文件的依赖从Wigdget.h转移动Wigdget.cpp文件中。如此，Widget类的使用者</span><br><span class="hljs-comment">//只需依赖Widget.h，而把复杂的依赖关系留给Widget的实现者(Widget.cpp)去处理</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gadget</span> &#123;</span>&#125;; <span class="hljs-comment">//本应#include &quot;Gardget.h&quot;，但为了简明起见，就直接在这里声明该类</span><br><br><span class="hljs-comment">//Widget::Impl的实现(包括此前在Widget中的数据成员)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span>:</span>:Impl<br>&#123;<br>    std::string name;<br>    std::vector&lt;<span class="hljs-keyword">double</span>&gt; data;<br>    Gadget g1, g2, g3;<br>&#125;;<br><br>Widget::<span class="hljs-built_in">Widget</span>():<span class="hljs-built_in">pImpl</span>(std::make_unique&lt;Impl&gt;())<br>&#123;&#125;<br><br><span class="hljs-comment">//注意：析构函数必须在Widget::Impl类之后定义。因为此时调用~Widget时，会调用unique_ptr的析构函数</span><br><span class="hljs-comment">//而unique_ptr中会调用delete删除其指向的对象，由于~Widget定义在Widget::Impl之后，因此这时看到的</span><br><span class="hljs-comment">//Impl是个完整的类，delete前通过了unique_ptr内部完整类型的判断！</span><br>Widget::~<span class="hljs-built_in">Widget</span>() &#123;&#125;<span class="hljs-comment">//或Widget::~Widget = default;</span><br><br>Widget::<span class="hljs-built_in">Widget</span>(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;<br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-comment">//make_unique(Ts&amp;&amp;... params)== std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Ts&gt;(params)...));</span><br>Widget::<span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">const</span> Widget&amp; rhs):<span class="hljs-built_in">pImpl</span>(std::make_unique&lt;Impl&gt;(*rhs.pImpl))<span class="hljs-comment">//深拷贝！</span><br>&#123;<br>&#125;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Widget&amp; rhs)<br>&#123;<br>    *pImpl = *rhs.pImpl; <span class="hljs-comment">//深拷贝！复制两个指针所指向的内容。pImpl本身是只移动类型</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;iostream&gt;<br>#<span class="hljs-keyword">include</span> &lt;memory&gt;<br>#<span class="hljs-keyword">include</span> &lt;functional&gt;<br>#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Widget.h&quot;</span><br>using namespace std;<br><br>enum <span class="hljs-keyword">class</span> InvestmentType &#123;itSock, itBond, itRealEstate&#125;;<br><span class="hljs-keyword">class</span> Investment<span class="hljs-comment">//投资</span><br>&#123;<br>public:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-constructor">Investment()</span> &#123;&#125; <span class="hljs-comment">//声明为virtual,以便正确释放子类对象</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> Stock : public Investment &#123;&#125;;<span class="hljs-comment">//股票</span><br><span class="hljs-keyword">class</span> Bond : public Investment &#123;&#125;;  <span class="hljs-comment">//债券</span><br><span class="hljs-keyword">class</span> RealEstate : public Investment &#123;&#125;; <span class="hljs-comment">//不动产</span><br><br>void make<span class="hljs-constructor">LogEntry(Investment<span class="hljs-operator">*</span> <span class="hljs-params">pInvmt</span>)</span> &#123;&#125;<br><br><span class="hljs-comment">//工厂函数</span><br>template&lt;typename... Ts&gt;<br>auto make<span class="hljs-constructor">Investment(Ts<span class="hljs-operator">&amp;&amp;</span><span class="hljs-operator">...</span> <span class="hljs-params">params</span>)</span> <span class="hljs-comment">//返回unique_ptr智能指针</span><br>&#123;<br>    <span class="hljs-comment">//自定义deleter</span><br>    auto delInvmt = <span class="hljs-literal">[]</span>(Investment* pInvmt) <span class="hljs-comment">//父类指针</span><br>    &#123;<br>        make<span class="hljs-constructor">LogEntry(<span class="hljs-params">pInvmt</span>)</span>;<br>        delete pInvmt; <span class="hljs-comment">//delete父类指针，所有析构函数须声明为virtual</span><br>    &#125;;<br><br>    std::unique_ptr&lt;Investment, decltype(delInvmt)&gt; p<span class="hljs-constructor">Inv(<span class="hljs-params">nullptr</span>, <span class="hljs-params">delInvmt</span>)</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span><span class="hljs-comment">/*a Stock Object should be created*/</span>) &#123;<br>        pInv.reset(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Stock(<span class="hljs-params">std</span>::<span class="hljs-params">forward</span>&lt;Ts&gt;(<span class="hljs-params">params</span>)</span>...)); <span class="hljs-comment">//原始指针无法隐式转为unique_ptr，使用reset重置所有权</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span><span class="hljs-comment">/*a Bond Object should be created*/</span>)<br>    &#123;<br>        pInv.reset(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Bond(<span class="hljs-params">std</span>::<span class="hljs-params">forward</span>&lt;Ts&gt;(<span class="hljs-params">params</span>)</span>...));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span><span class="hljs-comment">/*a RealEstate should be created*/</span>)<br>    &#123;<br>        pInv.reset(<span class="hljs-keyword">new</span> <span class="hljs-constructor">RealEstate(<span class="hljs-params">std</span>::<span class="hljs-params">forward</span>&lt;Ts&gt;(<span class="hljs-params">params</span>)</span>...));<br>    &#125;<br><br>    return pInv;<br>&#125;<br><br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>    <span class="hljs-comment">//1. unique_ptr作为工厂函数的返回值。</span><br>    std::shared_ptr&lt;Investment&gt; sp =  make<span class="hljs-constructor">Investment()</span>;  <span class="hljs-comment">//从std::unique_ptr转换到std::shared_ptr（从独占到共享的</span><br>                                                         <span class="hljs-comment">//转换简单而高效） </span><br><br>    <span class="hljs-comment">//2. PImpl手法的测试</span><br>    Widget w;  <span class="hljs-comment">//注意Widget的析构函数必须手动实现。否则，则当w析构时编译器会将默认的析构函数inline</span><br>               <span class="hljs-comment">//到这里来，但由于include widget.h在inline动作之前，此时编译器看到的是非完整类型的</span><br>               <span class="hljs-comment">//Impl类。因此Widget类中的unique_ptr析构时，delete前检查出是个非完整类指针，从而报错。</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-shared-ptr"><a href="#2-shared-ptr" class="headerlink" title="2. shared_ptr"></a>2. shared_ptr</h1><h2 id="2-1-shared-ptr-的基本用法"><a href="#2-1-shared-ptr-的基本用法" class="headerlink" title="2.1 shared_ptr 的基本用法"></a>2.1 shared_ptr 的基本用法</h2><h3 id="2-1-1-与unique-ptr的比较"><a href="#2-1-1-与unique-ptr的比较" class="headerlink" title="2.1.1 与unique_ptr的比较"></a>2.1.1 与unique_ptr的比较</h3><table><thead><tr><th>比较</th><th>shared_ptr</th><th>unique_ptr</th><th>备注</th></tr></thead><tbody><tr><td>初始化</td><td>①shared_ptr<T> sp; sp.reset(new T());②shared_ptr<T> sp(new T());③shared_ptr<T> sp1 = sp; **//**<strong>拷贝构造</strong>④auto sp = make_shared<int>(10);</td><td>①unique_ptr<T> up; up.reset(new T());②unique_ptr<T> up(new T());③unique_ptr<T> up1 = std::move(up);**//**<strong>移动构造</strong>④auto up = make_unique<int>(10);</td><td>两者的构造函数将声明为<strong>explicit，即不允许隐式类型转换，</strong>如shared_ptr<int> sp = new int(10);</td></tr><tr><td>条件判断</td><td>如，if(sp){…}</td><td>如，if(up){…}</td><td>两都均<strong>重载operator bool()</strong></td></tr><tr><td>解引用</td><td>*sp</td><td>*up</td><td>解引用，获得它所指向的对象</td></tr><tr><td>-&gt;mem</td><td>sp-&gt;mem</td><td>up-&gt;mem</td><td>重载-&gt;运算符</td></tr><tr><td>get()</td><td>sp.get()</td><td>up.get()</td><td>返回智能指针中保存的裸指针，要小心使用。</td></tr><tr><td>p.swap(q)</td><td>sp.swap(q);</td><td>up.swap(q);</td><td>交换p和q指针</td></tr><tr><td>独有操作</td><td>①shared_ptr<T> p(q);//拷贝构造②p = q;//赋值③p.unique();若p.use_count()为1，返回true,否则返回false。④p.use_count()//返回强引用计数</td><td>①up=nullptr;释放up指向的对象，并将up置空。②up.release();//up<strong>放弃对指针的控制权，返回裸指针，并将up置空</strong>③up.reset();释放up指向的对象。 up.reset(q);其中q为裸指针。令up指向q所指对象。 up.reset(nullptr);置空</td><td>注意:①unique_ptr<strong>不可拷贝和赋值，但可以被移动</strong>。②release会切断unique_ptr和它原来管理的对象间的联系。<strong>通常用来初始化另一个智能指针</strong>。</td></tr></tbody></table><h3 id="2-1-2-指定删除器"><a href="#2-1-2-指定删除器" class="headerlink" title="2.1.2 指定删除器"></a>2.1.2 指定删除器</h3><ol><li><p>shared_ptr<T> sp1(q, deleter1);与unique_ptr不同，<strong>删除器不是shared_ptr类型的组成部分</strong>。假设，shared_ptr<T> sp2(q,deleter2)，尽管sp1和sp2有着不同的删除器，但两者的类型是一致的，都可以被放入vector&lt;shared_ptr<T>&gt;类型的同一容器里。</p></li><li><p>与std::unique_ptr不同，自定义删除器不会改变std::shared_ptr的大小。<strong>其始终是祼指针大小的两倍</strong>。</p></li><li><p>当使用shared_ptr<strong>管理动态数组</strong>时，需要指定删除器。因为默认删除器不支持数组对象。如shared_ptr<int> sp(new int[10], std::default_delete&lt;**int[]**&gt;);</p><p> 数组删除器示例1：</p> <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> main()<br>    &#123;<br>           shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], default_delete&lt;<span class="hljs-type">int</span>[]&gt;());<br>           // shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr(<span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span>* p) &#123;<span class="hljs-keyword">delete</span>[]p; &#125;);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 对象删除器示例2：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 自定义删除器函数，释放int型内存</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteIntPtr</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">delete</span> p;<br>cout &lt;&lt; <span class="hljs-string">&quot;int 型内存被释放了...&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">250</span>), deleteIntPtr)</span></span>;<br><span class="hljs-comment">// 删除器为 lambda 表达式</span><br><span class="hljs-comment">// shared_ptr&lt;int&gt; ptr(new int(250), [](int* p) &#123;delete p; &#125;); </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>删除器可以是普通函数、函数对象和lambda表达式等。默认的删除器为std::default_delete，其内部是通过delete来实现功能的。</p></li></ol><h2 id="2-2-剖析-std-shared-ptr"><a href="#2-2-剖析-std-shared-ptr" class="headerlink" title="2.2 剖析 std::shared_ptr"></a>2.2 剖析 std::shared_ptr</h2><h3 id="2-2-1-std-shared-ptr-的内存模型"><a href="#2-2-1-std-shared-ptr-的内存模型" class="headerlink" title="2.2.1 std::shared_ptr 的内存模型"></a>2.2.1 std::shared_ptr 的内存模型</h3><img src="/2021/08/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/11unique_ptr%E5%92%8Cshared_ptr%E5%8F%8Aweak_ptr%E7%9A%84%E4%BD%BF%E7%94%A8/2.png" class=""><p>　　1. shared_ptr包含了<strong>一个指向对象的指针和一个指向控制块的指针</strong>。每一个由std::shared_ptr管理的对象都有一个<strong>控制块</strong>，它除了<strong>包含引用计数之外，还包含了自定义删除器的副本和分配器的副本以及其他附加数据</strong>。<br>　　2. 控制块的创建规则：<br>　　（1）<strong>std::make_shared总是创建一个控制块</strong>。</p><p>　　（2）从<strong>具备所有权的指针出发构造一个std::shared_ptr时，会创建一个控制块</strong>。（如std::unique_ptr转为shared_ptr时会创建控制块，因为unique_ptr本身不使用控制块，同时unique_ptr置空）</p><p>　　（3）<strong>当std::shared_ptr构造函数使用裸指针作为实参时，会创建一个控制块</strong>。这意味从同一个裸指针出发来构造不止一个std::shared_ptr时会创建多重的控制块，也意味着对象会被析构多次。如果想从一个己经拥有控制块的对象出发创建一个std::shared_ptr，可以传递一个shared_ptr或weak_ptr而非裸指针作为构造函数的实参，这样则不会创建新的控制块。</p><p>　　3. 引用计数（强引用计数）</p><p>　　（1）<strong>shared_ptr的构造函数会使该引用计数递增</strong>，而<strong>析构函数会使该计数递减</strong>。但移动构造时表示从一个己有的shared_ptr移动构造到一个新的shared_ptr。这意味着一旦新的shared_ptr产生后，原有的shared_ptr会被置空，其结果是引用计数没有变化。</p><p>　　（2）<strong>复制赋值同时执行两种操作</strong>（如sp1 和sp2是指向不同对象的shared_ptr，则sp1 = sp2时，将修改sp1使得其指向sp2所指的对象。而最初sp1所指向的对象的引用计数递减，同时sp2所指向的对象引用计数递增）</p><p>　　（3）reset函数，如果不带参数时，则引用计数减1。如果不带参数时，如sp.reset(p)则sp原来指向的对象引用计数减1，同时sp指向新的对象(p)</p><p>　　（4）<strong>如果实施一次递减后最后的引用计数变成0，即不再有shared_ptr指向该对象，则会被shared_ptr析构掉</strong>。</p><p>　　（5）引用计数的递增和递减是<strong>原子操作</strong>，即允许不同线程并发改变引用计数。</p><p>shared_ptr的陷阱分析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span> <span class="hljs-comment">// for smart pointer</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>&#123;</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(shared_ptr&lt;Widget&gt; sp)</span></span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">funcException</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/*throw 1;*/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125; <span class="hljs-comment">//假设该函数会抛出异常</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; sp, <span class="hljs-keyword">int</span> f)</span></span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1. 陷阱：用同一裸指针创建多个shared_ptr</span><br>    <span class="hljs-comment">//1.1 错误做法</span><br>    <span class="hljs-keyword">auto</span> pw = <span class="hljs-keyword">new</span> Widget;<br>    <span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw1</span><span class="hljs-params">(pw)</span></span>; <span class="hljs-comment">//强引用计数为1，为pw创建一个控制块</span><br>    <span class="hljs-comment">//std::shared_ptr&lt;Widget&gt; spw2(pw); //强引用计数为1，为pw创建另一个新的控制块，会导致多次析构</span><br><br>    <span class="hljs-keyword">auto</span> sp = <span class="hljs-keyword">new</span> Widget;<br>    <span class="hljs-built_in">func</span>(shared_ptr&lt;Widget&gt;(sp)); <span class="hljs-comment">//慎用裸指针，sp将在func结束后被释放！</span><br><br>    <span class="hljs-comment">//1.2 正确做法</span><br>    <span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw3</span><span class="hljs-params">(spw1)</span></span>; <span class="hljs-comment">//ok，pw的强引用计数为2。使用与spw1同一个控制块。</span><br>    <span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>; <span class="hljs-comment">//将new的结果直接传递给shared_ptr</span><br>    std::shared_ptr&lt;Widget&gt; spw5 = std::make_shared&lt;Widget&gt;(); <span class="hljs-comment">//强烈推荐的做法!</span><br>    <br>    <span class="hljs-comment">//2. 陷阱：在函数实参中创建shared_ptr</span><br>    <span class="hljs-comment">//2.1 shared_ptr与异常安全问题</span><br>    <span class="hljs-comment">//由于参数的计算顺序因编译器和调用约定而异。假定按如下顺序计算</span><br>    <span class="hljs-comment">//A.先前new int，然后funcException();</span><br>    <span class="hljs-comment">//B.假设恰好此时funcException产生异常。</span><br>    <span class="hljs-comment">//C.因异常出现shared_ptr还来不及创建，于是int内存泄露</span><br>    <span class="hljs-built_in">demo</span>(shared_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">100</span>)), <span class="hljs-built_in">funcException</span>());<br><br>    <span class="hljs-comment">//2.2 正确做法</span><br>    <span class="hljs-keyword">auto</span> p1 = std::make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">demo</span>(p1, <span class="hljs-built_in">funcException</span>());<br><br>    <span class="hljs-comment">//3. 陷阱：shared_ptr的循环引用（应避免）（见第22课 weak_ptr）</span><br><br>    <span class="hljs-comment">//4. 删除器</span><br>    <span class="hljs-keyword">auto</span> deleter1 = [](Widget* pw) &#123;cout &lt;&lt; <span class="hljs-string">&quot;deleter1&quot;</span>&lt;&lt; endl; <span class="hljs-keyword">delete</span> pw; &#125;;<br>    <span class="hljs-keyword">auto</span> deleter2 = [](Widget* pw) &#123;cout &lt;&lt; <span class="hljs-string">&quot;deleter2&quot;</span>&lt;&lt; endl; <span class="hljs-keyword">delete</span> pw; &#125;;<br><br>    <span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, deleter1)</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget, deleter2)</span></span>;<br><br>    <span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw3</span><span class="hljs-params">(pw1)</span></span>;<br>    pw3.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Widget); <span class="hljs-comment">//deleter恢复为默认的std::default_delete</span><br><br>    vector&lt;std::shared_ptr&lt;Widget&gt;&gt; vecs;<br>    vecs.<span class="hljs-built_in">emplace_back</span>(pw1);<br>    vecs.<span class="hljs-built_in">emplace_back</span>(pw2); <span class="hljs-comment">//pw1和pw2虽然有不同的删除器，但类型相同，可以放入同一容器内。</span><br><br>    <span class="hljs-comment">//5. 其它</span><br>    <span class="hljs-comment">//5.1 shared_ptr的大小</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(spw1) &lt;&lt; endl;<span class="hljs-comment">//8</span><br>    cout &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pw1) &lt;&lt; endl; <span class="hljs-comment">//8</span><br>    <span class="hljs-comment">//5.2 shared_ptr管理动态数组（建议用std::array、std::vector取代）</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pArray1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-keyword">int</span>* p) &#123;<span class="hljs-keyword">delete</span>[] p; &#125;)</span></span>; <span class="hljs-comment">//使用delete[]</span><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">pArray2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>], std::default_delete&lt;<span class="hljs-keyword">int</span>[]&gt;())</span></span>; <span class="hljs-comment">//使用default_delete&lt;int[]&gt;()</span><br>    <span class="hljs-comment">//5.3 常见操作</span><br>    cout &lt;&lt; pw1.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//2</span><br><br>    <span class="hljs-keyword">if</span> (pw1) <span class="hljs-comment">//pw1.use_count &gt;= 1 ?</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;pw1.use_count &gt;= 1&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;pw1.use_count == 0&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">//5.4 别名构造</span><br>    <span class="hljs-keyword">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">20</span>))</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(a, p)</span></span>;  <span class="hljs-comment">// alias constructor: co-owns a, points to p。可用于多继承中</span><br>                                   <span class="hljs-comment">// a 和 b拥用相同的控制块，但两者指向的对象不同。由于两者拥用相同的</span><br>                                   <span class="hljs-comment">//的控制块，可认为a和b所指对象具有相同的拥有者，因此10和20两个堆对象</span><br>                                   <span class="hljs-comment">//拥有相同的生命期</span><br>    cout &lt;&lt; *a &lt;&lt; endl; <span class="hljs-comment">//20</span><br>    cout &lt;&lt; *b &lt;&lt; endl; <span class="hljs-comment">//10</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-enable-shared-from-this-模板的分析"><a href="#2-2-2-enable-shared-from-this-模板的分析" class="headerlink" title="2.2.2 enable_shared_from_this 模板的分析"></a>2.2.2 enable_shared_from_this 模板的分析</h3><p><strong>（一）模板分析（以boost::enable_shared_from_this为例）</strong></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">template&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-keyword">class</span> enable<span class="hljs-number">_</span><span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span><br>&#123;<br>protected:<br><br>    enable<span class="hljs-number">_</span><span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span>() BOOST<span class="hljs-number">_</span>NOEXCEPT<br>    &#123;<br>    &#125;<br><br>    enable<span class="hljs-number">_</span><span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span>(enable<span class="hljs-number">_</span><span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span> const &amp;) BOOST<span class="hljs-number">_</span>NOEXCEPT<br>    &#123;<br>    &#125;<br><br>    enable<span class="hljs-number">_</span><span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span> &amp; operator=(enable<span class="hljs-number">_</span><span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span> const &amp;) BOOST<span class="hljs-number">_</span>NOEXCEPT<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~enable<span class="hljs-number">_</span><span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span>() BOOST<span class="hljs-number">_</span>NOEXCEPT <span class="hljs-comment">// ~weak_ptr&lt;T&gt; newer throws, so this call also must not throw</span><br>    &#123;<br>    &#125;<br><br>public:<br><br>    <span class="hljs-keyword">shared</span><span class="hljs-number">_p</span>tr&lt;T&gt; <span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span>()<br>    &#123;<br>        <span class="hljs-keyword">shared</span><span class="hljs-number">_p</span>tr&lt;T&gt; p( weak<span class="hljs-number">_</span><span class="hljs-keyword">this</span><span class="hljs-number">_</span> );<br>        BOOST<span class="hljs-number">_</span>ASSERT( p.get() == <span class="hljs-keyword">this</span> );<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-keyword">shared</span><span class="hljs-number">_p</span>tr&lt;T const&gt; <span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span>() const<br>    &#123;<br>        <span class="hljs-keyword">shared</span><span class="hljs-number">_p</span>tr&lt;T const&gt; p( weak<span class="hljs-number">_</span><span class="hljs-keyword">this</span><span class="hljs-number">_</span> );<br>        BOOST<span class="hljs-number">_</span>ASSERT( p.get() == <span class="hljs-keyword">this</span> );<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>public: <span class="hljs-comment">// actually private, but avoids compiler template friendship issues</span><br><br>    <span class="hljs-comment">// Note: invoked automatically by shared_ptr; do not call</span><br>    template&lt;<span class="hljs-keyword">class</span> X, <span class="hljs-keyword">class</span> Y&gt; <span class="hljs-keyword">void</span> <span class="hljs-number">_</span>internal<span class="hljs-number">_</span>accept<span class="hljs-number">_</span>owner( <span class="hljs-keyword">shared</span><span class="hljs-number">_p</span>tr&lt;X&gt; const * ppx, Y * py ) const<br>    &#123;<br>        <span class="hljs-keyword">if</span>( weak<span class="hljs-number">_</span><span class="hljs-keyword">this</span><span class="hljs-number">_</span>.expired() )<br>        &#123;<br>            weak<span class="hljs-number">_</span><span class="hljs-keyword">this</span><span class="hljs-number">_</span> = <span class="hljs-keyword">shared</span><span class="hljs-number">_p</span>tr&lt;T&gt;( *ppx, py );<br>        &#125;<br>    &#125;<br><br>private:<br><br>    mutable weak<span class="hljs-number">_p</span>tr&lt;T&gt; weak<span class="hljs-number">_</span><span class="hljs-keyword">this</span><span class="hljs-number">_</span>;<br>&#125;;<br><br>boost::enable<span class="hljs-number">_</span><span class="hljs-keyword">shared</span><span class="hljs-number">_f</span>rom<span class="hljs-number">_</span><span class="hljs-keyword">this</span><br></code></pre></td></tr></table></figure><ol><li><p>enable_shared_from_this模板类提供两个public属性的shared_from_this成员函数。这两个函数内部会通过weak_this_（weak_ptr类型）成员来创建shared_ptr。</p></li><li><p><em>internal_accept_owner函数不能手动调用，这个**函数会被shared_ptr自动调用，该函数是用来初始化唯一的成员变量weak_this</em>**。</p></li><li><p>根据对象生成顺序，先初始化基类enable_shared_from_this，再初始化派生类对象本身。这时对象己经生成，但weak_this_成员还未被初始化，最后<strong>应通过shared_ptr<T> sp(new T())等方式调用shared_ptr构造函数(内部会调用_internal_accept_owner)来初始化weak_this_成员</strong>。而<strong>如果在调用shared_from_this函数之前weak_this_成员未被初始化，则会通过ASSERT报错提示。</strong></p></li></ol><p>** 使用说明**</p><ol><li>基类必须为enable_shared_from_this<T>，其中<strong>T为派生类的类名</strong>。（这种方法叫奇妙递归模板模式）</li><li>通过调用shared_from_this()成员函数获得一个和this指针指向相同对象的shared_ptr。</li><li>从内部实现看，shared_from_this会查询当前对象的控制块，并创建一个指向该控制块的新shared_ptr。这样的设计就要求当前对象己有一个与其关联的控制块。为了实现这一点，就必须有一个己经存在指向当前对象的std::shared_ptr，如果不存在，则通常shared_from_this会抛出异常。</li><li>从enable_shared_from_this继承的类，在构造函数中不能调用shared_from_this()获取智能指针，因为构造过程中weak_this_成员还未被初始化，所以会报异常  <strong>what():  bad_weak_ptr</strong></li></ol><p>安全地从this指针创建shared_ptr</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//1. 从this指针创建shared_ptr</span><br><span class="hljs-comment">//1.1 错误的做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Test1</span>() &#123; cout &lt;&lt;<span class="hljs-string">&quot;~Test1()&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-comment">//获取指向当前对象的指针</span><br>    <span class="hljs-function">std::shared_ptr&lt;Test1&gt; <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">shared_ptr&lt;Test1&gt; <span class="hljs-title">pTest</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>; <span class="hljs-comment">//危险！ 直接从this指针创建，会为this对象创建新的控制块！</span><br>                                       <span class="hljs-comment">//从而可能导致this所指对象被多次析构</span><br>        <span class="hljs-keyword">return</span> pTest;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//1.2 正确的做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> :</span> <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Test2&gt; <span class="hljs-comment">//继承！ 注意Test2为基类的模板参数  (递归模板模式)</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Test2</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;~Test2()&quot;</span> &lt;&lt; endl; &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;Test2&gt; <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); <span class="hljs-comment">//调用enable_shared_from_this模板的成员函数，获取this对象的shared_ptr</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//2. shared_from_this函数的正确调用</span><br><span class="hljs-comment">//2.1 一般做法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> :</span> <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Test3&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数中不能使用shared_from_this</span><br>    <span class="hljs-built_in">Test3</span>()<br>    &#123;<br>        <span class="hljs-comment">//std::shared_ptr&lt;Test3&gt; sp = shared_from_this(); //error，此时基类（enable_shared_from_this&lt;Test3&gt;）</span><br>                                                          <span class="hljs-comment">//虽己构造完，但shared_ptr的构造函数还没被调用，weak_this_指针</span><br>                                                          <span class="hljs-comment">//未被初始化，因此调用shared_from_this会抛出异常</span><br>    &#125;<br><br>    <span class="hljs-comment">//调用process之前，必须确保shared_ptr的构造函数己被执行（即weak_this_被初始化）</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;Test3&gt; sp = <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//2.2 改进做法：利用工厂函数来提供shared_ptr</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> :</span> <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Test4&gt;<br>&#123;<br>    <span class="hljs-built_in">Test4</span>() &#123;&#125;  <span class="hljs-comment">//构造函数设为private</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">//提供工厂函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Ts&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">static</span> std::shared_ptr&lt;Test4&gt; <span class="hljs-title">create</span><span class="hljs-params">(Ts&amp;&amp; ... params)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::shared_ptr&lt;Test4&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test4(params...))</span></span>;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;Test4&gt; sp = <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//3. enable_shared_from_this的应用举例</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span>;</span><br>std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processWidgets; <span class="hljs-comment">//记录己被处理过的Widgets</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> :</span> <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Widget&gt; <span class="hljs-comment">//需要从这里继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//错误做法：直接将this传给shared_ptr&lt;Widget&gt;</span><br>        <span class="hljs-comment">//processWidgets.emplace_back(this); //将处理完的Widget加入链表。</span><br>                                             <span class="hljs-comment">//error，这种做法本质上是用裸指针来创建shared_ptr，会为this对象创建</span><br>                                             <span class="hljs-comment">//新的控制块。如果外部new Widget时，也将指针交给shared_ptr管理时，会出现为同</span><br>                                             <span class="hljs-comment">//一个this对象创建多个控制块，从而造成this对象的多次析构！</span><br><br>        <span class="hljs-comment">//正确做法：（为了确保shared_from_this在shared_ptr构造函数后被调用，可以采用工厂函数的方式来创建Widget，</span><br>        <span class="hljs-comment">//具体见前面的例子）</span><br>        processWidgets.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">shared_from_this</span>()); <span class="hljs-comment">//将指向当前对象的shared_ptr加入到链表中</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">Widget</span>() &#123; cout &lt;&lt;<span class="hljs-string">&quot;~Widget()&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.  从this指针创建shared_ptr</span><br>    <span class="hljs-comment">//1.1 错误做法：对象被多次析构</span><br>    &#123;<br>        <span class="hljs-comment">//std::shared_ptr&lt;Test1&gt; pt1(new Test1());</span><br>        <span class="hljs-comment">//std::shared_ptr&lt;Test1&gt; pt2 = pt1-&gt;getObject();</span><br>    &#125;<br><br>    <span class="hljs-comment">//1.2 正确做法</span><br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;Test2&gt; <span class="hljs-title">pt1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test2())</span></span>;<br>        std::shared_ptr&lt;Test2&gt; pt2 = pt1-&gt;<span class="hljs-built_in">getObject</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//2. shared_from_this的正确调用</span><br>    &#123;<br>        <span class="hljs-comment">//2.1 错误方法：</span><br>        Test3 t;<br>        <span class="hljs-comment">//t.process(); //错误，shared_ptr构造函数没有被执行</span><br><br>        Test3* pt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test3</span>();<br>        <span class="hljs-comment">//pt-&gt;process(); //错误，原因同上。</span><br>        <span class="hljs-keyword">delete</span> pt;<br><br>        <span class="hljs-comment">//正确做法</span><br>        <span class="hljs-function">std::shared_ptr&lt;Test3&gt; <span class="hljs-title">spt</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Test3)</span></span>; <span class="hljs-comment">//shared_ptr构造被执行,weak_this_被正确初始化</span><br>        spt-&gt;<span class="hljs-built_in">process</span>(); <br><br>        <span class="hljs-comment">//2.2 工厂方法提供shared_ptr，确保shared_ptr构造函数被执行！</span><br>        std::shared_ptr&lt;Test4&gt; spt2 = Test4::<span class="hljs-built_in">create</span>();<br>        spt2-&gt;<span class="hljs-built_in">process</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//3. enable_shared_from_this的应用举例</span><br>    &#123;<br>        <span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br>        sp-&gt;<span class="hljs-built_in">process</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-dynamic-pointer-cast-的使用"><a href="#2-3-dynamic-pointer-cast-的使用" class="headerlink" title="2.3 dynamic_pointer_cast 的使用"></a>2.3 dynamic_pointer_cast 的使用</h2><ol><li>dynamic_pointer_cast用于将子类的shared_ptr对象转为父类的 shared_ptr 对象，成功转换后的对象new_base和原始父对象base共享引用计数. </li><li>成功转后base对象的引用计数加一.</li><li>转换后的new_base对象的reset将导致原始对象的引用计数减一.且new_base的内容为NULL</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">base</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">base</span> ()&#123; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">base</span> () &#123; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">classC</span> :</span> <span class="hljs-keyword">public</span> base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">classC</span>() &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">classC</span> () &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_cast_fun</span><span class="hljs-params">(std::shared_ptr&lt;base&gt; new_base, std::shared_ptr&lt;classC&gt; &amp;child)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new_base.count=%d, child.count=%d\n&quot;</span>, new_base.<span class="hljs-built_in">use_count</span>(), child.<span class="hljs-built_in">use_count</span>());<br>    new_base.<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after new_base.reset new_base.count=%d, child.count=%d, new_base=%s \n&quot;</span>, new_base.<span class="hljs-built_in">use_count</span>(), child.<span class="hljs-built_in">use_count</span>(), <span class="hljs-literal">NULL</span>==new_base?<span class="hljs-string">&quot;NULL&quot;</span>:<span class="hljs-string">&quot;NOT_NULL&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> , <span class="hljs-keyword">char</span> *[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> c = std::make_shared&lt;classC&gt;();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;dynamic_pointer_cast 前 child.count=%d\n&quot;</span>, c.<span class="hljs-built_in">use_count</span>());<br>    <span class="hljs-built_in">test_cast_fun</span>(std::dynamic_pointer_cast&lt;base&gt;(c), c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;执行 reset 后 child=%s, c.count=%d\n&quot;</span>, c==<span class="hljs-literal">NULL</span>?<span class="hljs-string">&quot;NULL&quot;</span>:<span class="hljs-string">&quot;NOT NULL&quot;</span>, c.<span class="hljs-built_in">use_count</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dynamic_pointer_cast 前 child.<span class="hljs-attribute">count</span>=1<br>new_base.<span class="hljs-attribute">count</span>=2, child.<span class="hljs-attribute">count</span>=2<br>after new_base.reset new_base.<span class="hljs-attribute">count</span>=0, child.<span class="hljs-attribute">count</span>=1, <span class="hljs-attribute">new_base</span>=<span class="hljs-literal">NULL</span> <br>执行 reset 后 <span class="hljs-attribute">child</span>=NOT <span class="hljs-literal">NULL</span>, c.<span class="hljs-attribute">count</span>=1<br></code></pre></td></tr></table></figure><h2 id="2-4-使用总结"><a href="#2-4-使用总结" class="headerlink" title="2.4 使用总结"></a>2.4 使用总结</h2><ol><li>尽可能<strong>避免将裸指针传递给一个std::shared_ptr的构造函数</strong>，常用的替代手法是使用std::make_shared。</li><li>如果必须将一个裸指针传递给shared_ptr的构造函数，就<strong>直接传递new运算符的结果，而非传递一个裸指针变量</strong>。如shared_ptr<Widget> spw (new Widget, logginDel);</li><li><strong>不要将this指针返回给shared_ptr</strong>。当希望将this指针托管给shared_ptr时，类需要继承自std::enable_shared_from_this，并且从shared_from_this()中获得shared_ptr指针。</li><li>自定义删除器的shared_ptr对象在销毁函数中不能再调用自己的 shared_from_this 函数, 否则会引起崩溃</li><li>不建议使用<code>malloc()</code>分配内存来创建<code>shared_ptr</code>（或任何包含构造函数的对象），因为构造函数不会被调用：<code>malloc()</code> 仅分配内存，不会调用对象的构造函数。因此，如果使用 <code>malloc()</code> 创建包含 <code>shared_ptr</code> 或其他 C++ 对象的结构体，这些对象将不会被正确初始化。<code>new</code> 操作符则确保调用了构造函数，这样对象就可以被正确初始化。</li><li>可以将shared_ptr<T> 对象直接传递给函数参数const sahred_ptr<const T> &amp; 来防止对象和对象内容被修改</li><li>当shared_ptr对象作为set存储内容时，可以按以下方式来实现按内容的opereator&lt;排序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">set_shardptr_compare</span> &#123;</span><br> <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::shared_ptr&lt;T&gt;&amp; lhs, <span class="hljs-keyword">const</span> std::shared_ptr&lt;T&gt;&amp; rhs)</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> *lhs &lt; *rhs;<br> &#125;<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::set&lt;std::shared_ptr&lt;xxx&gt;, set_shardptr_compare&lt;xxx&gt;&gt; SET_SHARE;<br><br>SET_SHARE m_; <span class="hljs-comment">// set存储xxx类型shared_ptr内容, 并按存储内容operator &lt;实现排序</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="3-weak-ptr"><a href="#3-weak-ptr" class="headerlink" title="3. weak_ptr"></a>3. weak_ptr</h1><h2 id="3-1-weak-ptr的概况"><a href="#3-1-weak-ptr的概况" class="headerlink" title="3.1. weak_ptr的概况"></a>3.1. weak_ptr的概况</h2><h3 id="3-1-1-weak-ptr的创建"><a href="#3-1-1-weak-ptr的创建" class="headerlink" title="3.1.1 weak_ptr的创建"></a>3.1.1 weak_ptr的创建</h3><p>　　1. 直接初始化：weak_ptr<T> wp(sp); //其中sp为shared_ptr类型</p><p>　　2. 赋值： wp1 = sp; //其中sp为shared_ptr类型</p><p> 　　　　　　wp2 = wp1; //其中wp1为weak_ptr类型</p><h3 id="3-1-2-常用操作"><a href="#3-1-2-常用操作" class="headerlink" title="3.1.2 常用操作"></a>3.1.2 常用操作</h3><p>　　1. use_count()：获取当前控制块中资源的强引用计数。</p><p>　　2. expired()：判断所观测的资源<strong>是否失效</strong>（即己经被释放），即use_count是否为0。</p><p> 　　（1）shared_ptr<int> sp1 = wp.<strong>lock()</strong>;//<strong>如果wp失效,则sp为空</strong>（其中wp为weak_ptr类型）</p><p> 　　（2）shared_ptr<int> sp2(wp); //<strong>如果wp失效，则抛std::bad_weak_ptr异常</strong>。</p><p>　　3. lock()：<strong>获取所监视资源的shared_ptr</strong>，如shared_ptr<int> sp = wp.lock(); //wp为weak_ptr类型。</p><p>　　4. reset()：重置weak_ptr，<strong>影响弱引用计数</strong>。</p><h3 id="3-1-3-注意事项"><a href="#3-1-3-注意事项" class="headerlink" title="3.1.3 注意事项"></a>3.1.3 注意事项</h3><p>　　1. weak_ptr不是独立的智能指针，它是shared_ptr的助手，只是监视shared_ptr管理的资源是否释放，<strong>不会影响强引用计数</strong>，不能管理资源。</p><p>　　2.weak_ptr**没有重载操作符*和-&gt;**，因为它不共享指针，不能操作资源。</p><p>　　3.weak_ptr主要<strong>用来代替可能空悬的shared_ptr</strong>。</p><p>weak_ptr示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> sp1 = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-function">weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(sp1)</span></span>;  <span class="hljs-comment">//通过shared_ptr初始化</span><br>    weak_ptr&lt;<span class="hljs-keyword">int</span>&gt; wp1, wp2;<br>    wp1 = sp1;   <span class="hljs-comment">//利用shared_ptr来赋值</span><br>    wp2 = wp;    <span class="hljs-comment">//利用weak_ptr赋值</span><br>    <span class="hljs-keyword">auto</span> sp2 = wp2.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//sp2为shared_ptr类型</span><br><br>    sp1 = <span class="hljs-literal">nullptr</span>;<br><br>    cout &lt;&lt; wp2.<span class="hljs-built_in">use_count</span>() &lt;&lt; endl; <span class="hljs-comment">//1，强引用计数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-2-weak-ptr的应用"><a href="#3-2-weak-ptr的应用" class="headerlink" title="3.2 weak_ptr的应用"></a>3.2 weak_ptr的应用</h2><h3 id="3-2-1-缓存对象"><a href="#3-2-1-缓存对象" class="headerlink" title="3.2.1 缓存对象"></a>3.2.1 缓存对象</h3><p>　　1. 考虑一个工厂函数loadWidget，该函数基于唯一ID来创建一些指向只读对象的智能指针。</p><p>　　2. 假设该只读对象需要被频繁使用，而且经常需要从文件或数据库中加载。那么可以考虑将对象缓存起来。同时为了避免过量缓存，当不再使用时，则将该对象删除。</p><p>　　3. 由于带缓存，工厂函数返回unique_ptr类型显然不合适。因为调用者和缓存管理器均需要一个指向这些对象的指针。</p><p>　　4. 当用户用完工厂函数返回的对象后，该对象会被析构，此时相应的缓存条目将会空悬。因为可以<strong>考虑将工厂函数的返回值设定为shared_ptr类型，而缓存类型为weak_ptr类型</strong>。</p><h3 id="3-2-2-观察者模式"><a href="#3-2-2-观察者模式" class="headerlink" title="3.2.2 观察者模式"></a>3.2.2 观察者模式</h3><ol><li><p>观察者模式是在subject状态发生改变时，通知观察者的一种设计模式。</p></li><li><p>在多数实现中，<strong>每个subject持有指向观察者的指针</strong>，这使得当subject状态改变时可以很容易通知观察者。</p></li><li><p><strong>subject</strong>不会控制其观察者的生存期，因此应该是持有观察者的weak_ptr指针**。同时在subject的使用某个指针时，可以先确定是否空悬。</p></li></ol><h3 id="3-2-3-解决循环引用"><a href="#3-2-3-解决循环引用" class="headerlink" title="3.2.3 解决循环引用"></a>3.2.3 解决循环引用</h3> <img src="/2021/08/09/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/11unique_ptr%E5%92%8Cshared_ptr%E5%8F%8Aweak_ptr%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" class=""><p>　　1. A、B、C三个对象的数据结构中，A和C共享B的所有权，因此各持有一个指向B的std::shared_ptr;</p><p>　　2. 假设有一个指针从B指回A（<strong>即上图中的红色箭****头</strong>），则该指针的类型应为weak_ptr，而不能是裸指针或shared_ptr，原因如下：</p><p>　　　①假如是裸指针，当A被析构时，由于C仍指向B，所以B会被保留。但B中保存着指向A的空悬指针（野指针），而B却检测不出来，但解引用该指针时会产生未定义行为。</p><p>　　　②假如是shared_ptr时。由于A和B相互保存着指向对方的shared_ptr，此时会形成循环引用，从而阻止了A和B的析构。</p><p>　　　③假如是weak_ptr，这可以避免循环引用。假设A被析构，那么B的回指指针会空悬，但B可以检测到这一点，同时由于该指针是weak_ptr，不会影响A的强引用计数，因此当shared_ptr不再指向A时，不会阻止A的析构。</p><h3 id="3-2-4监视this智能指针"><a href="#3-2-4监视this智能指针" class="headerlink" title="3.2.4监视this智能指针"></a>3.2.4监视this智能指针</h3><p>见shared_ptr中的enable_shared_from_this，其中的weak_this_指针即为weak_ptr类型，用于监视this指针。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span> <span class="hljs-comment">//for smart pointer</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span> <span class="hljs-comment">//for unordered_map</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>(<span class="hljs-keyword">int</span> id):<span class="hljs-built_in">ID</span>(id)&#123;&#125;<br>    <br>    <span class="hljs-keyword">int</span> ID;<br>&#125;;<br><br><span class="hljs-comment">//1. 利用weak_ptr来缓存对象</span><br><span class="hljs-comment">//模拟从数据库中加载，并创建shared_ptr指向widget对象</span><br><span class="hljs-function">shared_ptr&lt;Widget&gt; <span class="hljs-title">loadWidget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> WidgetID)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> make_shared&lt;Widget&gt;(WidgetID); <br>&#125;<br><br><span class="hljs-comment">//带缓存的工厂函数</span><br><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-keyword">const</span> Widget&gt; <span class="hljs-title">fastloadWidget</span><span class="hljs-params">(<span class="hljs-keyword">int</span> WidgetID)</span> <span class="hljs-comment">//返回shared_ptr类型</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//缓存：weak_ptr类型</span><br>    <span class="hljs-keyword">static</span> std::unordered_map&lt;<span class="hljs-keyword">int</span>, std::weak_ptr&lt;<span class="hljs-keyword">const</span> Widget&gt;&gt; cache;<br><br>    <span class="hljs-keyword">auto</span> objPtr = cache[WidgetID].<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//objPtr的类型为shared_ptr，指向缓存的对象</span><br><br>    <span class="hljs-keyword">if</span> (!objPtr) &#123; <span class="hljs-comment">//如果对象不在缓存中. 这里省略了缓存中因失效而不断累积std::weak_ptr的处理。</span><br>        objPtr = <span class="hljs-built_in">loadWidget</span>(WidgetID);<br>        cache[WidgetID] = objPtr;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> objPtr;<br>&#125;<br><br><span class="hljs-comment">//2. 观察者模式</span><br><span class="hljs-comment">//2.1 观察者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherObservers</span> //抽象观察者</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateWeatherInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">//机场：具体观察者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Airport</span> :</span> <span class="hljs-keyword">public</span> WeatherObservers<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateWeatherInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt;<span class="hljs-string">&quot;Airport: &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//学校：具体观察者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">School</span> :</span> <span class="hljs-keyword">public</span> WeatherObservers<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateWeatherInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;School: &quot;</span> &lt;&lt; num &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//2.1 主题（气象站）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherStation</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> ObserverPtr = std::weak_ptr&lt;WeatherObservers&gt;; <span class="hljs-comment">//弱引用</span><br><br>    <span class="hljs-comment">//set集合中保存观察者的弱引用（以ObserverPtr为关键字，基于ownership排序）</span><br>    <span class="hljs-keyword">using</span> ObserverList = std::set&lt;ObserverPtr, std::owner_less&lt;ObserverPtr&gt;&gt;;<br><br>    ObserverList obs; <span class="hljs-comment">//保存所有观察者</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//注册观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ObserverPtr oPtr)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (obs.<span class="hljs-built_in">find</span>(oPtr) == obs.<span class="hljs-built_in">end</span>()) &#123;<br>            obs.<span class="hljs-built_in">insert</span>(oPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//注销观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unregisterObserver</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ObserverPtr oPtr)</span> <span class="hljs-comment">//oPtr为weak_ptr类型</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (obs.<span class="hljs-built_in">find</span>(oPtr) != obs.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            obs.<span class="hljs-built_in">erase</span>(oPtr);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//通知各个观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;WeatherObservers&gt; tempPtr;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; ob : obs)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ((tempPtr = ob.<span class="hljs-built_in">lock</span>())) &#123;<br>                tempPtr-&gt;<span class="hljs-built_in">updateWeatherInfo</span>(num);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//观察者模式</span><br>    WeatherStation station;<br>    <span class="hljs-function">std::shared_ptr&lt;Airport&gt; <span class="hljs-title">airport</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Airport())</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;School&gt;  <span class="hljs-title">school</span><span class="hljs-params">(<span class="hljs-keyword">new</span> School())</span></span>;<br><br>    station.<span class="hljs-built_in">registerObserver</span>(airport);<br>    station.<span class="hljs-built_in">registerObserver</span>(school);<br><br>    station.<span class="hljs-built_in">notifyObservers</span>(<span class="hljs-number">1</span>);<br><br>    station.<span class="hljs-built_in">unregisterObserver</span>(school);<br>    station.<span class="hljs-built_in">notifyObservers</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*输出结果</span><br><span class="hljs-comment">Airport: 1</span><br><span class="hljs-comment">School: 1</span><br><span class="hljs-comment">Airport: 2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/5iedu/p/11622401.html">https://www.cnblogs.com/5iedu/p/11622401.html</a><br><a href="https://www.cnblogs.com/5iedu/p/11623757.html">https://www.cnblogs.com/5iedu/p/11623757.html</a><br><a href="https://www.cnblogs.com/5iedu/p/11619357.html">https://www.cnblogs.com/5iedu/p/11619357.html</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针精髓</title>
    <link href="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/"/>
    <url>/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="1-指针的定义"><a href="#1-指针的定义" class="headerlink" title="1. 指针的定义"></a>1. 指针的定义</h2><p>程序运行时，每一个变量的数据都是保存在内存的一个确定位置，可以用&amp;操作符取得这个内存位置的值。32位操作系统上，这个值实际上就是一个32位的整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> iA = <span class="hljs-number">30</span>;<br>cout&lt;&lt;”iA变量的内存地址：”&lt;&lt;&amp;iA&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>有时候我们需要把这个地址也保存起来，以实现在程序中直接使用。如果每次都对变量取地址，显得不方便。更何况有的情况并没有明确的变量名称，比如动态分配的一块内存。这些内存地址的值都有必要得到保存，因此指针数据类型就闪亮登场了。简单的说：<br>指针是一个变量，保存的是一个内存地址。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int * pA = <span class="hljs-meta">&amp;iA;</span><br></code></pre></td></tr></table></figure><p>这就是定义一个int类型的指针变量pValue来保存iA这个整数的内存地址。</p><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/1.png" class=""><p>强烈建议指针变量用小写的p表示前缀（p是point的首字母）。</p><p>定义指针变量必须注意几点：<br>    1. 指针是对其他的数据类型的复合，指针变量必须指向同类型的变量的地址。比如不能写成：<br>    <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">double * pA = <span class="hljs-meta">&amp;iA;   <span class="hljs-comment">// 错误，iA是整数，和double *不兼容</span></span><br></code></pre></td></tr></table></figure><br>    2. 指针的*位置可以紧靠数据类型，也可以紧靠指针变量，也可以两者都不紧靠。所以下面的三种写法都是可以的：<br>    <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int *pA = <span class="hljs-meta">&amp;iA;   <span class="hljs-comment">// 这种写法支持者较多，有的公司编码规范表示推荐这样写</span></span><br>int * pA = <span class="hljs-meta">&amp;iA;   <span class="hljs-comment">// 这种写法支持者也不少</span></span><br>int* pA = <span class="hljs-meta">&amp;iA;</span><br></code></pre></td></tr></table></figure><br>    3. 指针是一个变量，可以先定义，然后再使用。<br>    <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> *pA = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">int</span> iA = <span class="hljs-number">200</span>;<br>pA = &amp;iA;<br></code></pre></td></tr></table></figure><br>第1行代码就是对先定义指针变量，并把其初始值定义为NULL。NULL其实就0值，用    NULL更偏向于表示指针初值的意义。指针变量里的值为0，意味着还没有指向任何整数变量的内存地址。<br>[编程好习惯]<br>指针变量赋于初值NULL，是编程好习惯的一个体现。有的人甚至支持对所有变量都养成赋予初值的习惯。</p><h2 id="2-指针的基本功能"><a href="#2-指针的基本功能" class="headerlink" title="2. 指针的基本功能"></a>2. 指针的基本功能</h2><p>指针变量的基本功能就是对指针所指向的内存地址的数据进行操作，包括读取数据和修改数据。这里要用到C++的又一个操作符号：取值操作符<em>。值得注意的是和定义指针变量的</em>一样，但取值操作符*不是用在指针变量的声明语句里，而是用在其他语句的指针变量前（紧靠变量）表示取该指针指向的变量的值。这个时候指针变量一定是早已定义好了的变量。<br>程序实例5-1：Point(指针的基本用法)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">5.</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">6.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">7.</span>&#123;<br><span class="hljs-number">8.</span><span class="hljs-keyword">int</span> iValue = <span class="hljs-number">300</span>;<br><span class="hljs-number">9.</span><span class="hljs-keyword">int</span> * pValue = &amp;iValue;<br><span class="hljs-number">10.</span>cout&lt;&lt;<span class="hljs-string">&quot;iValue的值:&quot;</span>&lt;&lt;iValue&lt;&lt;endl;                <span class="hljs-comment">// 输出300</span><br><span class="hljs-number">11.</span>cout&lt;&lt;<span class="hljs-string">&quot;通过pValue取值:&quot;</span>&lt;&lt;*pValue&lt;&lt;endl;          <span class="hljs-comment">// 输出300</span><br><span class="hljs-number">12.</span><br><span class="hljs-number">13.</span>*pValue = <span class="hljs-number">400</span>;<br><span class="hljs-number">14.</span>cout&lt;&lt;<span class="hljs-string">&quot;iValue的值:&quot;</span>&lt;&lt;iValue&lt;&lt;endl;               <span class="hljs-comment">// 输出400</span><br><span class="hljs-number">15.</span>cout&lt;&lt;<span class="hljs-string">&quot;通过pValue取值:&quot;</span>&lt;&lt;*pValue&lt;&lt;endl;        <span class="hljs-comment">// 输出400</span><br><span class="hljs-number">16.</span><br><span class="hljs-number">17.</span>     iValue = <span class="hljs-number">500</span>;<br><span class="hljs-number">18.</span>cout&lt;&lt;<span class="hljs-string">&quot;iValue的值:&quot;</span>&lt;&lt;iValue&lt;&lt;endl;                <span class="hljs-comment">// 输出500</span><br><span class="hljs-number">19.</span>cout&lt;&lt;<span class="hljs-string">&quot;通过pValue取值:&quot;</span>&lt;&lt;*pValue&lt;&lt;endl;         <span class="hljs-comment">// 输出500</span><br><span class="hljs-number">20.</span><br><span class="hljs-number">21.</span>&#125;<br></code></pre></td></tr></table></figure><p>从程序的运行结果可以看出，指针变量pValue指向iValue后，就可以通过<em>pValue去读数iValue的值。也可以通过对</em>pValue进行赋值达到修该iValue变量的值的效果。这些操作并没有通过iValue进行，而是通过指针变量pValue间接去操作它所指向的变量的数据。所以取值操作符号<em>也叫间访操作符号。间访就是间接访问的意思。<br>第14行代码通过iValue变量修改了本身的值，因为pValue在程序里一直指向该变量，变量本身值发生变化理所当然会影响后面到</em>pValue取值，所以第16行的*pValue取到的就是变化过的值了。</p><h2 id="3-指针指向数组"><a href="#3-指针指向数组" class="headerlink" title="3. 指针指向数组"></a>3. 指针指向数组</h2><p>数组的名称代表整个数组，其意义等价于一个指针，表示数组的首地址，也就是第一个元素的内存地址。因此，指针可以用来指向数组名称。比如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrA[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;<br><span class="hljs-attribute">Int</span> *pA = arrA;    // 注意arrA前不能再加取地址符&amp;<br></code></pre></td></tr></table></figure><p>其意义如下图所表示：</p><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/2.png" class=""><h2 id="4-指针指向动态分配内存"><a href="#4-指针指向动态分配内存" class="headerlink" title="4. 指针指向动态分配内存"></a>4. 指针指向动态分配内存</h2><p>一个良好的程序更偏重于运行时的灵活性，编译时对程序过多的限制会削弱程序的质量，有时候甚至降低程序的性能。比如定义一个整数数组来保存学生的成绩，但目前的问题是并不知道学生的数量，如果定义成int arrScore[50]能满足一般的要求，可是在特殊情况学生有200人呢，程序不得不修改成int arrScore[200]。此时对于大多数情况只用了不到50个空间的情况来言，就是对内存空间的浪费。<br>动态分配内存就是运行时在进程内存空间的自由储存区（也称为堆区）去申请实际可需的内存，然后用来保存数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> szName[] = “SunWuKong”;<br>cout&lt;&lt;” szName变量的内存地址：”&lt;&lt;(<span class="hljs-keyword">int</span> *)szName&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h3 id="4-1-C语言的动态分配内存"><a href="#4-1-C语言的动态分配内存" class="headerlink" title="4.1 C语言的动态分配内存"></a>4.1 C语言的动态分配内存</h3><p>C语言用malloc函数来实现内存的动态分配。比如申请100个int的内存空间：<br>int * pA = (int *)malloc( 100 * sizeof(int) );<br>这句代码用下图表示其意义：</p><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/3.png" class=""><p>Malloc函数返回一块申请成功的内存，这块内存并没有明确的变量来表示它。我们要使用这块内存，就必须用一定类型的指针去指向它（就是保存他的内存地址，从而知道这块风水宝地在哪里）。这也是C++程序里为什么有指针这种数据类型的原因之一。<br>使用malloc函数注意三点：<br>    - malloc函数返回的是void *指针，要赋予别的类型指针，必须强制转换。<br>    - 所需要的空间大小需要自己计算。<br>    - 动态分配的内存使用结束后用free函数释放，否则引起内存泄露。</p><h3 id="4-2-空类型指针void-的理解"><a href="#4-2-空类型指针void-的理解" class="headerlink" title="4.2 空类型指针void *的理解"></a>4.2 空类型指针void *的理解</h3><p>void *表示空类型指针，通常人们又简称为空指针，它仅仅单纯的保存一个内存地址，这个内存地址的数据是什么类型或者这个这个内存地址将要放什么类型的数据取决于后面的实现。Malloc函数返回的就是void *，因为新申请的内存用来装什么类型的数据往往是个未知数，如果你确定了用来装整数，就可以把void *强制转化成int *。如果你心血来潮，想用来装结构变量的数据，还可以转换成结构指针。<br>程序实例5-1：VoidPoint(空指针的应用理解)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">22.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">23.</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">24.</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagSTUDENT</span></span><br><span class="hljs-class">25.&#123;</span><br><span class="hljs-number">26.</span>    <span class="hljs-keyword">char</span> szName[<span class="hljs-number">20</span>];<br><span class="hljs-number">27.</span>    <span class="hljs-keyword">int</span>  iAge;<br><span class="hljs-number">28.</span>&#125; T_STUDENT, *PT_STUDENT;<br><span class="hljs-number">29.</span><br><span class="hljs-number">30.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">31.</span>&#123;<br><span class="hljs-number">32.</span><span class="hljs-keyword">void</span> * pA = <span class="hljs-built_in">malloc</span>( <span class="hljs-number">100</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) );<br><span class="hljs-number">33.</span><span class="hljs-keyword">int</span> * pScore = (<span class="hljs-keyword">int</span> *)pA;<br><span class="hljs-number">34.</span>*pScore = <span class="hljs-number">100</span>;<br><span class="hljs-number">35.</span>cout&lt;&lt;*pScore&lt;&lt;endl;                  <span class="hljs-comment">// 输出100</span><br><span class="hljs-number">36.</span>T_STUDENT tZhangSan = &#123;<span class="hljs-string">&quot; ZhangSan&quot;</span>, <span class="hljs-number">20</span>&#125;;<br><span class="hljs-number">37.</span>T_STUDENT * pStudent = (T_STUDENT *) pA;<br><span class="hljs-number">38.</span>*pStudent = tZhangSan;<br><span class="hljs-number">39.</span>cout&lt;&lt;(*pStudent).iAge&lt;&lt;endl;           <span class="hljs-comment">// 输出20</span><br><span class="hljs-number">40.</span>     <span class="hljs-built_in">free</span>(pA);<br><span class="hljs-number">41.</span>&#125;<br></code></pre></td></tr></table></figure><p>程序说明：<br>第12行先把申请到的内存强制转化成整型指针，说明准备用来装整数。第13行就是利用指针给空间赋一个整数值，然后在第14行输出。<br>第16行又把申请到的内存用来装一个学生的结构变量，所以先把void*强制转化成结构指针，然后通过第17行直接把一个结构变量赋予到pStudent所指向的内存里。<br>第18行的(*pStudent)是指针变量取值，因为pStudent是结构指针，所以取值取到的就是一个结构的数据。因为cout并没有能力直接输出一个结构的信息，所以通过点号输出结构里的指定成员的值。<br>第19行的free是释放动态分配的内存。<br>此例说明，动态分配的内存可以反复使用，怎么使用取决于程序业务逻辑的实现。</p><h3 id="4-3-C-的动态分配内存"><a href="#4-3-C-的动态分配内存" class="headerlink" title="4.3 C++的动态分配内存"></a>4.3 C++的动态分配内存</h3><p>C++采用new操作符在堆空间上申请动态内存，使用完后用delete释放。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> * pA = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;    <span class="hljs-comment">//申请一个整数大小的动态内存，然后用pA指向它。</span><br><span class="hljs-keyword">delete</span> pA;          <span class="hljs-comment">//使用完毕后释放动态分配的内存。</span><br></code></pre></td></tr></table></figure><p>指针也可以指向动态分配的数组空间，比如</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> * pA = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];  <br></code></pre></td></tr></table></figure><p>这里的pA指向一个动态分配的整数数组的首地址(即第1个元素的地址)，数组有5个元素。释放这样的内存是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">delete</span> []pA;         <span class="hljs-regexp">//</span>注意不能少了中括号[ ]<br></code></pre></td></tr></table></figure><p>值得注意的是[ ]不能写成()，比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> * pA = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">5</span>); <span class="hljs-comment">//这不是申请数组空间，而是申请一个整数空间，并赋予初值5。</span><br></code></pre></td></tr></table></figure><p>使用new动态分配内存注意：</p><ul><li>new和delete并不是函数，而是c++的操作符</li><li>new操作符号后必须指定数据类型，如果是数组空间，[ ]里的数字就表示这种数据类型的个数，而不是字节总的大小。</li><li>由于new操作符指明了数据类型，所以不需要强制转化，就可以用相应数据类型的指针来指向申请成功的动态内存。<h2 id="5-指针数组"><a href="#5-指针数组" class="headerlink" title="5. 指针数组"></a>5. 指针数组</h2>定义一个整数指针数组：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> * pA[<span class="hljs-number">3</span>]；int iA, iB, iC;  <br><span class="hljs-attribute">pA</span>[<span class="hljs-number">0</span>] = &amp;iA; pA[<span class="hljs-number">1</span>] = &amp;iB; pA[<span class="hljs-number">2</span>] = &amp;iC;<br></code></pre></td></tr></table></figure>这表明每个元素都是一个整数指针，可以用来保存一个整数变量的内存地址（指向一个整数变量）。如下图所示：</li></ul><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/4.png" class=""><p>因为指针数组里每个整数指针也可以用来指向一个一维数组，因此指针数组可以用来“模拟”二维数组，只是这里的一维数组在内存上可以不用靠在一起。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> * pA[<span class="hljs-number">3</span>]；<br><span class="hljs-attribute">int</span> iA[<span class="hljs-number">5</span>], iB[<span class="hljs-number">5</span>], iC[<span class="hljs-number">5</span>];<br><span class="hljs-attribute">pA</span>[<span class="hljs-number">0</span>] = iA;   pA[<span class="hljs-number">1</span>] = iB;pA[<span class="hljs-number">2</span>] = iC;<br></code></pre></td></tr></table></figure><h2 id="6-指针的指针（二级指针）"><a href="#6-指针的指针（二级指针）" class="headerlink" title="6. 指针的指针（二级指针）"></a>6. 指针的指针（二级指针）</h2><p>指针的指针简称二级指针，这种指针指向另一个指针变量的内存地址。例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> iA = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">int</span> * pA = &amp;iA;<br><span class="hljs-built_in">int</span> **ppA = &amp;pA;<br></code></pre></td></tr></table></figure><p>这里ppA就是一个二级指针，它指向的是另一个指针变量pA的内存地址，而不是一个普通整数变量的内存地址。不能写成：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int **ppA = <span class="hljs-meta">&amp;iA;  <span class="hljs-comment">// 错误，iA只能用一级指针来指向。</span></span><br></code></pre></td></tr></table></figure><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/5.png" class=""><h2 id="7-指针的运算"><a href="#7-指针的运算" class="headerlink" title="7. 指针的运算"></a>7. 指针的运算</h2><p>指针的运算通常是指当一个指针指向一个内存地址后，通过一定的偏移指向新的内存地址。比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrValue = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><span class="hljs-attribute">int</span> * pA = arrValue;<br><span class="hljs-attribute">pA</span> = pA + <span class="hljs-number">1</span>;<br><span class="hljs-attribute">cout</span>&lt;&lt;*pA &lt;endl;<br></code></pre></td></tr></table></figure><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/6.png" class=""><p>当指针加1后，相当于往后移动了一个数据单位，所移动的内存字节数取决于指针的类型。这里是整数指针，所以内存实际上移动了4个字节。可以得出结论：<br>指针偏移1个单位，实际移动的字节数等于指针类型所占的字节数。<br>灵活利用指针的偏移，有时可以使程序代码变得简洁又高效。</p><h2 id="8-指针与字符串"><a href="#8-指针与字符串" class="headerlink" title="8. 指针与字符串"></a>8. 指针与字符串</h2><p>字符串即字符数组，而指针可以指向数组，所以字符指针可以指向字符串。字符指针取值取到的是指针当前指向位置的字符。<br>程序示例TranslateBig.cpp：把所有字符串转化为大写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">2.</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">3.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span>    <span class="hljs-comment">// 字符函数库</span></span><br><span class="hljs-number">4.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">5.</span>&#123;<br><span class="hljs-number">6.</span>    <span class="hljs-keyword">char</span> szInfo[] = <span class="hljs-string">&quot;I am a student!&quot;</span>;<br><span class="hljs-number">7.</span>    <span class="hljs-keyword">char</span> * pszValue = szInfo;<br><span class="hljs-number">8.</span><span class="hljs-keyword">while</span>(*pszValue != <span class="hljs-number">0</span>)<br><span class="hljs-number">9.</span>&#123;<br><span class="hljs-number">10.</span>*pszValue = <span class="hljs-built_in">toupper</span>(*pszValue);<br><span class="hljs-number">11.</span>pszValue++;<br><span class="hljs-number">12.</span>&#125;<br><span class="hljs-number">13.</span>cout&lt;&lt;szInfo&lt;&lt;endl;<br><span class="hljs-number">14.</span>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果：<br>I AM A STUDENT!<br>程序说明：<br>（1）、*pszValue字符指针取值取到的是一个字符，由于pszValue++导致指针逐渐往后偏移，所以每次取道的值是不一样的，当取道字符串的最后一个空字符时，由于空字符的ASCII值就是0，0值即为假，所以刚好遍历完字符串后退出循环。<br>（2）、第10行的函数toupper是把一个函数转化为大写。要使用字符库函数，必须包含头文件&lt;ctype.h&gt;。把取到的字符转化为大写后然后再赋值回去，这里利用了指针来修改数据。<br>[特别提醒]<br>很多人定义字符串的时候很喜欢这样定义：<br>char * pszInfo = “I am a student!”;<br>这样其意义侧重于定义字符指针，然后指向一个没有名称的常量字符串，这个字符串是不可修改的。对于本例要改变成大写就是不合符要求的。如果你这样定义，可以通过编译，但运行的时候第10行将引起崩溃。</p><h2 id="9-二维数组的指针访问形式"><a href="#9-二维数组的指针访问形式" class="headerlink" title="9. 二维数组的指针访问形式"></a>9. 二维数组的指针访问形式</h2><p>假设定义有二维整数数组：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrKey[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123; <span class="hljs-number">500</span>, <span class="hljs-number">600</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><p>如果要输出第2行第2列的元素值，最简单的形式是利用下标：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cout</span>&lt;&lt;arrKey[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>因为arrKey等价于指针，所以也可以通过指针形式来访问第2行第2列的元素值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cout</span>&lt;&lt;*(*(arrKey + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);   // 输出第<span class="hljs-number">2</span>行第<span class="hljs-number">2</span>列的值即<span class="hljs-number">400</span><br></code></pre></td></tr></table></figure><p>分析示意图如下图：</p><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88/7.png" class=""><h2 id="10-数组指针的指针"><a href="#10-数组指针的指针" class="headerlink" title="10. 数组指针的指针"></a>10. 数组指针的指针</h2><p>先看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">2.</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">3.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">4.</span>&#123;<br><span class="hljs-number">5.</span>    <span class="hljs-keyword">int</span> iValue = <span class="hljs-number">300</span>;<br><span class="hljs-number">6.</span>    <span class="hljs-keyword">int</span> *pValue = &amp;iValue;  <span class="hljs-comment">// 指向变量，取变量地址</span><br><span class="hljs-number">7.</span>    cout &lt;&lt; <span class="hljs-string">&quot;iValue:&quot;</span>&lt;&lt;*pValue&lt;&lt;endl;<br><span class="hljs-number">8.</span>   <br><span class="hljs-number">9.</span>    <span class="hljs-keyword">int</span> arrValue[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>&#125;;<br><span class="hljs-number">10.</span>    <span class="hljs-keyword">int</span> * pA = arrValue;  <span class="hljs-comment">//指向一维数组，数组名即数组首元素地址等价于指针，故直接赋值于Pa</span><br><span class="hljs-number">11.</span>    cout&lt;&lt;<span class="hljs-string">&quot;arrValue[0]:&quot;</span>&lt;&lt;*pA&lt;&lt;endl;    <span class="hljs-comment">// 通过指针输出第一个元素的值</span><br><span class="hljs-number">12.</span>    <br><span class="hljs-number">13.</span>    <span class="hljs-keyword">int</span> arrKey[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123; <span class="hljs-number">500</span>, <span class="hljs-number">600</span>&#125; &#125;;<br><span class="hljs-number">14.</span>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (* ppA)[<span class="hljs-number">2</span>] = arrKey;  <span class="hljs-comment">// 指向数组指针的指针</span><br><span class="hljs-number">15.</span>    cout&lt;&lt; <span class="hljs-string">&quot;arrKey[0]0]:&quot;</span>&lt;&lt;(*ppA)[<span class="hljs-number">0</span>]&lt;&lt;endl;   <span class="hljs-comment">// (*ppA)指针取值取到第一个数组</span><br><span class="hljs-number">16.</span><br><span class="hljs-number">17.</span>    <span class="hljs-keyword">int</span> arrNum[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>&#125;;<br><span class="hljs-number">18.</span>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*pNum)[<span class="hljs-number">5</span>] = &amp;arrNum;  <br><span class="hljs-number">19.</span>    cout&lt;&lt; <span class="hljs-string">&quot;arrNum[1]:&quot;</span>&lt;&lt;(*pNum)[<span class="hljs-number">1</span>]&lt;&lt;endl;<br><span class="hljs-number">20.</span>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs iValue:300">arrValue[0]:100<br>arrKey[0]0]:100<br>arrNum[1]:200<br></code></pre></td></tr></table></figure><p>程序说明：<br>第14行代码即定义一个指向数组指针的指针。如果写成： </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrValue[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123; <span class="hljs-number">500</span>, <span class="hljs-number">600</span>&#125; &#125;;<br><span class="hljs-attribute">int</span> * pA = arrValue;  // 编译出错<br></code></pre></td></tr></table></figure><p>编译产生的错误提示：cannot convert from ‘int [3][2]’ to ‘int *’。这说明二维数组名arrValue和一级指针pA是不等价的数据类型，不能相互转化。<br>二维数组arrValue[3][2]可以看成是一个一维数组arrValue[3]，只是这个一维数组里的每个元素又是一个一维数组。二维数组的名称arrValue代表这个一维数组的首地址，而不是一个普通整数元素的地址。所以二维数组名是在一定意义上的二级指针。<br>注意：<br>当程序需要指定一个指向数组指针的指针时，别忘了括号。对比一下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> (* ppA)[<span class="hljs-number">2</span>] = arrValue;  <span class="hljs-comment">// 指向数组指针的指针</span><br><span class="hljs-built_in">int</span> *pA[<span class="hljs-number">2</span>];              <span class="hljs-comment">// 指针数组</span><br></code></pre></td></tr></table></figure><p>指向数组指针的维数一定要一致。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrKey[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123; <span class="hljs-number">500</span>, <span class="hljs-number">600</span>&#125; &#125;;<br><span class="hljs-attribute">int</span> (* ppA)[<span class="hljs-number">5</span>] = arrKey;  // <span class="hljs-number">5</span>和<span class="hljs-number">2</span>不一致，导致编译错误<br></code></pre></td></tr></table></figure><p>编译错误提示：cannot convert from ‘int [3][2]’ to ‘int (*)[5]’<br>[特别提醒]<br>指向数组指针的指针是比较难以理解的，所幸的是实际应用极少。原因很简单，既然定义了数组，一般情况下通过数组名称结合下标就可以很方便的访问元素。因此，这种语法如果一时难以理解，并不是一件可怕的事情，你甚至可以不屑一顾，甚至置之不理。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针精髓</title>
    <link href="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/"/>
    <url>/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-指针的定义"><a href="#1-指针的定义" class="headerlink" title="1. 指针的定义"></a>1. 指针的定义</h2><p>程序运行时，每一个变量的数据都是保存在内存的一个确定位置，可以用&amp;操作符取得这个内存位置的值。32位操作系统上，这个值实际上就是一个32位的整数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> iA = <span class="hljs-number">30</span>;<br>cout&lt;&lt;”iA变量的内存地址：”&lt;&lt;&amp;iA&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>有时候我们需要把这个地址也保存起来，以实现在程序中直接使用。如果每次都对变量取地址，显得不方便。更何况有的情况并没有明确的变量名称，比如动态分配的一块内存。这些内存地址的值都有必要得到保存，因此指针数据类型就闪亮登场了。简单的说：<br>指针是一个变量，保存的是一个内存地址。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int * pA = <span class="hljs-meta">&amp;iA;</span><br></code></pre></td></tr></table></figure><p>这就是定义一个int类型的指针变量pValue来保存iA这个整数的内存地址。</p><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/1.png" class=""><p>强烈建议指针变量用小写的p表示前缀（p是point的首字母）。</p><p>定义指针变量必须注意几点：<br>    1. 指针是对其他的数据类型的复合，指针变量必须指向同类型的变量的地址。比如不能写成：<br>    <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">double * pA = <span class="hljs-meta">&amp;iA;   <span class="hljs-comment">// 错误，iA是整数，和double *不兼容</span></span><br></code></pre></td></tr></table></figure><br>    2. 指针的*位置可以紧靠数据类型，也可以紧靠指针变量，也可以两者都不紧靠。所以下面的三种写法都是可以的：<br>    <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int *pA = <span class="hljs-meta">&amp;iA;   <span class="hljs-comment">// 这种写法支持者较多，有的公司编码规范表示推荐这样写</span></span><br>int * pA = <span class="hljs-meta">&amp;iA;   <span class="hljs-comment">// 这种写法支持者也不少</span></span><br>int* pA = <span class="hljs-meta">&amp;iA;</span><br></code></pre></td></tr></table></figure><br>    3. 指针是一个变量，可以先定义，然后再使用。<br>    <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> *pA = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">int</span> iA = <span class="hljs-number">200</span>;<br>pA = &amp;iA;<br></code></pre></td></tr></table></figure><br>第1行代码就是对先定义指针变量，并把其初始值定义为NULL。NULL其实就0值，用    NULL更偏向于表示指针初值的意义。指针变量里的值为0，意味着还没有指向任何整数变量的内存地址。<br>[编程好习惯]<br>指针变量赋于初值NULL，是编程好习惯的一个体现。有的人甚至支持对所有变量都养成赋予初值的习惯。</p><h2 id="2-指针的基本功能"><a href="#2-指针的基本功能" class="headerlink" title="2. 指针的基本功能"></a>2. 指针的基本功能</h2><p>指针变量的基本功能就是对指针所指向的内存地址的数据进行操作，包括读取数据和修改数据。这里要用到C++的又一个操作符号：取值操作符<em>。值得注意的是和定义指针变量的</em>一样，但取值操作符*不是用在指针变量的声明语句里，而是用在其他语句的指针变量前（紧靠变量）表示取该指针指向的变量的值。这个时候指针变量一定是早已定义好了的变量。<br>程序实例5-1：Point(指针的基本用法)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">5.</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">6.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">7.</span>&#123;<br><span class="hljs-number">8.</span><span class="hljs-keyword">int</span> iValue = <span class="hljs-number">300</span>;<br><span class="hljs-number">9.</span><span class="hljs-keyword">int</span> * pValue = &amp;iValue;<br><span class="hljs-number">10.</span>cout&lt;&lt;<span class="hljs-string">&quot;iValue的值:&quot;</span>&lt;&lt;iValue&lt;&lt;endl;                <span class="hljs-comment">// 输出300</span><br><span class="hljs-number">11.</span>cout&lt;&lt;<span class="hljs-string">&quot;通过pValue取值:&quot;</span>&lt;&lt;*pValue&lt;&lt;endl;          <span class="hljs-comment">// 输出300</span><br><span class="hljs-number">12.</span><br><span class="hljs-number">13.</span>*pValue = <span class="hljs-number">400</span>;<br><span class="hljs-number">14.</span>cout&lt;&lt;<span class="hljs-string">&quot;iValue的值:&quot;</span>&lt;&lt;iValue&lt;&lt;endl;               <span class="hljs-comment">// 输出400</span><br><span class="hljs-number">15.</span>cout&lt;&lt;<span class="hljs-string">&quot;通过pValue取值:&quot;</span>&lt;&lt;*pValue&lt;&lt;endl;        <span class="hljs-comment">// 输出400</span><br><span class="hljs-number">16.</span><br><span class="hljs-number">17.</span>     iValue = <span class="hljs-number">500</span>;<br><span class="hljs-number">18.</span>cout&lt;&lt;<span class="hljs-string">&quot;iValue的值:&quot;</span>&lt;&lt;iValue&lt;&lt;endl;                <span class="hljs-comment">// 输出500</span><br><span class="hljs-number">19.</span>cout&lt;&lt;<span class="hljs-string">&quot;通过pValue取值:&quot;</span>&lt;&lt;*pValue&lt;&lt;endl;         <span class="hljs-comment">// 输出500</span><br><span class="hljs-number">20.</span><br><span class="hljs-number">21.</span>&#125;<br></code></pre></td></tr></table></figure><p>从程序的运行结果可以看出，指针变量pValue指向iValue后，就可以通过<em>pValue去读数iValue的值。也可以通过对</em>pValue进行赋值达到修该iValue变量的值的效果。这些操作并没有通过iValue进行，而是通过指针变量pValue间接去操作它所指向的变量的数据。所以取值操作符号<em>也叫间访操作符号。间访就是间接访问的意思。<br>第14行代码通过iValue变量修改了本身的值，因为pValue在程序里一直指向该变量，变量本身值发生变化理所当然会影响后面到</em>pValue取值，所以第16行的*pValue取到的就是变化过的值了。</p><h2 id="3-指针指向数组"><a href="#3-指针指向数组" class="headerlink" title="3. 指针指向数组"></a>3. 指针指向数组</h2><p>数组的名称代表整个数组，其意义等价于一个指针，表示数组的首地址，也就是第一个元素的内存地址。因此，指针可以用来指向数组名称。比如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrA[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;<br><span class="hljs-attribute">Int</span> *pA = arrA;    // 注意arrA前不能再加取地址符&amp;<br></code></pre></td></tr></table></figure><p>其意义如下图所表示：</p><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/2.png" class=""><h2 id="4-指针指向动态分配内存"><a href="#4-指针指向动态分配内存" class="headerlink" title="4. 指针指向动态分配内存"></a>4. 指针指向动态分配内存</h2><p>一个良好的程序更偏重于运行时的灵活性，编译时对程序过多的限制会削弱程序的质量，有时候甚至降低程序的性能。比如定义一个整数数组来保存学生的成绩，但目前的问题是并不知道学生的数量，如果定义成int arrScore[50]能满足一般的要求，可是在特殊情况学生有200人呢，程序不得不修改成int arrScore[200]。此时对于大多数情况只用了不到50个空间的情况来言，就是对内存空间的浪费。<br>动态分配内存就是运行时在进程内存空间的自由储存区（也称为堆区）去申请实际可需的内存，然后用来保存数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> szName[] = “SunWuKong”;<br>cout&lt;&lt;” szName变量的内存地址：”&lt;&lt;(<span class="hljs-keyword">int</span> *)szName&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h3 id="4-1-C语言的动态分配内存"><a href="#4-1-C语言的动态分配内存" class="headerlink" title="4.1 C语言的动态分配内存"></a>4.1 C语言的动态分配内存</h3><p>C语言用malloc函数来实现内存的动态分配。比如申请100个int的内存空间：<br>int * pA = (int *)malloc( 100 * sizeof(int) );<br>这句代码用下图表示其意义：</p><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/3.png" class=""><p>Malloc函数返回一块申请成功的内存，这块内存并没有明确的变量来表示它。我们要使用这块内存，就必须用一定类型的指针去指向它（就是保存他的内存地址，从而知道这块风水宝地在哪里）。这也是C++程序里为什么有指针这种数据类型的原因之一。<br>使用malloc函数注意三点：<br>    - malloc函数返回的是void *指针，要赋予别的类型指针，必须强制转换。<br>    - 所需要的空间大小需要自己计算。<br>    - 动态分配的内存使用结束后用free函数释放，否则引起内存泄露。</p><h3 id="4-2-空类型指针void-的理解"><a href="#4-2-空类型指针void-的理解" class="headerlink" title="4.2 空类型指针void *的理解"></a>4.2 空类型指针void *的理解</h3><p>void *表示空类型指针，通常人们又简称为空指针，它仅仅单纯的保存一个内存地址，这个内存地址的数据是什么类型或者这个这个内存地址将要放什么类型的数据取决于后面的实现。Malloc函数返回的就是void *，因为新申请的内存用来装什么类型的数据往往是个未知数，如果你确定了用来装整数，就可以把void *强制转化成int *。如果你心血来潮，想用来装结构变量的数据，还可以转换成结构指针。<br>程序实例5-1：VoidPoint(空指针的应用理解)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">22.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">23.</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">24.</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagSTUDENT</span></span><br><span class="hljs-class">25.&#123;</span><br><span class="hljs-number">26.</span>    <span class="hljs-keyword">char</span> szName[<span class="hljs-number">20</span>];<br><span class="hljs-number">27.</span>    <span class="hljs-keyword">int</span>  iAge;<br><span class="hljs-number">28.</span>&#125; T_STUDENT, *PT_STUDENT;<br><span class="hljs-number">29.</span><br><span class="hljs-number">30.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">31.</span>&#123;<br><span class="hljs-number">32.</span><span class="hljs-keyword">void</span> * pA = <span class="hljs-built_in">malloc</span>( <span class="hljs-number">100</span> * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>) );<br><span class="hljs-number">33.</span><span class="hljs-keyword">int</span> * pScore = (<span class="hljs-keyword">int</span> *)pA;<br><span class="hljs-number">34.</span>*pScore = <span class="hljs-number">100</span>;<br><span class="hljs-number">35.</span>cout&lt;&lt;*pScore&lt;&lt;endl;                  <span class="hljs-comment">// 输出100</span><br><span class="hljs-number">36.</span>T_STUDENT tZhangSan = &#123;<span class="hljs-string">&quot; ZhangSan&quot;</span>, <span class="hljs-number">20</span>&#125;;<br><span class="hljs-number">37.</span>T_STUDENT * pStudent = (T_STUDENT *) pA;<br><span class="hljs-number">38.</span>*pStudent = tZhangSan;<br><span class="hljs-number">39.</span>cout&lt;&lt;(*pStudent).iAge&lt;&lt;endl;           <span class="hljs-comment">// 输出20</span><br><span class="hljs-number">40.</span>     <span class="hljs-built_in">free</span>(pA);<br><span class="hljs-number">41.</span>&#125;<br></code></pre></td></tr></table></figure><p>程序说明：<br>第12行先把申请到的内存强制转化成整型指针，说明准备用来装整数。第13行就是利用指针给空间赋一个整数值，然后在第14行输出。<br>第16行又把申请到的内存用来装一个学生的结构变量，所以先把void*强制转化成结构指针，然后通过第17行直接把一个结构变量赋予到pStudent所指向的内存里。<br>第18行的(*pStudent)是指针变量取值，因为pStudent是结构指针，所以取值取到的就是一个结构的数据。因为cout并没有能力直接输出一个结构的信息，所以通过点号输出结构里的指定成员的值。<br>第19行的free是释放动态分配的内存。<br>此例说明，动态分配的内存可以反复使用，怎么使用取决于程序业务逻辑的实现。</p><h3 id="4-3-C-的动态分配内存"><a href="#4-3-C-的动态分配内存" class="headerlink" title="4.3 C++的动态分配内存"></a>4.3 C++的动态分配内存</h3><p>C++采用new操作符在堆空间上申请动态内存，使用完后用delete释放。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> * pA = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>;    <span class="hljs-comment">//申请一个整数大小的动态内存，然后用pA指向它。</span><br><span class="hljs-keyword">delete</span> pA;          <span class="hljs-comment">//使用完毕后释放动态分配的内存。</span><br></code></pre></td></tr></table></figure><p>指针也可以指向动态分配的数组空间，比如</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> * pA = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];  <br></code></pre></td></tr></table></figure><p>这里的pA指向一个动态分配的整数数组的首地址(即第1个元素的地址)，数组有5个元素。释放这样的内存是：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">delete</span> []pA;         <span class="hljs-regexp">//</span>注意不能少了中括号[ ]<br></code></pre></td></tr></table></figure><p>值得注意的是[ ]不能写成()，比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> * pA = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">5</span>); <span class="hljs-comment">//这不是申请数组空间，而是申请一个整数空间，并赋予初值5。</span><br></code></pre></td></tr></table></figure><p>使用new动态分配内存注意：</p><ul><li>new和delete并不是函数，而是c++的操作符</li><li>new操作符号后必须指定数据类型，如果是数组空间，[ ]里的数字就表示这种数据类型的个数，而不是字节总的大小。</li><li>由于new操作符指明了数据类型，所以不需要强制转化，就可以用相应数据类型的指针来指向申请成功的动态内存。<h2 id="5-指针数组"><a href="#5-指针数组" class="headerlink" title="5. 指针数组"></a>5. 指针数组</h2>定义一个整数指针数组：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> * pA[<span class="hljs-number">3</span>]；int iA, iB, iC;  <br><span class="hljs-attribute">pA</span>[<span class="hljs-number">0</span>] = &amp;iA; pA[<span class="hljs-number">1</span>] = &amp;iB; pA[<span class="hljs-number">2</span>] = &amp;iC;<br></code></pre></td></tr></table></figure>这表明每个元素都是一个整数指针，可以用来保存一个整数变量的内存地址（指向一个整数变量）。如下图所示：</li></ul><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/4.png" class=""><p>因为指针数组里每个整数指针也可以用来指向一个一维数组，因此指针数组可以用来“模拟”二维数组，只是这里的一维数组在内存上可以不用靠在一起。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> * pA[<span class="hljs-number">3</span>]；<br><span class="hljs-attribute">int</span> iA[<span class="hljs-number">5</span>], iB[<span class="hljs-number">5</span>], iC[<span class="hljs-number">5</span>];<br><span class="hljs-attribute">pA</span>[<span class="hljs-number">0</span>] = iA;   pA[<span class="hljs-number">1</span>] = iB;pA[<span class="hljs-number">2</span>] = iC;<br></code></pre></td></tr></table></figure><h2 id="6-指针的指针（二级指针）"><a href="#6-指针的指针（二级指针）" class="headerlink" title="6. 指针的指针（二级指针）"></a>6. 指针的指针（二级指针）</h2><p>指针的指针简称二级指针，这种指针指向另一个指针变量的内存地址。例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> iA = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">int</span> * pA = &amp;iA;<br><span class="hljs-built_in">int</span> **ppA = &amp;pA;<br></code></pre></td></tr></table></figure><p>这里ppA就是一个二级指针，它指向的是另一个指针变量pA的内存地址，而不是一个普通整数变量的内存地址。不能写成：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">int **ppA = <span class="hljs-meta">&amp;iA;  <span class="hljs-comment">// 错误，iA只能用一级指针来指向。</span></span><br></code></pre></td></tr></table></figure><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/5.png" class=""><h2 id="7-指针的运算"><a href="#7-指针的运算" class="headerlink" title="7. 指针的运算"></a>7. 指针的运算</h2><p>指针的运算通常是指当一个指针指向一个内存地址后，通过一定的偏移指向新的内存地址。比如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrValue = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><span class="hljs-attribute">int</span> * pA = arrValue;<br><span class="hljs-attribute">pA</span> = pA + <span class="hljs-number">1</span>;<br><span class="hljs-attribute">cout</span>&lt;&lt;*pA &lt;endl;<br></code></pre></td></tr></table></figure><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/6.png" class=""><p>当指针加1后，相当于往后移动了一个数据单位，所移动的内存字节数取决于指针的类型。这里是整数指针，所以内存实际上移动了4个字节。可以得出结论：<br>指针偏移1个单位，实际移动的字节数等于指针类型所占的字节数。<br>灵活利用指针的偏移，有时可以使程序代码变得简洁又高效。</p><h2 id="8-指针与字符串"><a href="#8-指针与字符串" class="headerlink" title="8. 指针与字符串"></a>8. 指针与字符串</h2><p>字符串即字符数组，而指针可以指向数组，所以字符指针可以指向字符串。字符指针取值取到的是指针当前指向位置的字符。<br>程序示例TranslateBig.cpp：把所有字符串转化为大写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">2.</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">3.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctype.h&gt;</span>    <span class="hljs-comment">// 字符函数库</span></span><br><span class="hljs-number">4.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">5.</span>&#123;<br><span class="hljs-number">6.</span>    <span class="hljs-keyword">char</span> szInfo[] = <span class="hljs-string">&quot;I am a student!&quot;</span>;<br><span class="hljs-number">7.</span>    <span class="hljs-keyword">char</span> * pszValue = szInfo;<br><span class="hljs-number">8.</span><span class="hljs-keyword">while</span>(*pszValue != <span class="hljs-number">0</span>)<br><span class="hljs-number">9.</span>&#123;<br><span class="hljs-number">10.</span>*pszValue = <span class="hljs-built_in">toupper</span>(*pszValue);<br><span class="hljs-number">11.</span>pszValue++;<br><span class="hljs-number">12.</span>&#125;<br><span class="hljs-number">13.</span>cout&lt;&lt;szInfo&lt;&lt;endl;<br><span class="hljs-number">14.</span>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果：<br>I AM A STUDENT!<br>程序说明：<br>（1）、*pszValue字符指针取值取到的是一个字符，由于pszValue++导致指针逐渐往后偏移，所以每次取道的值是不一样的，当取道字符串的最后一个空字符时，由于空字符的ASCII值就是0，0值即为假，所以刚好遍历完字符串后退出循环。<br>（2）、第10行的函数toupper是把一个函数转化为大写。要使用字符库函数，必须包含头文件&lt;ctype.h&gt;。把取到的字符转化为大写后然后再赋值回去，这里利用了指针来修改数据。<br>[特别提醒]<br>很多人定义字符串的时候很喜欢这样定义：<br>char * pszInfo = “I am a student!”;<br>这样其意义侧重于定义字符指针，然后指向一个没有名称的常量字符串，这个字符串是不可修改的。对于本例要改变成大写就是不合符要求的。如果你这样定义，可以通过编译，但运行的时候第10行将引起崩溃。</p><h2 id="9-二维数组的指针访问形式"><a href="#9-二维数组的指针访问形式" class="headerlink" title="9. 二维数组的指针访问形式"></a>9. 二维数组的指针访问形式</h2><p>假设定义有二维整数数组：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrKey[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123; <span class="hljs-number">500</span>, <span class="hljs-number">600</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><p>如果要输出第2行第2列的元素值，最简单的形式是利用下标：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cout</span>&lt;&lt;arrKey[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>因为arrKey等价于指针，所以也可以通过指针形式来访问第2行第2列的元素值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cout</span>&lt;&lt;*(*(arrKey + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);   // 输出第<span class="hljs-number">2</span>行第<span class="hljs-number">2</span>列的值即<span class="hljs-number">400</span><br></code></pre></td></tr></table></figure><p>分析示意图如下图：</p><img src="/2021/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/10%E6%8C%87%E9%92%88%E7%B2%BE%E9%AB%93/7.png" class=""><h2 id="10-数组指针的指针"><a href="#10-数组指针的指针" class="headerlink" title="10. 数组指针的指针"></a>10. 数组指针的指针</h2><p>先看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-number">2.</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-number">3.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function">4.</span>&#123;<br><span class="hljs-number">5.</span>    <span class="hljs-keyword">int</span> iValue = <span class="hljs-number">300</span>;<br><span class="hljs-number">6.</span>    <span class="hljs-keyword">int</span> *pValue = &amp;iValue;  <span class="hljs-comment">// 指向变量，取变量地址</span><br><span class="hljs-number">7.</span>    cout &lt;&lt; <span class="hljs-string">&quot;iValue:&quot;</span>&lt;&lt;*pValue&lt;&lt;endl;<br><span class="hljs-number">8.</span>   <br><span class="hljs-number">9.</span>    <span class="hljs-keyword">int</span> arrValue[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>&#125;;<br><span class="hljs-number">10.</span>    <span class="hljs-keyword">int</span> * pA = arrValue;  <span class="hljs-comment">//指向一维数组，数组名即数组首元素地址等价于指针，故直接赋值于Pa</span><br><span class="hljs-number">11.</span>    cout&lt;&lt;<span class="hljs-string">&quot;arrValue[0]:&quot;</span>&lt;&lt;*pA&lt;&lt;endl;    <span class="hljs-comment">// 通过指针输出第一个元素的值</span><br><span class="hljs-number">12.</span>    <br><span class="hljs-number">13.</span>    <span class="hljs-keyword">int</span> arrKey[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123; <span class="hljs-number">500</span>, <span class="hljs-number">600</span>&#125; &#125;;<br><span class="hljs-number">14.</span>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (* ppA)[<span class="hljs-number">2</span>] = arrKey;  <span class="hljs-comment">// 指向数组指针的指针</span><br><span class="hljs-number">15.</span>    cout&lt;&lt; <span class="hljs-string">&quot;arrKey[0]0]:&quot;</span>&lt;&lt;(*ppA)[<span class="hljs-number">0</span>]&lt;&lt;endl;   <span class="hljs-comment">// (*ppA)指针取值取到第一个数组</span><br><span class="hljs-number">16.</span><br><span class="hljs-number">17.</span>    <span class="hljs-keyword">int</span> arrNum[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>&#125;;<br><span class="hljs-number">18.</span>    <span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*pNum)[<span class="hljs-number">5</span>] = &amp;arrNum;  <br><span class="hljs-number">19.</span>    cout&lt;&lt; <span class="hljs-string">&quot;arrNum[1]:&quot;</span>&lt;&lt;(*pNum)[<span class="hljs-number">1</span>]&lt;&lt;endl;<br><span class="hljs-number">20.</span>&#125;<br></code></pre></td></tr></table></figure><p>程序运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs iValue:300">arrValue[0]:100<br>arrKey[0]0]:100<br>arrNum[1]:200<br></code></pre></td></tr></table></figure><p>程序说明：<br>第14行代码即定义一个指向数组指针的指针。如果写成： </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrValue[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123; <span class="hljs-number">500</span>, <span class="hljs-number">600</span>&#125; &#125;;<br><span class="hljs-attribute">int</span> * pA = arrValue;  // 编译出错<br></code></pre></td></tr></table></figure><p>编译产生的错误提示：cannot convert from ‘int [3][2]’ to ‘int *’。这说明二维数组名arrValue和一级指针pA是不等价的数据类型，不能相互转化。<br>二维数组arrValue[3][2]可以看成是一个一维数组arrValue[3]，只是这个一维数组里的每个元素又是一个一维数组。二维数组的名称arrValue代表这个一维数组的首地址，而不是一个普通整数元素的地址。所以二维数组名是在一定意义上的二级指针。<br>注意：<br>当程序需要指定一个指向数组指针的指针时，别忘了括号。对比一下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> (* ppA)[<span class="hljs-number">2</span>] = arrValue;  <span class="hljs-comment">// 指向数组指针的指针</span><br><span class="hljs-built_in">int</span> *pA[<span class="hljs-number">2</span>];              <span class="hljs-comment">// 指针数组</span><br></code></pre></td></tr></table></figure><p>指向数组指针的维数一定要一致。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> arrKey[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123; &#123;<span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;, &#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;, &#123; <span class="hljs-number">500</span>, <span class="hljs-number">600</span>&#125; &#125;;<br><span class="hljs-attribute">int</span> (* ppA)[<span class="hljs-number">5</span>] = arrKey;  // <span class="hljs-number">5</span>和<span class="hljs-number">2</span>不一致，导致编译错误<br></code></pre></td></tr></table></figure><p>编译错误提示：cannot convert from ‘int [3][2]’ to ‘int (*)[5]’<br>[特别提醒]<br>指向数组指针的指针是比较难以理解的，所幸的是实际应用极少。原因很简单，既然定义了数组，一般情况下通过数组名称结合下标就可以很方便的访问元素。因此，这种语法如果一时难以理解，并不是一件可怕的事情，你甚至可以不屑一顾，甚至置之不理。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树 AVL树 B树 B+树 红黑树等算法树介绍</title>
    <link href="/2021/05/10/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04%E4%BA%8C%E5%8F%89%E6%A0%91%20AVL%E6%A0%91%20B%E6%A0%91%E7%AD%89%E7%AE%97%E6%B3%95%E6%A0%91%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/05/10/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04%E4%BA%8C%E5%8F%89%E6%A0%91%20AVL%E6%A0%91%20B%E6%A0%91%E7%AD%89%E7%AE%97%E6%B3%95%E6%A0%91%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树是一种特殊的有序树：每个节点至多有两个分支（子节点），分支具有左右次序，不能颠倒。</p><p>两种特殊的二叉树：</p><ul><li>完全二叉树：除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点（注意是右边，而不能是左边缺少）。</li><li>满二叉树：每一层都是满的（除了最后一层，这里的最后一层是指叶节点）。</li></ul><h1 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树(Binary Search Tree)"></a>二叉查找树(Binary Search Tree)</h1><p>二叉查找树(Binary Search Tree，也叫二叉排序树，即Binary Sort Tree，也称二叉搜索树，有序二叉树(ordered binary tree)，排序二叉树(sorted binary tree) )能够支持多种动态集合操作，它可以用来表示有序集合、建立索引等，因而在实际应用中，二叉排序树是一种非常重要的数据结构。</p><p>从算法复杂度角度考虑，我们知道，作用于二叉查找树上的基本操作（如查找，插入等）的时间复杂度与树的高度成正比。对一个含n个节点的完全二叉树，这些操作的最坏情况运行时间为O(log n)。但如果因为频繁的删除和插入操作，导致树退化成一个n个节点的线性链（此时即为一个单链表），则这些操作的最坏情况运行时间为O(n)。为了克服以上缺点，很多二叉查找树的变形出现了，如红黑树、AVL树，Treap树等。</p><h1 id="平衡二叉树AVL树"><a href="#平衡二叉树AVL树" class="headerlink" title="平衡二叉树AVL树"></a>平衡二叉树AVL树</h1><p>二叉平衡树是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。</p><p>平衡因子BF将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF。</p><h1 id="多路查找树（B树）"><a href="#多路查找树（B树）" class="headerlink" title="多路查找树（B树）"></a>多路查找树（B树）</h1><ol><li><p>2-3树：（最简单的B树）</p><ul><li>2结点包含一个元素和两个孩子（或没有孩子）。</li><li>3结点包含两个元素和三个孩子（或没有孩子）。</li><li>并且2-3树的所有叶子结点都在同一层上。</li></ul></li><li><p>   3-4树<br>    同上<br>       4结点包含3个元素和4个孩子（或没有孩子）；</p></li><li><p>   B树</p></li></ol><p>结点最大的孩子书称为B树的阶。2-3树是3阶B树，2-3-4树是4阶B树。<br>如果结点不是叶结点，则其至少有两颗子树。<br>每一个非根的分支结点都有k-1个元素和k个孩子，其中⌈m/2⌉&lt;=k&lt;=m。<br>各一个叶子结点n都有n-1个元素，其中⌈m/2⌉&lt;=k&lt;=m。<br>所有叶子结点都位于同意层次。<br>所有结点包含以下信息数据（n,A0,K1,A1,K2,A2….,Kn,An）,其中，K1…Kn为关键字，且K1 &lt; Kn；A0.。。。An为指向子树根节点的指针，且指针Ai-1所指子树中所有关键字均要小于Ki，An所指子树中的关键字均要大于Kn。<br>总结<br>在B树上查找过程是一个顺指针查找结点和在结点中查找关键字的交叉过程。<br>由于B树每个结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能。可以说，B树的数据结构就是为了内外存的数据交互准备的。<br>例子：比如说一个B树的阶树为1001（即1个结点包含1000个关键字），高度为2。那么它可以存储超过10亿个关键字。我们只要将根结点持久的保留在内存中，那么在这棵树上，寻找一个关键字至多需要读取两次硬盘即可。</p><h1 id="多路查找平衡二叉树-B-树"><a href="#多路查找平衡二叉树-B-树" class="headerlink" title="多路查找平衡二叉树(B+树)"></a>多路查找平衡二叉树(B+树)</h1><p>提出原因：对于B数，遍历时，会多次对根节点进行遍历，造成损耗。</p><p>B树中每个元素只会在该树中出现一次，有可能在叶子结点，也有可能在分支结点。而在B+树中，出现在分子结点中的元素会被当作他们在该分支结点位置的中序后继者（叶子结点）中再次出现。另外，每个叶子结点都会保存一个指向后一个叶子结点的指针。<br>所以，B+树中所有的叶子结点包含了全部的关键字信息，及指向包含这些关键字记录的指针，叶子结点本身依照关键字大小自小而大顺序排列。<br>所有分支结点可以看成索引，结点中仅含有其子树中的最大（最小）关键字。<br>B+树结构特别适合带有范围的查找，比如说查找年龄19-22岁的学生人数，可以通过从根结点出发找到第一个19岁的学生，再在叶子结点中按照顺序查找到符合范围的所有记录。</p><h1 id="红黑树-Red–black-tree"><a href="#红黑树-Red–black-tree" class="headerlink" title="红黑树 (Red–black tree)"></a>红黑树 (Red–black tree)</h1><p>红黑树是一种自平衡二叉查找树。操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(log n)时间内做查找，插入和删除，这里的n是树中元素的数目。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/XieCH1995/article/details/79762786">https://blog.csdn.net/XieCH1995/article/details/79762786</a></p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>doxygen使用说明</title>
    <link href="/2021/03/24/04DevOps/12doxygen%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2021/03/24/04DevOps/12doxygen%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>doxygen文档中的所有命令均以反斜杠（\）或符号（@）开头，两者是等价的。</p><p>c++注释模板</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>makefile及编译相关知识汇总</title>
    <link href="/2021/02/24/04DevOps/11makefile%E5%8F%8A%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2021/02/24/04DevOps/11makefile%E5%8F%8A%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h2><p>makefile 的详细语法可参考 <a href="https://gitee.com/fly542/how-to-write-makefile">跟我一起写Makefile</a></p><h2 id="2-gcc-编译参数"><a href="#2-gcc-编译参数" class="headerlink" title="2. gcc 编译参数"></a>2. gcc 编译参数</h2><p>以-g，-f，-m，-O，-W或–param开头的选项是自动的传递给gcc调用的各个子流程。为了将其他选项传递给这些进程，必须使用-W <letter>选项。</p><p>执行 “ gcc -v –help” 可显示所有子流程的命令行选项 </p><h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a>3. 注意事项</h2><h3 id="Bstatic-及-Bdynamic-使用注意事项"><a href="#Bstatic-及-Bdynamic-使用注意事项" class="headerlink" title="Bstatic 及 Bdynamic 使用注意事项"></a>Bstatic 及 Bdynamic 使用注意事项</h3><ul><li>使用-Wl,-Bstatic 后续使用的库强制引用静态链接库</li><li>使用-Wl,-Bdynamic 后续的库强制引用动态库</li></ul>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>makeifle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中errno说明</title>
    <link href="/2021/02/22/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/09Linux%E4%B8%ADerrno%E8%AF%B4%E6%98%8E/"/>
    <url>/2021/02/22/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/09Linux%E4%B8%ADerrno%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>linux下errno的对应数值位于/usr/include/asm-generic/errno-base.h 和/usr/include/asm-generic/errno.h 中</p><p>errno-base.h的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EPERM 1<span class="hljs-comment">/* Operation not permitted */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOENT 2<span class="hljs-comment">/* No such file or directory */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ESRCH 3<span class="hljs-comment">/* No such process */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EINTR 4<span class="hljs-comment">/* Interrupted system call */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EIO 5<span class="hljs-comment">/* I/O error */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENXIO 6<span class="hljs-comment">/* No such device or address */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>E2BIG 7<span class="hljs-comment">/* Argument list too long */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOEXEC 8<span class="hljs-comment">/* Exec format error */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBADF 9<span class="hljs-comment">/* Bad file number */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ECHILD10<span class="hljs-comment">/* No child processes */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EAGAIN11<span class="hljs-comment">/* Try again */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOMEM12<span class="hljs-comment">/* Out of memory */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EACCES13<span class="hljs-comment">/* Permission denied */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EFAULT14<span class="hljs-comment">/* Bad address */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTBLK15<span class="hljs-comment">/* Block device required */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBUSY16<span class="hljs-comment">/* Device or resource busy */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EEXIST17<span class="hljs-comment">/* File exists */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EXDEV18<span class="hljs-comment">/* Cross-device link */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENODEV19<span class="hljs-comment">/* No such device */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTDIR20<span class="hljs-comment">/* Not a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EISDIR21<span class="hljs-comment">/* Is a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EINVAL22<span class="hljs-comment">/* Invalid argument */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENFILE23<span class="hljs-comment">/* File table overflow */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EMFILE24<span class="hljs-comment">/* Too many open files */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTTY25<span class="hljs-comment">/* Not a typewriter */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ETXTBSY26<span class="hljs-comment">/* Text file busy */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EFBIG27<span class="hljs-comment">/* File too large */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOSPC28<span class="hljs-comment">/* No space left on device */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ESPIPE29<span class="hljs-comment">/* Illegal seek */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EROFS30<span class="hljs-comment">/* Read-only file system */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EMLINK31<span class="hljs-comment">/* Too many links */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EPIPE32<span class="hljs-comment">/* Broken pipe */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EDOM33<span class="hljs-comment">/* Math argument out of domain of func */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ERANGE34<span class="hljs-comment">/* Math result not representable */</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>errno.h的内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _ASM_GENERIC_ERRNO_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _ASM_GENERIC_ERRNO_H</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;asm-generic/errno-base.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EDEADLK35<span class="hljs-comment">/* Resource deadlock would occur */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENAMETOOLONG36<span class="hljs-comment">/* File name too long */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOLCK37<span class="hljs-comment">/* No record locks available */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOSYS38<span class="hljs-comment">/* Function not implemented */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTEMPTY39<span class="hljs-comment">/* Directory not empty */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ELOOP40<span class="hljs-comment">/* Too many symbolic links encountered */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EWOULDBLOCKEAGAIN<span class="hljs-comment">/* Operation would block */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOMSG42<span class="hljs-comment">/* No message of desired type */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EIDRM43<span class="hljs-comment">/* Identifier removed */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ECHRNG44<span class="hljs-comment">/* Channel number out of range */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EL2NSYNC45<span class="hljs-comment">/* Level 2 not synchronized */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EL3HLT46<span class="hljs-comment">/* Level 3 halted */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EL3RST47<span class="hljs-comment">/* Level 3 reset */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ELNRNG48<span class="hljs-comment">/* Link number out of range */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EUNATCH49<span class="hljs-comment">/* Protocol driver not attached */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOCSI50<span class="hljs-comment">/* No CSI structure available */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EL2HLT51<span class="hljs-comment">/* Level 2 halted */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBADE52<span class="hljs-comment">/* Invalid exchange */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBADR53<span class="hljs-comment">/* Invalid request descriptor */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EXFULL54<span class="hljs-comment">/* Exchange full */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOANO55<span class="hljs-comment">/* No anode */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBADRQC56<span class="hljs-comment">/* Invalid request code */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBADSLT57<span class="hljs-comment">/* Invalid slot */</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EDEADLOCKEDEADLK</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBFONT59<span class="hljs-comment">/* Bad font file format */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOSTR60<span class="hljs-comment">/* Device not a stream */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENODATA61<span class="hljs-comment">/* No data available */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ETIME62<span class="hljs-comment">/* Timer expired */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOSR63<span class="hljs-comment">/* Out of streams resources */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENONET64<span class="hljs-comment">/* Machine is not on the network */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOPKG65<span class="hljs-comment">/* Package not installed */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EREMOTE66<span class="hljs-comment">/* Object is remote */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOLINK67<span class="hljs-comment">/* Link has been severed */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EADV68<span class="hljs-comment">/* Advertise error */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ESRMNT69<span class="hljs-comment">/* Srmount error */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ECOMM70<span class="hljs-comment">/* Communication error on send */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EPROTO71<span class="hljs-comment">/* Protocol error */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EMULTIHOP72<span class="hljs-comment">/* Multihop attempted */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EDOTDOT73<span class="hljs-comment">/* RFS specific error */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBADMSG74<span class="hljs-comment">/* Not a data message */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EOVERFLOW75<span class="hljs-comment">/* Value too large for defined data type */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTUNIQ76<span class="hljs-comment">/* Name not unique on network */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EBADFD77<span class="hljs-comment">/* File descriptor in bad state */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EREMCHG78<span class="hljs-comment">/* Remote address changed */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ELIBACC79<span class="hljs-comment">/* Can not access a needed shared library */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ELIBBAD80<span class="hljs-comment">/* Accessing a corrupted shared library */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ELIBSCN81<span class="hljs-comment">/* .lib section in a.out corrupted */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ELIBMAX82<span class="hljs-comment">/* Attempting to link in too many shared libraries */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ELIBEXEC83<span class="hljs-comment">/* Cannot exec a shared library directly */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EILSEQ84<span class="hljs-comment">/* Illegal byte sequence */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ERESTART85<span class="hljs-comment">/* Interrupted system call should be restarted */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ESTRPIPE86<span class="hljs-comment">/* Streams pipe error */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EUSERS87<span class="hljs-comment">/* Too many users */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTSOCK88<span class="hljs-comment">/* Socket operation on non-socket */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EDESTADDRREQ89<span class="hljs-comment">/* Destination address required */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EMSGSIZE90<span class="hljs-comment">/* Message too long */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EPROTOTYPE91<span class="hljs-comment">/* Protocol wrong type for socket */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOPROTOOPT92<span class="hljs-comment">/* Protocol not available */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EPROTONOSUPPORT93<span class="hljs-comment">/* Protocol not supported */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ESOCKTNOSUPPORT94<span class="hljs-comment">/* Socket type not supported */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EOPNOTSUPP95<span class="hljs-comment">/* Operation not supported on transport endpoint */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EPFNOSUPPORT96<span class="hljs-comment">/* Protocol family not supported */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EAFNOSUPPORT97<span class="hljs-comment">/* Address family not supported by protocol */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EADDRINUSE98<span class="hljs-comment">/* Address already in use */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EADDRNOTAVAIL99<span class="hljs-comment">/* Cannot assign requested address */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENETDOWN100<span class="hljs-comment">/* Network is down */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENETUNREACH101<span class="hljs-comment">/* Network is unreachable */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENETRESET102<span class="hljs-comment">/* Network dropped connection because of reset */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ECONNABORTED103<span class="hljs-comment">/* Software caused connection abort */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ECONNRESET104<span class="hljs-comment">/* Connection reset by peer */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOBUFS105<span class="hljs-comment">/* No buffer space available */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EISCONN106<span class="hljs-comment">/* Transport endpoint is already connected */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTCONN107<span class="hljs-comment">/* Transport endpoint is not connected */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ESHUTDOWN108<span class="hljs-comment">/* Cannot send after transport endpoint shutdown */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ETOOMANYREFS109<span class="hljs-comment">/* Too many references: cannot splice */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ETIMEDOUT110<span class="hljs-comment">/* Connection timed out */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ECONNREFUSED111<span class="hljs-comment">/* Connection refused */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EHOSTDOWN112<span class="hljs-comment">/* Host is down */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EHOSTUNREACH113<span class="hljs-comment">/* No route to host */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EALREADY114<span class="hljs-comment">/* Operation already in progress */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EINPROGRESS115<span class="hljs-comment">/* Operation now in progress */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ESTALE116<span class="hljs-comment">/* Stale file handle */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EUCLEAN117<span class="hljs-comment">/* Structure needs cleaning */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTNAM118<span class="hljs-comment">/* Not a XENIX named type file */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENAVAIL119<span class="hljs-comment">/* No XENIX semaphores available */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EISNAM120<span class="hljs-comment">/* Is a named type file */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EREMOTEIO121<span class="hljs-comment">/* Remote I/O error */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EDQUOT122<span class="hljs-comment">/* Quota exceeded */</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOMEDIUM123<span class="hljs-comment">/* No medium found */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EMEDIUMTYPE124<span class="hljs-comment">/* Wrong medium type */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ECANCELED125<span class="hljs-comment">/* Operation Canceled */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOKEY126<span class="hljs-comment">/* Required key not available */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EKEYEXPIRED127<span class="hljs-comment">/* Key has expired */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EKEYREVOKED128<span class="hljs-comment">/* Key has been revoked */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EKEYREJECTED129<span class="hljs-comment">/* Key was rejected by service */</span></span><br><br><span class="hljs-comment">/* for robust mutexes */</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>EOWNERDEAD130<span class="hljs-comment">/* Owner died */</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span>ENOTRECOVERABLE131<span class="hljs-comment">/* State not recoverable */</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ERFKILL132<span class="hljs-comment">/* Operation not possible due to RF-kill */</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EHWPOISON133<span class="hljs-comment">/* Memory page has hardware error */</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const char*, char const*, char*const 的区别</title>
    <link href="/2021/01/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/08%E5%90%84%E7%B1%BBconst%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/01/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/08%E5%90%84%E7%B1%BBconst%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>Bjarne在他的The C++ Programming Language里面给出过一个助记的方法：把一个声明从右向左读。</p><figure class="highlight nim"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs nim"><span class="hljs-built_in">char</span> * <span class="hljs-keyword">const</span> cp; ( * 读成 <span class="hljs-built_in">pointer</span> to ) <br>cp <span class="hljs-keyword">is</span> a <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-built_in">char</span> <br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> * p; <br>p <span class="hljs-keyword">is</span> a <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>; <br><br><span class="hljs-built_in">char</span> <span class="hljs-keyword">const</span> * p;  //同上因为C++里面没有<span class="hljs-keyword">const</span>*的运算符，所以<span class="hljs-keyword">const</span>只能属于前面的类型。<br></code></pre></td></tr></table></figure><p>C++标准规定，const关键字放在类型或变量名之前等价的。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> n=<span class="hljs-number">5</span>;    //same <span class="hljs-keyword">as</span> below<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> m=<span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> *p;    //same <span class="hljs-keyword">as</span> below  <span class="hljs-keyword">const</span> (<span class="hljs-built_in">int</span>) * p<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">const</span> *q;    // (<span class="hljs-built_in">int</span>) <span class="hljs-keyword">const</span> *p<br><br><span class="hljs-built_in">char</span> ** p1;  // <span class="hljs-built_in">pointer</span> to <span class="hljs-built_in">pointer</span> to <span class="hljs-built_in">char</span>;  p1是一个指针，p1指向的对象类型是<span class="hljs-built_in">char</span> *<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> **p2; // <span class="hljs-built_in">pointer</span> to    <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>; p2是一个非<span class="hljs-keyword">const</span>指针，p2指向对象类型指向<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> 类型的指针<br><span class="hljs-built_in">char</span> * <span class="hljs-keyword">const</span> * p3; // <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-built_in">char</span>; p3是一个指向<span class="hljs-keyword">const</span>指针的指针，而这个<span class="hljs-keyword">const</span>指针是一个指向<span class="hljs-built_in">char</span>类型的指针<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> * <span class="hljs-keyword">const</span> * p4; // <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>; p4是一个执行<span class="hljs-keyword">const</span>指针的指针，这个<span class="hljs-keyword">const</span>指针指向<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span><br><span class="hljs-built_in">char</span> ** <span class="hljs-keyword">const</span> p5;<br>// <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to    <span class="hljs-built_in">pointer</span> to    <span class="hljs-built_in">char</span> <br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> ** <span class="hljs-keyword">const</span> p6;<br>// <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to    <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> <br><span class="hljs-built_in">char</span> * <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> p7;<br>// <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to    <span class="hljs-built_in">char</span> <br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> * <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> p8;<br>// <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">pointer</span> to <span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span><br></code></pre></td></tr></table></figure><p>说到这里，我们可以看一道以前Google的笔试题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p=<span class="hljs-string">&quot;hello&quot;</span>;       <br><span class="hljs-built_in">foo</span>(&amp;p);  <span class="hljs-comment">// 函数foo(const char **pp)下面说法正确的是［］</span><br>A.函数<span class="hljs-built_in">foo</span>()不能改变p指向的字符串内容。<br>B.函数<span class="hljs-built_in">foo</span>()不能使指针p指向malloc生成的地址。<br>C.函数<span class="hljs-built_in">foo</span>()可以使p指向新的字符串常量。<br>D.函数<span class="hljs-built_in">foo</span>()可以把p赋值为 <span class="hljs-literal">NULL</span>。<br>至于这道题的答案是众说纷纭。针对上面这道题，我们可以用下面的程序测试：<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **pp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//    *pp=NULL;</span><br><span class="hljs-comment">//    *pp=&quot;Hello world!&quot;;</span><br>        *pp = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">snprintf</span>(*pp, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi google!&quot;</span>);<br><span class="hljs-comment">//       (*pp)[1] = &#x27;x&#x27;;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span></span><br><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p=<span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;before foo %s/n&quot;</span>,p);<br>    <span class="hljs-built_in">foo</span>(&amp;p);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;after foo %s/n&quot;</span>,p);<br>    p[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">在foo函数中，可以使main函数中p指向的新的字符串常量。<br>在foo函数中，可以使main函数中的p指向<span class="hljs-literal">NULL</span>。<br>在foo函数中，可以使main函数中的p指向由malloc生成的内存块，并可以在main中用free释放，但是会有警告。但是注意，即使在foo中让p指向了由malloc生成的内存块，但是仍旧不能用p[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;x&#x27;</span>;这样的语句改变p指向的内容。<br>在foo中，不能用(*pp)[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;x&#x27;</span>;这样的语句改变p的内容。<br>所以，感觉gcc只是根据<span class="hljs-keyword">const</span>的字面的意思对其作了限制，即对于<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*p这样的指针，不管后来p实际指向malloc的内存或者常量的内存，均不能用p[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;x&#x27;</span>这样的语句改变其内容。但是很奇怪，在foo里面，对p指向malloc的内存后，可以用snprintf之类的函数修改其内容。<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏定义define的奇技淫巧</title>
    <link href="/2020/12/08/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/07%E5%AE%8F%E5%AE%9A%E4%B9%89define%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <url>/2020/12/08/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/07%E5%AE%8F%E5%AE%9A%E4%B9%89define%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="define中的三个特殊符号：-，-，"><a href="#define中的三个特殊符号：-，-，" class="headerlink" title="define中的三个特殊符号：#，##，#@"></a>define中的三个特殊符号：#，##，#@</h1><div class="code-wrapper"><pre><code class="hljs">#define Conn(x,y) x##y#define ToChar(x)#@x#define ToString(x)#x</code></pre></div><p>对应解释如下：</p><div class="code-wrapper"><pre><code class="hljs">(1)x##y 表示x连接y，如下：    int n = Conn(123,456);/* 结果就是n=123456;*/    char* str = Conn(&quot;asdf&quot;,&quot;adf&quot;);/*结果就是 str = &quot;asdfadf&quot;;*/(2) #@x代表给x加上单引号，结果返回是一个const char。如下：    char a = ToChar(1);结果就是a=&#39;1&#39;;    做个越界试验char a = ToChar(123);结果就错了;    但是如果你的参数超过四个字符，编译器就给给你报错了！    error C2015: too many characters in constant ：P(3) #x 给x加双引号    char* str = ToString(123132);就成了str=&quot;123132&quot;;    </code></pre></div><h1 id="得到一个field在结构体-struct-中的偏移量"><a href="#得到一个field在结构体-struct-中的偏移量" class="headerlink" title="得到一个field在结构体(struct)中的偏移量"></a>得到一个field在结构体(struct)中的偏移量</h1><div class="code-wrapper"><pre><code class="hljs">#define OFFSETOF( type, field ) ((size_t)&amp;(( type *) 0)-&gt; field )</code></pre></div><h1 id="得到一个结构体中field所占用的字节数"><a href="#得到一个结构体中field所占用的字节数" class="headerlink" title="得到一个结构体中field所占用的字节数"></a>得到一个结构体中field所占用的字节数</h1><div class="code-wrapper"><pre><code class="hljs">#define FSIZ( type, field ) sizeof(((type *) 0)-&gt;field )</code></pre></div><h1 id="将一个字母转换为大写"><a href="#将一个字母转换为大写" class="headerlink" title="将一个字母转换为大写"></a>将一个字母转换为大写</h1><div class="code-wrapper"><pre><code class="hljs">#define UPCASE( c )(((c)&gt;=&#39;a&#39;&amp;&amp;(c)&lt;=&#39;z&#39;)?((c)- 0x20):(c))</code></pre></div><h1 id="判断字符是不是10进值的数字"><a href="#判断字符是不是10进值的数字" class="headerlink" title="判断字符是不是10进值的数字"></a>判断字符是不是10进值的数字</h1><div class="code-wrapper"><pre><code class="hljs">#define DECCHK( c )((c)&gt;=&#39;0&#39;&amp;&amp;(c)&lt;=&#39;9&#39;)</code></pre></div><h1 id="判断字符是不是16进值的数字"><a href="#判断字符是不是16进值的数字" class="headerlink" title="判断字符是不是16进值的数字"></a>判断字符是不是16进值的数字</h1><div class="code-wrapper"><pre><code class="hljs">#define HEXCHK( c )(((c)&gt;=&#39;0&#39;&amp;&amp;(c)&lt;=&#39;9&#39;)||((c)&gt;=&#39;A&#39;&amp;&amp;(c)&lt;=&#39;F&#39;)||((c)&gt;=&#39;a&#39;&amp;&amp;(c)&lt;=&#39;f&#39;))</code></pre></div><h1 id="防止溢出的一个方法"><a href="#防止溢出的一个方法" class="headerlink" title="防止溢出的一个方法"></a>防止溢出的一个方法</h1><div class="code-wrapper"><pre><code class="hljs">#define INC_SAT( val )(val =((val)+1 &gt;(val))?(val)+1 :(val))</code></pre></div><h1 id="返回数组元素的个数"><a href="#返回数组元素的个数" class="headerlink" title="返回数组元素的个数"></a>返回数组元素的个数</h1><div class="code-wrapper"><pre><code class="hljs">#define ARR_SIZE( a )(sizeof((a))/sizeof((a[0])))</code></pre></div><h1 id="使用一些宏跟踪调试"><a href="#使用一些宏跟踪调试" class="headerlink" title="使用一些宏跟踪调试"></a>使用一些宏跟踪调试</h1><div class="code-wrapper"><pre><code class="hljs">_LINE_ /*(两个下划线)，对应%d*/_FILE_ /*对应%s*/_DATE_ /*对应%s*/_TIME_ /*对应%s*/</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用命令及快捷键</title>
    <link href="/2020/12/04/04DevOps/10vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2020/12/04/04DevOps/10vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>关闭文件</strong><br>:w    //保存文件<br>:w vpser.net //保存至vpser.net文件<br>:q      //退出编辑器，如果文件已修改请使用下面的命令<br>:q!     //退出编辑器，且不保存<br>:wq     //退出编辑器，且保存文件<br>：x：保存当前文件并退出</p><p><strong>移动光标类命令</strong></p><p>h ：光标左移一个字符<br>l ：光标右移一个字符<br>space：光标右移一个字符<br>Backspace：光标左移一个字符<br>k或Ctrl+p：光标上移一行<br>j或Ctrl+n ：光标下移一行<br>Enter ：光标下移一行<br>w或W ：光标右移一个字至字首<br>b或B ：光标左移一个字至字首<br>e或E ：光标右移一个字至字尾<br>) ：光标移至句尾<br>( ：光标移至句首<br>}：光标移至段落开头<br>{：光标移至段落结尾<br>nG：光标移至第n行首<br>n+：光标下移n行<br>n-：光标上移n行<br>n$：光标移至第n行尾<br>H ：光标移至屏幕顶行<br>M ：光标移至屏幕中间行<br>L ：光标移至屏幕最后行<br>0：（注意是数字零）光标移至当前行首<br>$：光标移至当前行尾<br>n+     //向下跳n行<br>n-     //向上跳n行<br>nG     //跳到行号为n的行<br>G      //跳至文件的底部</p><p><strong>屏幕翻滚类命令</strong><br>Ctrl+u：向文件首翻半屏<br>Ctrl+d：向文件尾翻半屏<br>Ctrl+f：向文件尾翻一屏<br>Ctrl＋b；向文件首翻一屏<br>nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。</p><p><strong>插入文本类命令</strong><br>i ：在光标前<br>I ：在当前行首<br>a：光标后<br>A：在当前行尾<br>o：在当前行之下新开一行<br>O：在当前行之上新开一行<br>r：替换当前字符<br>R：替换当前字符及其后的字符，直至按ESC键<br>s：从当前光标位置处开始，以输入的文本替代指定数目的字符<br>S：删除指定数目的行，并以所输入文本代替之<br>ncw或nCW：修改指定数目的字<br>nCC：修改指定数目的行</p><p><strong>复制、粘贴</strong><br>yy   //将当前行复制到缓存区，也可以用 “ayy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>nyy  //将当前行向下n行复制到缓冲区，也可以用 “anyy 复制，”a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>yw   //复制从光标开始到词尾的字符。<br>nyw  //复制从光标开始的n个单词。<br>y^    //复制从光标到行首的内容。<br>y$    //复制从光标到行尾的内容。<br>p     //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用”ap 进行粘贴。<br>P     //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用”aP 进行粘贴。</p><p><strong>文本替换</strong><br>:s/old/new    //用new替换行中首次出现的old<br>:s/old/new/g     //用new替换行中所有的old<br>:n,m s/old/new/g   //用new替换从n到m行里所有的old<br>:%s/old/new/g    //用new替换当前文件里所有的old<br>:%s/\s+$//    //将行未空格删除<br>简单替换表达式<br>:%s/four/4/g<br>“%” 范围前缀表示在所有行中执行替换，最后的 “g” 标记表示替换行中的所有匹配点，如果仅仅对当前行进行操作，那么只要去掉%即可<br>如果你有一个像 “thirtyfour” 这样的单词，上面的命令会出错。这种情况下，这个单词会被替换成”thirty4″。要解决这个问题，用 “&lt; span&gt;来指定匹配单词开头：<br> :%s/<br>显然，这样在处理 “fourty” 的时候还是会出错。用 “&lt;” 来解决这个问题：<br> :%s//4/g<br>如果你在编码，你可能只想替换注释中的 “four”，而保留代码中的。由于这很难指定，可以在替换命令中加一个 “c” 标记，这样，Vim 会在每次替换前提示你：<br>:%s//4/gc</p><p><strong>单词精确匹配替换</strong><br>sed -e “s//new/g”  file</p><p><strong>删除命令</strong><br>ndw或ndW：删除光标处开始及其后的n-1个字<br>d0：删至行首   (0为数字)<br>d$：删至行尾<br>D : 删除至行尾<br>ndd：删除当前行及其后n-1行<br>x或X：删除一个字符，x删除光标后的，而X删除光标前的<br>Ctrl+u：删除输入方式下所输入的文本<br>x     //删除当前字符<br>nx     //删除从光标开始的n个字符<br>dd    //删除当前行<br>ndd   //向下删除当前行在内的n行<br>u     //撤销上一步操作<br>U    //撤销对当前行的所有操作</p><p><strong>搜索及替换命令</strong><br>/pattern：从光标开始处向文件尾搜索pattern<br>?pattern：从光标开始处向文件首搜索pattern<br>n：在同一方向重复上一次搜索命令<br>N：在反方向上重复上一次搜索命令<br>：s/p1/p2/g：将当前行中所有p1均用p2替代<br>：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代<br>：g/p1/s//p2/g：将文件中所有p1均用p2替换</p><p><strong>最后行方式命令</strong><br>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下<br>：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下<br>：n1,n2 d ：将n1行到n2行之间的内容删除<br>：e filename：打开文件filename进行编辑<br>：!command：执行shell命令command<br>：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入<br>：r!command：将命令command的输出结果放到当前行<br>：%!xxd  十六进制显示内容</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚继承</title>
    <link href="/2020/11/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/06%E8%99%9A%E7%BB%A7%E6%89%BF/"/>
    <url>/2020/11/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/06%E8%99%9A%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="虚继承的目的"><a href="#虚继承的目的" class="headerlink" title="虚继承的目的"></a>虚继承的目的</h1><p>虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。这将存在两个问题：</p><p>其一，浪费存储空间；</p><p>第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间及其转换</title>
    <link href="/2020/11/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/05%E6%97%B6%E9%97%B4/"/>
    <url>/2020/11/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/05%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-日历时间-Calendar-Time"><a href="#1-日历时间-Calendar-Time" class="headerlink" title="1. 日历时间(Calendar Time)"></a>1. 日历时间(Calendar Time)</h1><p>unix系统内部对时间的表示方式均是以自Epoch以来的秒数来度量的。Epoch即通用协调时间(UTC, 也称为格林威治标准时间，或GMT)的1970年1月1日早晨零点。</p><p>日历时间存储在类型为 <strong>time_t</strong>  的变量中。</p><h2 id="1-1-gettimeofday"><a href="#1-1-gettimeofday" class="headerlink" title="1.1 gettimeofday()"></a>1.1 gettimeofday()</h2><p> 可与tv指向的缓冲区中返回日历时间</p><p>int gettimeofday(struct timeval * tv, struct timezone *tz)</p><p>其中tv定义如下：</p><p>struct timeval {</p><p>​    time_t tv_sec;                 //      UTC 以来的秒数</p><p>​    suseconds_t tv_usec;    //  微妙</p><p>}</p><p>tz为历史产物，目前已经被废弃，应始终设置为NULL。</p><h2 id="1-2-time"><a href="#1-2-time" class="headerlink" title="1.2 time()"></a>1.2 time()</h2><p>time() 返回Epoch以来的秒数，和gettimeofday()所返回的tv参数中的tv_sec字段的数值相同。</p><h2 id="1-3-时间转换函数"><a href="#1-3-时间转换函数" class="headerlink" title="1.3 时间转换函数"></a>1.3 时间转换函数</h2><p>time_t 可通过以下转换函数实现不同格式间的转换</p><img src="/2020/11/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/05%E6%97%B6%E9%97%B4/time.png" class=""><h3 id="1-3-1-ctime"><a href="#1-3-1-ctime" class="headerlink" title="1.3.1 ctime()"></a>1.3.1 ctime()</h3><p>char* ctime(const time_t *timep) 将返回一个长达26字节的字符串 (包含\n \0 结束符)，内含标准格式的日期和时间。如下所示:<br><code>Tue Nov 17 12:22:34 CST 2020</code><br>ctime函数自动的对本地时区和DST（Daylight Saving Time， 即夏令时）的设置加以考虑，返回的字符串是静态分配，下一次调用将会覆盖上一次的值。（可使用ctime_r版本替换ctime，解决静态分配问题)</p><h3 id="1-3-2-gmtime-和localtime-将time-t转为分解时间"><a href="#1-3-2-gmtime-和localtime-将time-t转为分解时间" class="headerlink" title="1.3.2 gmtime() 和localtime() 将time_t转为分解时间"></a>1.3.2 gmtime() 和localtime() 将time_t转为分解时间</h3><p>函数gmtime()和localtime()可将time_t 的值转换为分解时间，分解时间被置于静态结构中，其地址作为函数结果返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">struct tm * <span class="hljs-title">gmtime</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">time_t</span> *timep)</span></span><br><span class="hljs-function">struct tm * <span class="hljs-title">localtime</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">time_t</span> * timep)</span></span><br></code></pre></td></tr></table></figure><p>gmtime 可以将<code>日历时间</code>转换为UTC的分解时间，（GM来自于格林威治标准时间)<br>localtime 将考虑时区和夏令时设置，返回对应于系统本地时间的一个分解时间</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">gmtime_r</span> 和localtime_r 为两个函数的可重入版本<br></code></pre></td></tr></table></figure><h3 id="1-3-3-mktime-将本地分解时间转为time-t"><a href="#1-3-3-mktime-将本地分解时间转为time-t" class="headerlink" title="1.3.3 mktime() 将本地分解时间转为time_t"></a>1.3.3 mktime() 将本地分解时间转为time_t</h3><p>这一转换会忽略输入tm结构中的tm_wday和tm_yday字段。</p><h2 id="1-4-分解时间和打印格式之间的转换"><a href="#1-4-分解时间和打印格式之间的转换" class="headerlink" title="1.4 分解时间和打印格式之间的转换"></a>1.4 分解时间和打印格式之间的转换</h2><h3 id="1-4-1-asctime"><a href="#1-4-1-asctime" class="headerlink" title="1.4.1 asctime()"></a>1.4.1 asctime()</h3><p>char* asctime(const struct tm* timeptr) 功能等同于ctime(), 只不过接收的参数是struct tm*类型；本地时区的设置对本函数没有影响<br><code>可重入版本为asctime_r()</code></p><h3 id="1-4-2-strftime-更精确的打印格式转换"><a href="#1-4-2-strftime-更精确的打印格式转换" class="headerlink" title="1.4.2 strftime() 更精确的打印格式转换"></a>1.4.2 strftime() 更精确的打印格式转换</h3><p>size_t strftime(char * outstr, size_t maxsize, const char * format, cosnt struct tm* timeptr); 在分解时间转换为打印格式时，可通过format 提供更为精确的控制。令timeptr指向分解时间，strftime()会将以null结尾，由日期和时间组成的响应字符串置于outstr所指向的缓冲区中</p><h3 id="strptime-将打印格时间-转换为分解时间"><a href="#strptime-将打印格时间-转换为分解时间" class="headerlink" title="strptime() 将打印格时间 转换为分解时间"></a>strptime() 将打印格时间 转换为分解时间</h3><p>函数strptime() 是strftime()的逆向函数，将字符串转为分解时间<br><code>char * strptime(cosnt char * str, const char * format, struct tm * timeptr)</code></p><h1 id="2-进程时间"><a href="#2-进程时间" class="headerlink" title="2. 进程时间"></a>2. 进程时间</h1><p>也成为cpu时间，以时钟滴答进行计算</p><h2 id="times"><a href="#times" class="headerlink" title="times()"></a>times()</h2><p>clock_t times(struct tms * buf) 获取程序执行消耗的用户时间和cpu时间，tms结构体的前两个字返回调用进程到目前为止使用的用户和系统组件的cpu时间，最后两个字段返回的信息是：父进程(比如，times()的调用者)执行了系统调用wait()的所有已经终止的子进程使用的cpu时间。<br>clock_t 是用时钟计时单元为单位度量时间的整型值。我们可以调用sysconf(_SC_CLK_TCK)来获取每秒包含的时钟计时单元数，然后用这个数字除以clock_t 转换为秒</p><p>注意：clock_t 是有有效范围的，溢出后，times(0的返回值将再次从0开始计算)</p><h2 id="clock"><a href="#clock" class="headerlink" title="clock()"></a>clock()</h2><p>函数<code>clock_t clock(void);</code>  提供了一个简单的接口用于取得进程时间。它返回一个值描述了调用进程使用的总的CPU时间（包括用户和系统).</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>监控进程的句柄及启动时间</title>
    <link href="/2020/11/12/04DevOps/09%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%A5%E6%9F%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <url>/2020/11/12/04DevOps/09%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%A5%E6%9F%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">################################################################################</span><br><span class="hljs-comment">#  Copyright (C) 2015-2018 IQIYI All rights reserved.</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#  Author     : </span><br><span class="hljs-comment">#  E-mail     : fly542@gmail.com</span><br><span class="hljs-comment">#  Version    :</span><br><span class="hljs-comment">#  Date       : Wed 04 Nov 2020 09:15:31 AM CST</span><br><span class="hljs-comment">#  Destription: 监控相关句柄数是否正常，每2秒输出一次相关内容</span><br><span class="hljs-comment">#               使用方法：./watch_fd 进程过滤唯一关键字</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">################################################################################</span><br><span class="hljs-built_in">cd</span> `dirname <span class="hljs-variable">$0</span>`<br><br>keyInfo=<span class="hljs-variable">$1</span><br>proc_num=<span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment"># 获取到的最新进程id</span><br>sleep_idle=2   <span class="hljs-comment"># 监控间隔</span><br>outSeq=1       <span class="hljs-comment"># 输出行数</span><br>procInfoInt=20 <span class="hljs-comment"># 进程启动信息输出记录行数，</span><br><br>startTime=0<br><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;keyInfo&#125;</span>&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;usage: <span class="hljs-variable">$0</span> key_path &quot;</span><br>    <span class="hljs-built_in">exit</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;key path=<span class="hljs-variable">$&#123;keyInfo&#125;</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 获取进程的启动时间</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">GetProcStartTime</span></span>() <br>&#123; <br>    <span class="hljs-built_in">local</span> PID=<span class="hljs-variable">$1</span><br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$&#123;PID&#125;</span> ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;usage <span class="hljs-variable">$&#123;0&#125;</span> pid&quot;</span><br>        <span class="hljs-built_in">return</span> 0    <br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">local</span> STARTTIME=$(awk <span class="hljs-string">&#x27;&#123;print int($22 /100)&#125;&#x27;</span> /proc/<span class="hljs-variable">$PID</span>/<span class="hljs-built_in">stat</span>)<br>    <span class="hljs-built_in">local</span> UT=$(awk <span class="hljs-string">&#x27;&#123;print int($1)&#125;&#x27;</span> /proc/uptime)<br>    <span class="hljs-built_in">local</span> NOW=$(date +%s)<br>    startTime=$((NOW - (UT - STARTTIME)))<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;proc <span class="hljs-variable">$PID</span> start at : `date -d @<span class="hljs-variable">$startTime</span>`&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 获取最新进程的进程id</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">GetLatestPid</span></span>()<br>&#123; <br>    proc_num_all=(`ps -ef |grep <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;keyInfo&#125;</span>&quot;</span> |grep -v grep |awk <span class="hljs-string">&#x27;&#123;print $2,$8&#125;&#x27;</span> |grep <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;keyInfo&#125;</span>&quot;</span> |awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`)<br>    proc_num=<span class="hljs-variable">$&#123;proc_num_all[@]&#125;</span><br>    <span class="hljs-keyword">for</span> tmpPid <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;proc_num_all[@]&#125;</span>&quot;</span><br>    <span class="hljs-keyword">do</span><br>        oldTime=<span class="hljs-variable">$&#123;startTime&#125;</span><br>        GetProcStartTime <span class="hljs-variable">$&#123;tmpPid&#125;</span><br>        <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;oldTime&#125;</span> -lt <span class="hljs-variable">$&#123;startTime&#125;</span> ]<br>        <span class="hljs-keyword">then</span><br>            proc_num=<span class="hljs-variable">$&#123;tmpPid&#125;</span><br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br>&#125;<br><br>GetLatestPid<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    sleep <span class="hljs-variable">$&#123;sleep_idle&#125;</span><br>    <span class="hljs-keyword">if</span> [ ! -d /proc/<span class="hljs-variable">$&#123;proc_num&#125;</span> ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;proc <span class="hljs-variable">$&#123;proc_num&#125;</span> is dead&quot;</span><br>    <span class="hljs-keyword">else</span> <br>        proInfo=`ls /proc/<span class="hljs-variable">$&#123;proc_num&#125;</span>/fd -l 2&gt;&amp;1 |awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">        BEGIN &#123;sum=0; sock=0; efd=0; ep=0; fd=0;&#125; </span><br><span class="hljs-string">        &#123; </span><br><span class="hljs-string">            sum += 1; </span><br><span class="hljs-string">            if($0~&quot;socket&quot;) &#123; sock+=1; &#125; </span><br><span class="hljs-string">            else if($0~&quot;eventfd&quot;) &#123; efd+=1; &#125; </span><br><span class="hljs-string">            else if($0~&quot;eventpoll&quot;) &#123; ep+=1; &#125; </span><br><span class="hljs-string">            else &#123; fd+=1; &#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        END &#123;print &quot;total_fd=&quot;sum, &quot;sock_num=&quot;sock, &quot;eventfd_num=&quot;efd, &quot;eventpool_num=&quot;ep, &quot;file_fd=&quot;fd &#125;&#x27;</span><br>        `<br>        vmInfo=`cat /proc/<span class="hljs-variable">$&#123;proc_num&#125;</span>/status |awk <span class="hljs-string">&#x27;BEGIN&#123;vm=&quot;&quot;; rss=&quot;&quot;;&#125; &#123; if($0~&quot;VmSize&quot;) vm=$2$3 fi; if($0~&quot;VmRSS&quot;) rss=$2$3 fi;&#125; END &#123;print &quot;VmSize=&quot;vm, &quot;VmRSS=&quot;rss&#125;&#x27;</span>`<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;`date &quot;</span>+%Y-%m-%d %T<span class="hljs-string">&quot;` pid=<span class="hljs-variable">$&#123;proc_num&#125;</span> <span class="hljs-variable">$&#123;proInfo&#125;</span> <span class="hljs-variable">$&#123;vmInfo&#125;</span>&quot;</span><br>        outSeq=$((<span class="hljs-variable">$&#123;outSeq&#125;</span>+<span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">if</span> [ $(( <span class="hljs-variable">$outSeq</span> % <span class="hljs-variable">$&#123;procInfoInt&#125;</span> )) -eq 0 ]<br>        <span class="hljs-keyword">then</span><br>            GetProcStartTime <span class="hljs-variable">$&#123;proc_num&#125;</span><br>        <span class="hljs-keyword">fi</span><br><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>01 kafka 驱动使用详解</title>
    <link href="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/01%20kafka%E9%A9%B1%E5%8A%A8/"/>
    <url>/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/01%20kafka%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="c-c-驱动地址"><a href="#c-c-驱动地址" class="headerlink" title="c/c++驱动地址"></a>c/c++驱动地址</h2><p>国内：<a href="https://gitee.com/mirrors/librdkafka">https://gitee.com/mirrors/librdkafka</a></p><p>github: <a href="https://github.com/edenhill/librdkafka">https://github.com/edenhill/librdkafka</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>高性能代理软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka基础</title>
    <link href="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本文转载自《<a href="https://developer.51cto.com/art/202003/611798.htm%E3%80%8B">https://developer.51cto.com/art/202003/611798.htm》</a></p><p>本文主要讲解 Kafka 是什么、Kafka 的架构包括工作流程和存储机制，以及生产者和消费者。</p><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p>Kafka 是一个分布式的基于发布/订阅模式的消息队列(Message Queue)，主要应用与大数据实时处理领域。</p><p><strong>消息队列</strong></p><p>Kafka 本质上是一个 MQ(Message Queue)，使用消息队列的好处?(面试会问)</p><ul><li><strong>解耦</strong>：允许我们独立的扩展或修改队列两边的处理过程。</li><li><strong>可恢复性</strong>：即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</li><li><strong>缓冲</strong>：有助于解决生产消息和消费消息的处理速度不一致的情况。</li><li><strong>灵活性&amp;峰值处理能力</strong>：不会因为突发的超负荷的请求而完全崩溃，消息队列能够使关键组件顶住突发的访问压力。</li><li><strong>异步通信</strong>：消息队列允许用户把消息放入队列但不立即处理它。</li></ul><p><strong>发布/订阅模式</strong></p><p>一对多，生产者将消息发布到 Topic 中，有多个消费者订阅该主题，发布到 Topic 的消息会被所有订阅者消费，被消费的数据不会立即从 Topic 清除。</p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/1.jpg" class=""><h1 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h1><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/2.jpg" class=""><p>Kafka 存储的消息来自任意多被称为 Producer 生产者的进程。数据从而可以被发布到不同的 Topic 主题下的不同 Partition 分区。</p><p>在一个分区内，这些消息被索引并连同时间戳存储在一起。其它被称为 Consumer 消费者的进程可以从分区订阅消息。</p><p>Kafka 运行在一个由一台或多台服务器组成的集群上，并且分区可以跨集群结点分布。</p><p>下面给出 Kafka 一些重要概念，让大家对 Kafka 有个整体的认识和感知，后面还会详细的解析每一个概念的作用以及更深入的原理：</p><ul><li><strong>Producer</strong>： 消息生产者，向 Kafka Broker 发消息的客户端。</li><li><strong>Consumer</strong>：消息消费者，从 Kafka Broker 取消息的客户端。</li><li><strong>Consumer Group</strong>：消费者组(CG)，消费者组内每个消费者负责消费不同分区的数据，提高消费能力。一个分区只能由组内一个消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li><li><strong>Broker</strong>：一台 Kafka 机器就是一个 Broker。一个集群由多个 Broker 组成。一个 Broker 可以容纳多个 Topic。</li><li><strong>Topic</strong>：可以理解为一个队列，Topic 将消息分类，生产者和消费者面向的是同一个 Topic。</li><li><strong>Partition</strong>：为了实现扩展性，提高并发能力，一个非常大的 Topic 可以分布到多个 Broker (即服务器)上，一个 Topic 可以分为多个 Partition，每个 Partition 是一个 有序的队列。</li><li><strong>Replica</strong>：副本，为实现备份的功能，保证集群中的某个节点发生故障时，该节点上的 Partition 数据不丢失，且 Kafka 仍然能够继续工作，Kafka 提供了副本机制，一个 Topic 的每个分区都有若干个副本，一个 Leader 和若干个 Follower。</li><li><strong>Leader</strong>：每个分区多个副本的“主”副本，生产者发送数据的对象，以及消费者消费数据的对象，都是 Leader。</li><li><strong>Follower</strong>：每个分区多个副本的“从”副本，实时从 Leader 中同步数据，保持和 Leader 数据的同步。Leader 发生故障时，某个 Follower 还会成为新的 Leader。</li><li><strong>Offset</strong>：消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从消费位置继续消费。</li><li><strong>Zookeeper</strong>：Kafka 集群能够正常工作，需要依赖于 Zookeeper，Zookeeper 帮助 Kafka 存储和管理集群信息。</li></ul><h1 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3. 工作流程"></a>3. 工作流程</h1><p>Kafka集群将 Record 流存储在称为 Topic 的类别中，每个记录由一个键、一个值和一个时间戳组成。</p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/3.jpg" class=""><p>Kafka 是一个分布式流平台，这到底是什么意思?</p><ul><li>发布和订阅记录流，类似于消息队列或企业消息传递系统。</li><li>以容错的持久方式存储记录流。</li><li>处理记录流。</li></ul><p>Kafka 中消息是以 Topic 进行分类的，生产者生产消息，消费者消费消息，面向的都是同一个 Topic。</p><p>Topic 是逻辑上的概念，而 Partition 是物理上的概念，每个 Partition 对应于一个 log 文件，该 log 文件中存储的就是 Producer 生产的数据。</p><p>Producer 生产的数据会不断追加到该 log 文件末端，且每条数据都有自己的 Offset。</p><p>消费者组中的每个消费者，都会实时记录自己消费到了哪个 Offset，以便出错恢复时，从上次的位置继续消费。</p><h1 id="4-存储机制"><a href="#4-存储机制" class="headerlink" title="4. 存储机制"></a>4. 存储机制</h1><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/4.jpg" class=""><p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka 采取了分片和索引机制。</p><p>它将每个 Partition 分为多个 Segment，每个 Segment 对应两个文件：“.index” 索引文件和 “.log” 数据文件。</p><p>这些文件位于同一文件下，该文件夹的命名规则为：topic 名-分区号。例如，first 这个 topic 有三分分区，则其对应的文件夹为 first-0，first-1，first-2。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs pgsql"># ls /root/data/kafka/first<span class="hljs-number">-0</span><br><span class="hljs-number">00000000000000009014.</span><span class="hljs-keyword">index</span><br><span class="hljs-number">00000000000000009014.</span><span class="hljs-keyword">log</span><br><span class="hljs-number">00000000000000009014.</span>timeindex<br><span class="hljs-number">00000000000000009014.</span><span class="hljs-keyword">snapshot</span><br>leader-epoch-<span class="hljs-keyword">checkpoint</span> <br></code></pre></td></tr></table></figure><p>index 和 log 文件以当前 Segment 的第一条消息的 Offset 命名。下图为 index 文件和 log 文件的结构示意图：</p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/5.jpg" class=""><p>“.index” 文件存储大量的索引信息，“.log” 文件存储大量的数据，索引文件中的元数据指向对应数据文件中 Message 的物理偏移量。</p><h1 id="5-生产者"><a href="#5-生产者" class="headerlink" title="5. 生产者"></a>5. 生产者</h1><p><strong>分区策略</strong></p><p><strong>分区原因：</strong></p><ul><li>方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 Topic 又可以有多个 Partition 组成，因此可以以 Partition 为单位读写了。</li><li>可以提高并发，因此可以以 Partition 为单位读写了。</li></ul><p><strong>分区原则</strong>：我们需要将 Producer 发送的数据封装成一个 ProducerRecord 对象。</p><p>该对象需要指定一些参数：</p><ul><li>topic：string 类型，NotNull。</li><li>partition：int 类型，可选。</li><li>timestamp：long 类型，可选。</li><li>key：string 类型，可选。</li><li>value：string 类型，可选。</li><li>headers：array 类型，Nullable。</li></ul><p>①指明 Partition 的情况下，直接将给定的 Value 作为 Partition 的值。</p><p>②没有指明 Partition 但有 Key 的情况下，将 Key 的 Hash 值与分区数取余得到 Partition 值。</p><p>③既没有 Partition 有没有 Key 的情况下，第一次调用时随机生成一个整数(后面每次调用都在这个整数上自增)，将这个值与可用的分区数取余，得到 Partition 值，也就是常说的 Round-Robin 轮询算法。</p><p><strong>数据可靠性保证</strong></p><p>为保证 Producer 发送的数据，能可靠地发送到指定的 Topic，Topic 的每个 Partition 收到 Producer 发送的数据后，都需要向 Producer 发送 ACK(ACKnowledge 确认收到)。</p><p>如果 Producer 收到 ACK，就会进行下一轮的发送，否则重新发送数据。</p><p><strong>①副本数据同步策略</strong></p><p>何时发送 ACK?确保有 Follower 与 Leader 同步完成，Leader 再发送 ACK，这样才能保证 Leader 挂掉之后，能在 Follower 中选举出新的 Leader 而不丢数据。</p><p>多少个 Follower 同步完成后发送 ACK?全部 Follower 同步完成，再发送 ACK。</p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/7.jpg" class=""><p><strong>②ISR</strong></p><p>采用第二种方案，所有 Follower 完成同步，Producer 才能继续发送数据，设想有一个 Follower 因为某种原因出现故障，那 Leader 就要一直等到它完成同步。</p><p>这个问题怎么解决?Leader维护了一个动态的 in-sync replica set(ISR)：和 Leader 保持同步的 Follower 集合。</p><p>当 ISR 集合中的 Follower 完成数据的同步之后，Leader 就会给 Follower 发送 ACK。</p><p>如果 Follower 长时间未向 Leader 同步数据，则该 Follower 将被踢出 ISR 集合，该时间阈值由 replica.lag.time.max.ms 参数设定。Leader 发生故障后，就会从 ISR 中选举出新的 Leader。</p><p><strong>③ACK 应答机制</strong></p><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没必要等 ISR 中的 Follower 全部接受成功。</p><p>所以 Kafka 为用户提供了三种可靠性级别，用户根据可靠性和延迟的要求进行权衡，选择以下的配置。</p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/8.jpg" class=""><p>Ack 参数配置：</p><ul><li>0：Producer 不等待 Broker 的 ACK，这提供了最低延迟，Broker 一收到数据还没有写入磁盘就已经返回，当 Broker 故障时有可能丢失数据。</li><li>1：Producer 等待 Broker 的 ACK，Partition 的 Leader 落盘成功后返回 ACK，如果在 Follower 同步成功之前 Leader 故障，那么将会丢失数据。</li><li>-1(all)：Producer 等待 Broker 的 ACK，Partition 的 Leader 和 Follower 全部落盘成功后才返回 ACK。但是在 Broker 发送 ACK 时，Leader 发生故障，则会造成数据重复。</li></ul><p><strong>④故障处理细节</strong></p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/9.jpg" class=""><p>LEO：每个副本最大的 Offset。HW：消费者能见到的最大的 Offset，ISR 队列中最小的 LEO。</p><p><strong>Follower 故障</strong>：Follower 发生故障后会被临时踢出 ISR 集合，待该 Follower 恢复后，Follower 会 读取本地磁盘记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 Leader 进行同步数据操作。</p><p>等该 Follower 的 LEO 大于等于该 Partition 的 HW，即 Follower 追上 Leader 后，就可以重新加入 ISR 了。</p><p><strong>Leader 故障</strong>：Leader 发生故障后，会从 ISR 中选出一个新的 Leader，之后，为保证多个副本之间的数据一致性，其余的 Follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 Leader 同步数据。</p><p>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p><p><strong>Exactly Once 语义</strong></p><p>将服务器的 ACK 级别设置为 -1，可以保证 Producer 到 Server 之间不会丢失数据，即 At Least Once 语义。</p><p>相对的，将服务器 ACK 级别设置为 0，可以保证生产者每条消息只会被发送一次，即 At Most Once 语义。</p><p>At Least Once 可以保证数据不丢失，但是不能保证数据不重复;相对的，At Most Once 可以保证数据不重复，但是不能保证数据不丢失。</p><p>但是，对于一些非常重要的信息，比如交易数据，下游数据消费者要求数据既不重复也不丢失，即 Exactly Once 语义。</p><p>0.11 版本的 Kafka，引入了幂等性：Producer 不论向 Server 发送多少重复数据，Server 端都只会持久化一条。</p><p>即：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">At</span> <span class="hljs-variable">Least</span> <span class="hljs-built_in">Once</span> <span class="hljs-operator">+</span> 幂等性 <span class="hljs-operator">=</span> <span class="hljs-variable">Exactly</span> <span class="hljs-built_in">Once</span> <br></code></pre></td></tr></table></figure><p>要启用幂等性，只需要将 Producer 的参数中 enable.idompotence 设置为 true 即可。</p><p>开启幂等性的 Producer 在初始化时会被分配一个 PID，发往同一 Partition 的消息会附带 Sequence Number。</p><p>而 Borker 端会对</p><p>但是 PID 重启后就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨分区会话的 Exactly Once。</p><h1 id="6-消费者"><a href="#6-消费者" class="headerlink" title="6. 消费者"></a>6. 消费者</h1><p><strong>消费方式</strong></p><p>Consumer 采用 Pull(拉取)模式从 Broker 中读取数据。</p><p>Consumer 采用 Push(推送)模式，Broker 给 Consumer 推送消息的速率是由 Broker 决定的，很难适应消费速率不同的消费者。</p><p>它的目标是尽可能以最快速度传递消息，但是这样很容易造成 Consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。</p><p>而 Pull 模式则可以根据 Consumer 的消费能力以适当的速率消费消息。Pull 模式不足之处是，如果 Kafka 没有数据，消费者可能会陷入循环中，一直返回空数据。</p><p>因为消费者从 Broker 主动拉取数据，需要维护一个长轮询，针对这一点， Kafka 的消费者在消费数据时会传入一个时长参数 timeout。</p><p>如果当前没有数据可供消费，Consumer 会等待一段时间之后再返回，这段时长即为 timeout。</p><p><strong>分区分配策略</strong></p><p>一个 Consumer Group 中有多个 Consumer，一个 Topic 有多个 Partition，所以必然会涉及到 Partition 的分配问题，即确定哪个 Partition 由哪个 Consumer 来消费。</p><p>Kafka 有两种分配策略，一个是 RoundRobin，一个是 Range，默认为Range，当消费者组内消费者发生变化时，会触发分区分配策略(方法重新分配)。</p><p><strong>①RoundRobin</strong></p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/10.jpg" class=""><p>RoundRobin 轮询方式将分区所有作为一个整体进行 Hash 排序，消费者组内分配分区个数最大差别为 1，是按照组来分的，可以解决多个消费者消费数据不均衡的问题。</p><p>但是，当消费者组内订阅不同主题时，可能造成消费混乱，如下图所示，Consumer0 订阅主题 A，Consumer1 订阅主题 B。</p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/11.jpg" class=""><p>将 A、B 主题的分区排序后分配给消费者组，TopicB 分区中的数据可能分配到 Consumer0 中。</p><p><strong>②Range</strong></p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/12.jpg" class=""><p>Range 方式是按照主题来分的，不会产生轮询方式的消费混乱问题。</p><p>但是，如下图所示，Consumer0、Consumer1 同时订阅了主题 A 和 B，可能造成消息分配不对等问题，当消费者组内订阅的主题越多，分区分配可能越不均衡。</p><img src="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/05%20kafka/00%20kafka%E5%9F%BA%E7%A1%80/13.jpg" class=""><p><strong>Offset 的维护</strong></p><p>由于 Consumer 在消费过程中可能会出现断电宕机等故障，Consumer 恢复后，需要从故障前的位置继续消费。</p><p>所以 Consumer 需要实时记录自己消费到了哪个 Offset，以便故障恢复后继续消费。</p><p>Kafka 0.9 版本之前，Consumer 默认将 Offset 保存在 Zookeeper 中，从 0.9 版本开始，Consumer 默认将 Offset 保存在 Kafka 一个内置的 Topic 中，该 Topic 为 __consumer_offsets。</p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>上面和大家一起深入探讨了 Kafka 的架构，比较偏重理论和基础，这是掌握 Kafka 的必要内容，接下来我会以代码和实例的方式，更新 Kafka 有关 API 以及事务、拦截器、监控等高级篇，让大家彻底理解并且会用 Kafka。</p><p>作者：臧远慧</p>]]></content>
    
    
    <categories>
      
      <category>高性能代理软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scylladb 介绍</title>
    <link href="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/04%20scylladb&amp;&amp;cassandra/00%20scylladb/"/>
    <url>/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/04%20scylladb&amp;&amp;cassandra/00%20scylladb/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ScyllaDB是用C++重写的Cassandra，其官网宣称其每节点每秒可处理100万TPS。ScyllaDB完全兼容Apache Cassandra，拥有比Cassandra多10X倍的吞吐量，并降低了延迟。ScyllaDB是性能优异的NoSQL列存储数据库。</p><p>ScyllaDB在垃圾收集或者Compaction的时候不需要暂停（但是通过压测和Longevity测试发现Compaction的过程中对性能还是有很大影响）。</p><p>ScyllaDB在常规生产负载的时候可以添加或删除节点（通过nodetool来同步数据）。</p><p>ScyllaDB是一个P2P的分布式系统，集群中各节点之间相互平等。其数据分布于集群中的各节点，各节点之间每秒钟交换一次信息。</p><p>其每个节点使用Commit Log提交日志捕获写操作来保持数据的正确性。数据首先被写入MemTable（内存中的数据结构）中。当MemTable满后数据被写入SSTable（存储在硬盘上的数据文件）中。</p><p>用户可以使用类似于SQL的CQL来查询数据。用户可以链接至集群中的任意节点。</p><p>在集群中，一个Keyspace代表关系数据库中的一个数据库。一个Keyspace中可以包含多个表。</p><p>参考文档： <a href="https://blog.csdn.net/mytobaby00/article/details/80375196">https://blog.csdn.net/mytobaby00/article/details/80375196</a></p><h1 id="驱动使用说明："><a href="#驱动使用说明：" class="headerlink" title="驱动使用说明："></a>驱动使用说明：</h1><p>datastax提供的cpp驱动，在 centos7 下只能安装v2.9.0 版，高于2.9.0版由于ssl原因无法编译通过，待研究解决中。<br>2.9版驱动地址： <a href="https://downloads.datastax.com/cpp-driver/centos/7/cassandra/v2.9.0/">https://downloads.datastax.com/cpp-driver/centos/7/cassandra/v2.9.0/</a></p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p>官方网址：<a href="https://www.scylladb.com/download/#drivers">https://www.scylladb.com/download/#drivers</a><br>官网驱动列表：<a href="https://docs.scylladb.com/getting-started/scylla_drivers/">https://docs.scylladb.com/getting-started/scylla_drivers/</a><br>Cassandra 驱动源码地址：<a href="https://github.com/datastax/cpp-driver/">https://github.com/datastax/cpp-driver/</a><br>Cassandra 驱动rpm包地址: <a href="https://downloads.datastax.com/cpp-driver/centos/7/cassandra/">https://downloads.datastax.com/cpp-driver/centos/7/cassandra/</a><br>Cassandra 驱动依赖包地址: <a href="https://downloads.datastax.com/cpp-driver/centos/7/dependencies/libuv/">https://downloads.datastax.com/cpp-driver/centos/7/dependencies/libuv/</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>scylladb 驱动使用方法</title>
    <link href="/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/04%20scylladb&amp;&amp;cassandra/01%20scylladb%20%E9%A9%B1%E5%8A%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2020/08/31/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/04%20scylladb&amp;&amp;cassandra/01%20scylladb%20%E9%A9%B1%E5%8A%A8%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文主要总结下 scylladb 的c/c++驱动使用详细方法与步骤，便于快速进行开发。</p><h2 id="1-基本使用步骤"><a href="#1-基本使用步骤" class="headerlink" title="1. 基本使用步骤"></a>1. 基本使用步骤</h2><h3 id="创建-cluster"><a href="#创建-cluster" class="headerlink" title="创建 cluster"></a>创建 cluster</h3><ol><li>创建方法：<br> CassCluster * cluster = cass_cluster_new();<br> cass_cluster_free(cluster); //不用时释放申请的资源</li><li>对cluster进行参数设置</li></ol><p>根据需要对cluster 进行各种相关参数的设置，主要进行以下设置</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">cass<span class="hljs-constructor">_cluster_set_port(<span class="hljs-params">cluster</span>, <span class="hljs-params">port</span>)</span>;  <span class="hljs-comment">//设置集群连接的端口号</span><br>cass<span class="hljs-constructor">_cluster_set_contact_points(<span class="hljs-params">cluster</span>, <span class="hljs-params">addr</span>)</span>; <span class="hljs-comment">//设置集群连接地址，只需要指定一个地址即可</span><br>cass<span class="hljs-constructor">_cluster_set_credentials(<span class="hljs-params">cluster</span>, <span class="hljs-params">user</span>, <span class="hljs-params">pass</span>)</span>; <span class="hljs-comment">//设置集群连接时的认证信息(用户名、密码)</span><br>cass<span class="hljs-constructor">_cluster_set_num_threads_io(<span class="hljs-params">cluster</span>, <span class="hljs-params">num</span>)</span>; <span class="hljs-comment">//设置处理io的线程数，，默认2个</span><br>cass<span class="hljs-constructor">_cluster_set_core_connections_per_host(<span class="hljs-params">cluster</span>, <span class="hljs-params">count</span>)</span>; <span class="hljs-comment">// 设置集群中每个服务端的连接数，默认为1个</span><br></code></pre></td></tr></table></figure><p>总的io连接数=io线程数 × 每个服务端的连接数 × 集群服务端个数</p><h3 id="创建-session"><a href="#创建-session" class="headerlink" title="创建 session"></a>创建 session</h3><p>CassSession维护每个节点的连接以及可调整的I / O线程池，以根据负载平衡策略进行查询。 因为CassSession是线程安全的，所以通常建议您为每个 keyspace 创建一个会话，并在应用程序线程之间共享它。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">CassSession<span class="hljs-operator"> * </span>session = cass<span class="hljs-constructor">_session_new()</span>;<br>cass<span class="hljs-constructor">_session_free(<span class="hljs-params">session</span>)</span>;  <span class="hljs-comment">//不用时释放申请的资源</span><br></code></pre></td></tr></table></figure><h3 id="执行操作语句"><a href="#执行操作语句" class="headerlink" title="执行操作语句"></a>执行操作语句</h3><p>执行操作主要按以下步骤进行处理</p><ol><li>创建操作执行对象<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">CassStatement<span class="hljs-operator"> * </span>statement = cass<span class="hljs-constructor">_statement_new(<span class="hljs-params">qstr</span>.<span class="hljs-params">c_str</span>()</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>第一个参数为要执行的操作语句，第二个参数代表要使用的占位符个数，在批量循环处理的时候使用占位符时使用，</li><li>执行具体操作语句<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">CassFuture<span class="hljs-operator"> * </span>futrue = cass<span class="hljs-constructor">_session_execute(<span class="hljs-params">session</span>, <span class="hljs-params">statement</span>)</span>;<br></code></pre></td></tr></table></figure></li><li>等待执行结果<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cass<span class="hljs-constructor">_future_wait(<span class="hljs-params">future</span>)</span>;<br></code></pre></td></tr></table></figure></li><li>判定执行结果<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (CASS_OK != cass_future_error_code(future)) &#123;<br><span class="hljs-regexp">//</span> 异常处理<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-regexp">//</span> 成功执行相关语句<br>&#125;<br></code></pre></td></tr></table></figure></li><li>释放执行资源<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cass<span class="hljs-constructor">_statement_free(<span class="hljs-params">statement</span>)</span>;<br>cass<span class="hljs-constructor">_future_free(<span class="hljs-params">future</span>)</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-封装库示例"><a href="#2-封装库示例" class="headerlink" title="2. 封装库示例"></a>2. 封装库示例</h2><p>头文件db_scylla.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cassandra.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> DB &#123;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ed_error</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">scylla_obj</span></span><br><span class="hljs-class">&#123;</span> <span class="hljs-comment">//数据库查询查询传递对象</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">scylla_obj</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">scylla_obj</span> () &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    std::string  uri_;                          <span class="hljs-comment">//uri</span><br>    std::vector&lt;std::string&gt; vidc_;             <span class="hljs-comment">//idc列表</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">record_scylla</span> :</span> <span class="hljs-keyword">public</span> record_base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">record_scylla</span>();<br>    ~<span class="hljs-built_in">record_scylla</span>();<br><br><span class="hljs-keyword">public</span>:<br>    std::string  uri_;                           <span class="hljs-comment">//uri</span><br>    std::string  vidc_;                          <span class="hljs-comment">//vidc</span><br>    std::string  cache_;                         <span class="hljs-comment">//cache</span><br>    std::string  zone_;                          <span class="hljs-comment">//zone</span><br>    <span class="hljs-keyword">int</span>     type_;                          <span class="hljs-comment">//type</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">db_scylla</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">db_scylla</span> ();<br>    ~<span class="hljs-built_in">db_scylla</span> ();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打开数据库</span><br><span class="hljs-comment">     * @param addr 要打开的地址</span><br><span class="hljs-comment">     * @param port 要打开的端口号</span><br><span class="hljs-comment">     * @return true 成功打开，false 打开失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * addr, <span class="hljs-keyword">int</span> port)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询内容</span><br><span class="hljs-comment">     * @param obj 要查询的信息</span><br><span class="hljs-comment">     * @param bhot 是否是查询热点数据</span><br><span class="hljs-comment">     * @param vec 返回查询结果</span><br><span class="hljs-comment">     * @param err 错误时返回错误详细信息</span><br><span class="hljs-comment">     * @return true 成功查询，false 未查询到</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">const</span> scylla_obj &amp; obj, <span class="hljs-keyword">bool</span> bhot,</span></span><br><span class="hljs-params"><span class="hljs-function">            std::vector&lt;record_scylla&gt; &amp; vec, ed_error * err)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 批量插入数据</span><br><span class="hljs-comment">     * @param vec 要插入的数据总量</span><br><span class="hljs-comment">     * @param ttl 过期时间 &lt;=0 则永不过期，单位秒</span><br><span class="hljs-comment">     * @param err 出错时返回错误详细信息</span><br><span class="hljs-comment">     * @return  成功插入记录数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;record_scylla&gt; &amp; vec,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ttl, ed_error * err)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除数据</span><br><span class="hljs-comment">     * @param vec 要删除的记录</span><br><span class="hljs-comment">     * @param err 出错时返回错误详细信息</span><br><span class="hljs-comment">     * @return 成功删除的记录数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;record_scylla&gt; &amp; vec, ed_error * err)</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置认证的用户名和密码</span><br><span class="hljs-comment">     * @param user 用户名</span><br><span class="hljs-comment">     * @param pass 密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_auth</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * user, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * pass)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置连接超时</span><br><span class="hljs-comment">     * @param ms_timeout 超时时间，单位ms</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_conn_timeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ms_timeout)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置读写超时</span><br><span class="hljs-comment">     * @param timeout 超时时间，单位ms</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_rw_timeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ms_timeout)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置scyllad 处理io的线程数</span><br><span class="hljs-comment">     * @param cn 线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_io_thread_num</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cn)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建session连接</span><br><span class="hljs-comment">     * @return 非NULL 成功连接，返回连接对象，NULL 连接失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">CassSession* <span class="hljs-title">create_connect_session</span><span class="hljs-params">(ed_error *err)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取查询的字符串信息</span><br><span class="hljs-comment">     * @param obj 要查询的对象信息</span><br><span class="hljs-comment">     * @param bhot 是否是查询热点数据</span><br><span class="hljs-comment">     * @param str 返回查询字符串</span><br><span class="hljs-comment">     * @param cloNum 返回查询的字段个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_query_string</span><span class="hljs-params">(<span class="hljs-keyword">const</span> scylla_obj &amp; obj, <span class="hljs-keyword">bool</span> bhot, acl::string &amp; str)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从row中解析一条记录到vec中</span><br><span class="hljs-comment">     * @param row 要解析的行</span><br><span class="hljs-comment">     * @param bhot 是否是查询热点数据</span><br><span class="hljs-comment">     * @param vec 存储解析结果</span><br><span class="hljs-comment">     * @return true 成功解析，false 解析失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">parse_one_record</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CassRow* row, <span class="hljs-keyword">bool</span> bhot,</span></span><br><span class="hljs-params"><span class="hljs-function">            std::vector&lt;record_scylla&gt; &amp; vec)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取其中某一列的值</span><br><span class="hljs-comment">     * @param row 行信息</span><br><span class="hljs-comment">     * @param cname 列名</span><br><span class="hljs-comment">     * @param value 返回获取到的value</span><br><span class="hljs-comment">     * @return true 成功获取，false 获取失败</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">get_col_value</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CassRow* row, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * cname,</span></span><br><span class="hljs-params"><span class="hljs-function">            std::string &amp; value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">get_col_value</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CassRow* row, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * cname, <span class="hljs-keyword">int</span> &amp; value)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取删除条件字符串</span><br><span class="hljs-comment">     * @param key 添加的条件字符串</span><br><span class="hljs-comment">     * @param key_title 添加时使用的关键字</span><br><span class="hljs-comment">     * @param all 返回添加后的结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_remove_cond_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * key_title, std::string &amp; all)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_remove_cond_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * key_title, std::string &amp; all)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从连接池池中获取一个连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">CassSession * <span class="hljs-title">get_session</span><span class="hljs-params">(ed_error * err)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 归还使用后的session</span><br><span class="hljs-comment">     * @param session 要归还的session</span><br><span class="hljs-comment">     * @param bok false session 异常，true 正常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put_session</span><span class="hljs-params">(CassSession * session, <span class="hljs-keyword">bool</span> bok)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> port_;                          <span class="hljs-comment">//端口号</span><br>    <span class="hljs-keyword">int</span> conn_timeout_;                  <span class="hljs-comment">//连接超时</span><br>    <span class="hljs-keyword">int</span> rw_timeout_;                    <span class="hljs-comment">//读写超时</span><br>    <span class="hljs-keyword">int</span> thread_num_;                    <span class="hljs-comment">//处理io线程数</span><br>    std::string addr_;                  <span class="hljs-comment">//连接地址</span><br>    std::string user_;                  <span class="hljs-comment">//用户名</span><br>    std::string pass_;                  <span class="hljs-comment">//密码</span><br>    CassSession * session_;<br>#    QLock lock_;                        <span class="hljs-comment">// pool_ 实际应用时需要考虑加 锁</span><br>&#125;;<br><br>&#125; <span class="hljs-comment">/* DB */</span><br><br></code></pre></td></tr></table></figure><p>db_scylla.cpp</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;db_scylla.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> DB &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * CONST_COL_URI = <span class="hljs-string">&quot;uri&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * CONST_COL_VIDC = <span class="hljs-string">&quot;vidc&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * CONST_COL_CACHE = <span class="hljs-string">&quot;cache&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * CONST_COL_TYPE = <span class="hljs-string">&quot;typ&quot;</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * CONST_COL_ZONE = <span class="hljs-string">&quot;zone&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * CONST_COL_LEVEL = <span class="hljs-string">&quot;level&quot;</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * KEYSPACE_TABLE=<span class="hljs-string">&quot;keyspace.test_table&quot;</span>;<br><br>db_scylla::<span class="hljs-built_in">db_scylla</span>()<br>: <span class="hljs-built_in">port_</span>(<span class="hljs-number">9042</span>)<br>, <span class="hljs-built_in">conn_timeout_</span>(<span class="hljs-number">2000</span>)<br>, <span class="hljs-built_in">rw_timeout_</span>(<span class="hljs-number">2000</span>)<br>, <span class="hljs-built_in">thread_num_</span>(<span class="hljs-number">10</span>)<br>, <span class="hljs-built_in">cluster_</span>(<span class="hljs-literal">NULL</span>)<br>, <span class="hljs-built_in">session_</span>(<span class="hljs-literal">NULL</span>)<br>&#123;<br>&#125;<br><br>db_scylla::~<span class="hljs-built_in">db_scylla</span>() &#123;<br>    <span class="hljs-keyword">if</span>(cluster_) &#123;<br>        <span class="hljs-built_in">cass_cluster_free</span>(cluster_);<br>    &#125;<br><span class="hljs-keyword">if</span>(session_) &#123;<br><span class="hljs-built_in">cass_session_free</span>(session_);<br>session_ = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">db_scylla::open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * addr, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==addr || port&gt;<span class="hljs-number">65535</span> || port&lt;=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open scylladb failed addr=%s, port=%d\n&quot;</span>,<br>                <span class="hljs-literal">NULL</span>==addr?<span class="hljs-string">&quot;NULL&quot;</span>:addr, port);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    cluster_ = <span class="hljs-built_in">cass_cluster_new</span>();<br>    <span class="hljs-built_in">cass_cluster_set_port</span>(cluster_, port);<br>    <span class="hljs-built_in">cass_cluster_set_contact_points</span>(cluster_, addr);<br>    <span class="hljs-built_in">cass_cluster_set_credentials</span>(cluster_, user_.<span class="hljs-built_in">c_str</span>(), pass_.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-built_in">cass_cluster_set_num_threads_io</span>(cluster_, thread_num_); <span class="hljs-comment">//处理请求的线程数</span><br>    <span class="hljs-comment">//cass_cluster_set_max_connections_per_host(cluster_, 50); //被废弃可不用了</span><br>    <span class="hljs-comment">//cass_cluster_set_core_connections_per_host(cluster_, 1); //每个线程的连接, 不用设置太多，默认的就够</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">db_scylla::get_remove_cond_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp; key,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * key_title, std::string &amp; all)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(key.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    acl::string tmp;<br>    tmp.format(<span class="hljs-string">&quot;%s=&#x27;%s&#x27;&quot;</span>,key_title, key.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span> == all.<span class="hljs-built_in">empty</span>()) &#123;<br>        all.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; AND &quot;</span>);<br>    &#125;<br>    all.<span class="hljs-built_in">append</span>(tmp.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">db_scylla::get_remove_cond_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * key_title, std::string &amp; all)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(key&lt;<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    acl::string tmp;<br>    tmp.format(<span class="hljs-string">&quot;%s=%d&quot;</span>,key_title, key);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span> == all.<span class="hljs-built_in">empty</span>()) &#123;<br>        all.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot; AND &quot;</span>);<br>    &#125;<br>    all.<span class="hljs-built_in">append</span>(tmp.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">db_scylla::remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;record_scylla&gt; &amp; vec, ed_error * err)</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> iok = <span class="hljs-number">0</span>;<br>    CassSession * session = <span class="hljs-built_in">get_session</span>(err);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==session || vec.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> iok;<br>    &#125;<br><br>    CassFuture* futures[ vec.<span class="hljs-built_in">size</span>() ];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i&lt;vec.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        std::string strtmp;<br>        <span class="hljs-built_in">get_remove_cond_str</span>(vec[i].uri_, CONST_COL_URI, strtmp);<br>        <span class="hljs-built_in">get_remove_cond_str</span>(vec[i].vidc_, CONST_COL_VIDC, strtmp);<br>        <span class="hljs-built_in">get_remove_cond_str</span>(vec[i].cache_, CONST_COL_CACHE, strtmp);<br>        <span class="hljs-built_in">get_remove_cond_int</span>(vec[i].type_, CONST_COL_TYPE, strtmp);<br><br>        acl::string qstr;<br>        qstr.format(<span class="hljs-string">&quot;DELETE FROM cdn_global_index.uri_index WHERE %s ;&quot;</span>, strtmp.<span class="hljs-built_in">c_str</span>());<br>        CassStatement * statement = <span class="hljs-built_in">cass_statement_new</span>(qstr.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>);<br>        futures[i] = <span class="hljs-built_in">cass_session_execute</span>(session, statement);<br>        <span class="hljs-built_in">cass_statement_free</span>(statement);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i&lt;vec.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        CassFuture* future = futures[i];<br>        <span class="hljs-built_in">cass_future_wait</span>(future);<br>        CassError rc = <span class="hljs-built_in">cass_future_error_code</span>(future);<br>        <span class="hljs-keyword">if</span> (rc != CASS_OK) &#123;<br>            <span class="hljs-built_in">ADD_ED_ERROR</span>(err, ERR_SDB_DELETE, <span class="hljs-string">&quot;%s failed. err=%s&quot;</span>, vec[i].uri_.<span class="hljs-built_in">c_str</span>(),<br>                    <span class="hljs-built_in">cass_error_desc</span>(rc));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            iok++;<br>        &#125;<br>        <span class="hljs-built_in">cass_future_free</span>(future);<br>    &#125;<br>    <span class="hljs-built_in">put_session</span>(session, <span class="hljs-number">0</span>==iok?<span class="hljs-literal">false</span>:<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> iok;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">size_t</span>  <span class="hljs-title">db_scylla::insert</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;record_scylla&gt; &amp; vec, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ttl,</span></span><br><span class="hljs-params"><span class="hljs-function">        ed_error * err)</span> </span>&#123;<br>    <span class="hljs-keyword">size_t</span> iok = <span class="hljs-number">0</span>;<br>    CassSession * session = <span class="hljs-built_in">get_session</span>(err);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==session || vec.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">return</span> iok;<br>    &#125;<br>    acl::string qstr;<br>    <span class="hljs-keyword">if</span>(ttl&gt;<span class="hljs-number">0</span>) &#123;<br>        qstr.format(<span class="hljs-string">&quot;INSERT INTO %s (%s, %s, %s, %s) VALUES(?,?,?,?) USING TTL %lld;&quot;</span>,<br>                KEYSPACE_TABLE, CONST_COL_URI, CONST_COL_VIDC, CONST_COL_CACHE, CONST_COL_TYPE, ttl);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        qstr.format(<span class="hljs-string">&quot;INSERT INTO %s (%s, %s, %s, %s) VALUES(?,?,?,?) ;&quot;</span>,<br>                KEYSPACE_TABLE, CONST_COL_URI, CONST_COL_VIDC, CONST_COL_CACHE, CONST_COL_TYPE);<br>    &#125;<br>    CassFuture* futures[ vec.<span class="hljs-built_in">size</span>() ];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i&lt;vec.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        CassStatement * statement = <span class="hljs-built_in">cass_statement_new</span>(qstr.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">4</span>);<br>        <span class="hljs-built_in">cass_statement_bind_string</span>(statement, <span class="hljs-number">0</span>, vec[i].uri_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">cass_statement_bind_string</span>(statement, <span class="hljs-number">1</span>, vec[i].vidc_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">cass_statement_bind_string</span>(statement, <span class="hljs-number">2</span>, vec[i].cache_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">cass_statement_bind_int32</span>(statement, <span class="hljs-number">3</span>, vec[i].type_);<br><br>        futures[i] = <span class="hljs-built_in">cass_session_execute</span>(session, statement);<br>        <span class="hljs-built_in">cass_statement_free</span>(statement);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i&lt;vec.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        CassFuture* future = futures[i];<br>        <span class="hljs-built_in">cass_future_wait</span>(future);<br>        CassError rc = <span class="hljs-built_in">cass_future_error_code</span>(future);<br>        <span class="hljs-keyword">if</span> (rc != CASS_OK) &#123;<br>            <span class="hljs-built_in">ADD_ED_ERROR</span>(err, ERR_SDB_INSERT, <span class="hljs-string">&quot;%s failed. err=%s&quot;</span>, vec[i].uri_.<span class="hljs-built_in">c_str</span>(),<br>                    <span class="hljs-built_in">cass_error_desc</span>(rc));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            iok++;<br>        &#125;<br>        <span class="hljs-built_in">cass_future_free</span>(future);<br>    &#125;<br>    <span class="hljs-built_in">put_session</span>(session, <span class="hljs-number">0</span>==iok?<span class="hljs-literal">false</span>:<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> iok;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">db_scylla::query</span><span class="hljs-params">(<span class="hljs-keyword">const</span> scylla_obj &amp; obj, <span class="hljs-keyword">bool</span> bhot,</span></span><br><span class="hljs-params"><span class="hljs-function">        std::vector&lt;record_scylla&gt; &amp; vec, ed_error * err)</span> </span>&#123;<br>    CassSession * session = <span class="hljs-built_in">get_session</span>(err);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==session) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    CassError rc = CASS_OK;<br>    acl::string qstr;<br>    <span class="hljs-built_in">get_query_string</span>(obj, bhot, qstr);<br>    CassStatement * statement = <span class="hljs-built_in">cass_statement_new</span>(qstr.<span class="hljs-built_in">c_str</span>(), <span class="hljs-number">0</span>);<br>    CassFuture * future = <span class="hljs-built_in">cass_session_execute</span>(session, statement);<br>    <span class="hljs-keyword">if</span>(CASS_OK!=(rc=<span class="hljs-built_in">cass_future_error_code</span>(future))) &#123;<br>        <span class="hljs-built_in">ADD_ED_ERROR</span>(err, ERR_SDB_QUERY, <span class="hljs-string">&quot;query cass_future_wait failed. err=%s&quot;</span>,<br>                <span class="hljs-built_in">cass_error_desc</span>(rc));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> CassResult* result = <span class="hljs-built_in">cass_future_get_result</span>(future);<br>        CassIterator* iterator = <span class="hljs-built_in">cass_iterator_from_result</span>(result);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cass_iterator_next</span>(iterator)) &#123;<br>            <span class="hljs-keyword">const</span> CassRow* row = <span class="hljs-built_in">cass_iterator_get_row</span>(iterator);<br>            <span class="hljs-built_in">parse_one_record</span>(row, bhot, vec);<br>        &#125;<br>        <span class="hljs-built_in">cass_result_free</span>(result);<br>        <span class="hljs-built_in">cass_iterator_free</span>(iterator);<br>    &#125;<br><br>    <span class="hljs-built_in">cass_future_free</span>(future);<br>    <span class="hljs-built_in">cass_statement_free</span>(statement);<br>    <span class="hljs-built_in">put_session</span>(session, rc==CASS_OK);<br>    <span class="hljs-keyword">return</span> rc==CASS_OK;<br>&#125;<br><br><br><span class="hljs-function">CassSession * <span class="hljs-title">db_scylla::get_session</span><span class="hljs-params">(ed_error * err)</span> </span>&#123;<br>    lock_.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==session_) &#123;<br>        session_ = <span class="hljs-built_in">create_connect_session</span>(err);<br>    &#125;<br>    lock_.<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">return</span> session_;<br>    CassSession * session = <span class="hljs-literal">NULL</span>;<br>    lock_.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(pool_.<span class="hljs-built_in">empty</span>()) &#123;<br>        lock_.<span class="hljs-built_in">unlock</span>();<br>        session = <span class="hljs-built_in">create_connect_session</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        session = pool_.<span class="hljs-built_in">front</span>();<br>        pool_.<span class="hljs-built_in">pop_front</span>();<br>        lock_.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> session;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">db_scylla::put_session</span><span class="hljs-params">(CassSession * session, <span class="hljs-keyword">bool</span> bok)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(bok) &#123;<br>        lock_.<span class="hljs-built_in">lock</span>();<br>        pool_.<span class="hljs-built_in">push_back</span>(session);<br>        lock_.<span class="hljs-built_in">unlock</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">cass_session_free</span>(session);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">db_scylla::set_auth</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * user, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * pass)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==pass || <span class="hljs-literal">NULL</span>==user) &#123;<br>        <span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;user or pass is NULL.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    user_ = user;<br>    pass_ = pass;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">db_scylla::set_conn_timeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ms_timeout)</span> </span>&#123;<br>    conn_timeout_ = ms_timeout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">db_scylla::set_rw_timeout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ms_timeout)</span> </span>&#123;<br>    rw_timeout_ = ms_timeout;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">db_scylla::set_io_thread_num</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cn)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(cn&gt;<span class="hljs-number">0</span> &amp;&amp; cn&lt;<span class="hljs-number">1024</span>) &#123;<br>        thread_num_ = cn;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">CassSession* <span class="hljs-title">db_scylla::create_connect_session</span><span class="hljs-params">(ed_error* err)</span></span>&#123;<br>    CassSession* session = <span class="hljs-built_in">cass_session_new</span>();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==session) &#123;<br>        <span class="hljs-built_in">ADD_ED_ERROR</span>(err, ERR_SDB_CREATE_SESSION, <span class="hljs-string">&quot;create session failed.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    CassFuture* future = <span class="hljs-built_in">cass_session_connect</span>(session, cluster_);<br>    <span class="hljs-built_in">cass_future_wait</span>(future);<br>    CassError rc = <span class="hljs-built_in">cass_future_error_code</span>(future);<br>    <span class="hljs-keyword">if</span> (rc != CASS_OK) &#123;<br>        <span class="hljs-built_in">ADD_ED_ERROR</span>(err, ERR_SDB_CREATE_SESSION, <span class="hljs-string">&quot;create session failed. err=%s&quot;</span>,<br>                <span class="hljs-built_in">cass_error_desc</span>(rc));<br>        <span class="hljs-built_in">cass_session_free</span>(session);<br>        session = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">cass_future_free</span>(future);<br>    <span class="hljs-keyword">return</span> session;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">db_scylla::get_query_string</span><span class="hljs-params">(<span class="hljs-keyword">const</span> scylla_obj &amp; obj, <span class="hljs-keyword">bool</span> bhot,</span></span><br><span class="hljs-params"><span class="hljs-function">        acl::string &amp; str)</span> </span>&#123;<br>    std::string tmpstr;<br>    <span class="hljs-keyword">size_t</span> maxPos = obj.vidc_.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i=<span class="hljs-number">0</span>; i&lt;obj.vidc_.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        tmpstr.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;&#x27;&quot;</span>).<span class="hljs-built_in">append</span>(obj.vidc_[i]).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        <span class="hljs-keyword">if</span>(i!=maxPos) &#123;<br>            tmpstr.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(bhot) &#123;<br>        <span class="hljs-keyword">if</span>(tmpstr.<span class="hljs-built_in">empty</span>()) &#123;<br>            str.format(<span class="hljs-string">&quot;SELECT %s,%s FROM %s WHERE uri=&#x27;%s&#x27;&quot;</span>,<br>                    CONST_COL_ZONE, CONST_COL_LEVEL, KEYSPACE_TABLE, obj.uri_.<span class="hljs-built_in">c_str</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            str.format(<span class="hljs-string">&quot;SELECT %s,%s FROM %s WHERE uri=&#x27;%s&#x27; AND zone in(%s)&quot;</span>,<br>                    CONST_COL_ZONE, CONST_COL_LEVEL, KEYSPACE_TABLE, <br>                    obj.uri_.<span class="hljs-built_in">c_str</span>(), tmpstr.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(tmpstr.<span class="hljs-built_in">empty</span>()) &#123;<br>            str.format(<span class="hljs-string">&quot;SELECT %s,%s,%s,%s FROM %s WHERE uri=&#x27;%s&#x27;&quot;</span>,<br>                    CONST_COL_URI, CONST_COL_VIDC, CONST_COL_CACHE, CONST_COL_TYPE,<br>                    KEYSPACE_TABLE, obj.uri_.<span class="hljs-built_in">c_str</span>());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            str.format(<span class="hljs-string">&quot;SELECT %s,%s,%s,%s FROM %s WHERE uri=&#x27;%s&#x27; AND vidc in(%s)&quot;</span>,<br>                    CONST_COL_URI, CONST_COL_VIDC, CONST_COL_CACHE, CONST_COL_TYPE,<br>                    KEYSPACE_TABLE, obj.uri_.<span class="hljs-built_in">c_str</span>(), tmpstr.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">db_scylla::parse_one_record</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CassRow* row, <span class="hljs-keyword">bool</span> bhot,</span></span><br><span class="hljs-params"><span class="hljs-function">        std::vector&lt;record_scylla&gt; &amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> bret = <span class="hljs-literal">true</span>;<br>    record_scylla record;<br>    <span class="hljs-keyword">if</span>(bhot) &#123;<br>        <span class="hljs-built_in">get_col_value</span>(row, CONST_COL_ZONE, record.vidc_); <span class="hljs-comment">//将zone 存放到vidc_中</span><br>        <span class="hljs-built_in">get_col_value</span>(row, CONST_COL_LEVEL, record.type_); <span class="hljs-comment">//将level 存放到type中</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">get_col_value</span>(row, CONST_COL_URI, record.uri_);<br>        <span class="hljs-built_in">get_col_value</span>(row, CONST_COL_VIDC, record.vidc_);<br>        <span class="hljs-built_in">get_col_value</span>(row, CONST_COL_CACHE, record.cache_);<br>        <span class="hljs-comment">//    get_col_value(row, &quot;zone&quot;, record.zone_);</span><br>        <span class="hljs-built_in">get_col_value</span>(row, CONST_COL_TYPE, record.type_);<br>    &#125;<br>    vec.<span class="hljs-built_in">push_back</span>(record);<br>    <span class="hljs-keyword">return</span> bret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">db_scylla::get_col_value</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CassRow* row, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * cname,</span></span><br><span class="hljs-params"><span class="hljs-function">        std::string &amp; value)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> bret = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* row_key;<br>    <span class="hljs-keyword">size_t</span> row_key_length;<br>    <span class="hljs-keyword">if</span>(CASS_OK==<span class="hljs-built_in">cass_value_get_string</span>(<br>                <span class="hljs-built_in">cass_row_get_column_by_name</span>(row, cname),<br>                &amp;row_key, &amp;row_key_length)) &#123;<br>        value = row_key;<br>        bret = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">db_scylla::get_col_value</span><span class="hljs-params">(<span class="hljs-keyword">const</span> CassRow* row, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * cname,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">int</span> &amp; value)</span> </span>&#123;<br>    <span class="hljs-keyword">bool</span> bret = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(CASS_OK==<span class="hljs-built_in">cass_value_get_int32</span>(<span class="hljs-built_in">cass_row_get_column_by_name</span>(row, cname),<br>                &amp;value)) &#123;<br>        bret = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bret;<br>&#125;<br><br>&#125; <span class="hljs-comment">/* DB */</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>typedef 精髓</title>
    <link href="/2020/08/29/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/04typedef%E7%B2%BE%E9%AB%93/"/>
    <url>/2020/08/29/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/04typedef%E7%B2%BE%E9%AB%93/</url>
    
    <content type="html"><![CDATA[<p>本文转载自《<a href="https://tonybai.com/2008/05/02/also-talk-about-typedef/%E3%80%8B">https://tonybai.com/2008/05/02/also-talk-about-typedef/》</a></p><h2 id="核心阐述"><a href="#核心阐述" class="headerlink" title="核心阐述"></a>核心阐述</h2><p>C语言语法简单，但内涵却博大精深；如果在学习时只是止步于表面，那么往往后期会遇到很多困难。typedef是C语言中一个很好用的工具，大量存在于已有代码中，特别值得一提的是：C++标准库实现中更是对typedef有着大量的使用。但很多初学者对其的理解仅局限于：typedef用来定义一个已有类型的”别名(alias)”。正是因为有了这样的理解，才有了后来初学者在typedef int myint和typedef myint int之间的犹豫不决。很多国内大学的C语言课之授课老师也都是如是说的，或者老师讲的不够透彻，导致学生们都是如是理解的。我这里想结合C语言标准文档以及一些代码实例，也说说typedef。</p><figure class="highlight abnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs abnf">int    *p<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这样的代码是C语言中最最基础的一个语句了，大家都知道这个语句声明了一个变量p，其类型是指向整型的指针(pointer to int)；如果在这个声明的前面加上一个typedef后，整个语义(semantics)又会是如何改变的呢？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span>  <span class="hljs-built_in">int</span>    *p;<br></code></pre></td></tr></table></figure><p>我们先来看看C99标准中关于typedef是如何诠释的？C99标准中这样一小段精辟的描述：”In a declaration whose storage-class specifier is typedef, each declarator defines an identifier to be a typedef name that denotes the type specified for the identifier in the way described in xx”。</p><p>参照这段描述，并拿<code>typedef int *p</code>作为例子来理解：</p><div class="code-wrapper"><pre><code class="hljs">在一个声明中，如果有存储类说明符typedef的修饰，标识符p将被定义为了一个typedef name，这个typedef name表示(denotes)一个类型，什么类型呢？就是int *p这个声明(declarator)中标识符(indentifier)p的类型(int*)。</code></pre></div><p>再比对一下两个声明：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>    *p;<br><span class="hljs-keyword">typedef</span>  <span class="hljs-built_in">int</span>    *p;<br></code></pre></td></tr></table></figure><p>是不是有点”茅舍顿开”的感觉，<code>int *p</code>中, <code>p</code>是一个变量，其类型为<code>pointer to int</code>；在<code>int *p</code>前面增加一个 <code>typedef</code>后，<code>p</code>变为一个<code>typedef-name</code>，这个 <code>typedef-name</code> 所表示的类型就是 <code>int *p</code> 声明式中 <code>p</code> 的类型<code>(int*)</code>。<br>说句白话，<code>typedef</code> 让 <code>p</code> 去除了普通变量的身份，摇身一变，变成了 <code>p</code> 的类型的一个<code>typedef-name</code>了。</p><p>为了巩固上面的理解，我们再来看看”C语言参考手册(C: A Reference Manual)”中的说法：任何 <code>declarator</code> (如<code>typedef int   *p</code> )中的indentifier(如p)定义为<code>typedef-name</code>， 其(指代p)表示的类型是declarator为正常变量声明(指代int  <em>p)的那个标识符(指代p)的类型(int</em>)。有些绕嘴，不过有例子支撑：</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><code>typedef double MYDOUBLE;</code></p><p>分析:<br>去掉 <code>typedef</code> , 得到正常变量声明=&gt; <code>double MYDOUBLE;</code>,<br>变量<code>MYDOUBLE</code> 的类型为 <code>double</code>;<br>由此可推导出 =&gt; <code>typedef double MYDOUBLE;</code> 中 <code>MYDOUBLE</code> 是类型 <code>double</code> 的一个 <code>typedef-name</code>。</p><p>如： MYDOUBLE    d; // 说明 <code>d</code> 是一个 <code>double</code> 类型的变量</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p><code>typedef double *Dp;</code></p><p>分析:<br>去掉 <code>typedef</code>, 得到正常变量声明 <code>double *Dp;</code>,<br>变量 <code>Dp</code> 的类型为 <code>double*</code>，即 <code>pointer to double;</code><br>由此可推导出 =&gt; <code>typedef double *Dp;</code> 中 <code>Dp</code> 是类型 <code>double*</code> 的一个 <code>typedef-name</code>。</p><p>如： Dp    dptr;   // dptr是一个pointer to double的变量， 和double * dptr; 是同等含义</p><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><p><code>typedef int* Func(int);</code></p><p>分析:<br>去掉 <code>typedef</code>, 得到正常变量声明 <code>int* Func(int);</code>,<br>变量 <code>Func</code> 的类型为一个函数标识符，该函数返回值类型为 <code>int*</code>，参数类型为 <code>int</code> ;<br>由此可推导出 =&gt; <code>typedef int* Func(int)</code> 中 <code>Func</code> 是<u>函数类型</u>(函数返回值类型为int*，参数类型为int)的一个 <code>typedef-name</code>。</p><p>如： Func  *fptr;  // fptr是一个pointer to function with one int parameter, returning a pointer to int<br>如： Func     f;   这样的声明意义就不大了。</p><h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h3><p><code>typedef int (*PFunc)(int);</code></p><p>分析:<br>去掉 <code>typedef</code>,得到正常变量声明 =&gt; int (*PFunc)(int);<br>变量<code>PFunc</code> 的类型为一个函数指针，指向的返回值类型为 <code>int</code>，<code>参数类型为int</code>的函数原型;</p><p>由此可推导出 =&gt; “typedef int (*PFunc)(int)”中PFunc是函数指针类型(该指针类型指向返回值类型为int，参数类型为int的函数)的一个typedef-name。</p><p>PFunc     fptr; &lt;=&gt; fptr是一个pointer to function with one int parameter, returning int</p><h3 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h3><p><code>typedef    int   A[5];</code></p><p>分析:<br>去掉 <code>typedef</code>,得到正常变量声明 =&gt; int   A[5];<br>变量A的类型为一个含有5个元素的整型数组；</p><p>由此可推导出 =&gt; “typedef    int   A[5]“中A是含有5个元素的数组类型的一个typedef-name。</p><p>A   a = {3, 4, 5, 7, 8};<br>A   b = { 3, 4, 5, 7, 8, 9}; /* 会给出Warning: excess elements in array initializer */</p><h3 id="示例6"><a href="#示例6" class="headerlink" title="示例6"></a>示例6</h3><p><code>typedef    int   (*A)[5]; </code> (注意与typedef    int*    A[5]; 区分)</p><p>分析:<br>去掉 <code>typedef</code>,得到正常变量声明 =&gt; int   (*A)[5];<br>变量A的类型为pointer to an array with 5 int elements；</p><p>由此可推导出 =&gt; “typedef    int   (*A)[5]“中A是”pointer to an array with 5 int elements”的一个typedef-name。</p><p>int   c[5] = {3, 4, 5, 7, 8};<br>A    a = &c;<br>printf(“%d\n”, (<em>a)[0]); /</em> output: 3 */</p><p>如果这样赋值：<br>int   c[6] = {3, 4, 5, 7, 8, 9};<br>A    a = &c; /* 会有Warning: initialization from incompatible pointer type */</p><h3 id="示例7"><a href="#示例7" class="headerlink" title="示例7"></a>示例7</h3><p><code>typedef struct _Foo_t Foo_t;</code></p><p>分析:<br>去掉 <code>typedef</code>,得到正常变量声明 =&gt; struct _Foo_t Foo_t;<br>变量Foo_t的类型为struct _Foo_t;</p><p>由此可推导出 =&gt; “typedef struct _Foo_t Foo_t”中Foo_t是”struct _Foo_t”的一个typedef-name。</p><h3 id="示例8"><a href="#示例8" class="headerlink" title="示例8"></a>示例8</h3><p><code>typedef   struct &#123; … // &#125;   Foo_t;</code></p><p>分析:<br>去掉 <code>typedef</code>,得到正常变量声明 =&gt; struct { … // }   Foo_t;<br>变量Foo_t的类型为struct { … // } ;</p><p>由此可推导出 =&gt;  “typedef   struct { … // }   Foo_t “中Foo_t是”struct { … // }”的一个typedef-name。这里struct {…//}是一个无”标志名称(tag name)”的结构体声明。</p><h3 id="示例9"><a href="#示例9" class="headerlink" title="示例9"></a>示例9</h3><p><code>typedef      struct &#123; … // &#125;   Foo_t[1];</code></p><p>分析：<br>去掉 <code>typedef</code>, 得到正常变量声明 =&gt; struct { … // }   Foo_t[1];<br>变量Foo_t的类型为包含一个元素的struct { … // }类别的数组类型;</p><p>由此可推导出 =&gt; 这样一来，Foo_t在typedef定义后实际上就变成了一个struct { … // }数组类型。要问实际编程中会这么用typedef吗？你还别说，这还是C语言常用的一个小技巧，如果你有机会看到jmp_buf的类型定义，你就会发现jmp_buf在很多系统实现中也是如此定义的，大约类似：typedef struct XX {…} jmp_buf[1]; 这样做的目的大致是这样的：如果你在函数里定义了一个char a[n]；那么a和&amp;a作为参数传入某个函数时是等价的。看似传值，实则传址，在被调用函数中通过参数可直接修改数组a的元素的内容。另外这么做的目的是否是为了让代码更符合某些人的口味我还不得而知。</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>1、”ISOIEC-98991999(E)–Programming Languages–C”之Page 123;<br>2、C语言参考手册(中文版) 之 Page 119</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux中线程与CPU核的绑定</title>
    <link href="/2020/08/28/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/03Linux%E4%B8%AD%E7%BA%BF%E7%A8%8B%E4%B8%8ECPU%E6%A0%B8%E7%9A%84%E7%BB%91%E5%AE%9A/"/>
    <url>/2020/08/28/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/03Linux%E4%B8%AD%E7%BA%BF%E7%A8%8B%E4%B8%8ECPU%E6%A0%B8%E7%9A%84%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>不管是线程还是进程，都是通过设置亲和性(affinity)来达到目的。对于进程一般是使用 <code>sched_setaffinity</code> 这个函数来实现.</p><p>与进程的情况相似，线程亲和性的设置和获取主要通过下面两个函数来实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_setaffinity_np(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">cpusetsize</span>， <span class="hljs-params">const</span> <span class="hljs-params">cpu_set_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cpuset</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_getaffinity_np(<span class="hljs-params">pthread_t</span> <span class="hljs-params">thread</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">cpusetsize</span>,  <span class="hljs-params">cpu_set_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cpuset</span>)</span>;<br></code></pre></td></tr></table></figure><p>从函数名以及参数名都很明了，唯一需要点解释下的可能就是cpu_set_t这个结构体了。这个结构体的理解类似于select中的fd_set，可以理解为cpu集，也是通过约定好的以下宏来进行清除、设置以及判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_ZERO</span> <span class="hljs-params">(<span class="hljs-keyword">cpu_set_t</span> *set)</span></span>;  <span class="hljs-comment">//初始化，设为空      </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_SET</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *set)</span></span>; <span class="hljs-comment">//将某个cpu加入cpu集中        </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CPU_CLR</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">cpu_set_t</span> *set)</span></span>; <span class="hljs-comment">//将某个cpu从cpu集中移出        </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">CPU_ISSET</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> cpu, <span class="hljs-keyword">const</span> <span class="hljs-keyword">cpu_set_t</span> *set)</span></span>; <span class="hljs-comment">//判断某个cpu是否已在cpu集中设置了 </span><br></code></pre></td></tr></table></figure><p>cpu集可以认为是一个掩码，每个设置的位都对应一个可以合法调度的 cpu，而未设置的位则对应一个不可调度的 CPU。换而言之，线程都被绑定了，只能在那些对应位被设置了的处理器上运行。通常，掩码中的所有位都被置位了，也就是可以在所有的cpu中调度。 </p><p>以下为测试代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">myfun</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>&#123;<br>    <span class="hljs-keyword">cpu_set_t</span> mask;<br>    <span class="hljs-keyword">cpu_set_t</span> get;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">sysconf</span>(_SC_NPROCESSORS_CONF);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;system has %d processor(s)\n&quot;</span>, num);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>        <span class="hljs-built_in">CPU_ZERO</span>(&amp;mask);<br>        <span class="hljs-built_in">CPU_SET</span>(i, &amp;mask);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_setaffinity_np</span>(<span class="hljs-built_in">pthread_self</span>(), <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(mask), &amp;mask) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;set thread affinity failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">CPU_ZERO</span>(&amp;get);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_getaffinity_np</span>(<span class="hljs-built_in">pthread_self</span>(), <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(get), &amp;get) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;get thread affinity failed\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; num; j++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CPU_ISSET</span>(j, &amp;get)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %d is running in processor %d\n&quot;</span>, (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pthread_self</span>(), j);<br>            &#125;<br>        &#125;<br>        j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j++ &lt; <span class="hljs-number">100000000</span>) &#123;<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(buf));<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pthread_t</span> tid;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>, (<span class="hljs-keyword">void</span> *)myfun, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;thread create failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">pthread_join</span>(tid, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 内置的SimpleHTTPServer使用指南</title>
    <link href="/2020/08/27/04DevOps/08Python%E5%86%85%E7%BD%AE%E7%9A%84SimpleHTTPServer%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2020/08/27/04DevOps/08Python%E5%86%85%E7%BD%AE%E7%9A%84SimpleHTTPServer%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>Python内置了一个简单的HTTP服务器，只需要在命令行下面敲一行命令，一个HTTP服务器就起来了：(假设我们需要共享我们的目录 /home/haoel 而IP地址是192.168.1.1）</p><figure class="highlight powershell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> /home/haoel<br><span class="hljs-variable">$</span> python <span class="hljs-literal">-m</span> SimpleHTTPServer <span class="hljs-number">8888</span><br></code></pre></td></tr></table></figure><p>后面的8888端口是可选的，不填会采用缺省端口8000。注意，这会将当前所在的文件夹设置为默认的Web目录</p><p>如果你只想让这个HTTP服务器服务于本地环境，那么，你需要定制一下你的Python的程序，下面是一个示例：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-built_in">import</span> sys <br><span class="hljs-built_in">import</span> BaseHTTPServer <br>from SimpleHTTPServer <span class="hljs-built_in">import</span> SimpleHTTPRequestHandler <br><span class="hljs-attr">HandlerClass</span> = SimpleHTTPRequestHandler <br><span class="hljs-attr">ServerClass</span> = BaseHTTPServer.HTTPServer <br><span class="hljs-attr">Protocol</span> = <span class="hljs-string">&quot;HTTP/1.0&quot;</span><br>  <br><span class="hljs-keyword">if</span> sys.argv[<span class="hljs-number">1</span>:]: <br>  <span class="hljs-attr">port</span> = int(sys.argv[<span class="hljs-number">1</span>]) <br><span class="hljs-keyword">else</span>: <br>  <span class="hljs-attr">port</span> = <span class="hljs-number">8000</span><br><span class="hljs-attr">server_address</span> = (&#x27;<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>&#x27;, port) <br>  <br>HandlerClass.<span class="hljs-attr">protocol_version</span> = Protocol <br><span class="hljs-attr">httpd</span> = ServerClass(server_address, HandlerClass) <br>  <br><span class="hljs-attr">sa</span> = httpd.socket.getsockname() <br>print <span class="hljs-string">&quot;Serving HTTP on&quot;</span>, sa[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;port&quot;</span>, sa[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;...&quot;</span><br>httpd.serve_forever()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DNS协议介绍</title>
    <link href="/2020/08/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/01DNS%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/08/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/01DNS%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="惯例"><a href="#惯例" class="headerlink" title="惯例"></a>惯例</h1><h2 id="首选name语法"><a href="#首选name语法" class="headerlink" title="首选name语法"></a>首选name语法</h2><p>DNS规范试图使构建的域名规则尽可能通用。这一想法的精髓是任何现有对象的名称经过尽量小的改变都能表示为域名。<br>但是在为对象分配域名时，谨慎的用户将选择即满足域名系统规则，又满足对象任何现有规则的名称，无论这些规则是公开出版的还是由现有程序暗示的。<br>如：当命名邮件域时，用于应当即满足本备忘录的规则，又满足RFC-822宏的规则。创建新的主机名时，应当遵守旧的HOSTS.TXT规则。这可避免当旧软件被转换为使用域名时出现问题<br>以下语法(BNF范式)将减少许多使用域名的应用程序（例如邮件，TELNET）的问题。</p><figure class="highlight bnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;domain&gt;</span> ::= &lt;subdomain&gt; | <span class="hljs-string">&quot; &quot;</span><br><span class="hljs-attribute">&lt;subdomain&gt;</span> ::= &lt;label&gt; | &lt;subdomain&gt;<span class="hljs-string">&quot;.&quot;</span> &lt;label&gt;<br><span class="hljs-attribute">&lt;label&gt;</span> ::= &lt;letter&gt; [[&lt;ldh-str&gt;] &lt;let-dig&gt;]<br><span class="hljs-attribute">&lt;ldh-str&gt;</span> ::= &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;<br><span class="hljs-attribute">&lt;let-dig-hyp&gt;</span> ::= &lt;let-dig&gt; “-”<br><span class="hljs-attribute">&lt;let-dig&gt;</span> ::= &lt;letter&gt; | &lt;digit&gt;<br><span class="hljs-attribute">&lt;letter&gt;</span> ::= 52个字母字符A到Z中的任何一个（大写）和a到z中的小写<br><span class="hljs-attribute">&lt;digit&gt;</span> ::= 十个数字0到9中的任何一个<br></code></pre></td></tr></table></figure><h1 id="DNS报文格式"><a href="#DNS报文格式" class="headerlink" title=" DNS报文格式"></a><span id=dformat> DNS报文格式</span></h1><p>整个报文的格式如下，包括了五部分组成。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------------------+</span><br><span class="hljs-section">|        Header       | 报文头</span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">|       Question      | 查询请求</span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">|        Answer       | 应答</span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">|      Authority      | 授权应答</span><br><span class="hljs-section">+---------------------+</span><br><span class="hljs-section">|      Additional     | 附加信息</span><br><span class="hljs-section">+---------------------+</span><br></code></pre></td></tr></table></figure><p>详细介绍如下。</p><ul><li>Header 必选，定义了报文是请求还是应答、错误码以及其它的一些标志位；</li><li>Question 描述了查询的请求报文，包括查询类型(QTYPE)、查询类(QCLASS) 以及查询的域名(QNAME)；</li></ul><p>剩下的3个段包含相同的格式:一系列可能为空的<a href="#rr">资源记录(RR)</a>。 Answer段包含回答问题的RR列表；Authority段包含授权域名服务器的RR列表； <span id=additional> Additional</span>段包含和请求相关的RR列表，但这些附件的RR不是必须回答的。</p><h2 id="报文头-Header"><a href="#报文头-Header" class="headerlink" title="报文头(Header)"></a>报文头(Header)</h2><p>DNS的报文头由固定的12个字节构成。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">|                      ID                       |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|QR|  Opcode   |AA|TC|RD|RA|   Z    |   RCODE   |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    QDCOUNT                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    ANCOUNT                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    NSCOUNT                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    ARCOUNT                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>字段介绍如下：</p><table><thead><tr><th>字段简写</th><th>字段长度</th><th>说明</th></tr></thead><tbody><tr><td>ID</td><td>16 bits无符号整数</td><td>客户端设置，响应报文会原样带回，用于客户端区分不同的请求应答；</td></tr><tr><td>QR</td><td>1 bit</td><td>区分是请求还是应答<br>0 请求<br>1 应答</td></tr><tr><td>Opcode</td><td>4 bits</td><td>设置查询的种类，响应报文会原样带回.<br> 0 标准查询 QUERY；<br> 1 反向查询 IQUERY；<br> 2 服务器状态查询 STATUS；<br> 3~15 保留；</td></tr><tr><td>AA</td><td>1bit</td><td>授权应答 AuthoritativeAnswer，响应报文生效，用于标示服务器响应报文是否为授权服务器返回的结果，可能是在本地 Cache 的缓存；</td></tr><tr><td>TC</td><td>1bit</td><td>截断 TrunCation，报文因为超过了允许的长度，导致被截断；</td></tr><tr><td>RD</td><td>1bit</td><td>用于请求报文，代表期望是否使用递归查询；<br>0 不使用递归查询<br>1 使用递归查询</td></tr><tr><td>RA</td><td>1bit</td><td>用于响应报文中，表示服务端是否支持递归查询<br>0 不支持递归<br>1 支持递归</td></tr><tr><td>RCODE</td><td>4 bits</td><td>应答码 ResponseCode，会在响应报文中设置。<br> 0 没有错误；<br> 1 报文格式错误(Format Error)，服务器解析请求报文时报错<br> 2 服务器失败(Server Failure)，意思是服务器失败，也就是这个域名的权威服务器拒绝响应或者响应REFUSE，递归服务器返回Rcode值为2给CLIENT<br> 3 名字错误(Name Error)，对应的DNS应答状态为NXDOMAIN，意思是不存在的记录，也就是这个具体的域名在权威服务器中并不存在<br>  4 没有实现(Not Implemented)，域名服务器不支持查询类型<br>  5 拒绝(Refused)，由于服务器设置的策略拒绝给出应答，通常是安全的配置；也就是这个请求源IP不在服务的范围内<br>  6-15 保留值，暂未使用。</td></tr><tr><td>QDCOUNT</td><td>16 bits 无符号整数</td><td>请求段中的<a href="#rr">RR</a>数</td></tr><tr><td>ANCOUNT</td><td>16 bits 无符号整数</td><td>应答段中的<a href="#rr">RR</a>数,</td></tr><tr><td>NSCOUNT</td><td>16 bits 无符号整数</td><td>报文授权段中的授权<a href="#rr">RR</a>数</td></tr><tr><td>ARCOUNT</td><td>16 bits 无符号整数</td><td>报文附加段中的附加<a href="#rr">RR</a>数</td></tr></tbody></table><h2 id="查询请求-Question"><a href="#查询请求-Question" class="headerlink" title="查询请求(Question)"></a>查询请求(Question)</h2><p>用来标识，查询的请求参数，同时需要在头中设置 <code>QDCOUNT</code> 这个字段。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br>|                                               |<br>/                     QNAME                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                     QTYPE                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                     QCLASS                    |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>字段含义如下:</p><table><thead><tr><th>字段名</th><th>长度</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>QNAME</td><td>最大255字节</td><td>标签字符串</td><td>域名被编码为一些labels序列，每个labels包含一个字节表示后续字符串长度，以及这个字符串，以0长度和空字符串来表示域名结束。注意这个字段可能为奇数字节，不需要进行边界填充对齐。</td></tr><tr><td>QTYPE</td><td>2字节</td><td>无符号整数</td><td>表示查询类型, 取值可以为任何可用的类型值，该字段的值包括对<a href="#rr_type">TYPE</a>字段有效的所有代码，以及一些更通用的代码，这些代码可以匹配一种以上的RR, 以及通配码来表示所有的RR记录。</td></tr><tr><td>QCLASS</td><td>2 字节</td><td>无符号整数</td><td>表示查询的协议类，<br> 0 保留 <br> 1 Internet (IN)<br> 2  未使用<br> 3 Chaos (CH) <br> 4 Hesiod (HS) <br> 5-253 未使用<br> 254 QCLASS NONE <br> 255 QCLASS * (ANY)</td></tr></tbody></table><h1 id="DNS-RR介绍"><a href="#DNS-RR介绍" class="headerlink" title="DNS RR介绍"></a><span id="rr">DNS RR介绍</span></h1><p>DNS资源记录（Resource Record，简称RR）</p><p>DNS server 内的每一个域名都有自己的域文件(zone file)，zone file 是由多个记录组成的，每一个记录就被称为资源记录(Resource Record，简称RR)。</p><h2 id="RR-记录格式"><a href="#RR-记录格式" class="headerlink" title="RR 记录格式"></a><span id="rr_format">RR 记录格式</span></h2><p>所有的RR具有以下相同的格式</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                                               |<br>/                                               /<br>/                      NAME                     /<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                      TYPE                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                     CLASS                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                      TTL                      |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                   RDLENGTH                    |<br><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--|<br>/                     RDATA                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>各个字段说明如下：</p><table><thead><tr><th>字段名</th><th>长度</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>NAME</td><td>最大255字节</td><td>标签字符串</td><td>不定长与之前QNAME相同,这里会使用省略字段<br>为了压缩消息总长度此内容可能会采用<a href="#compress">消息压缩</a>方式存储。</td></tr><tr><td>TYPE</td><td>2字节</td><td>无符号整数</td><td>资源类型，是QTYPE的子集</td></tr><tr><td>CLASS</td><td>2字节</td><td>无符号整数</td><td>与之前的QCLASS相同</td></tr><tr><td>TTL</td><td>4字节</td><td>有符号整数</td><td>它指定在再次查询信息源之前可以缓存资源记录的时间间隔。零值被解释为表示RR仅可用于进行中的事务，不应缓存。例如，SOA记录始终以零TTL分发，以禁止缓存。零值也可以用于易失性数据。</td></tr><tr><td>RDLENGTH</td><td>2字节</td><td>无符号整数</td><td>后面跟随的RDATA的长度</td></tr><tr><td>RDATA</td><td></td><td></td><td>真实的数据内容</td></tr></tbody></table><h3 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a><span id="compress">消息压缩</span></h3><p>为了减小dns消息的大小，dns协议中针对域名采用了一种压缩方案，消除了消息中重复的域名。压缩方式为：使用2个字节的指针来指向消息中已经存在相同域名的位置。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--+<br><span class="hljs-section">| 1  1|                OFFSET                   |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><p>第一个字节的前2个bit为11时表示此域名采用的压缩格式，后面的OFFSET (14 bit) 是当前域名所在的位置相对于DNS消息开始的偏移量。<br>  如：之前的header数组中出现过3www6google3com0,且处的位置为12,这里就可以用1100 000c 两个字节来代替3www6google3com0表示的16个字节</p><h3 id="TYPE值说明"><a href="#TYPE值说明" class="headerlink" title="TYPE值说明"></a><span id="rr_type">TYPE值说明</span></h3><h4 id="标准RR类型介绍"><a href="#标准RR类型介绍" class="headerlink" title="标准RR类型介绍"></a>标准RR类型介绍</h4><table><thead><tr><th align="center">类型</th><th>数值</th><th align="center">RFC来源</th><th align="left">描述</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">A</td><td>1</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">IP 地址记录</td><td align="left">传回一个 32 比特的 IPv4 地址，最常用于映射主机名称到IP地址，但也用于 DNSBL（<a href="https://tools.ietf.org/html/rfc1101">RFC 1101</a>）等。</td></tr><tr><td align="center">AAAA</td><td>28</td><td align="center"><a href="https://tools.ietf.org/html/rfc3596">RFC 3596</a></td><td align="left">IPv6 IP 地址记录</td><td align="left">传回一个 128 比特的 IPv6 地址，最常用于映射主机名称到 IP 地址。</td></tr><tr><td align="center">AFSDB</td><td>18</td><td align="center"><a href="https://tools.ietf.org/html/rfc1183">RFC 1183</a></td><td align="left">AFS文件系统</td><td align="left">（Andrew File System）数据库核心的位置，于域名以外的 AFS 客户端常用来联系 AFS 核心。这个记录的子类型是被过时的<a href="https://zh.wikipedia.org/wiki/DCE/DFS">DCE/DFS</a>（DCE Distributed File System）所使用。</td></tr><tr><td align="center">APL</td><td>42</td><td align="center"><a href="https://tools.ietf.org/html/rfc3123">RFC 3123</a></td><td align="left">地址前缀列表</td><td align="left">指定地址列表的范围，例如：CIDR 格式为各个类型的地址（试验性）。</td></tr><tr><td align="center">CAA</td><td>257</td><td align="center"><a href="https://tools.ietf.org/html/rfc6844">RFC 6844</a></td><td align="left">权威认证授权</td><td align="left"><a href="https://zh.wikipedia.org/wiki/DNS%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84%E6%8E%88%E6%9D%83">DNS认证机构授权</a>，限制主机/域的可接受的CA</td></tr><tr><td align="center">CDNSKEY</td><td>60</td><td align="center"><a href="https://tools.ietf.org/html/rfc7344">RFC 7344</a></td><td align="left">子关键记录</td><td align="left">关键记录记录的子版本，用于转移到父级</td></tr><tr><td align="center">CDS</td><td>59</td><td align="center"><a href="https://tools.ietf.org/html/rfc7344">RFC 7344</a></td><td align="left">子委托签发者</td><td align="left">委托签发者记录的子版本，用于转移到父级</td></tr><tr><td align="center">CERT</td><td>37</td><td align="center"><a href="https://tools.ietf.org/html/rfc4398">RFC 4398</a></td><td align="left">证书记录</td><td align="left">存储 PKIX、SPKI、PGP等。</td></tr><tr><td align="center">CNAME</td><td>5</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">规范名称记录</td><td align="left">一个主机名字的别名：域名系统将会继续尝试查找新的名字。</td></tr><tr><td align="center">DHCID</td><td>49</td><td align="center"><a href="https://tools.ietf.org/html/rfc4701">RFC 4701</a></td><td align="left">DHCP（动态主机设置协议）识别码</td><td align="left">用于将 FQDN 选项结合至 DHCP。</td></tr><tr><td align="center">DLV</td><td>32769</td><td align="center"><a href="https://tools.ietf.org/html/rfc4431">RFC 4431</a></td><td align="left">DNSSEC（域名系统安全扩展）来源验证记录</td><td align="left">为不在DNS委托者内发布DNSSEC的信任锚点，与 DS 记录使用相同的格式，<a href="https://tools.ietf.org/html/rfc5074">RFC 5074</a>介绍了如何使用这些记录。</td></tr><tr><td align="center">DNAME</td><td>39</td><td align="center"><a href="https://tools.ietf.org/html/rfc2672">RFC 2672</a></td><td align="left">代表名称</td><td align="left">DNAME 会为名称和其子名称产生别名，与 CNAME 不同，在其标签别名不会重复。但与 CNAME 记录相同的是，DNS将会继续尝试查找新的名字。</td></tr><tr><td align="center">DNSKEY</td><td>48</td><td align="center"><a href="https://tools.ietf.org/html/rfc4034">RFC 4034</a></td><td align="left">DNS 关键记录</td><td align="left">于DNSSEC内使用的关键记录，与 KEY 使用相同格式。</td></tr><tr><td align="center">DS</td><td>43</td><td align="center"><a href="https://tools.ietf.org/html/rfc4034">RFC 4034</a></td><td align="left">委托签发者</td><td align="left">此记录用于鉴定DNSSEC已授权区域的签名密钥。</td></tr><tr><td align="center">HIP</td><td>55</td><td align="center"><a href="https://tools.ietf.org/html/rfc5205">RFC 5205</a></td><td align="left">主机鉴定协议</td><td align="left">将端点标识符及IP 地址定位的分开的方法。</td></tr><tr><td align="center">IPSECKEY</td><td>45</td><td align="center"><a href="https://tools.ietf.org/html/rfc4025">RFC 4025</a></td><td align="left">IPSEC 密钥</td><td align="left">与 IPSEC 同时使用的密钥记录。</td></tr><tr><td align="center">KEY</td><td>25</td><td align="center"><a href="https://tools.ietf.org/html/rfc2535">RFC 2535</a> 和 <a href="https://tools.ietf.org/html/rfc2930">RFC 2930</a></td><td align="left">关键记录</td><td align="left">只用于 SIG(0)（<a href="https://tools.ietf.org/html/rfc2931">RFC 2931</a>）及 TKEY（<a href="https://tools.ietf.org/html/rfc2930">RFC 2930</a>。<a href="https://tools.ietf.org/html/rfc3455">RFC 3455</a> 否定其作为应用程序键及限制DNSSEC的使用。<a href="https://tools.ietf.org/html/rfc3755">RFC 3755</a> 指定了 DNSKEY 作为DNSSEC的代替。</td></tr><tr><td align="center">LOC</td><td>29</td><td align="center"><a href="https://tools.ietf.org/html/rfc1876">RFC 1876</a></td><td align="left">位置记录</td><td align="left">将一个域名指定地理位置。</td></tr><tr><td align="center">MX</td><td>15</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">电邮交互记录</td><td align="left">引导域名到该域名的邮件传输代理（MTA, Message Transfer Agents）列表。</td></tr><tr><td align="center">NAPTR</td><td>35</td><td align="center"><a href="https://tools.ietf.org/html/rfc3403">RFC 3403</a></td><td align="left">命名管理指针</td><td align="left">允许基于正则表达式的域名重写使其能够作为 URI 、进一步域名查找等。</td></tr><tr><td align="center">NS</td><td>2</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">名称服务器记录</td><td align="left">委托 DNS 域（DNS zone）使用已提供的权威域名服务器。</td></tr><tr><td align="center">NSEC</td><td>47</td><td align="center"><a href="https://tools.ietf.org/html/rfc4034">RFC 4034</a></td><td align="left">下一代安全记录</td><td align="left">DNSSEC 的一部分; 用来验证一个未存在的服务器，使用与 NXT（已过时）记录的格式。</td></tr><tr><td align="center">NSEC3</td><td>50</td><td align="center"><a href="https://tools.ietf.org/html/rfc5155">RFC 5155</a></td><td align="left">NSEC 记录第三版</td><td align="left">用作允许未经允许的区域行走以证明名称不存在性的 DNSSEC 扩展。</td></tr><tr><td align="center">NSEC3PARAM</td><td>51</td><td align="center"><a href="https://tools.ietf.org/html/rfc5155">RFC 5155</a></td><td align="left">NSEC3 参数</td><td align="left">与 NSEC3 同时使用的参数记录。</td></tr><tr><td align="center">OPENPGPKEY</td><td>61</td><td align="center"><a href="https://tools.ietf.org/html/rfc7929">RFC 7929</a></td><td align="left">OpenPGP公钥记录</td><td align="left">基于DNS的域名实体认证方法，用于使用OPENPGPKEY DNS资源记录在特定电子邮件地址的DNS中发布和定位OpenPGP公钥。</td></tr><tr><td align="center">PTR</td><td>12</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">指针记录</td><td align="left">引导至一个规范名称（Canonical Name）。与 CNAME 记录不同，DNS“不会”进行进程，只会传回名称。最常用来运行反向 DNS 查找，其他用途包括引作DNS-SD。</td></tr><tr><td align="center">RRSIG</td><td>46</td><td align="center"><a href="https://tools.ietf.org/html/rfc4034">RFC 4034</a></td><td align="left">DNSSEC 证书</td><td align="left">DNSSEC 安全记录集证书，与 SIG 记录使用相同的格式。</td></tr><tr><td align="center">RP</td><td>17</td><td align="center"><a href="https://tools.ietf.org/html/rfc1183">RFC 1183</a></td><td align="left">负责人</td><td align="left">有关域名负责人的信息，电邮地址的 <strong>@</strong> 通常写为 <strong>a</strong>。</td></tr><tr><td align="center">SIG</td><td>24</td><td align="center"><a href="https://tools.ietf.org/html/rfc2535">RFC 2535</a></td><td align="left">证书</td><td align="left">SIG(0)（<a href="https://tools.ietf.org/html/rfc2931">RFC 2931</a>）及 TKEY（<a href="https://tools.ietf.org/html/rfc2930">RFC 2930</a>）使用的证书。<a href="https://tools.ietf.org/html/rfc3755">RFC 3755</a> designated RRSIG as the replacement for SIG for use within DNSSEC.</td></tr><tr><td align="center">SOA</td><td>6</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">权威记录的起始</td><td align="left">指定有关DNS区域的权威性信息，包含主要名称服务器、域名管理员的电邮地址、域名的流水式编号、和几个有关刷新区域的定时器。</td></tr><tr><td align="center">SPF</td><td>99</td><td align="center"><a href="https://tools.ietf.org/html/rfc4408">RFC 4408</a></td><td align="left">SPF 记录</td><td align="left">作为 SPF 协议的一部分，优先作为先前在 TXT 存储 SPF 数据的临时做法，使用与先前在 TXT 存储的格式。</td></tr><tr><td align="center">SRV</td><td>33</td><td align="center"><a href="https://tools.ietf.org/html/rfc2782">RFC 2782</a></td><td align="left">服务定位器</td><td align="left">广义为服务定位记录，被新式协议使用而避免产生特定协议的记录，例如：MX 记录。</td></tr><tr><td align="center">SSHFP</td><td>44</td><td align="center"><a href="https://tools.ietf.org/html/rfc4255">RFC 4255</a></td><td align="left">SSH 公共密钥指纹</td><td align="left">DNS 系统用来发布SSH公共密钥指纹的资源记录，以用作辅助验证服务器的真实性。</td></tr><tr><td align="center">TA</td><td>32768</td><td align="center">无</td><td align="left">DNSSEC 信任当局</td><td align="left">DNSSEC 一部分无签订 DNS 根目录的部署提案，，使用与 DS 记录相同的格式。</td></tr><tr><td align="center">TKEY</td><td>249</td><td align="center"><a href="https://tools.ietf.org/html/rfc2930">RFC 2930</a></td><td align="left">秘密密钥记录</td><td align="left">为 TSIG 提供密钥材料的其中一类方法，that is 在公共密钥下加密的 accompanying KEY RR。</td></tr><tr><td align="center">TSIG</td><td>250</td><td align="center"><a href="https://tools.ietf.org/html/rfc2845">RFC 2845</a></td><td align="left">交易证书</td><td align="left">用以认证动态更新（Dynamic DNS）是来自合法的客户端，或与 DNSSEC 一样是验证回应是否来自合法的递归名称服务器。</td></tr><tr><td align="center">TXT</td><td>16</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">文本记录</td><td align="left">最初是为任意可读的文本 DNS 记录。自1990年起，些记录更经常地带有机读数据，以 <a href="https://tools.ietf.org/html/rfc1464">RFC 1464</a>指定：opportunistic encryption、Sender Policy Framework（虽然这个临时使用的 TXT 记录在 SPF 记录推出后不被推荐）、DomainKeys、DNS-SD等。</td></tr><tr><td align="center">URI</td><td>256</td><td align="center"><a href="https://tools.ietf.org/html/rfc7553">RFC 7553</a></td><td align="left">统一资源标识符</td><td align="left">可用于发布从主机名到URI的映射。</td></tr><tr><td align="center"><a href="https://en.wikipedia.org/w/index.php?title=ZONEMD_record&action=edit&redlink=1">ZONEMD</a></td><td>63</td><td align="center">RFC 8976</td><td align="left">DNS 区域消息摘要</td><td align="left">在<a href="https://en.wikipedia.org/wiki/Cryptographic_message_digest">静态</a>DNS 区域数据上提供<a href="https://en.wikipedia.org/wiki/Cryptographic_message_digest">加密消息摘要</a></td></tr><tr><td align="center">SVCB</td><td>64</td><td align="center"><a href="https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/00/?include_text=1">IETF 草案</a></td><td align="left">服务绑定</td><td align="left">为需要解析许多资源以访问域的客户端提高性能的 RR。 DNSOP 工作组和 Akamai 技术在此<a href="https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/00/?include_text=1">IETF 草案中提供</a>了更多信息。</td></tr><tr><td align="center">HTTPS</td><td>65</td><td align="center"><a href="https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/00/?include_text=1">IETF 草案</a></td><td align="left">HTTPS 绑定</td><td align="left">为需要解析许多资源以访问域的客户端提高性能的 RR。 DNSOP 工作组和 Akamai 技术在此<a href="https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/00/?include_text=1">IETF 草案中提供</a>了更多信息。</td></tr></tbody></table><h4 id="其他或伪资源记录类型"><a href="#其他或伪资源记录类型" class="headerlink" title="其他或伪资源记录类型"></a>其他或伪资源记录类型</h4><table><thead><tr><th align="center">类型</th><th>数值</th><th align="center">RFC来源</th><th align="left">描述</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center">*</td><td>255</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">所有缓存的记录</td><td align="left">传回所有服务器已知类型的记录。如果服务器未有任何关于名称的记录，该请求将被转发。而传回的记录未必完全完成，例如：当一个名称有 A 及 MX 类型的记录时，但服务器已缓存了 A 记录，就只有 A 记录会被传回。</td></tr><tr><td align="center">AXFR</td><td>252</td><td align="center"><a href="https://tools.ietf.org/html/rfc1035">RFC 1035</a></td><td align="left">全域转移</td><td align="left">由主域名服务器转移整个区域文件至二级域名服务器。</td></tr><tr><td align="center">IXFR</td><td>251</td><td align="center"><a href="https://tools.ietf.org/html/rfc1995">RFC 1995</a></td><td align="left">增量区域转移</td><td align="left">请求只有与先前流水式编号不同的特定区域的区域转移。此请求有机会被拒绝，如果权威服务器由于配置或缺乏必要的数据而无法履行请求，一个完整的（AXFR）会被发送以作回应。</td></tr><tr><td align="center"><span id=opt>OPT</span></td><td>41</td><td align="center"><a href="https://tools.ietf.org/html/rfc2671">RFC 2671</a>  已被<a href="https://tools.ietf.org/html/rfc6891">RFC 6891</a>取代</td><td align="left">选项(optinon)</td><td align="left">这是一个“伪DNS 记录类型”，用于支持EDNS(0)。EDNS根据<a href="https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-11">OPTION-CODE</a>来确定传递的附加数据类型，从而决定传递的附加数据内容</td></tr></tbody></table><h4 id="已过时的RR类型"><a href="#已过时的RR类型" class="headerlink" title="已过时的RR类型"></a>已过时的RR类型</h4><table><thead><tr><th>类型</th><th>数值</th><th>RFC来源</th><th>被淘汰RFC</th><th>描述</th></tr></thead><tbody><tr><td>A6</td><td>38</td><td>RFC 2874</td><td>RFC 6563</td><td>Defined as part of early IPv6 but downgraded to experimental by RFC 3363; later downgraded to historic by RFC 6563.</td></tr><tr><td>APL</td><td>42</td><td>RFC 3123</td><td></td><td>Specify lists of address ranges, e.g. in <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR</a> format, for various address families. Experimental.</td></tr><tr><td>EID</td><td>31</td><td>N/A</td><td></td><td>Defined by the <a href="http://www.tools.ietf.org/html/draft-ietf-nimrod-dns-00">Nimrod DNS</a> <a href="https://en.wikipedia.org/wiki/Internet_draft">internet draft</a>, but never made it to RFC status. Not in current use by any notable application</td></tr><tr><td>GPOS</td><td>27</td><td>RFC 1712</td><td></td><td>A more limited early version of the LOC record</td></tr><tr><td>L32</td><td>105</td><td>RFC 6742</td><td></td><td>未被任何值得注意的应用程序使用并标记为“实验性”</td></tr><tr><td>L64</td><td>106</td><td>RFC 6742</td><td></td><td>未被任何值得注意的应用程序使用并标记为“实验性”</td></tr><tr><td>LP</td><td>107</td><td>RFC 6742</td><td></td><td>未被任何值得注意的应用程序使用并标记为“实验性”</td></tr><tr><td>MB</td><td>7</td><td>RFC 883</td><td>Not formally obsoleted. Unlikely to be ever adopted (RFC 2505).</td><td>MB, MG, MR, and MINFO are records to publish subscriber mailing lists. MAILB is a query code which returns one of those records. The intent was for MB and MG to replace the <a href="https://en.wikipedia.org/wiki/SMTP">SMTP</a> VRFY and EXPN commands. MR was to replace the “551 User Not Local” SMTP error. Later, RFC 2505 recommended that both VRFY and EXPN be disabled, making MB and MG unnecessary. They were classified as experimental by RFC 1035.</td></tr><tr><td>MF</td><td>4</td><td>RFC 883</td><td>RFC 973</td><td>邮件目的地 (MD) 和邮件转发器 (MF) 记录；MAILA 不是实际的记录类型，而是返回 MF 和/或 MD 记录的查询类型。RFC 973 将这些记录替换为 MX 记录。</td></tr><tr><td>MG</td><td>8</td><td>RFC 883</td><td>没有正式过时。不太可能被采用（RFC 2505）。</td><td>MB、MG、MR 和 MINFO 是发布订阅者邮件列表的记录。MAILB 是一个查询代码，它返回这些记录之一。目的是让 MB 和 MG 替换<a href="https://en.wikipedia.org/wiki/SMTP">SMTP</a> VRFY 和 EXPN 命令。MR 是为了替换“551 User Not Local”SMTP 错误。后来，RFC 2505 建议禁用 VRFY 和 EXPN，使 MB 和 MG 变得不必要。它们被 RFC 1035 归类为实验性的。</td></tr><tr><td>NB</td><td>32</td><td>RFC 1002</td><td></td><td>Mistakes (from RFC 1002); the numbers are now assigned to NIMLOC and SRV.</td></tr><tr><td>NSAP-PTR</td><td>23</td><td>RFC 1706</td><td></td><td>Not in current use by any notable application</td></tr><tr><td>NXT</td><td>30</td><td>RFC 2065</td><td>RFC 3755</td><td>Part of the first version of DNSSEC (RFC 2065). NXT was obsoleted by DNSSEC updates (RFC 3755). At the same time, the domain of applicability for KEY and SIG was also limited to not include DNSSEC use.</td></tr><tr><td>PX</td><td>26</td><td>RFC 2163</td><td></td><td>Not in current use by any notable application</td></tr><tr><td>RP</td><td>17</td><td>RFC 1183</td><td></td><td>RP may be used for certain human-readable information regarding a different contact point for a specific host, subnet, or other domain level label separate than that used in the SOA record.</td></tr><tr><td>SIG</td><td>24</td><td>RFC 2065</td><td>RFC 3755</td><td>DNSSEC 第一个版本 (RFC 2065) 的一部分。NXT 已被 DNSSEC 更新 (RFC 3755) 淘汰。同时，KEY 和 SIG 的适用范围也仅限于不包括 DNSSEC 的使用。</td></tr><tr><td>X25</td><td>19</td><td>RFC 1183</td><td></td><td>Not in current use by any notable application</td></tr><tr><td>WKS</td><td>11</td><td>RFC 883, RFC 1035</td><td>Declared as “not to be relied upon” by RFC 1123 (more in RFC 1127).</td><td>Record to describe well-known services supported by a host. Not used in practice. The current recommendation and practice is to determine whether a service is supported on an IP address by trying to connect to it. SMTP is even prohibited from using WKS records in MX processing.[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-rfc1123-14">14]</a></td></tr><tr><td>SINK</td><td>40</td><td>N/A</td><td></td><td>Defined by the <a href="http://www.tools.ietf.org/html/draft-eastlake-kitchen-sink">Kitchen Sink</a> <a href="https://en.wikipedia.org/wiki/Internet_draft">internet draft</a>, but never made it to RFC status</td></tr><tr><td>NID</td><td>104</td><td>RFC 6742</td><td></td><td>Not in use by any notable application and marked as “experimental”</td></tr><tr><td>UINFO</td><td>100</td><td>N/A</td><td></td><td>IANA reserved, no RFC documented them [<a href="https://web.archive.org/web/20080611185015/http://www.ops.ietf.org/lists/namedroppers/namedroppers.2004/msg00949.html">1]</a> and support was removed from <a href="https://en.wikipedia.org/wiki/BIND">BIND</a> in the early 90s.</td></tr><tr><td>HINFO</td><td>13</td><td>RFC 883</td><td>Unobsoleted by RFC 8482. Currently used by <a href="https://en.wikipedia.org/wiki/Cloudflare">Cloudflare</a> in response to queries of the type ANY.[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-CF-HINFO-15">15]</a></td><td>Record intended to provide information about host CPU type and operating system. It was intended to allow protocols to optimize processing when communicating with similar peers.</td></tr><tr><td>NINFO</td><td>56</td><td>N/A</td><td></td><td>Used to provide status information about a zone. Requested for the IETF draft “The Zone Status (ZS) DNS Resource Record” in 2008. Expired without adoption.[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-IETF-dnsext-zs-19">19]</a></td></tr><tr><td>MR</td><td>9</td><td>RFC 883</td><td>没有正式过时。不太可能被采用（RFC 2505）。</td><td>MB、MG、MR 和 MINFO 是发布订阅者邮件列表的记录。MAILB 是一个查询代码，它返回这些记录之一。目的是让 MB 和 MG 替换<a href="https://en.wikipedia.org/wiki/SMTP">SMTP</a> VRFY 和 EXPN 命令。MR 是为了替换“551 User Not Local”SMTP 错误。后来，RFC 2505 建议禁用 VRFY 和 EXPN，使 MB 和 MG 变得不必要。它们被 RFC 1035 归类为实验性的。</td></tr><tr><td>MD</td><td>3</td><td>RFC 883</td><td>RFC 973</td><td>Mail destination (MD) and mail forwarder (MF) records; MAILA is not an actual record type, but a query type which returns MF and/or MD records. RFC 973 replaced these records with the MX record.</td></tr><tr><td>NSAP</td><td>22</td><td>RFC 1706</td><td></td><td>Not in current use by any notable application</td></tr><tr><td>NBSTAT</td><td>33</td><td>RFC 1002</td><td></td><td>错误（来自 RFC 1002）；编号现在分配给 NIMLOC 和 SRV。</td></tr><tr><td>TALINK</td><td>58</td><td>N/A</td><td></td><td>Defined by the <a href="https://tools.ietf.org/html/draft-wijngaards-dnsop-trust-history-02">DNSSEC Trust Anchor History Service</a> <a href="https://en.wikipedia.org/wiki/Internet_draft">internet draft</a>, but never made it to RFC status</td></tr><tr><td>RKEY</td><td>57</td><td>N/A</td><td></td><td>Used for encryption of NAPTR records. Requested for the IETF draft “The RKEY DNS Resource Record” in 2008. Expired without adoption.[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-IETF-dnsext-rkey-20">20]</a></td></tr><tr><td>NIMLOC</td><td>32</td><td>N/A</td><td></td><td>由<a href="http://www.tools.ietf.org/html/draft-ietf-nimrod-dns-00">Nimrod DNS</a> <a href="https://en.wikipedia.org/wiki/Internet_draft">互联网草案</a>定义，但从未达到 RFC 状态。当前未由任何显着应用程序使用</td></tr><tr><td>ATMA</td><td>34</td><td>N/A</td><td></td><td>Defined by The ATM Forum Committee.[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-AF-DANS-0152-16">16]</a></td></tr><tr><td>NULL</td><td>10</td><td>RFC 883</td><td>RFC 1035</td><td>Obsoleted by RFC 1035. RFC 883 defined “completion queries” (opcode 2 and maybe 3) which used this record. RFC 1035 later reassigned opcode 2 to be “status” and reserved opcode 3.</td></tr><tr><td>MINFO</td><td>14</td><td>RFC 883</td><td>没有正式过时。不太可能被采用（RFC 2505）。</td><td>MB、MG、MR 和 MINFO 是发布订阅者邮件列表的记录。MAILB 是一个查询代码，它返回这些记录之一。目的是让 MB 和 MG 替换<a href="https://en.wikipedia.org/wiki/SMTP">SMTP</a> VRFY 和 EXPN 命令。MR 是为了替换“551 User Not Local”SMTP 错误。后来，RFC 2505 建议禁用 VRFY 和 EXPN，使 MB 和 MG 变得不必要。它们被 RFC 1035 归类为实验性的。</td></tr><tr><td>UID</td><td>101</td><td>N/A</td><td></td><td>IANA 保留，没有 RFC 记录它们[<a href="https://web.archive.org/web/20080611185015/http://www.ops.ietf.org/lists/namedroppers/namedroppers.2004/msg00949.html">1]</a>并且在 90 年代初从<a href="https://en.wikipedia.org/wiki/BIND">BIND</a>中删除了支持。</td></tr><tr><td>DOA</td><td>259</td><td>N/A</td><td></td><td>Defined by the <a href="https://tools.ietf.org/html/draft-durand-doa-over-dns-03">DOA over DNS</a> <a href="https://en.wikipedia.org/wiki/Internet_draft">internet draft</a>, but never made it to RFC status</td></tr><tr><td>ISDN</td><td>20</td><td>RFC 1183</td><td></td><td>Not in current use by any notable application</td></tr><tr><td>UNSPEC</td><td>103</td><td>N/A</td><td></td><td>IANA 保留，没有 RFC 记录它们[<a href="https://web.archive.org/web/20080611185015/http://www.ops.ietf.org/lists/namedroppers/namedroppers.2004/msg00949.html">1]</a>并且在 90 年代初从<a href="https://en.wikipedia.org/wiki/BIND">BIND</a>中删除了支持。</td></tr><tr><td>RT</td><td>21</td><td>RFC 1183</td><td></td><td>Not in current use by any notable application</td></tr><tr><td>MAILA</td><td>254</td><td>RFC 883</td><td>RFC 973</td><td>邮件目的地 (MD) 和邮件转发器 (MF) 记录；MAILA 不是实际的记录类型，而是返回 MF 和/或 MD 记录的查询类型。RFC 973 将这些记录替换为 MX 记录。</td></tr><tr><td>GID</td><td>102</td><td>N/A</td><td></td><td>IANA 保留，没有 RFC 记录它们[<a href="https://web.archive.org/web/20080611185015/http://www.ops.ietf.org/lists/namedroppers/namedroppers.2004/msg00949.html">1]</a>并且在 90 年代初从<a href="https://en.wikipedia.org/wiki/BIND">BIND</a>中删除了支持。</td></tr><tr><td>MAILB</td><td>253</td><td>RFC 883</td><td>没有正式过时。不太可能被采用（RFC 2505）。</td><td>MB、MG、MR 和 MINFO 是发布订阅者邮件列表的记录。MAILB 是一个查询代码，它返回这些记录之一。目的是让 MB 和 MG 替换<a href="https://en.wikipedia.org/wiki/SMTP">SMTP</a> VRFY 和 EXPN 命令。MR 是为了替换“551 User Not Local”SMTP 错误。后来，RFC 2505 建议禁用 VRFY 和 EXPN，使 MB 和 MG 变得不必要。它们被 RFC 1035 归类为实验性的。</td></tr><tr><td>KEY</td><td>25</td><td>RFC 2065</td><td>RFC 3755</td><td>DNSSEC 第一个版本 (RFC 2065) 的一部分。NXT 已被 DNSSEC 更新 (RFC 3755) 淘汰。同时，KEY 和 SIG 的适用范围也仅限于不包括 DNSSEC 的使用。</td></tr><tr><td>SPF</td><td>99</td><td>RFC 4408</td><td>RFC 7208</td><td>Specified as part of the <a href="https://en.wikipedia.org/wiki/Sender_Policy_Framework">Sender Policy Framework</a> protocol as an alternative to storing SPF data in TXT records, using the same format. Support for it was discontinued in RFC 7208 due to widespread lack of support.[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-IETF-RFC6686-17">17]</a>[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-IETF-RFC7208-18">18]</a></td></tr></tbody></table><h2 id="RR格式详解"><a href="#RR格式详解" class="headerlink" title="RR格式详解"></a>RR格式详解</h2><h3 id="SRV"><a href="#SRV" class="headerlink" title="SRV"></a>SRV</h3><p>DNS SRV是DNS记录中一种，用来指定服务地址。与常见的A记录、cname不同的是，SRV中除了记录<strong>服务器</strong>的地址，还记录了<strong>服务</strong>的端口，并且可以设置每个服务地址的优先级和权重。访问服务的时候，本地的DNS resolver从DNS服务器查询到一个地址列表，根据优先级和权重，从中选取一个地址作为本次请求的目标地址。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>一个能够支持SRV的LDAP client可以通过查询域名，得知LDAP服务的IP地址和服务端口：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_ldap</span>.</span><span class="hljs-module"><span class="hljs-identifier">_tcp</span>.</span></span>example.com<br></code></pre></td></tr></table></figure><p>这个域名的格式是<a href="https://datatracker.ietf.org/doc/html/rfc2782">rfc-2782</a>中推荐的格式，_ldap表示LDAP服务，_tcp表示通过TCP协议访问LDAP服务。</p><h4 id="SRV的记录格式"><a href="#SRV的记录格式" class="headerlink" title="SRV的记录格式:"></a>SRV的记录格式:</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                                               |<br>/                                               /<br>/            _Service._Proto.Name               /<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                      33                       |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                     CLASS                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                      TTL                      |<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                   RDLENGTH                    |<br><span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--<span class="hljs-code">+--+</span>--|<br>/                     RDATA                     /<br><span class="hljs-section">/                                               /</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><h5 id="Service-Proto-Name-格式说明"><a href="#Service-Proto-Name-格式说明" class="headerlink" title="_Service._Proto.Name 格式说明"></a>_Service._Proto.Name 格式说明</h5><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>_Service</td><td>服务名称，前缀“_”是为防止与DNS Label（普通域名）冲突。</td></tr><tr><td>_Proto</td><td>服务使用的通信协议，_TCP、_UDP、其它标准协议或者自定义的协议。前缀“_”是为防止与DNS Label（普通域名）冲突</td></tr><tr><td>Name</td><td>提供服务的域名。</td></tr><tr><td>TTL/ CLASS及RDLENGTH</td><td>参考<a href="#rr_format">《RR记录格式》</a>的标准含义</td></tr></tbody></table><h5 id="RDATA格式为"><a href="#RDATA格式为" class="headerlink" title="RDATA格式为:"></a>RDATA格式为:</h5><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                  Priority                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    Weight                     |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br><span class="hljs-section">|                    Port                       |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br>|                                               |<br>/                                               /<br>/                    Target                     /<br><span class="hljs-section">|                                               |</span><br><span class="hljs-section">+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span><br></code></pre></td></tr></table></figure><h5 id="RDATA字段含义如下："><a href="#RDATA字段含义如下：" class="headerlink" title="RDATA字段含义如下："></a>RDATA字段含义如下：</h5><table><thead><tr><th>字段名</th><th>长度</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>Priority</td><td>2字节</td><td>无符号整形</td><td>该记录的优先级，数值越小表示优先级越高，范围0-65535。</td></tr><tr><td>Weight</td><td>2字节</td><td>无符号整形</td><td>该记录的权重，数值越高权重越高，范围0-65535。</td></tr><tr><td>Port</td><td>2字节</td><td>无符号整形</td><td>服务端口号，0-65535。</td></tr><tr><td>Target</td><td></td><td>标签字符串</td><td>目标主机对应的域名。 此域名必须有一个或多个地址记录(A或AAAA记录)，此域名不能是别名（在 RFC 1034 或 RFC 2181 的意义上）。 建议并不强制要求在应答数据的附加数据部分返回此地址记录数据。 除非未来的标准允许，否则此名称不能使用<a href="#compress">标签压缩</a>。<br>“.” 代表该服务在此域中绝对不可用。</td></tr></tbody></table><p>客户端查询到多条记录的时候，使用优先级最高的记录。</p><p>对相同优先级的记录，按照权重选择，记录的权重越高，被选择的可能性越高。</p><p>选择的时候，将所有记录的权重值累加，得到一个选择区间[0,sum]，每个记录在[0,sum]中占据一段连续的、长度为自身权重值区间。然后生成一个[0,sum]中的随机数，随机数落在的区间所属的记录就是被选择的记录。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p>在使用DNS SRV的时候，要注意DNS Client是否按照预期的方式处理收到的SRV记录。当前DNS SRV只能够负责提供服务地址列表，对这个列表如何解读，完全取决于Client的实现。</p></li><li><p><a href="https://datatracker.ietf.org/doc/html/rfc1035">rfc-1035</a>中规定，通过UDP协议传输DNS响应时，UDP报文的<strong>负载</strong>不能超过512字节，在添加SRV记录的时候，要特别注意。（通过TCP传输时没有512字节的限制）</p></li><li><p>当一个服务地址有多个相同优先级的SRV记录的时候，Client会按照这些SRV的权重分配请求。下一次向服务发起的请求可能是发送到了另一个地址。</p></li><li><p>在通过SRV记录的权重来分配请求的时候，使用的是本地缓存的DNS记录，所以不能实时地感知到服务的地址列表变化。除非将TTL设置的非常短暂，但这样将会频繁地查询DNS服务器。</p></li></ol><h4 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下"></a>示例如下</h4><img src="/2020/08/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/01DNS%E5%8D%8F%E8%AE%AE/srv.png" class="" title="SRV应答"><h1 id="EDNS-DNS扩展机制"><a href="#EDNS-DNS扩展机制" class="headerlink" title="EDNS( DNS扩展机制)"></a>EDNS( DNS扩展机制)</h1><p>EDNS即Extension Mechanisms for DNS。最新定义在<a href="https://tools.ietf.org/html/rfc6891">RFC 6891</a>(替换了RFC2671)向DNS添加了扩展机制。EDNS在遵循已有的<a href="#dformat">DNS报文格式</a>的基础上增加一些字段，来支持更多的DNS请求业务，许多新的DNS使用和协议扩展依赖于这些扩展的存在。</p><p>需要注意的是，像DNS服务器这样一个大型且广泛应用的系统软件，新增加扩展协议的时候一定要考虑到向后兼容性(backward compatibility)，即你增加了你这个特性的消息传输给未支持该特性的服务器时，后者依然能正确处理。</p><p>EDNS是DNS的逐跳( hop-by-hop )扩展。</p><p>EDNS0是第一个被广泛使用的EDNS协议版本。它提供了DNS消息的扩展格式，允许DNS协议支持更大的消息长度和更多的资源记录类型. EDNS(1)也是一种DNS协议扩展，用于增加DNS消息中的额外信息字段，与EDNS(0)相比，EDNS(1)的扩展性能更强</p><h2 id="为什么要有EDNS？"><a href="#为什么要有EDNS？" class="headerlink" title="为什么要有EDNS？"></a>为什么要有EDNS？</h2><p>RFC2671中指出EDNS被提出来的几个理由：</p><ul><li><p>DNS协议头部的第二个16字节中都已经被用的差不多了，需要添加新的返回类型(RCODE)和标记(FLAGS)来支持其他需求；</p></li><li><p>只为标示domain类型的标签分配了两位，现在已经用掉了两位（00标示字符串类型，11表示压缩类型），后面如果有更多的标签类型则无法支持；</p></li><li><p>当初DNS协议中设计的用UDP包传输时包大小限制为512字节，现在很多主机已经具备重组大数据包的能力，所以要有一种机制来允许DNS请求方通知DNS服务器让其返回大包；</p></li></ul><p>以后我们会看到，<a href="#dnssec">DNSSEC机制(DNS Security Extensions)</a>和<a href="#ecs">ECS(edns-client-subnet)机制</a>等都需要有EDNS的支持。</p><h2 id="EDNS的内容是什么"><a href="#EDNS的内容是什么" class="headerlink" title="EDNS的内容是什么"></a>EDNS的内容是什么</h2><p>怎样在DNS消息协议的基础上再增加一些字段呢？为了保持向后兼容性，更改已有的DNS协议格式是不可能的，所以只能在DNS协议的数据部分中做文章。</p><p>由此，EDNS中引入了一种新的<a href="#opt">伪资源记录 OPT</a>（一种特殊的RR），之所以叫做伪资源记录是因为它不包含任何DNS数据，OPT RR不能被cache、不能被转发、不能被存储在zone文件中。OPT被放在DNS通信双方（requestor和responsor）DNS消息的<a href="#additional"><strong>Additional</strong></a>区域中。</p><h2 id="OPT-伪RR介绍"><a href="#OPT-伪RR介绍" class="headerlink" title="OPT 伪RR介绍"></a>OPT 伪RR介绍</h2><p>OPT RR 有时称为meta RR一般存放在<a href="#additional"><strong>Additional</strong></a>区域中。其对应的<a href="#opt">RR TYPE</a>值为41 。</p><h3 id="线状数据格式表示"><a href="#线状数据格式表示" class="headerlink" title="线状数据格式表示"></a>线状数据格式表示</h3><p>OPT RR遵循<a href="#rr_format">标准RR格式</a>，但相关的含义会和<a href="#rr_format">标准的RR格式</a>有些差别，每个字段定义如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+------------+--------------+------------------------------+<br>|<span class="hljs-string"> Field Name </span>|<span class="hljs-string"> Field Type   </span>|<span class="hljs-string"> Description                  </span>|<br>+------------+--------------+------------------------------+<br>|<span class="hljs-string"> NAME       </span>|<span class="hljs-string"> domain name  </span>|<span class="hljs-string"> MUST be 0 (root domain)      </span>|<span class="hljs-string"> 固定为空</span><br><span class="hljs-string"></span>|<span class="hljs-string"> TYPE       </span>|<span class="hljs-string"> u_int16_t    </span>|<span class="hljs-string"> OPT (41)                     </span>|<span class="hljs-string"> 固定为41(0x29)</span><br><span class="hljs-string"></span>|<span class="hljs-string"> CLASS      </span>|<span class="hljs-string"> u_int16_t    </span>|<span class="hljs-string"> requestor&#x27;s UDP payload size </span>|<span class="hljs-string"> </span><br><span class="hljs-string"></span>|<span class="hljs-string"> TTL        </span>|<span class="hljs-string"> u_int32_t    </span>|<span class="hljs-string"> extended RCODE and flags     </span>|<span class="hljs-string"> 扩展的DNS消息头部</span><br><span class="hljs-string"></span>|<span class="hljs-string"> RDLEN      </span>|<span class="hljs-string"> u_int16_t    </span>|<span class="hljs-string"> length of all RDATA          </span>|<br>|<span class="hljs-string"> RDATA      </span>|<span class="hljs-string"> octet stream </span>|<span class="hljs-string"> &#123;attribute,value&#125; pairs      </span>|<span class="hljs-string"> KV类型的可变部分</span><br><span class="hljs-string">+------------+--------------+------------------------------+</span><br></code></pre></td></tr></table></figure><h4 id="TTL字段说明"><a href="#TTL字段说明" class="headerlink" title="TTL字段说明"></a>TTL字段说明</h4><p>原来的TTL字段被用来存储扩展消息头部中的RCODE和flags，它的格式如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">              +0 <span class="hljs-params">(MSB)</span>                            +1 <span class="hljs-params">(LSB)</span><br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>0: |         EXTENDED-RCODE        |            VERSION            |<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>2: | DO|                           Z                               |<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br></code></pre></td></tr></table></figure><p>EXTENDED-RCODE<br>      高位8个bit是扩展RCODE(返回状态码)，这8个bit加上DNS头部的4bit总共有12bit(8bit在高位),这样就可以表示更多的返回类型；<br>      Forms the upper 8 bits of extended 12-bit RCODE (together with the<br>      4 bits defined in [RFC1035].  Note that EXTENDED-RCODE value 0<br>      indicates that an unextended RCODE is in use (values 0 through<br>      15).</p><p>   VERSION<br>      表示EDNS的版本（EDNS根据支持不同的扩展内容会有很多版本）,<br>      Indicates the implementation level of the setter.  Full<br>      conformance with this specification is indicated by version ‘0’.<br>      Requestors are encouraged to set this to the lowest implemented<br>      level capable of expressing a transaction, to minimise the<br>      responder and network load of discovering the greatest common<br>      implementation level between requestor and responder.  A<br>      requestor’s version numbering strategy MAY ideally be a run-time<br>      configuration option.<br>      If a responder does not implement the VERSION level of the<br>      request, then it MUST respond with RCODE=BADVERS.  All responses<br>      MUST be limited in format to the VERSION level of the request, but<br>      the VERSION of each response SHOULD be the highest implementation<br>      level of the responder.  In this way, a requestor will learn the<br>      implementation level of a responder as a side effect of every<br>      response, including error responses and including RCODE=BADVERS.</p><h4 id="RDATA-字段说明"><a href="#RDATA-字段说明" class="headerlink" title="RDATA 字段说明"></a><span id=opt_rdata>RDATA 字段说明</span></h4><p>RDATA中可能包含零个或多个<code>option</code>。每个<code>option</code>必须视为一个位字段。每个<code>option</code>的格式如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">              +0 <span class="hljs-params">(MSB)</span>                            +1 <span class="hljs-params">(LSB)</span><br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>0: |                          OPTION-CODE                          |<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>2: |                         OPTION-LENGTH                         |<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>4: |                                                               |<br>   /                          OPTION-DATA                          /<br>   /                                                               /<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br></code></pre></td></tr></table></figure><p>OPTION-CODE ：由IANA分配，<a href="https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-11">参考</a></p><p>OPTION-LENGTH: OPTION-DATA的长度</p><p>OPTION-DATA: OPTION-CODE对应的内容, 具体实现依赖于具体RFC定义，如<a href="#ecs_option">ECS</a></p><h2 id="EDNS-应用实现"><a href="#EDNS-应用实现" class="headerlink" title="EDNS 应用实现"></a>EDNS 应用实现</h2><h3 id="ECS"><a href="#ECS" class="headerlink" title="ECS "></a><span id=ecs>ECS </span></h3><p>ECS即ENS Client Subnet。 是EDNS(0)中的一个OPT，它允许递归 DNS 解析器为其代表进行DNS查询的主机或客户端指定子网。这通常旨在通过允许更好地使用基于 DNS 的负载平衡来在客户端计算机不一定靠近递归解析器时选择客户端附近的服务地址，从而帮助加快从内容传递网络传递数据的速度。</p><p>ECS 的详细内容可参考<a href="https://datatracker.ietf.org/doc/html/rfc7871">RFC7871</a>。</p><h4 id="ECS-option-数据格式"><a href="#ECS-option-数据格式" class="headerlink" title="ECS option 数据格式"></a><span id=ecs_option>ECS option 数据格式</span></h4><p>ECS基于设置<a href="#opt_rdata">OPT伪RR的RDATA</a>来实现的。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">             +0 <span class="hljs-params">(MSB)</span>                            +1 <span class="hljs-params">(LSB)</span><br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>0: |                          OPTION-CODE                          |<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>2: |                         OPTION-LENGTH                         |<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>4: |                            FAMILY                             |<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>6: |     SOURCE PREFIX-LENGTH      |     SCOPE PREFIX-LENGTH       |<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br>8: |                           ADDRESS.<span class="hljs-string">..</span>                          /<br>   +<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<span class="hljs-params">---</span>+<br></code></pre></td></tr></table></figure><ul><li>OPTION-CODE： 长度为2个字节，固定为 8 (0x00 0x80)由 <a href="https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-11">IANA</a> 统一规定对应的编码序号。</li><li>OPTION-LENGTH：长度为2个字节，代表了后续的FAMILY、 SOURCE PREFIX-LENGTH 、SCOPE PREFIX-LENGTH  、ADDRESS等内容的总长度。</li><li>FAMILY：2个字节，标识ADDRESS的地址族，由<a href="https://www.iana.org/assignments/address-family-numbers/address-family-numbers.xhtml">IANA</a>统一确定地址族编码序号，ipv4为1，ipv6为2</li><li>SOURCE PREFIX-LENGTH：1个字节，标识要查找的<code>ADDRESS</code>数据的最左边的有效位数即IP地址<code>ADDRESS </code>宏的网络号的位数,ipv4最大32，ipv6最大128。在应答结果中返回请求时指定的网络号的位数</li><li>SCOPE PREFIX-LENGTH ：在查询请求中固定为0；在应答数据中标识应答数据<code>ADDRESS</code>的最左边的有效位数即IP地址<code>ADDRESS </code>的网络号的位数</li><li>ADDRESS：就是设置的SubNet的IP地址,依据上面的FAMILY</li></ul><h3 id="DNSSEC"><a href="#DNSSEC" class="headerlink" title="DNSSEC"></a><span id=dnssec>DNSSEC</span></h3><p>DNSSEC( DNS Security Extensions) 即DNS安全扩展.DNSSEC是一种基于EDNS0的协议扩展，用于提供DNS域名解析的安全性和完整性。DNSSEC可以保护DNS查询和响应的完整性，防止DNS欺骗攻击和DNS污染攻击</p><h1 id="什么是SOA？"><a href="#什么是SOA？" class="headerlink" title="什么是SOA？"></a>什么是SOA？</h1><p>SOA，即Start Of Authority，放在 zone file 中，用于描述这个 zone 负责的 name server，version number…等资料，以及当 slave server 要备份这个 zone 时的一些参数。</p><p>每个 zone file 中必须有且仅有一条 SOARR ，并在 zone file 中作为第一条资源记录保存。</p><p>举个栗子：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs llvm">@ IN SOA lv<span class="hljs-number">3</span>ns<span class="hljs-number">1</span>.ffdns.net. webmaster.ffdns.net. (<br>    <span class="hljs-number">2009092868</span> <span class="hljs-comment">; Serial</span><br>    <span class="hljs-number">604800</span> <span class="hljs-comment">; Refresh</span><br>    <span class="hljs-number">3600</span> <span class="hljs-comment">; Retry</span><br>    <span class="hljs-number">2419200</span> <span class="hljs-comment">; Expire</span><br>    <span class="hljs-number">3600</span> ) <span class="hljs-comment">; Minimum</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>第一行：</strong><code>@</code>指代该 zone ； <code>lv3ns1.ffdns.net.</code>是该 zone 的授权主机；<code>webmaster.ffdns.net.</code>代表[<code>webmaster@ffdns.net](mailto:</code><a href="mailto:&#119;&#x65;&#98;&#109;&#x61;&#x73;&#x74;&#x65;&#114;&#x40;&#102;&#102;&#100;&#110;&#x73;&#46;&#110;&#101;&#x74;">&#119;&#x65;&#98;&#109;&#x61;&#x73;&#x74;&#x65;&#114;&#x40;&#102;&#102;&#100;&#110;&#x73;&#46;&#110;&#101;&#x74;</a>)`，即该 zone 的管理者信箱。</p><p><strong>Serial：</strong>代表 zone file 的版本，每当 zone file 内容有变动，name server 管理者就应该增加这个号码，因为 slave 会将这个号码与其 copy 的那份比对以便决定是否要再 copy 一次（即进行 zone transfer ）。</p><p><strong>Refresh：</strong> slave server 每隔这段时间(秒)，就去检查 master server 上的 serial number 。</p><p><strong>Retry：</strong>当 slave server 无法和 master 进行 serial check 时，要每隔这段时间（秒） retry 一次。</p><p><strong>Expire：</strong>当时间超过 Expire 所定的秒数而 slave server 都无法和 master 取得连络，那么 slave 会删除自己的这份 copy 。</p><p><strong>Minimum：</strong>代表这个 zone file 中所有 record 的内定的 TTL 值，也就是其它的 DNS server cache 这笔 record 时，最长不应该超过这个时间。</p></blockquote><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td>逐跳扩展</td><td>是一种网络协议设计中的扩展方式，它允许协议在数据包中添加自定义的扩展选项，而这些选项会在每一跳节点上进行处理和解析。<br>在逐跳扩展中，数据包会携带一个或多个扩展选项，这些选项在每一个跳的节点上被处理，然后转发到下一个节点。每一个节点只负责处理自己的扩展选项，而不影响其他选项或者原始数据包的内容。因此，逐跳扩展是一种比较灵活的扩展方式，能够让协议在不影响基本功能的情况下，添加额外的功能和特性。<br>逐跳扩展常常用于一些底层协议中，如IP协议、IPv6协议等。在这些协议中，逐跳扩展可以用来添加一些新的路由或者策略信息，或者用于网络诊断和测试等用途。另外，在一些应用层协议中，也可能会采用逐跳扩展，如DNS协议中的EDNS扩展就是一种基于逐跳扩展的设计。</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/cobbliu/p/3188632.html">https://www.cnblogs.com/cobbliu/p/3188632.html</a></p><p><a href="https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-11">https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-11</a></p><p><a href="https://www.iana.org/assignments/address-family-numbers/address-family-numbers.xhtml">https://www.iana.org/assignments/address-family-numbers/address-family-numbers.xhtml</a></p><p><a href="https://asutorufa.github.io/posts/668530ca/">https://asutorufa.github.io/posts/668530ca/</a></p><p><a href="https://www.lijiaocn.com/%E6%8A%80%E5%B7%A7/2017/03/06/dns-srv.html">https://www.lijiaocn.com/%E6%8A%80%E5%B7%A7/2017/03/06/dns-srv.html</a><br><a href="https://www.jianshu.com/p/27c3f95e7509">https://www.jianshu.com/p/27c3f95e7509</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS基础</title>
    <link href="/2020/08/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/00DNS%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/08/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/00DNS%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="DNS-基础内容"><a href="#DNS-基础内容" class="headerlink" title="DNS 基础内容"></a>DNS 基础内容</h1><h2 id="什么是-DNS？"><a href="#什么是-DNS？" class="headerlink" title="什么是 DNS？"></a>什么是 DNS？</h2><p>DNS 是一个应用层协议,域名系统 (DNS) 的作用是将人类可读的域名 (如，<a href="http://www.example.com/">www.example.com</a>) 转换为机器可读的 IP 地址 (如，192.0.2.44)。DNS 协议建立在 UDP 或 TCP 协议之上，默认使用 53 号端口。客户端默认通过 UDP 协议进行通讯，但是由于广域网中不适合传输过大的 UDP 数据包，因此规定当报文长度超过了 512 字节时，应转换为使用 TCP 协议进行数据传输。<br>可能会出现如下的两种情况：</p><ul><li>客户端认为 UDP 响应包长度可能超过 512 字节，主动使用 TCP 协议；</li><li>客户端使用 UDP 协议发送 DNS 请求，服务端发现响应报文超过了 512 字节，在截断的 UDP 响应报文中将 TC 设置为 1 ，以通知客户端该报文已经被截断，客户端收到之后再发起一次 TCP 请求。</li></ul><h2 id="什么是域名？"><a href="#什么是域名？" class="headerlink" title="什么是域名？"></a>什么是域名？</h2><p>域名是由一串用点分隔符 . 组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的方位。域名可以说是一个 IP 地址的代称，目的是为了便于记忆后者。例如，wikipedia.org 是一个域名，和 IP 地址 208.80.152.2 相对应。人们可以直接访问 wikipedia.org 来代替 IP 地址，然后域名系统（DNS）就会将它转化成便于机器识别的 IP 地址。这样，人们只需要记忆 wikipedia.org 这一串带有特殊含义的字符，而不需要记忆没有含义的数字。</p><h2 id="DNS-的分层"><a href="#DNS-的分层" class="headerlink" title="DNS 的分层"></a>DNS 的分层</h2><p>域名系统是分层次的。</p><ul><li><p>根域：DNS域名使用中规定由尾部句点’.’来指定名称位于根或者更高层次的域层次结构,根服务器有13台。</p></li><li><p>顶级域：用来指示某个国家、地区或者组织。采用三个字符，如com -&gt; 商业公司，edu -&gt; 教育机构，net -&gt; 网络公司，gov -&gt; 非军事政府机构等等。</p></li><li><p>二级域：个人或者组织在Internet使用的注册名称。采用两个字符，如：cn -&gt; 代表中国，jp -&gt; 日本，uk -&gt; 英国，hk -&gt; 香港等等</p></li><li><p>主机：主机名处于域名空间结构中的最底层，主机名和域名结合构成FQDN，主机名是FQDN最左端的部分。</p></li></ul><p>在域名系统的层次结构中，各种域名都隶属于域名系统根域的下级。域名的第一级是顶级域，它包括通用顶级域，例如 .com、.net 和 .org；以及国家和地区顶级域，例如 .us、.cn 和 .tk。顶级域名下一层是二级域名，一级一级地往下。这些域名向人们提供注册服务，人们可以用它创建公开的互联网资源或运行网站。顶级域名的管理服务由对应的域名注册管理机构（域名注册局）负责，注册服务通常由域名注册商负责。</p><ul><li>授权型 DNS - 一种授权型 DNS 服务提供一种更新机制，供开发人员用于管理其公用 DNS 名称。然后，它响应 DNS 查询，将域名转换为 IP 地址，以便计算机可以相互通信。授权型 DNS 对域有最终授权且负责提供递归型 DNS 服务器对 IP 地址信息的响应。Amazon Route 53 是一种授权型 DNS 系统。</li><li>递归型 DNS - 客户端通常不会对授权型 DNS 服务直接进行查询。而是通常连接到称为解析程序的其他类型 DNS 服务，或递归型 DNS 服务。递归型 DNS 服务就像是旅馆的门童：尽管没有任何自身的 DNS 记录，但是可充当代表您获得 DNS 信息的中间程序。如果递归型 DNS 拥有已缓存或存储一段时间的 DNS 参考，那么它会通过提供源或 IP 信息来响应 DNS 查询。如果没有，则它会将查询传递到一个或多个授权型 DNS 服务器以查找信息。</li></ul><p><strong>记录类型</strong><br> DNS 中，常见的资源记录类型有：</p><ul><li>NS 记录（域名服务） ─ 指定解析域名或子域名的 DNS 服务器。</li><li>MX 记录（邮件交换） ─ 指定接收信息的邮件服务器。</li><li>A 记录（地址） ─ 指定域名对应的 IPv4 地址记录。</li><li>AAAA 记录（地址） ─ 指定域名对应的 IPv6 地址记录。</li><li><strong>NAME（规范）</strong> ─ 一个域名映射到另一个域名或 <code>CNAME</code> 记录（ example.com 指向 <a href="https://links.jianshu.com/go?to=http://www.example.com/">www.example.com</a> ）或映射到一个 <code>A</code>记录。</li><li>PTR 记录（反向记录） ─ PTR 记录用于定义与 IP 地址相关联的名称。 PTR 记录是 A 或 AAAA 记录的逆。 PTR 记录是唯一的，因为它们以 .arpa 根开始并被委派给 IP 地址的所有者。</li></ul><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><h3 id="域名解析的基本过程"><a href="#域名解析的基本过程" class="headerlink" title="域名解析的基本过程"></a>域名解析的基本过程</h3><p>主机名到 IP 地址的映射有两种方式：</p><ul><li>静态映射 - 在本机上配置域名和 IP 的映射，旨在本机上使用。Windows 和 Linux 的 hosts 文件中的内容就属于静态映射。</li><li>动态映射 - 建立一套域名解析系统（DNS），只在专门的 DNS 服务器上配置主机到 IP 地址的映射，网络上需要使用主机名通信的设备，首先需要到 DNS 服务器查询主机所对应的 IP 地址。</li></ul><p>通过域名去查询域名服务器，得到 IP 地址的过程叫做域名解析。在解析域名时，一般先静态域名解析，再动态解析域名。可以将一些常用的域名放入静态域名解析表中，这样可以大大提高域名解析效率。</p><img src="/2020/08/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/00DNS%E5%9F%BA%E7%A1%80/2.png" class="" title="域名解析过程"><p>上图展示了一个动态域名解析的流程，步骤如下：</p><ol><li><p>用户打开 Web 浏览器，在地址栏中输入 <a href="http://www.example.com/">www.example.com</a> ，然后按 Enter 键。</p></li><li><p><a href="http://www.example.com/">www.example.com</a> 的请求被路由到 DNS 解析程序，这一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服<br> 务提供商、DSL 宽带提供商或公司网络。</p></li><li><p>ISP 的 DNS 解析程序将 <a href="http://www.example.com/">www.example.com</a> 的请求转发到 DNS 根名称服务器。</p></li><li><p>ISP 的 DNS 解析程序再次转发 <a href="http://www.example.com/">www.example.com</a>  的请求，这次转发到 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 example.com 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。</p></li><li><p>ISP 的 DNS 解析程序选择一个 Amazon Route 53 名称服务器，并将  <a href="http://www.example.com/">www.example.com</a>  的请求转发到该名称服务器。</p></li><li><p>Amazon Route 53 名称服务器在 example.com 托管区域中查找 <a href="http://www.example.com/">www.example.com</a> 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。</p></li><li><p>ISP 的 DNS 解析程序最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 example.com 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 example.com 时更快地作出响应。有关更多信息，请参阅存活期 (TTL)。</p></li><li><p>Web 浏览器将 <a href="http://www.example.com/">www.example.com</a> 的请求发送到从 DNS 解析程序中获得的 IP 地址。这是您的内容所处位置，例如，在 Amazon EC2 实例中或配置为网站终端节点的 Amazon S3 存储桶中运行的 Web 服务器。</p></li><li><p>192.0.2.44 上的 Web 服务器或其他资源将 <a href="http://www.example.com/">www.example.com</a>  的 Web 页面返回到 Web 浏览器，且 Web 浏览器会显示该页面。<br> 注意：只有配置了域名服务器，才能执行域名解析。<br> 例如，在 Linux 中执行 vim /etc/resolv.conf 命令，在其中添加下面的内容来配置域名服务器地址：</p><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">nameserver</span> <span class="hljs-number">218.2.135.1</span><br></code></pre></td></tr></table></figure><h3 id="域名解析涉及4个DNS服务器"><a href="#域名解析涉及4个DNS服务器" class="headerlink" title="域名解析涉及4个DNS服务器"></a>域名解析涉及4个DNS服务器</h3><p>DNS recursor、根名称服务器 、TLD名称服务器、权威名称服务器</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DNS</span> recursor: recursor可以被认为是一个图书管理员，被要求在图书馆的某个地方找到一本特定的书。DNS recursor是一个服务器，旨在通过Web浏览器等应用程序从客户端计算机接收查询。通常，recursor负责发出其他请求以满足客户端的DNS查询。<br><br>根名称服务器: 根服务器是将人类可读主机名转换（解析）为<span class="hljs-built_in">IP</span>地址的第一步。它可以被认为是图书馆中指向不同书籍书籍的索引 - 通常它可以作为对其他更具体位置的参考。<br><br><span class="hljs-symbol">TLD</span>名称服务器: 顶级域名服务器（TLD）可以被视为库中特定的书架。此名称服务器是搜索特定<span class="hljs-built_in">IP</span>地址的下一步，它托管主机名的最后一部分（在east263.com中，TLD服务器是“com”）。<br><br>权威名称服务器:  这个最终名称服务器可以被认为是书架上的字典，其中可以将特定名称翻译成其定义。权威名称服务器是名称服务器查询中的最后一站。如果权威名称服务器可以访问所请求的记录，它将把请求的主机名的<span class="hljs-built_in">IP</span>地址返回给发出初始请求的DNS Recursor（图书管理员）<br></code></pre></td></tr></table></figure></li></ol><h2 id="权威DNS服务器和递归DNS解析器的区别"><a href="#权威DNS服务器和递归DNS解析器的区别" class="headerlink" title="权威DNS服务器和递归DNS解析器的区别"></a>权威DNS服务器和递归DNS解析器的区别</h2><p>这两个概念都指的是与DNS基础结构不可分割的服务器（服务器组），但每个服务器执行不同的角色并且位于DNS查询管道内的不同位置。考虑差异的一种方法是递归解析器位于DNS查询的开头，而权威的名称服务器位于最后。</p><p><strong>递归DNS解析器</strong><br>    递归解析器是响应来自客户端的递归请求并花时间跟踪DNS记录的计算机。它通过发出一系列请求直到它到达请求记录的权威DNS名称服务器（或者如果没有找到记录则超时或返回错误）来完成此操作。幸运的是，递归DNS解析器并不总是需要发出多个请求才能跟踪响应客户端所需的记录; 缓存是一种数据持久性过程，它通过在DNS查找中提前提供请求的资源记录来帮助缩短必要的请求。</p><p><strong>权威DNS服务器</strong><br>    简而言之，权威DNS服务器是实际持有并负责DNS资源记录的服务器。这是DNS查找链底部的服务器，它将使用查询的资源记录进行响应，最终允许Web浏览器发出请求以访问访问网站或其他Web资源所需的IP地址。权威的名称服务器可以满足来自其自身数据的查询，而无需查询其他来源，因为它是某些DNS记录的最终真实来源。</p><h2 id="递归DNS查询和递归DNS解析器的差异"><a href="#递归DNS查询和递归DNS解析器的差异" class="headerlink" title="递归DNS查询和递归DNS解析器的差异"></a>递归DNS查询和递归DNS解析器的差异</h2><p><code>递归DNS查询</code>是指对需要解析查询的DNS解析器发出的请求。<code>递归DNS解析器</code>是接受递归查询并通过发出必要请求来处理响应的计算机。</p><h2 id="DNS查询的类型"><a href="#DNS查询的类型" class="headerlink" title="DNS查询的类型"></a>DNS查询的类型</h2><p>在典型的DNS查找中，会发生三种类型的查询。通过使用这些查询的组合，用于DNS解析的优化过程可以导致行进距离的减少。在理想情况下，缓存记录数据将可用，允许DNS名称服务器返回非递归查询。</p><div class="code-wrapper"><pre><code class="hljs">递归查询: 在递归查询中，DNS客户端要求DNS服务器（通常是DNS递归解析程序）将使用请求的资源记录响应客户端，或者如果解析程序无法找到记录，则会响应错误消息。迭代查询: 在这种情况下，DNS客户端将允许DNS服务器返回它可以的最佳答案。如果查询的DNS服务器与查询名称不匹配，则它将返回对域名称空间的较低级别具有权威性的DNS服务器的引用。然后，DNS客户端将对引用地址进行查询。此过程将继续使用查询链中的其他DNS服务器，直到发生错误或超时。非递归查询: 通常在DNS解析器客户端向DNS服务器查询其有权访问的记录时会发生这种情况，因为它对记录具有权威性，或者记录存在于其缓存中。通常，DNS服务器将缓存DNS记录以防止额外的带宽消耗和上游服务器的负载。</code></pre></div><h3 id="递归查询-VS-迭代查询"><a href="#递归查询-VS-迭代查询" class="headerlink" title="递归查询 VS. 迭代查询"></a>递归查询 VS. 迭代查询</h3><p>在递归查询模式下，DNS 服务器在接收到客户机请求时，必须使用一个准确的查询结果回复客户机。也就意味着，如果 DNS 服务器本地没有缓存所查询的 DNS 信息，那么该服务器会询问其它服务器，并将返回的查询结果提交给客户机。</p><p>而在使用迭代查询时，DNS 服务器会向客户机提供其它能够解析查询请求的 DNS 服务器地址。也就是说，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机需要再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果为止。</p><p>也就是说，关键的区别是由谁去查询最终的结果。</p><h2 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h2><p>发送大量的 DNS 递归查询会消耗服务端的一定资源，所以，只需要将发送的报文设置一个 RD 标志位即可。<br>当发送垃圾查询时，例如 <code>www.baidu.com</code> 这类必然不存在的域名，必然会导致查询很慢。</p><h2 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h2><p>ECS（EDNS-Client-Subnet）是DNS服务支持的新协议。该协议会在DNS请求包中附加请求域名解析的用户IP地址。这样，DNS服务器就可以根据该地址返回用户更容易访问的服务器IP地址。该技术广泛应用于CDN应用中。Nmap的dns-client-subnet-scan脚本利用该协议，通过提交不同的IP地址，获取指定域名所有的IP地址。</p><h2 id="Non-authoritative-answer"><a href="#Non-authoritative-answer" class="headerlink" title="Non-authoritative answer"></a>Non-authoritative answer</h2><p>为加快 DNS 的查询速度，一般会在服务端缓存一段时间，所以有可能 DNS 会返回缓存在 Cache 中的内容，那么此时就会将 AA 响应设置为 0 ，也就是是这里显示的 Non-authoritative answer 。</p><h1 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h1><p>缓存的目的是将数据临时存储在一个位置，从而提高数据请求的性能和可靠性。DNS缓存涉及将数据存储在更靠近请求客户端的位置，以便可以更早地解析DNS查询，并且可以避免在DNS查找链中进一步查询，从而改善加载时间并减少带宽/ CPU消耗。DNS数据可以缓存在各种位置，每个位置将存储DNS记录一段时间，该时间由生存时间（TTL）决定。</p><h2 id="缓存存在的位置"><a href="#缓存存在的位置" class="headerlink" title="缓存存在的位置"></a>缓存存在的位置</h2><h3 id="浏览器DNS缓存"><a href="#浏览器DNS缓存" class="headerlink" title="浏览器DNS缓存"></a>浏览器DNS缓存</h3><p>默认情况下，现代Web浏览器设计为在一段时间内缓存DNS记录。这里的目的很明显; DNS缓存越接近Web浏览器，为了检查缓存并对IP地址发出正确的请求，必须采取的处理步骤越少。当请求DNS记录时，浏览器缓存是为请求的记录检查的第一个位置。</p><p>在chrome中，您可以转到chrome：// net-internals / #dns查看DNS缓存的状态。</p><h3 id="操作系统（OS）级DNS缓存"><a href="#操作系统（OS）级DNS缓存" class="headerlink" title="操作系统（OS）级DNS缓存"></a>操作系统（OS）级DNS缓存</h3><p>操作系统级DNS解析程序是DNS查询离开计算机之前的第二个也是最后一个本地停止。设计用于处理此查询的操作系统内部的进程通常称为“存根解析程序”或DNS客户端。当存根解析器从应用程序获取请求时，它首先检查自己的缓存以查看它是否具有该记录。如果没有，则它将本地网络外部的DNS查询（带有递归标志集）发送到Internet服务提供商（ISP）内的DNS递归解析器。</p><h3 id="递归解析器DNS缓存"><a href="#递归解析器DNS缓存" class="headerlink" title="递归解析器DNS缓存"></a>递归解析器DNS缓存</h3><p>当ISP内部的递归解析器收到DNS查询时，如同之前的所有步骤一样，它还将检查所请求的主机到IP地址转换是否已存储在其本地持久层内。</p><p>递归解析器还具有其他功能，具体取决于它在缓存中的记录类型：</p><p>如果解析程序没有A记录，但确实拥有权威名称服务器的NS记录，它将直接查询这些名称服务器，绕过DNS查询中的几个步骤。此快捷方式可防止从root和.com名称服务器（在我们的east263.com搜索中）中进行查找，并有助于更快地解析DNS查询。</p><p>如果解析器没有NS记录，它将向TLD服务器发送查询（在我们的例子中为.com），跳过根服务器。</p><p>万一解析器没有指向TLD服务器的记录，它将查询根服务器。此事件通常在清除DNS缓存后发生。</p><h1 id="3-Linux-上的域名相关命令"><a href="#3-Linux-上的域名相关命令" class="headerlink" title="3. Linux 上的域名相关命令"></a>3. Linux 上的域名相关命令</h1><p><strong>hostname</strong></p><blockquote><p>hostname 命令用于查看和设置系统的主机名称。环境变量 HOSTNAME 也保存了当前的主机名。在使用 hostname 命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改 /etc/hosts 和 /etc/sysconfig/network 的相关内容。<br> 示例：</p></blockquote>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hostname<br>test123vm6<br></code></pre></td></tr></table></figure><p>  <strong>nslookup</strong><br> nslookup 命令是常用域名查询工具，就是查 DNS 信息用的命令。<br> 示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>nslookup www.baidu.com<br><span class="hljs-symbol">Server:</span>     <span class="hljs-number">192.168</span>.<span class="hljs-number">16.24</span><br><span class="hljs-symbol">Address:</span>    <span class="hljs-number">192.168</span>.<span class="hljs-number">16.24</span><span class="hljs-comment">#53</span><br><br>Non-authoritative <span class="hljs-symbol">answer:</span><br>www.baidu.com   canonical name = www.a.shifen.com.<br><span class="hljs-symbol">Name:</span>   www.a.shifen.com<br><span class="hljs-symbol">Address:</span> <span class="hljs-number">14.215</span>.<span class="hljs-number">177.38</span><br><span class="hljs-symbol">Name:</span>   www.a.shifen.com<br><span class="hljs-symbol">Address:</span> <span class="hljs-number">14.215</span>.<span class="hljs-number">177.39</span><br></code></pre></td></tr></table></figure><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1><p><a href="https://www.jianshu.com/p/915de89d070e">https://www.jianshu.com/p/915de89d070e</a><br><a href="https://jin-yang.github.io/post/network-dns-protocol-details-introduce.html">https://jin-yang.github.io/post/network-dns-protocol-details-introduce.html</a><br>DNS 协议 <a href="https://www.ietf.org/rfc/rfc1035.txt">RFC1035</a> 详细规定了 DNS 报文的格式，详见 <code>4. MESSAGES</code> 中的部分。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>suqid 存储模型研究</title>
    <link href="/2020/08/22/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/01%20suqid%20%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6/"/>
    <url>/2020/08/22/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/01%20suqid%20%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>squid 从3.5.0开始移除了之前的coss存储机制，改为支持aufs, diskd, rock, ufs四种存储机制。</p><p>至于为什么去掉coss机制有待后续调研确定。</p><p>当前先研究下已有的几种类型</p><h2 id="ufs-存储机制"><a href="#ufs-存储机制" class="headerlink" title="ufs 存储机制"></a>ufs 存储机制</h2><p>ufs是Squid存储格式中一直存储的著名的存储格式。UFS 即 Unix Filesystem 的缩写<br>使用方法：<br>    cache_dir ufs Directory-Name Mbytes L1 L2 [options]</p><p>Mbytes 是此目录下要使用的磁盘空间（MB）数量。 默认值为100 MB。 更改此设置以适合您的配置。 请勿在此处放置磁盘驱动器的大小。 相反，如果您希望Squid使用整个磁盘驱动器，请减去20％并使用该值。</p><p>L1 是将在”目录”下创建的第一级子目录的数量。 默认值为16。</p><p>L2 是将在每个第一级目录下创建的第二级子目录的数量。 默认值为256。</p><h2 id="aufs-存储机制"><a href="#aufs-存储机制" class="headerlink" title="aufs 存储机制"></a>aufs 存储机制</h2><p>aufs存储机制已经发展到超出了改进squid磁盘I/O响应时间的最初尝试。”a”代表着异步I/O。默认的ufs和aufs之间的唯一区别，在于I/O是否被squid主进程执行。数据格式都是一样的，所以你能在两者之间轻松选择，而不用丢失任何cache数据。</p><p>aufs使用大量线程进行磁盘I/O操作。每次squid需要读写，打开关闭，或删除cache文件时，I/O请求被分派到这些线程之一。当线程完成了I/O后，它给squid主进程发送信号，并且返回一个状态码。实际上在squid2.5中，某些文件操作默认不是异步执行的。最明显的，磁盘写总是同步执行。你可以修改src/fs/aufs/store_asyncufs.h文件，将ASYNC_WRITE设为1，并且重编译squid。</p><p>aufs代码需要pthreads库。这是POSIX定义的标准线程接口。尽管许多Unix系统支持pthreads库，但我经常遇到兼容性问题。aufs存储系统看起来仅仅在Linux和Solaris上运行良好。在其他操作系统上，尽管代码能编译，但也许会面临严重的问题。</p><p>为了使用aufs，可以在./configure时增加一个选项：</p><div class="code-wrapper"><pre><code class="hljs">% ./configure --enable-storeio=aufs,ufs</code></pre></div><p>严格讲，你不必在storeio模块列表中指定ufs。然而，假如你以后不喜欢aufs，那么就需要指定ufs，以便能重新使用稳定的ufs存储机制。</p><p>假如愿意，你也能使用—with-aio-threads=N选项。假如你忽略它，squid基于aufs cache_dir的数量，自动计算可使用的线程数量。表8-1显示了1-6个cache目录的默认线程数量。</p><h3 id="aufs如何工作-待研究确定4-12版机制"><a href="#aufs如何工作-待研究确定4-12版机制" class="headerlink" title="aufs如何工作 (待研究确定4.12版机制???)"></a>aufs如何工作 (待研究确定4.12版机制???)</h3><p>Squid通过调用pthread_create()来创建大量的线程。所有线程在任何磁盘活动之上创建。这样，即使squid空闲，你也能见到所有的线程。</p><p>无论何时，squid想执行某些磁盘I/O操作（例如打开文件读），它分配一对数据结构，并将I/O请求放进队列中。线程循环读取队列，取得I/O请求并执行它们。因为请求队列共享给所有线程，squid使用独享锁来保证仅仅一个线程能在给定时间内更新队列。</p><p>I/O操作阻塞线程直到它们被完成。然后，将操作状态放进一个完成队列里。作为完整的操作，squid主进程周期性的检查完成队列。请求磁盘I/O的模块被通知操作已完成，并获取结果。</p><p>你可能已猜想到，aufs在多CPU系统上优势更明显。唯一的锁操作发生在请求和结果队列。然而，所有其他的函数执行都是独立的。当主进程在一个CPU上执行时，其他的CPU处理实际的I/O系统调用。</p><h2 id="diskd-存储机制"><a href="#diskd-存储机制" class="headerlink" title="diskd 存储机制"></a>diskd 存储机制</h2><p>diskd（disk守护进程的短称）类似于aufs，磁盘I/O被外部进程来执行。不同于aufs的是，diskd不使用线程。代替的，它通过消息队列和共享内存来实现内部进程间通信。</p><p>消息队列是现代Unix操作系统的标准功能。许多年以前在AT&amp;T的Unix System V的版本1上实现了它们。进程间的队列消息以较少的字节传递：32-40字节。每个diskd进程使用一个队列来接受来自squid的请求，并使用另一个队列来传回请求。</p><h3 id="diskd如何工作-待研究确定4-12版机制"><a href="#diskd如何工作-待研究确定4-12版机制" class="headerlink" title="diskd如何工作 (待研究确定4.12版机制???)"></a>diskd如何工作 (待研究确定4.12版机制???)</h3><p>Squid对每个cache_dir创建一个diskd进程。这不同于aufs，aufs对所有的cache_dir使用一个大的线程池。对每个I/O操作，squid发送消息到相应的diskd进程。当该操作完成后，diskd进程返回一个状态消息给squid。squid和diskd进程维护队列里的消息的顺序。这样，不必担心I/O会无序执行。</p><p>对读和写操作，squid和diskd进程使用共享内存区域。两个进程能对同一内存区域进行读和写。例如，当squid产生读请求时，它告诉diskd进程在内存中何处放置数据。diskd将内存位置传递给read()系统调用，并且通过发送队列消息，通知squid该过程完成了。然后squid从共享内存区域访问最近的可读数据。</p><p>diskd与aufs本质上都支持squid的无阻塞磁盘I/O。当diskd进程在I/O操作上阻塞时，squid有空去处理其他任务。在diskd进程能跟上负载情况下，这点确实工作良好。因为squid主进程现在能够去做更多工作，当然它有可能会加大diskd的负载。diskd有两个功能来帮助解决这个问题。</p><p>首先，squid等待diskd进程捕获是否队列超出了某种极限。默认值是64个排队消息。假如diskd进程获取的数值远大于此，squid会休眠片刻，并等待diskd完成一些未决操作。这本质上让squid进入阻塞I/O模式。它也让更多的CPU时间对diskd进程可用。通过指定cache_dir行的Q2参数的值，你可以配置这个极限值：</p><p>cache_dir diskd /cache0 7000 16 256 Q2=50<br>第二，假如排队操作的数量抵达了另一个极限，squid会停止要求diskd进程打开文件。这里的默认值是72个消息。假如squid想打开一个磁盘文件读或写，但选中的cache_dir有太多的未完成操作，那么打开请求会失败。当打开文件读时，会导致cache丢失。当打开文件写时，会阻碍squid存储cache响应。这两种情况下用户仍能接受到有效响应。唯一实际的影响是squid的命中率下降。这个极限用Q1参数来配置：</p><p>cache_dir diskd /cache0 7000 16 256 Q1=60 Q2=50<br>注意在某些版本的squid中，Q1和Q2参数混杂在默认的配置文件里。最佳选择是，Q1应该大于Q2。</p><h2 id="rock-存储机制"><a href="#rock-存储机制" class="headerlink" title="rock 存储机制"></a>rock 存储机制</h2><p>rock 存储机制是数据库样式的存储。所有缓存的条目都使用固定大小的 slot 存储在“数据库”文件中。单个条目占用一个或多个slot。</p><p>如果可能的话，使用Rock Store的Squid会创建一个名为 “disker” 的专用子进程，以避免Squid 的worker阻塞磁盘I/O上。将为每个cache_dir创建一个disker进程。squid只有运行在daemon模式下且磁盘的I/O模式设置为 IpcIo 时才会创建disker。</p><p>参数 swap-timeout = msec<br>    如果Squid预估swap操作花费的时间超过指定的毫秒数，则开始停止向磁盘写未命中数据或从磁盘中读取命中数据。默认情况下，当设置为零时，禁用磁盘I / O时间限制实施。使用阻塞I/O模式时将被忽略，因为阻塞同步I/O不允许Squid预估swap操作消耗的时间。</p><p>参数 max-swap-rate = swaps / sec：<br>    使用指定的I/O速率限制来人为限制磁盘访问。交换将导致平均I/O速率超过限制的请求将延迟。各个请求的交换（例如，命中或读取）不会延迟，但是它们确实有助于测量交换率，并且由于它们与交换请求位于同一FIFO队列中，因此如果max-swap-rate较小，它们可能会等待更长的时间。这在缓冲 “太多” 写入然后在将这些写入提交到磁盘的同时开始阻止Squid和其他进程的文件系统上是必需的。通常与swap-timeout一起使用，以避免在磁盘需求超出可用磁盘“带宽”时出现过多的延迟和队列溢出。默认情况下，当设置为零时，禁用磁盘I / O速率限制实施。当前只有 IpcIo 模式支持。</p><p>参数 slot-size = bytes<br>    用于存储缓存的响应的数据库 “记录” 的大小。一个已经被缓存的请求内容至少占用一个slot，并且所有数据库I/O 均使用单独的 slot 完成，因此增加此参数会导致更多的磁盘空间浪费，而减少则导致更多的磁盘I/O开销。应该设置为操作系统I/O页面大小的倍数。默认为16KB。每个slot均存储一个header，较小尺寸的slot将被拒绝。header 小于100个字节。</p><h1 id="二、源码研究"><a href="#二、源码研究" class="headerlink" title="二、源码研究"></a>二、源码研究</h1><h2 id="代码理解关键点："><a href="#代码理解关键点：" class="headerlink" title="代码理解关键点："></a>代码理解关键点：</h2><p><em>SwapDir</em> 的定义是通过在src/store/forword.h 中的 typedef Store::Disk SwapDir 来定义的，实际上是Store命名空间中的Disk类</p><p>StoreController 的定义是通过在src/store/forword.h 中的 typedef Store::Controller StoreController来定义的，实际上是Store命名空间中的Controller 类</p><p>StoreHashIndex 的定义是通过在src/store/forword.h 中的 typedef Store::Disks StoreHashIndex;来定义的，实际是Store命名空间中的Disks 类</p><p>SwapDirPointer 的定义是通过在src/store/forword.h 中的 typedef RefCount&lt;Store::Disk&gt; SwapDirPointer来定义的，实际是Store命名空间中的Disks 类</p><p>UFSSwapLogParser  swap log解析器, 通过cc文件中继承实现了不同版本解析器来解析对应的swap log</p>]]></content>
    
    
    <categories>
      
      <category>高性能代理软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>squid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pstack 跟踪进程栈</title>
    <link href="/2020/08/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/03pstack%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E6%A0%88/"/>
    <url>/2020/08/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/03pstack%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>此命令可显示每个进程的栈跟踪,且可显示每个线程的栈状态。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。请参见 proc(1) 手册页。</p><p>这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；</p><p>示例：查看bash程序进程栈:</p><figure class="highlight less"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[root@xxxxx ]</span># <span class="hljs-selector-tag">pstack</span> <span class="hljs-selector-tag">16185</span><br><span class="hljs-selector-tag">Thread</span> <span class="hljs-selector-tag">35</span> (Thread <span class="hljs-number">0</span>x7f098b51e700 (LWP <span class="hljs-number">16186</span>)):<br><span class="hljs-selector-id">#0</span>  <span class="hljs-selector-tag">0x00007f09931657fa</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">sigwaitinfo</span> () <span class="hljs-selector-tag">from</span> /<span class="hljs-selector-tag">usr</span>/<span class="hljs-selector-tag">lib64</span>/<span class="hljs-selector-tag">libc</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.6</span><br><span class="hljs-selector-id">#1</span>  <span class="hljs-selector-tag">0x0000000000f0f2db</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">timer_notify_thread_func</span> (arg=arg<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7ffc2e5b8af0) <span class="hljs-selector-tag">at</span> /<span class="hljs-selector-tag">export</span>/<span class="hljs-selector-tag">home2</span>/<span class="hljs-selector-tag">pb2</span>/<span class="hljs-selector-tag">build</span>/<span class="hljs-selector-tag">sb_1-32013917-1545390379</span><span class="hljs-selector-class">.14</span>/<span class="hljs-selector-tag">rpm</span>/<span class="hljs-selector-tag">BUILD</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysys</span>/<span class="hljs-selector-tag">posix_timers</span><span class="hljs-selector-class">.c</span>:<span class="hljs-selector-tag">77</span><br><span class="hljs-selector-id">#2</span>  <span class="hljs-selector-tag">0x000000000127fae4</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">pfs_spawn_thread</span> (arg=<span class="hljs-number">0</span>x2fb02b0) <span class="hljs-selector-tag">at</span> /<span class="hljs-selector-tag">export</span>/<span class="hljs-selector-tag">home2</span>/<span class="hljs-selector-tag">pb2</span>/<span class="hljs-selector-tag">build</span>/<span class="hljs-selector-tag">sb_1-32013917-1545390379</span><span class="hljs-selector-class">.14</span>/<span class="hljs-selector-tag">rpm</span>/<span class="hljs-selector-tag">BUILD</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">storage</span>/<span class="hljs-selector-tag">perfschema</span>/<span class="hljs-selector-tag">pfs</span><span class="hljs-selector-class">.cc</span>:<span class="hljs-selector-tag">2190</span><br><span class="hljs-selector-id">#3</span>  <span class="hljs-selector-tag">0x00007f0994767dc5</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">start_thread</span> () <span class="hljs-selector-tag">from</span> /<span class="hljs-selector-tag">usr</span>/<span class="hljs-selector-tag">lib64</span>/<span class="hljs-selector-tag">libpthread</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.0</span><br><span class="hljs-selector-id">#4</span>  <span class="hljs-selector-tag">0x00007f099322528d</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">clone</span> () <span class="hljs-selector-tag">from</span> /<span class="hljs-selector-tag">usr</span>/<span class="hljs-selector-tag">lib64</span>/<span class="hljs-selector-tag">libc</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.6</span><br><span class="hljs-selector-tag">Thread</span> <span class="hljs-selector-tag">34</span> (Thread <span class="hljs-number">0</span>x7f097d529700 (LWP <span class="hljs-number">16187</span>)):<br><span class="hljs-selector-id">#0</span>  <span class="hljs-selector-tag">0x00007f099455e644</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">__io_getevents_0_4</span> () <span class="hljs-selector-tag">from</span> /<span class="hljs-selector-tag">usr</span>/<span class="hljs-selector-tag">lib64</span>/<span class="hljs-selector-tag">libaio</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.1</span><br><span class="hljs-selector-id">#1</span>  <span class="hljs-selector-tag">0x0000000000fca3d1</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">LinuxAIOHandler</span>::<span class="hljs-selector-tag">collect</span> (this=this<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7f097d528de0) <span class="hljs-selector-tag">at</span> /<span class="hljs-selector-tag">export</span>/<span class="hljs-selector-tag">home2</span>/<span class="hljs-selector-tag">pb2</span>/<span class="hljs-selector-tag">build</span>/<span class="hljs-selector-tag">sb_1-32013917-1545390379</span><span class="hljs-selector-class">.14</span>/<span class="hljs-selector-tag">rpm</span>/<span class="hljs-selector-tag">BUILD</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">storage</span>/<span class="hljs-selector-tag">innobase</span>/<span class="hljs-selector-tag">os</span>/<span class="hljs-selector-tag">os0file</span><span class="hljs-selector-class">.cc</span>:<span class="hljs-selector-tag">2506</span><br><span class="hljs-selector-id">#2</span>  <span class="hljs-selector-tag">0x0000000000fcadfd</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">LinuxAIOHandler</span>::<span class="hljs-selector-tag">poll</span> (this=this<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7f097d528de0, m1=m1<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7f097d528e80, m2=m2<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7f097d528e88, request=request<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7f097d528e90) <span class="hljs-selector-tag">at</span> /<span class="hljs-selector-tag">export</span>/<span class="hljs-selector-tag">home2</span>/<span class="hljs-selector-tag">pb2</span>/<span class="hljs-selector-tag">build</span>/<span class="hljs-selector-tag">sb_1-32013917-1545390379</span><span class="hljs-selector-class">.14</span>/<span class="hljs-selector-tag">rpm</span>/<span class="hljs-selector-tag">BUILD</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">storage</span>/<span class="hljs-selector-tag">innobase</span>/<span class="hljs-selector-tag">os</span>/<span class="hljs-selector-tag">os0file</span><span class="hljs-selector-class">.cc</span>:<span class="hljs-selector-tag">2652</span><br><span class="hljs-selector-id">#3</span>  <span class="hljs-selector-tag">0x0000000000fcd436</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">os_aio_linux_handler</span> (request=<span class="hljs-number">0</span>x7f097d528e90, m2=<span class="hljs-number">0</span>x7f097d528e88, m1=<span class="hljs-number">0</span>x7f097d528e80, global_segment=<span class="hljs-number">0</span>) <span class="hljs-selector-tag">at</span> /<span class="hljs-selector-tag">export</span>/<span class="hljs-selector-tag">home2</span>/<span class="hljs-selector-tag">pb2</span>/<span class="hljs-selector-tag">build</span>/<span class="hljs-selector-tag">sb_1-32013917-1545390379</span><span class="hljs-selector-class">.14</span>/<span class="hljs-selector-tag">rpm</span>/<span class="hljs-selector-tag">BUILD</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">storage</span>/<span class="hljs-selector-tag">innobase</span>/<span class="hljs-selector-tag">os</span>/<span class="hljs-selector-tag">os0file</span><span class="hljs-selector-class">.cc</span>:<span class="hljs-selector-tag">2708</span><br><span class="hljs-selector-id">#4</span>  <span class="hljs-selector-tag">os_aio_handler</span> (segment=segment<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>, m1=m1<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7f097d528e80, m2=m2<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7f097d528e88, request=request<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>x7f097d528e90) <span class="hljs-selector-tag">at</span> /<span class="hljs-selector-tag">export</span>/<span class="hljs-selector-tag">home2</span>/<span class="hljs-selector-tag">pb2</span>/<span class="hljs-selector-tag">build</span>/<span class="hljs-selector-tag">sb_1-32013917-1545390379</span><span class="hljs-selector-class">.14</span>/<span class="hljs-selector-tag">rpm</span>/<span class="hljs-selector-tag">BUILD</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">storage</span>/<span class="hljs-selector-tag">innobase</span>/<span class="hljs-selector-tag">os</span>/<span class="hljs-selector-tag">os0file</span><span class="hljs-selector-class">.cc</span>:<span class="hljs-selector-tag">6254</span><br><span class="hljs-selector-id">#5</span>  <span class="hljs-selector-tag">0x0000000001197d5f</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">fil_aio_wait</span> (segment=segment<span class="hljs-variable">@entry</span>=<span class="hljs-number">0</span>) <span class="hljs-selector-tag">at</span> /<span class="hljs-selector-tag">export</span>/<span class="hljs-selector-tag">home2</span>/<span class="hljs-selector-tag">pb2</span>/<span class="hljs-selector-tag">build</span>/<span class="hljs-selector-tag">sb_1-32013917-1545390379</span><span class="hljs-selector-class">.14</span>/<span class="hljs-selector-tag">rpm</span>/<span class="hljs-selector-tag">BUILD</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">storage</span>/<span class="hljs-selector-tag">innobase</span>/<span class="hljs-selector-tag">fil</span>/<span class="hljs-selector-tag">fil0fil</span><span class="hljs-selector-class">.cc</span>:<span class="hljs-selector-tag">5854</span><br><span class="hljs-selector-id">#6</span>  <span class="hljs-selector-tag">0x0000000001080458</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">io_handler_thread</span> (arg=&lt;optimized out&gt;) <span class="hljs-selector-tag">at</span> /<span class="hljs-selector-tag">export</span>/<span class="hljs-selector-tag">home2</span>/<span class="hljs-selector-tag">pb2</span>/<span class="hljs-selector-tag">build</span>/<span class="hljs-selector-tag">sb_1-32013917-1545390379</span><span class="hljs-selector-class">.14</span>/<span class="hljs-selector-tag">rpm</span>/<span class="hljs-selector-tag">BUILD</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">mysql-5</span><span class="hljs-selector-class">.7</span><span class="hljs-selector-class">.25</span>/<span class="hljs-selector-tag">storage</span>/<span class="hljs-selector-tag">innobase</span>/<span class="hljs-selector-tag">srv</span>/<span class="hljs-selector-tag">srv0start</span><span class="hljs-selector-class">.cc</span>:<span class="hljs-selector-tag">311</span><br><span class="hljs-selector-id">#7</span>  <span class="hljs-selector-tag">0x00007f0994767dc5</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">start_thread</span> () <span class="hljs-selector-tag">from</span> /<span class="hljs-selector-tag">usr</span>/<span class="hljs-selector-tag">lib64</span>/<span class="hljs-selector-tag">libpthread</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.0</span><br><span class="hljs-selector-id">#8</span>  <span class="hljs-selector-tag">0x00007f099322528d</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">clone</span> () <span class="hljs-selector-tag">from</span> /<span class="hljs-selector-tag">usr</span>/<span class="hljs-selector-tag">lib64</span>/<span class="hljs-selector-tag">libc</span><span class="hljs-selector-class">.so</span><span class="hljs-selector-class">.6</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>strace 跟踪进程中的系统调用</title>
    <link href="/2020/08/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/06strace%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <url>/2020/08/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/06strace%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p><h1 id="1-输出参数含义"><a href="#1-输出参数含义" class="headerlink" title="1. 输出参数含义"></a>1. 输出参数含义</h1><p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$strace</span> cat /dev/null<br><span class="hljs-function"><span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-string">&quot;/bin/cat&quot;</span>, [<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;/dev/null&quot;</span>], [/* <span class="hljs-number">22</span> vars */])</span></span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">brk</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>                                  = <span class="hljs-number">0</span>xab1000<br><span class="hljs-function"><span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK)</span></span>      = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<br><span class="hljs-function"><span class="hljs-title">mmap</span><span class="hljs-params">(NULL, <span class="hljs-number">8192</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>x7f29379a7000<br><span class="hljs-function"><span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)</span></span>      = -<span class="hljs-number">1</span> ENOENT (No such file or directory)<br>...<br></code></pre></td></tr></table></figure><h1 id="2-参数"><a href="#2-参数" class="headerlink" title="2. 参数"></a>2. 参数</h1><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs mercury">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.<br>-d 输出strace关于标准错误的调试信息.<br>-f 跟踪由fork调用所产生的子进程.<br>-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.<br>-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.<br>-h 输出简要的帮助信息.<br>-i 输出系统调用的入口指针.<br>-q 禁止输出关于脱离的消息.<br>-r 打印出相对时间关于,,每一个系统调用.<br>-t 在输出中的每一行前加上时间信息.<br>-tt 在输出中的每一行前加上时间信息,微秒级.<br>-ttt 微秒级输出,以秒了表示时间.<br>-T 显示每一调用所耗的时间.<br>-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.<br>-V 输出strace的版本信息.<br>-x 以十六进制形式输出非标准字符串<br>-xx 所有字符串以十六进制形式输出.<br>-a column<br>设置返回值的输出位置.默认 为<span class="hljs-number">40</span>.<br>-e expr<br>指定一个表达式,用来控制如何跟踪.格式如下:<br>[qualifier<span class="hljs-built_in">=</span>][!]value1[,value2]...<br>qualifier只能是 <span class="hljs-keyword">trace</span>,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 <span class="hljs-keyword">trace</span>.感叹号是否定符号.例如:<br>-eopen等价于 -e <span class="hljs-keyword">trace</span><span class="hljs-built_in">=</span>open,表示只跟踪open调用.而-etrace!<span class="hljs-built_in">=</span>open表示跟踪除了open以外的其他调用.有两个特殊的符号 <span class="hljs-built_in">all</span> 和 none.<br>注意有些shell使用!来执行历史记录里的命令,所以要使用\\.<br>-e <span class="hljs-keyword">trace</span><span class="hljs-built_in">=</span>set<br>只跟踪指定的系统 调用.例如:-e <span class="hljs-keyword">trace</span><span class="hljs-built_in">=</span>open,close,rean,write表示只跟踪这四个系统调用.默认的为set<span class="hljs-built_in">=</span><span class="hljs-built_in">all</span>.<br>-e <span class="hljs-keyword">trace</span><span class="hljs-built_in">=</span>file<br>只跟踪有关文件操作的系统调用.<br>-e <span class="hljs-keyword">trace</span><span class="hljs-built_in">=</span>process<br>只跟踪有关进程控制的系统调用.<br>-e <span class="hljs-keyword">trace</span><span class="hljs-built_in">=</span>network<br>跟踪与网络有关的所有系统调用.<br>-e strace<span class="hljs-built_in">=</span>signal<br>跟踪所有与系统信号有关的 系统调用<br>-e <span class="hljs-keyword">trace</span><span class="hljs-built_in">=</span>ipc<br>跟踪所有与进程通讯有关的系统调用<br>-e abbrev<span class="hljs-built_in">=</span>set<br>设定 strace输出的系统调用的结果集.-v 等与 abbrev<span class="hljs-built_in">=</span>none.默认为abbrev<span class="hljs-built_in">=</span><span class="hljs-built_in">all</span>.<br>-e raw<span class="hljs-built_in">=</span>set<br>将指 定的系统调用的参数以十六进制显示.<br>-e signal<span class="hljs-built_in">=</span>set<br>指定跟踪的系统信号.默认为<span class="hljs-built_in">all</span>.如 signal<span class="hljs-built_in">=</span>!SIGIO(或者signal<span class="hljs-built_in">=</span>!io),表示不跟踪SIGIO信号.<br>-e read<span class="hljs-built_in">=</span>set<br>输出从指定文件中读出 的数据.例如:<br>-e read<span class="hljs-built_in">=</span><span class="hljs-number">3</span>,<span class="hljs-number">5</span><br>-e write<span class="hljs-built_in">=</span>set<br>输出写入到指定文件中的数据.<br>-o filename<br>将strace的输出写入文件filename<br>-p pid<br>跟踪指定的进程pid.<br>-s strsize<br>指定输出的字符串的最大长度.默认为<span class="hljs-number">32</span>.文件名一直全部输出.<br>-u username<br>以username 的UID和GID执行被跟踪的命令<br></code></pre></td></tr></table></figure><h1 id="3-命令实例"><a href="#3-命令实例" class="headerlink" title="3. 命令实例"></a>3. 命令实例</h1><h2 id="3-1-跟踪可执行程序"><a href="#3-1-跟踪可执行程序" class="headerlink" title="3.1 跟踪可执行程序"></a>3.1 跟踪可执行程序</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">strace <span class="hljs-operator">-f</span> <span class="hljs-operator">-F</span> <span class="hljs-literal">-o</span> ~/straceout.txt myserver<br></code></pre></td></tr></table></figure><p>-f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p><h2 id="3-2-跟踪服务程序"><a href="#3-2-跟踪服务程序" class="headerlink" title="3.2 跟踪服务程序"></a>3.2 跟踪服务程序</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">strace</span> -o output.txt -T -tt -e trace=<span class="hljs-literal">all</span> -p <span class="hljs-number">28979</span><br></code></pre></td></tr></table></figure><p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lsof 一切皆文件</title>
    <link href="/2020/08/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/04lsof%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6/"/>
    <url>/2020/08/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/04lsof%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</p><p>lsof打开的文件可以是：</p><ol><li>普通文件</li><li>目录</li><li>网络文件系统的文件</li><li>字符或设备文件</li><li>(函数)共享库</li><li>管道，命名管道</li><li>符号链接</li><li>网络文件（例如：NFS file、网络socket，unix域名socket）</li><li>还有其它类型的文件，等等</li></ol><h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><ul><li>-a 列出打开文件存在的进程</li><li>-c&lt;进程名&gt; 列出指定进程所打开的文件</li><li>-g 列出GID号进程详情</li><li>-d&lt;文件号&gt; 列出占用该文件号的进程</li><li>+d&lt;目录&gt; 列出目录下被打开的文件</li><li>+D&lt;目录&gt; 递归列出目录下被打开的文件</li><li>-n&lt;目录&gt; 列出使用NFS的文件</li><li>-i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）</li><li>-p&lt;进程号&gt; 列出指定进程号所打开的文件</li><li>-u 列出UID号进程详情</li><li>-h 显示帮助信息</li><li>-v 显示版本信息</li></ul><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="1：无任何参数"><a href="#1：无任何参数" class="headerlink" title="1：无任何参数"></a>1：无任何参数</h2><figure class="highlight tap"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs tap">$lsof| more<br>COMMAND     PID      USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME<br>init         <span class="hljs-number"> 1 </span>     root  cwd       DIR              253,0    <span class="hljs-number"> 4096 </span>        <span class="hljs-number"> 2 </span>/<br>init         <span class="hljs-number"> 1 </span>     root  rtd       DIR              253,0    <span class="hljs-number"> 4096 </span>        <span class="hljs-number"> 2 </span>/<br>init         <span class="hljs-number"> 1 </span>     root  txt       REG              253,0  <span class="hljs-number"> 150352 </span>  <span class="hljs-number"> 1310795 </span>/sbin/init<br></code></pre></td></tr></table></figure><p>说明：</p><p>lsof输出各列信息的意义如下：</p><ul><li>COMMAND：进程的名称</li><li>PID：进程标识符</li><li>PPID：父进程标识符（需要指定-R参数）</li><li>USER：进程所有者</li><li>PGID：进程所属组</li><li>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等::<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">（<span class="hljs-number">1</span>）cwd：表示<span class="hljs-keyword">current</span> <span class="hljs-keyword">work</span> dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改<br>   （<span class="hljs-number">2</span>）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序<br>   （<span class="hljs-number">3</span>）lnn：library <span class="hljs-keyword">references</span> (AIX);<br>   （<span class="hljs-number">4</span>）er：FD information error (see <span class="hljs-type">NAME</span> <span class="hljs-keyword">column</span>);<br>   （<span class="hljs-number">5</span>）jld：jail directory (FreeBSD);<br>   （<span class="hljs-number">6</span>）ltx：shared library text (code <span class="hljs-keyword">and</span> data);<br>   （<span class="hljs-number">7</span>）mxx ：hex memory-mapped <span class="hljs-keyword">type</span> number xx.<br>   （<span class="hljs-number">8</span>）m86：DOS Merge mapped file;<br>   （<span class="hljs-number">9</span>）mem：memory-mapped file;<br>   （<span class="hljs-number">10</span>）mmap：memory-mapped device;<br>   （<span class="hljs-number">11</span>）pd：parent directory;<br>   （<span class="hljs-number">12</span>）rtd：root directory;<br>   （<span class="hljs-number">13</span>）tr：kernel trace file (OpenBSD);<br>   （<span class="hljs-number">14</span>）v86  VP/ix mapped file;<br>   （<span class="hljs-number">15</span>）<span class="hljs-number">0</span>：表示标准输入<br>   （<span class="hljs-number">16</span>）<span class="hljs-number">1</span>：表示标准输出<br>   （<span class="hljs-number">17</span>）<span class="hljs-number">2</span>：表示标准错误<br>   一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等<br>   （<span class="hljs-number">1</span>）u：表示该文件被打开并处于读取/写入模式<br>   （<span class="hljs-number">2</span>）r：表示该文件被打开并处于只读模式<br>   （<span class="hljs-number">3</span>）w：表示该文件被打开并处于<br>   （<span class="hljs-number">4</span>）空格：表示该文件的状态模式为unknow，且没有锁定<br>   （<span class="hljs-number">5</span>）-：表示该文件的状态模式为unknow，且被锁定<br>   同时在文件状态模式后面，还跟着相关的锁<br>   （<span class="hljs-number">1</span>）N：<span class="hljs-keyword">for</span> a Solaris NFS <span class="hljs-keyword">lock</span> <span class="hljs-keyword">of</span> <span class="hljs-type">unknown</span> <span class="hljs-keyword">type</span>;<br>   （<span class="hljs-number">2</span>）r：<span class="hljs-keyword">for</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">on</span> part <span class="hljs-keyword">of</span> the file;<br>   （<span class="hljs-number">3</span>）R：<span class="hljs-keyword">for</span> a <span class="hljs-keyword">read</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">on</span> the entire file;<br>   （<span class="hljs-number">4</span>）w：<span class="hljs-keyword">for</span> a <span class="hljs-keyword">write</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">on</span> part <span class="hljs-keyword">of</span> the file;（文件的部分写锁）<br>   （<span class="hljs-number">5</span>）W：<span class="hljs-keyword">for</span> a <span class="hljs-keyword">write</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">on</span> the entire file;（整个文件的写锁）<br>   （<span class="hljs-number">6</span>）u：<span class="hljs-keyword">for</span> a <span class="hljs-keyword">read</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">write</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">any</span> length;<br>   （<span class="hljs-number">7</span>）U：<span class="hljs-keyword">for</span> a <span class="hljs-keyword">lock</span> <span class="hljs-keyword">of</span> <span class="hljs-type">unknown</span> <span class="hljs-keyword">type</span>;<br>   （<span class="hljs-number">8</span>）x：<span class="hljs-keyword">for</span> an SCO OpenServer Xenix <span class="hljs-keyword">lock</span> <span class="hljs-keyword">on</span> part      <span class="hljs-keyword">of</span> the file;<br>   （<span class="hljs-number">9</span>）X：<span class="hljs-keyword">for</span> an SCO OpenServer Xenix <span class="hljs-keyword">lock</span> <span class="hljs-keyword">on</span> the      entire file;<br>   （<span class="hljs-number">10</span>）space：<span class="hljs-keyword">if</span> there <span class="hljs-keyword">is</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">lock</span>.<br></code></pre></td></tr></table></figure></li><li>TYPE：文件类型，如DIR、REG等，常见的文件类型::<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less">（<span class="hljs-selector-tag">1</span>）<span class="hljs-selector-tag">DIR</span>：表示目录<br>（<span class="hljs-selector-tag">2</span>）<span class="hljs-selector-tag">CHR</span>：表示字符类型<br>（<span class="hljs-selector-tag">3</span>）<span class="hljs-selector-tag">BLK</span>：块设备类型<br>（<span class="hljs-selector-tag">4</span>）<span class="hljs-selector-tag">UNIX</span>： <span class="hljs-selector-tag">UNIX</span> 域套接字<br>（<span class="hljs-selector-tag">5</span>）<span class="hljs-selector-tag">FIFO</span>：先进先出 (FIFO) 队列<br>（<span class="hljs-selector-tag">6</span>）<span class="hljs-selector-tag">IPv4</span>：网际协议 (IP) 套接字<br></code></pre></td></tr></table></figure></li><li>DEVICE：指定磁盘的名称</li><li>SIZE：文件的大小</li><li>NODE：索引节点（文件在磁盘上的标识）</li><li>NAME：打开文件的确切名称</li></ul><h2 id="2：查找某个文件相关的进程"><a href="#2：查找某个文件相关的进程" class="headerlink" title="2：查找某个文件相关的进程"></a>2：查找某个文件相关的进程</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$lsof</span> <span class="hljs-regexp">/bin/</span>bash<br>COMMAND     PID USER  FD   TYPE DEVICE SIZE/OFF    NODE NAME<br>mysqld_sa  <span class="hljs-number">2169</span> root txt    REG  <span class="hljs-number">253</span>,<span class="hljs-number">0</span>   <span class="hljs-number">938736</span> <span class="hljs-number">4587562</span> <span class="hljs-regexp">/bin/</span>bash<br>ksmtuned   <span class="hljs-number">2334</span> root txt    REG  <span class="hljs-number">253</span>,<span class="hljs-number">0</span>   <span class="hljs-number">938736</span> <span class="hljs-number">4587562</span> <span class="hljs-regexp">/bin/</span>bash<br>bash      <span class="hljs-number">20121</span> root txt    REG  <span class="hljs-number">253</span>,<span class="hljs-number">0</span>   <span class="hljs-number">938736</span> <span class="hljs-number">4587562</span> <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h2 id="3：列出某个用户打开的文件信息"><a href="#3：列出某个用户打开的文件信息" class="headerlink" title="3：列出某个用户打开的文件信息"></a>3：列出某个用户打开的文件信息</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$lsof</span> -u username</span><br></code></pre></td></tr></table></figure><p> -u 选项，u是user的缩写</p><h2 id="4：列出某个程序进程所打开的文件信息"><a href="#4：列出某个程序进程所打开的文件信息" class="headerlink" title="4：列出某个程序进程所打开的文件信息"></a>4：列出某个程序进程所打开的文件信息</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$lsof</span> -c mysql</span><br></code></pre></td></tr></table></figure><p>-c 选项将会列出所有以mysql这个进程开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符；</p><h2 id="5：列出某个用户以及某个进程所打开的文件信息"><a href="#5：列出某个用户以及某个进程所打开的文件信息" class="headerlink" title="5：列出某个用户以及某个进程所打开的文件信息"></a>5：列出某个用户以及某个进程所打开的文件信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$lsof</span>  -u <span class="hljs-built_in">test</span> -c mysql<br></code></pre></td></tr></table></figure><h2 id="6：通过某个进程号显示该进程打开的文件"><a href="#6：通过某个进程号显示该进程打开的文件" class="headerlink" title="6：通过某个进程号显示该进程打开的文件"></a>6：通过某个进程号显示该进程打开的文件</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$lsof</span> -p 11968</span><br></code></pre></td></tr></table></figure><h2 id="7：列出所有的网络连接"><a href="#7：列出所有的网络连接" class="headerlink" title="7：列出所有的网络连接"></a>7：列出所有的网络连接</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$lsof</span> -i</span><br></code></pre></td></tr></table></figure><h2 id="8：列出所有tcp-网络连接信息"><a href="#8：列出所有tcp-网络连接信息" class="headerlink" title="8：列出所有tcp 网络连接信息"></a>8：列出所有tcp 网络连接信息</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$lsof -i tcp<br><br>$lsof -n -i tcp<br>COMMAND     PID  <span class="hljs-keyword">USER</span>   <span class="hljs-title">FD</span>   <span class="hljs-keyword">TYPE</span>  DEVICE SIZE/OFF <span class="hljs-keyword">NODE</span> <span class="hljs-title">NAME</span><br>svnserve  <span class="hljs-number">11552</span> weber    <span class="hljs-number">3</span>u  IPv4 <span class="hljs-number">3799399</span>      <span class="hljs-number">0</span>t0  TCP *:svn (LISTEN)<br>redis-ser <span class="hljs-number">25501</span> weber    <span class="hljs-number">4</span>u  IPv4  <span class="hljs-number">113150</span>      <span class="hljs-number">0</span>t0  TCP <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span> (LISTEN)<br></code></pre></td></tr></table></figure><h2 id="9：列出谁在使用某个端口"><a href="#9：列出谁在使用某个端口" class="headerlink" title="9：列出谁在使用某个端口"></a>9：列出谁在使用某个端口</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$lsof</span> -i :3306</span><br></code></pre></td></tr></table></figure><h2 id="10：列出某个用户的所有活跃的网络端口"><a href="#10：列出某个用户的所有活跃的网络端口" class="headerlink" title="10：列出某个用户的所有活跃的网络端口"></a>10：列出某个用户的所有活跃的网络端口</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$lsof</span> -a -u <span class="hljs-built_in">test</span> -i<br></code></pre></td></tr></table></figure><h2 id="11：根据文件描述列出对应的文件信息"><a href="#11：根据文件描述列出对应的文件信息" class="headerlink" title="11：根据文件描述列出对应的文件信息"></a>11：根据文件描述列出对应的文件信息</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$lsof</span> -d description(like 2)</span><br></code></pre></td></tr></table></figure><p>示例::</p><div class="code-wrapper"><pre><code class="hljs">$lsof -d 3 | grep PARSER1tail      6499 tde    3r   REG    253,3   4514722     417798 /opt/applog/open/log/HOSTPARSER1_ERROR_141217.log.001</code></pre></div><p>说明：<br>0表示标准输入，1表示标准输出，2表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始</p><h2 id="12：列出被进程号为1234的进程所打开的所有IPV4-network-files"><a href="#12：列出被进程号为1234的进程所打开的所有IPV4-network-files" class="headerlink" title="12：列出被进程号为1234的进程所打开的所有IPV4 network files"></a>12：列出被进程号为1234的进程所打开的所有IPV4 network files</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$lsof</span> -<span class="hljs-selector-tag">i</span> <span class="hljs-number">4</span> -<span class="hljs-selector-tag">a</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h2 id="13：列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行"><a href="#13：列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行" class="headerlink" title="13：列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行"></a>13：列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">lsof</span> -i @nf<span class="hljs-number">5260</span>i<span class="hljs-number">5</span>-td:<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">80</span> -r <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00 objdump 二进制文件分析</title>
    <link href="/2020/08/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/00objdump%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/20/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/00objdump%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>objdump工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。</p><h1 id="1-常用参数说明"><a href="#1-常用参数说明" class="headerlink" title="1. 常用参数说明"></a>1. 常用参数说明</h1><p>-f 显示文件头信息<br>-D 反汇编所有section (-d反汇编特定section)<br>-h 显示目标文件各个section的头部摘要信息<br>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。<br>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。<br>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。<br>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。<br>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。<br>-t 显示文件的符号表入口。类似于nm -s提供的信息</p><h1 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h1><h2 id="2-1-查看本机目标结构（使用大端还是小端存储）"><a href="#2-1-查看本机目标结构（使用大端还是小端存储）" class="headerlink" title="2.1 查看本机目标结构（使用大端还是小端存储）:"></a>2.1 查看本机目标结构（使用大端还是小端存储）:</h2><figure class="highlight gams"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$objdump</span> -i</span><br></code></pre></td></tr></table></figure><h2 id="2-2-反汇编程序"><a href="#2-2-反汇编程序" class="headerlink" title="2.2 反汇编程序:"></a>2.2 反汇编程序:</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$objdump</span> -d main.o</span><br></code></pre></td></tr></table></figure><h2 id="2-3-显示符号表入口"><a href="#2-3-显示符号表入口" class="headerlink" title="2.3 显示符号表入口:"></a>2.3 显示符号表入口:</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$objdump</span>  -t main.o</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>tools,linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(转载)C++ 内存分配(new，operator new)详解</title>
    <link href="/2020/08/16/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/00c++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/08/16/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/00c++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>本文转载自《<a href="https://blog.csdn.net/WUDAIJUN/article/details/9273339%E3%80%8B">https://blog.csdn.net/WUDAIJUN/article/details/9273339》</a></p><p>本文主要讲述C++ new关键字和operator new, placement new之间的种种关联，new的底层实现，以及operator new的重载和一些在内存池，STL中的应用。</p><h1 id="一-new-operator-和-operator-new"><a href="#一-new-operator-和-operator-new" class="headerlink" title="一. new operator 和 operator new"></a>一. new operator 和 operator new</h1><p>new operator：指我们在C++里通常用到的关键字，比如A* a = new A;<br>operator new：它是一个操作符，并且可被重载(类似加减乘除的操作符重载)<br>关于这两者的关系，我找到一段比较经典的描述（来自于<a href="http://www.cplusplus.com/">www.cplusplus.com</a> 见参考文献：</p><p><code> operator new can be called explicitly as a regular function, but in C++, new is an operator with a very specific behavior: An expression with the new operator, first calls function operator new (i.e., this function) with the size of its type specifier as first argument, and if this is successful, it then automatically initializes or constructs the object (if needed). Finally, the expression evaluates as a pointer to the appropriate type.</code></p><p>比如我们写如下代码：</p><figure class="highlight dns"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs dns"><span class="hljs-keyword">A</span>* a = new <span class="hljs-keyword">A</span>；<br></code></pre></td></tr></table></figure><p>我们知道这里分为三步：1.分配内存，2.调用A()构造对象，3. 返回分配指针。事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，否则调用全局::operator new(size_t )，后者由C++默认提供。因此前面的步骤也就是：</p><p>调用operator new (sizeof(A))<br>调用A:A()<br>返回指针<br>这里再一次提出来是因为后面关于这两步会有一些变形，在关于placement new那里会讲到。先举个简单例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">A</span>()&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;call A constructor&quot;</span>&lt;&lt;std::endl;<br>     &#125;<br> <br>     ~<span class="hljs-built_in">A</span>()&#123;<br>          std::cout&lt;&lt;<span class="hljs-string">&quot;call A destructor&quot;</span>&lt;&lt;std::endl;<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> _tmain(<span class="hljs-keyword">int</span> argc, _TCHAR* argv[])<br>&#123;<br> <br>     A* a = <span class="hljs-keyword">new</span> A;<br>     <span class="hljs-keyword">delete</span> a;<br> <br>     <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们跟踪一下A反汇编代码，由于Debug版本反汇编跳转太多，因此此处通过Release版本在A* a = new A;处设断点反汇编：<br>在Release版本中，构造函数和析构函数都是直接展开的。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">A* a = new A<span class="hljs-comment">;</span><br><span class="hljs-number">01301022</span>  <span class="hljs-keyword">push</span>        <span class="hljs-number">1</span>    <span class="hljs-comment">;不含数据成员的类占用一字节空间，此处压入sizeof(A)</span><br><span class="hljs-number">01301024</span>  <span class="hljs-keyword">call</span>        operator new (<span class="hljs-number">13013C2h</span>) <span class="hljs-comment">;调用operator new(size_t size)</span><br><span class="hljs-number">01301029</span>  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">eax</span> <span class="hljs-comment">;返回值保存到esi</span><br>0130102B  <span class="hljs-keyword">add</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">4</span> <span class="hljs-comment">;平衡栈</span><br>0130102E  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">8</span>],<span class="hljs-built_in">esi</span> <span class="hljs-comment">;</span><br><span class="hljs-number">01301032</span>  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">14h</span>],<span class="hljs-number">0</span> <br>0130103A  <span class="hljs-keyword">test</span>        <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">esi</span> <span class="hljs-comment">;在operator new之后，检查其返回值，如果为空(分配失败)，则不调用A()构造函数</span><br>0130103C  <span class="hljs-keyword">je</span>          wmain+<span class="hljs-number">62h</span> (<span class="hljs-number">1301062h</span>) <span class="hljs-comment">;为空 跳过构造函数部分</span><br>0130103E  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [__imp_std::endl (<span class="hljs-number">1302038h</span>)] <span class="hljs-comment">;构造函数内部，输出字符串</span><br><span class="hljs-number">01301043</span>  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [__imp_std::cout (<span class="hljs-number">1302050h</span>)] <br><span class="hljs-number">01301049</span>  <span class="hljs-keyword">push</span>        <span class="hljs-built_in">eax</span>  <br>0130104A  <span class="hljs-keyword">push</span>        offset string <span class="hljs-string">&quot;call A constructor&quot;</span> (<span class="hljs-number">1302134h</span>) <br>0130104F  <span class="hljs-keyword">push</span>        <span class="hljs-built_in">ecx</span>  <br><span class="hljs-number">01301050</span>  <span class="hljs-keyword">call</span>        <span class="hljs-keyword">std</span>::operator&lt;&lt;&lt;<span class="hljs-keyword">std</span>::char_traits&lt;char&gt; &gt; (<span class="hljs-number">13011F0h</span>) <br><span class="hljs-number">01301055</span>  <span class="hljs-keyword">add</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">8</span> <br><span class="hljs-number">01301058</span>  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">eax</span> <br>0130105A  <span class="hljs-keyword">call</span>        <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [__imp_std::basic_ostream&lt;char,<span class="hljs-keyword">std</span>::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (<span class="hljs-number">1302040h</span>)] <br><span class="hljs-number">01301060</span>  <span class="hljs-keyword">jmp</span>         wmain+<span class="hljs-number">64h</span> (<span class="hljs-number">1301064h</span>) <span class="hljs-comment">;构造完成，跳过下一句</span><br><span class="hljs-number">01301062</span>  <span class="hljs-keyword">xor</span>         <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">esi</span> <span class="hljs-comment">;将esi置空，这里的esi即为new A的返回值</span><br><span class="hljs-number">01301064</span>  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">14h</span>],<span class="hljs-number">0FFFFFFFFh</span> <br>    delete a<span class="hljs-comment">;</span><br>0130106C  <span class="hljs-keyword">test</span>        <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">esi</span> <span class="hljs-comment">;检查a是否为空</span><br>0130106E  <span class="hljs-keyword">je</span>          wmain+<span class="hljs-number">9Bh</span> (<span class="hljs-number">130109Bh</span>) <span class="hljs-comment">;如果为空，跳过析构函数和operator delete</span><br><span class="hljs-number">01301070</span>  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">edx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [__imp_std::endl (<span class="hljs-number">1302038h</span>)] <span class="hljs-comment">;析构函数 输出字符串</span><br><span class="hljs-number">01301076</span>  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [__imp_std::cout (<span class="hljs-number">1302050h</span>)] <br>0130107B  <span class="hljs-keyword">push</span>        <span class="hljs-built_in">edx</span>  <br>0130107C  <span class="hljs-keyword">push</span>        offset string <span class="hljs-string">&quot;call A destructor&quot;</span> (<span class="hljs-number">1302148h</span>) <br><span class="hljs-number">01301081</span>  <span class="hljs-keyword">push</span>        <span class="hljs-built_in">eax</span>  <br><span class="hljs-number">01301082</span>  <span class="hljs-keyword">call</span>        <span class="hljs-keyword">std</span>::operator&lt;&lt;&lt;<span class="hljs-keyword">std</span>::char_traits&lt;char&gt; &gt; (<span class="hljs-number">13011F0h</span>) <br><span class="hljs-number">01301087</span>  <span class="hljs-keyword">add</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">8</span> <br>0130108A  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">eax</span> <br>0130108C  <span class="hljs-keyword">call</span>        <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [__imp_std::basic_ostream&lt;char,<span class="hljs-keyword">std</span>::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (<span class="hljs-number">1302040h</span>)] <br><span class="hljs-number">01301092</span>  <span class="hljs-keyword">push</span>        <span class="hljs-built_in">esi</span>  <span class="hljs-comment">;压入a </span><br><span class="hljs-number">01301093</span>  <span class="hljs-keyword">call</span>        operator delete (<span class="hljs-number">13013BCh</span>) <span class="hljs-comment">;调用operator delete </span><br><span class="hljs-number">01301098</span>  <span class="hljs-keyword">add</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><p>通过反汇编可以确认A* = new A的三个步骤，delete a类似<br>，包含了~A()和operator delete(a)两个步骤。</p><h1 id="二-operator-new的三种形式"><a href="#二-operator-new的三种形式" class="headerlink" title="二. operator new的三种形式"></a>二. operator new的三种形式</h1><p>operator new有三种形式：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">throwing</span> (<span class="hljs-number">1</span>)    <br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> size)</span> <span class="hljs-title">throw</span> <span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-built_in">nothrow</span> (<span class="hljs-number">2</span>) <br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> std::<span class="hljs-keyword">nothrow_t</span>&amp; nothrow_value)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">placement</span> (<span class="hljs-number">3</span>)   <br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>(1)(2)的区别仅是是否抛出异常，当分配失败时，前者会抛出bad_alloc异常，后者返回null，不会抛出异常。它们都分配一个固定大小的连续内存。</p><p>A* a = new A; //调用throwing(1)<br>A* a = new(std::nothrow) A; //调用nothrow(2)<br>(3)是<code>placement new</code>，它也是对<code>operator new</code>的一个重载，定义于#include <new>中，它多接收一个ptr参数，但它只是简单地返回ptr。其在new.h下的源代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __PLACEMENT_NEW_INLINE</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __PLACEMENT_NEW_INLINE</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> *__cdecl <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">void</span> *_P)</span></span><br><span class="hljs-function">        </span>&#123;<span class="hljs-keyword">return</span> (_P); &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span>     _MSC_VER &gt;= 1200</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __cdecl <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">void</span> *)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>那么它究竟有什么用呢？事实上，它可以实现在ptr所指地址上构建一个对象(通过调用其构造函数)，这在内存池技术上有广泛应用。<br>它的调用形式为：</p><p>new(p) A(); //也可用A(5)等有参构造函数<br>placement new本身只是返回指针p，new(p) A()调用placement new之后，还会在p上调用A:A()，这里的p可以是动态分配的内存，也可以是栈中缓冲，如char buf[100]; new(buf) A(); </p><p>我们仍然可以通过一个例子来验证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A constructor&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br> <br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A destructor&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> _tmain(<span class="hljs-keyword">int</span> argc, _TCHAR* argv[]) &#123;<br> <br>    A* p = (A*)::<span class="hljs-keyword">operator</span> <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A)); <span class="hljs-comment">//分配</span><br>    <span class="hljs-keyword">new</span>(p) <span class="hljs-built_in">A</span>(); <span class="hljs-comment">//构造</span><br>    p-&gt;~<span class="hljs-built_in">A</span>();   <span class="hljs-comment">//析构</span><br>    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>; <span class="hljs-comment">//释放</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码将对象的分配，构造，析构和释放分离开来，这也是new和delete关键字两句就能完成的操作。<br>先直接运行可以看到程序输出：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">call A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure><p>再分别注释掉new(a) A();和a-&gt;~A();两句，可以看到对应的构造和析构函数将不会被调用。</p><p>然后查看反汇编：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">//平台: Visual Studio <span class="hljs-number">2008</span> Debug版<br>    A* a = (A*)::operator new(sizeof(A))<span class="hljs-comment">; //分配</span><br>00F9151D  <span class="hljs-keyword">push</span>        <span class="hljs-number">1</span>    <br>00F9151F  <span class="hljs-keyword">call</span>        operator new (<span class="hljs-number">0F91208h</span>) <span class="hljs-comment">;调用::operator new(size_t size)也就是throwing(1)版本</span><br>00F91524  <span class="hljs-keyword">add</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">4</span> <br>00F91527  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">14h</span>],<span class="hljs-built_in">eax</span> <span class="hljs-comment">;返回地址放入[ebp-14h] 即为p</span><br> <br>    new(a) A()<span class="hljs-comment">; //构造</span><br>00F9152A  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">14h</span>] <br>00F9152D  <span class="hljs-keyword">push</span>        <span class="hljs-built_in">eax</span>  <br>00F9152E  <span class="hljs-keyword">push</span>        <span class="hljs-number">1</span>    <span class="hljs-comment">;压入p</span><br>00F91530  <span class="hljs-keyword">call</span>        operator new (<span class="hljs-number">0F91280h</span>)<span class="hljs-comment">;调用operator new(size_t, void* p)即placement(3)版本 只是简单返回p</span><br>00F91535  <span class="hljs-keyword">add</span>         <span class="hljs-built_in">esp</span>,<span class="hljs-number">8</span> <br>00F91538  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0E0h</span>],<span class="hljs-built_in">eax</span> <span class="hljs-comment">;将p放入[ebp-0E0h]</span><br>00F9153E  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-number">0</span> <br>00F91545  <span class="hljs-keyword">cmp</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0E0h</span>],<span class="hljs-number">0</span>   <span class="hljs-comment">;判断p是否为空</span><br>00F9154C  <span class="hljs-keyword">je</span>          wmain+<span class="hljs-number">81h</span> (<span class="hljs-number">0F91561h</span>)     <span class="hljs-comment">;如果为空 跳过构造函数</span><br>00F9154E  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0E0h</span>] <span class="hljs-comment">;取出p到ecx</span><br>00F91554  <span class="hljs-keyword">call</span>        A::A (<span class="hljs-number">0F91285h</span>)          <span class="hljs-comment">;调用构造函数 根据_thiscall调用约定 this指针通过ecx寄存器传递</span><br>00F91559  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0F4h</span>],<span class="hljs-built_in">eax</span> <span class="hljs-comment">;将返回值(this指针)放入[ebp-0F4h]中</span><br>00F9155F  <span class="hljs-keyword">jmp</span>         wmain+<span class="hljs-number">8Bh</span> (<span class="hljs-number">0F9156Bh</span>)     <span class="hljs-comment">;跳过下一句</span><br>00F91561  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0F4h</span>],<span class="hljs-number">0</span>   <span class="hljs-comment">;将[ebp-0F4h]置空 当前面判断p为空时执行此语句</span><br>00F9156B  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0F4h</span>] <span class="hljs-comment">;[ebp-0F4h]为最终构造完成后的this指针(或者为空) 放入ecx</span><br>00F91571  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0ECh</span>],<span class="hljs-built_in">ecx</span> <span class="hljs-comment">;又将this放入[ebp-0ECh] 这些都是调试所用</span><br>00F91577  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">4</span>],<span class="hljs-number">0FFFFFFFFh</span> <br> <br>    a-&gt;~A()<span class="hljs-comment">;   //析构</span><br>00F9157E  <span class="hljs-keyword">push</span>        <span class="hljs-number">0</span>    <br>00F91580  <span class="hljs-keyword">mov</span>         <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">14h</span>] <span class="hljs-comment">;从[ebp-14h]中取出p</span><br>00F91583  <span class="hljs-keyword">call</span>        A::<span class="hljs-string">`scalar deleting destructor&#x27; (0F91041h) ;调用析构函数(跟踪进去比较复杂 如果在Release下，构造析构函数都是直接展开的)</span><br><span class="hljs-string"> </span><br><span class="hljs-string">    ::operator delete(a); //释放</span><br><span class="hljs-string">00F91588  mov         eax,dword ptr [ebp-14h]   ;将p放入eax</span><br><span class="hljs-string">00F9158B  push        eax           ;压入p</span><br><span class="hljs-string">00F9158C  call        operator delete (0F910B9h);调用operator delete(void* )</span><br><span class="hljs-string">00F91591  add         esp,4</span><br></code></pre></td></tr></table></figure><p>从反汇编中可以看出，其实operator new调用了两次，只不过每一次调用不同的重载函数，并且placement new的主要作用只是将p放入ecx，并且调用其构造函数。<br>事实上，在指定地址上构造对象还有另一种方法，即手动调用构造函数：p-&gt;A::A(); 这里要加上A::作用域，用p-&gt;A::A();替换掉new(p) A();仍然能达到同样的效果，反汇编：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs delphi">    A* a = (A*)::<span class="hljs-keyword">operator</span> new(sizeof(A)); <span class="hljs-comment">//分配</span><br><span class="hljs-number">010614</span>FE  push        <span class="hljs-number">1</span>    <br><span class="hljs-number">01061500</span>  call        <span class="hljs-keyword">operator</span> new (<span class="hljs-number">1061208</span>h) <br><span class="hljs-number">01061505</span>  add         esp,<span class="hljs-number">4</span> <br><span class="hljs-number">01061508</span>  mov         dword ptr [a],eax <br>    <span class="hljs-comment">//new(a) A();   //构造</span><br>    a-&gt;A::A();<br><span class="hljs-number">0106150</span>B  mov         ecx,dword ptr [a] <br><span class="hljs-number">0106150</span>E  call        <span class="hljs-keyword">operator</span> new (<span class="hljs-number">1061285</span>h) <br> <br>    a-&gt;~A();   <span class="hljs-comment">//析构</span><br><span class="hljs-number">01061513</span>  push        <span class="hljs-number">0</span>    <br><span class="hljs-number">01061515</span>  mov         ecx,dword ptr [a] <br><span class="hljs-number">01061518</span>  call        A::`scalar deleting <span class="hljs-function"><span class="hljs-keyword">destructor</span>&#x27; <span class="hljs-params">(1061041h)</span> </span><br><span class="hljs-function"> </span><br><span class="hljs-function">    :</span>:<span class="hljs-keyword">operator</span> delete(a); <span class="hljs-comment">//释放</span><br><span class="hljs-number">0106151</span>D  mov         eax,dword ptr [a] <br><span class="hljs-number">01061520</span>  push        eax  <br><span class="hljs-number">01061521</span>  call        <span class="hljs-keyword">operator</span> delete (<span class="hljs-number">10610</span>B9h) <br><span class="hljs-number">01061526</span>  add         esp,<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>比之前的方法更加简洁高效(不需要调用placement new)。不知道手动调用构造函数是否有违C++标准或有什么隐晦，我在其他很多有名的内存池(包括SGI STL alloc)实现上看到都是用的placement new，而不是手动调用构造函数。</p><h1 id="三-operator-new重载"><a href="#三-operator-new重载" class="headerlink" title="三. operator new重载"></a>三. operator new重载</h1><p>前面简单提到过A* p = new A;所发生的事情：先调用operator new，如果类A重载了operator new，那么就使用该重载版本，否则使用全局版本::operatro new(size_t size)。</p><p>上面提到的throwing(1)和nothrow(2)的operator new是可以被重载的，比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A constructor&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br> <br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A destructor&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> </span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A::operator new&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> std::<span class="hljs-keyword">nothrow_t</span>&amp; nothrow_value)</span> </span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A::operator new nothrow&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">int</span> _tmain(<span class="hljs-keyword">int</span> argc, _TCHAR* argv[]) &#123;<br>    A* p1 = <span class="hljs-keyword">new</span> A;<br>    <span class="hljs-keyword">delete</span> p1;<br> <br>    A* p2 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span>(std::nothrow) A;<br>    <span class="hljs-keyword">delete</span> p2;<br> <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">call A::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span><br>call A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span>:</span>:<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span> nothrow<br>call A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure><p>如果类A中没有对operator new的重载，那么new A和new(std::nothrow) A; 都将会使用全局operator new(size_t size)。可将A中两个operator new注释掉，并且在A外添加一个全局operator new重载：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">void</span>* ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;call global operator new&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">call <span class="hljs-keyword">global</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span><br>call A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">global</span> <span class="hljs-title">operator</span> <span class="hljs-title">new</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure><p>注意，这里的重载遵循作用域覆盖原则，即在里向外寻找operator new的重载时，只要找到operator new()函数就不再向外查找，如果参数符合则通过，如果参数不符合则报错，而不管全局是否还有相匹配的函数原型。比如如果这里只将A中operator new(size_t, const std::nothrow_t&amp;)删除掉，就会报错：</p><p>error C2660: “A::operator new”: 函数不接受 2 个参数。<br>对operator new的重载还可以添加自定义参数，如在类A中添加</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;X=&quot;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot;  Y=&quot;</span>&lt;&lt;y&lt;&lt;<span class="hljs-string">&quot; Z=&quot;</span>&lt;&lt;z&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种重载看起来没有什么大作用，因为它operator new需要完成的任务只是分配内存，但是通过对这类重载的巧妙应用，可以让它在动态分配内存调试和检测中大展身手。这将在后面operator new重载运用技巧中展现。</p><p>至于placement new，它本身就是operator new的一个重载，不需也尽量不要对它进行改写，因为它一般是搭配 new(p) A(); 工作的，它的职责只需简单返回指针。</p><h1 id="四-operator-new运用技巧和一些实例探索"><a href="#四-operator-new运用技巧和一些实例探索" class="headerlink" title="四. operator new运用技巧和一些实例探索"></a>四. operator new运用技巧和一些实例探索</h1><h2 id="4-1-operator-new重载运用于调试："><a href="#4-1-operator-new重载运用于调试：" class="headerlink" title="4.1. operator new重载运用于调试："></a>4.1. operator new重载运用于调试：</h2><p>前面提到如何operator new的重载是可以有自定义参数的，那么我们如何利用自定义参数获取更多的信息呢，这里一个很有用的做法就是给operator new添加两个参数:char* file, int line,这两个参数记录new关键字的位置，然后再在new时将文件名和行号传入，这样我们就能在分配内存失败时给出提示：输出文件名和行号。</p><p>那么如何获取当前语句所在文件名和行号呢，windows提供两个宏：__FILE__和__LINE__。利用它们可以直接获取到文件名和行号，也就是 new(<strong>FILE</strong>, <strong>LINE</strong>) 由于这些都是不变的，因此可以再定义一个宏：#define new new(<strong>FILE</strong>, <strong>LINE</strong>)。这样我们就只需要定义这个宏，然后重载operator new即可。</p><p>源代码如下，这里只是简单输出new的文件名和行号。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//A.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A constructor&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br> <br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A destructor&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file, <span class="hljs-keyword">int</span> line)</span> </span>&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A::operator new on file:&quot;</span>&lt;&lt;file&lt;&lt;<span class="hljs-string">&quot;  line:&quot;</span>&lt;&lt;line&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br> <br>&#125;;<br><span class="hljs-comment">//Test.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;A.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> new new(__FILE__, __LINE__)</span><br> <br><span class="hljs-keyword">int</span> _tmain(<span class="hljs-keyword">int</span> argc, _TCHAR* argv[]) &#123;<br>    A* p1 = <span class="hljs-keyword">new</span> A;<br>    <span class="hljs-keyword">delete</span> p1;<br> <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">call A::<span class="hljs-keyword">operator</span> new <span class="hljs-keyword">on</span> <span class="hljs-keyword">file</span>:d:\desktop\test\test.cpp line:<span class="hljs-number">8</span><br>call A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br></code></pre></td></tr></table></figure><p>注意：需要将类的声明实现与new的使用隔离开来。并且将类头文件放在宏定义之前。否则在类A中的operator new重载中的new会被宏替换，整个函数就变成了：void* operator new(<strong>FILE</strong>, <strong>LINE</strong>)(size_t size, char* file, int line)，编译器自然会报错。</p><h2 id="4-2-内存池优化"><a href="#4-2-内存池优化" class="headerlink" title="4.2. 内存池优化"></a>4.2. 内存池优化</h2><p>operator new的另一个大用处就是内存池优化，内存池的一个常见策略就是分配一次性分配一块大的内存作为内存池(buffer或pool)，然后重复利用该内存块，每次分配都从内存池中取出，释放则将内存块放回内存池。在我们客户端调用的是new关键字，我们可以改写operator new函数，让它从内存池中取出(当内存池不够时，再从系统堆中一次性分配一块大的)，至于构造和析构则在取出的内存上进行，然后再重载operator delete，它将内存块放回内存池。关于内存池和operator new在参考文献中有一篇很好的文章。这里就不累述了。</p><h2 id="4-3-STL中的new"><a href="#4-3-STL中的new" class="headerlink" title="4.3. STL中的new"></a>4.3. STL中的new</h2><p>在SGI STL源码中,defalloc.h和stl_construct.h中提供了最简单的空间配置器(allocator)封装，见《STL源码剖析》P48。它将对象的空间分配和构造分离开来，虽然在defalloc.h中仅仅是对::operator new和::operator delete的一层封装，但是它仍然给STL容器提供了更加灵活的接口。SGI STL真正使用的并不是defalloc.h中的分配器，而是stl_alloc.h中的SGI精心打造的”双层级配置器”，它将内存池技术演绎得淋漓尽致，值得细细琢磨。顺便提一下，在stl_alloc.h中并没有使用::operator new/delete 而直接使用malloc和free。具体缘由均可参见《STL源码剖析》。</p><h1 id="五-delete的使用"><a href="#五-delete的使用" class="headerlink" title="五. delete的使用"></a>五. delete的使用</h1><p>delete的使用基本和new一致，包括operator delete的重载方式这些都相似，只不过它的参数是void*，返回值为void。但是有一点需要注意，operator delete的自定义参数重载并不能手动调用。比如</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot; x = &quot;</span>&lt;&lt;x&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot; x = &quot;</span>&lt;&lt;x&lt;&lt;endl;<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>如下调用是无法通过的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">A* p = new(<span class="hljs-number">3</span>) A;<span class="hljs-regexp">//</span>ok<br><span class="hljs-keyword">delete</span>(<span class="hljs-number">3</span>) p;<span class="hljs-regexp">//</span>error C2541: “<span class="hljs-keyword">delete</span>”: 不能删除不是指针的对象<br></code></pre></td></tr></table></figure><p>那么重载operator delete有什么作用？如何调用？事实上以上自定义参数operator delete 只在一种情况下被调用：当new关键字抛出异常时。</p><p>可以这样理解，只有在new关键字中，编译器才知道你调用的operator new形式，然后它会调用对应的operator delete。一旦出了new关键字，编译器对于这块内存是如何分配的一无所知，因此它只会调用默认的operator delete，而至于为什么不能主动调用自定义delete(而只能老老实实delete p)，这个就不知道了。</p><p>细心观察的话，上面operator new用于调试的例子代码中，由于我们没有给出operator new对应的operator delete。在VS2008下会有如下警告：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">warning</span> C4291: “<span class="hljs-keyword">void</span> *A::operator <span class="hljs-keyword">new</span>(size_t,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *,<span class="hljs-keyword">int</span>)”: 未找到匹配的删除运算符；如果初始化引发异常，则不会释放内存<br></code></pre></td></tr></table></figure><h1 id="六-关于new和内存分配的其他"><a href="#六-关于new和内存分配的其他" class="headerlink" title="六. 关于new和内存分配的其他"></a>六. 关于new和内存分配的其他</h1><ol><li><p>set_new_handler<br>还有一些零散的东西没有介绍到，比如set_new_handler可以在malloc(需要调用set_new_mode(1))或operator new内存分配失败时指定一个入口函数new_handler，这个函数完成自定义处理(继续尝试分配，抛出异常，或终止程序)，如果new_handler返回，那么系统将继续尝试分配内存，如果失败，将继续重复调用它，直到内存分配完毕或new_handler不再返回(抛出异常，终止)。下面这段程序完成这个测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;new.h&gt;</span><span class="hljs-comment">// 使用_set_new_mode和set_new_handler</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nomem_handler</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;call nomem_handler&quot;</span>&lt;&lt;std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _set_new_mode(<span class="hljs-number">1</span>);  <span class="hljs-comment">//使new_handler有效</span><br>    <span class="hljs-built_in">set_new_handler</span>(nomem_handler);<span class="hljs-comment">//指定入口函数 函数原型void f();</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;try to alloc 2GB memory....&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">char</span>* a = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>);<br>    <span class="hljs-keyword">if</span>(a)<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;ok...I got it&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行后会一直输出call nomem_handler 因为函数里面只是简单输出，返回，系统尝试分配失败后，调用nomem_handler函数，由于该函数并没有起到实际作用(让可分配内存增大)，因此返回后系统再次尝试分配失败，再调用nomem_handler，循环下去。<br>在SGI STL中的也有个仿new_handler函数:oom_malloc</p></li><li><p>new分配数组<br>new[]和new类似，仍然会优先调用类中重载的operator new[]。另外还要注意的是，在operator new[](size_t size)中传入的并不是sizeof(A)*3。而要在对象数组的大小上加上一个额外数据，用于编译器区分对象数组指针和对象指针以及对象数组大小。在VS2008(32 bit)下这个额外数据占4个字节，一个int大小。测试代码如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//A.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A constructor&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br> <br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A destructor&quot;</span>&lt;&lt;std::endl;<br>    &#125;<br> <br>    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size) &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A::operator new[] size:&quot;</span>&lt;&lt;size&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p) &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;call A::operator delete[]&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-built_in">free</span>(p);<br>    &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p)</span> </span>&#123;<br>        <span class="hljs-built_in">free</span>(p);<br>    &#125; <br>&#125;;<br><span class="hljs-comment">//Test.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;A.h&quot;</span></span><br> <br><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-keyword">size_t</span> size) &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;call global new[] size: &quot;</span>&lt;&lt;size&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">malloc</span>(size);<br>&#125;<br> <br><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p) &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;call global delete[] &quot;</span>&lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-keyword">int</span> _tmain(<span class="hljs-keyword">int</span> argc, _TCHAR* argv[]) &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;sizeof A &quot;</span>&lt;&lt;<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(A)&lt;&lt;std::endl;<br>    A* p1 = <span class="hljs-keyword">new</span> A[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">delete</span> []p1;<br> <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">sizeof A <span class="hljs-number">1</span><br>call <span class="hljs-keyword">global</span> <span class="hljs-keyword">new</span>[] size: <span class="hljs-number">7</span><br>call A <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span> <span class="hljs-title">destructor</span></span><br><span class="hljs-function"><span class="hljs-title">call</span> <span class="hljs-title">A</span>:</span>:<span class="hljs-keyword">operator</span> delete[]<br></code></pre></td></tr></table></figure><p>简单跟踪了一下，operator new[]返回的是0x005b668 而最后new关键字返回给p的是0x005b66c。也就是说p就是数组的起始地址，这样程序看到的内存就是线性的，不包括前面的额外数据。</p></li></ol><p>在内存中，可以看到前面的四个字节额外数据是0x00000003 也就是3，代表数组元素个数。后面三个cd是堆在Debug中的默认值(中文的cdcd就是”屯”，栈的初始值为cc，0xcccc中文”烫”)。再后面的0xfdfdfdfd应该是堆块的结束标志，前面我有博客专门跟踪过。</p><p>注：其实在malloc源码中也有内存池的运用，而且也比较复杂。最近在参考dlmalloc版本和STL空间适配器，真没有想到一个内存分配能涉及这么多的东西。</p><h1 id="七-参考文献"><a href="#七-参考文献" class="headerlink" title="七. 参考文献:"></a>七. 参考文献:</h1><ol><li><a href="http://www.cplusplus.com/reference/new/operator%20new/?kw=operator%25">http://www.cplusplus.com/reference/new/operator%20new/?kw=operator%</a> operator new的三种形式 </li><li><a href="http://www.relisoft.com/book/tech/9new.html">http://www.relisoft.com/book/tech/9new.html</a> c++ operator new重载和内存池技术 </li><li>《STL源码剖析》 空间配置器 </li><li><a href="http://blog.csdn.net/songthin/article/details/1703966">http://blog.csdn.net/songthin/article/details/1703966</a> 一篇关于理解C++ New的好文 </li><li><a href="http://blog.csdn.net/solstice/article/details/6198937">http://blog.csdn.net/solstice/article/details/6198937</a> 陈硕的Blog</li></ol>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00 squid 内存池研究</title>
    <link href="/2020/08/16/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/00%20squid%20%E5%86%85%E5%AD%98%E6%B1%A0%E7%A0%94%E7%A9%B6/"/>
    <url>/2020/08/16/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/00%20squid%20%E5%86%85%E5%AD%98%E6%B1%A0%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文的squid原理及代码基于squid 4.12版的源码，主要阐述及分析了squid的内存池原理及响应的代码实现。<br>squid的内存池有两种模式，一种是poolmalloc模式，另外一种是poolchunked模式</p><h1 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h1><p>从总体上来看，squid的内存池是通过按照不同大小的固定尺寸内存链来处理的。应用向内存池申请内存时，先找到应用需要的内存对应的内存链，再从内存链中获取一个可用的固定尺寸的内存块即可。</p><img src="/2020/08/16/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/00%20squid%20%E5%86%85%E5%AD%98%E6%B1%A0%E7%A0%94%E7%A9%B6/1.png" class=""><p>当内存链中的没有任何可用对象时，根据新申请的可用对象的申请方式，将内存池模式分为了malloc和chunked两种模式。</p><h2 id="2-1-malloc-模式分析"><a href="#2-1-malloc-模式分析" class="headerlink" title="2.1 malloc 模式分析"></a>2.1 malloc 模式分析</h2><p>此模式的内存池原理比较简单，每次应用向内存池申请内存时，先从内存池已有的空闲对象列表中直接pop出一个即可，如果空闲列表对象池中没有任何可用空闲对象，则直接调用系统的malloc进行申请；当应用归还内存时直接将归还的内存放入空闲队列中即可。</p><h2 id="2-2-chunked-模式分析"><a href="#2-2-chunked-模式分析" class="headerlink" title="2.2 chunked 模式分析"></a>2.2 chunked 模式分析</h2><p>此模式主要原理是，当内存链中没有可用空闲内存对象时，先向操作系统申请一块大内存(如2MB)，再将这块大内存按照内存链对象的大小进行切分，将规整切分后的内存加入到可用内存链中。</p><img src="/2020/08/16/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/00%20squid%20%E5%86%85%E5%AD%98%E6%B1%A0%E7%A0%94%E7%A9%B6/2.png" class=""><h1 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h1><p>内存源码位于src/mem目录下，</p><h2 id="3-1-文件及目录结构说明"><a href="#3-1-文件及目录结构说明" class="headerlink" title="3.1 文件及目录结构说明"></a>3.1 文件及目录结构说明</h2><table><thead><tr><th align="left">文件名</th><th>说明</th></tr></thead><tbody><tr><td align="left">AllocatorProxy.h和AllocatorProxy.cpp</td><td>提供给外部期望使用内存池分配类对象空间的代理类</td></tr><tr><td align="left">forward.h</td><td>内存池对外头文件</td></tr><tr><td align="left">Meter.h</td><td>跟踪内存使用情况的对象</td></tr><tr><td align="left">old_api.cc</td><td>实现forward.h中的相关全局函数声明</td></tr><tr><td align="left">pool.h 及pool.cpp</td><td>内存池对象接口</td></tr><tr><td align="left">PoolMalloc.h及PoolMalloc.cc</td><td>malloc内存池模式实现</td></tr><tr><td align="left">PoolChunked.h及PoolChunked.cc</td><td>chunked内存池模式实现</td></tr></tbody></table><h2 id="3-2-总体调用关系说明"><a href="#3-2-总体调用关系说明" class="headerlink" title="3.2 总体调用关系说明"></a>3.2 总体调用关系说明</h2><p>程序启动的时候调用Mem::Init() 函数对全局的内存池进行初始化，默认全局初始化了2KB、4KB、8KB、16KB、32KB、64KB、dread_ctrl、dwrite_q、MD5 digest(16字节)  的全局内存池对象（static MemAllocator *pools[MEM_MAX]） ，并设置内存池对象类型的最大个数为mem_type::MEM_MAX个;</p><p>其中除了MD5 digest内存池的chunk块大小512字节外，其他内存池的chunk块大小均为2MB</p><p>针对String 类型，squid定义了一组特殊的小内存内存块。通过memAllocString 函数调用，默认定义了6中类型的内存池，大小分别是36Byte, 128Byte, 512Byte, 1024Byte,  4096Byte, 16KB 等6种，存放于static const PoolMeta PoolAttrs[mem_str_pool_count] 中</p><p>当程序申请内存时通过2中方式来申请，</p><ol><li>调用memAllocBuf 来申请内存自定义大小的内存，当申请的内存超过pools中最大内存池64KB时则直接调用malloc进行申请</li><li>调用memAllocate根据类型MEM_NONE~~MEM_MAX的类型来调用指定大小的内存</li></ol><h2 id="3-3-PoolChunked源码分析"><a href="#3-3-PoolChunked源码分析" class="headerlink" title="3.3 PoolChunked源码分析"></a>3.3 PoolChunked源码分析</h2><p>每个固定大小的内存池 MemPoolChunked 由多个MemChunk组成，MemPoolChunked 成员变量解释如下：</p><table><thead><tr><th>变量名</th><th>变量含义</th></tr></thead><tbody><tr><td>chunk_size</td><td>当前内存池每个chunk的大小</td></tr><tr><td>chunk_capacity</td><td>每个chunk内可分配的内存item个数</td></tr><tr><td>chunkCount</td><td>当前内存池的chunk个数</td></tr><tr><td>freeCache</td><td>当前内存池中空闲item列表(自身是空闲的，自身前sizeof(void*)个字节内记录了下一个空闲对象的地址)</td></tr><tr><td>nextFreeChunk</td><td>当有新申请的空闲chunk时指向新申请的空闲chunk</td></tr><tr><td>Chunks</td><td>当前内存池chunk块链表的第一个chunk</td></tr><tr><td>allChunks</td><td>所有chunk块列表，使用伸展树(<em>Splay Tree</em>)存储</td></tr></tbody></table><p>MemChunk 成员变量说明如下：</p><table><thead><tr><th>变量名</th><th>变量含义</th></tr></thead><tbody><tr><td>freeList</td><td>当前chunk内空闲item列表</td></tr><tr><td>objCache</td><td>当前chunk的首个item地址</td></tr><tr><td>inuse_count</td><td>当前chunk中正在被使用的item个数</td></tr><tr><td>nextFreeChunk</td><td>当前chunk的前一个被使用完的空闲chunk</td></tr><tr><td>next</td><td>当前chunk的下一个chunk地址</td></tr><tr><td>lastref</td><td>最后使用时间</td></tr><tr><td>pool</td><td>所属的内存池对象地址</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>高性能代理软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>squid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伸展树(splay)</title>
    <link href="/2020/08/15/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03%E4%BC%B8%E5%B1%95%E6%A0%91(splay)/"/>
    <url>/2020/08/15/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03%E4%BC%B8%E5%B1%95%E6%A0%91(splay)/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>二叉查找树（Binary Search Tree，也叫二叉排序树，即Binary Sort Tree）能够支持多种动态集合操作，它可以用来表示有序集合、建立索引等，因而在实际应用中，二叉排序树是一种非常重要的数据结构。</p><p>从算法复杂度角度考虑，我们知道，作用于二叉查找树上的基本操作（如查找，插入等）的时间复杂度与树的高度成正比。对一个含n个节点的完全二叉树，这些操作的最坏情况运行时间为O(log n)。但如果因为频繁的删除和插入操作，导致树退化成一个n个节点的线性链（此时即为一个单链表），则这些操作的最坏情况运行时间为O(n)。为了克服以上缺点，很多二叉查找树的变形出现了，如红黑树、AVL树，Treap树等。</p><h1 id="splay-特点"><a href="#splay-特点" class="headerlink" title="splay 特点"></a>splay 特点</h1><p>伸展树(Splay Tree)是二叉查找树的一种改进数据结构。它的主要特点是不会保证树一直是平衡的，但各种操作的平摊时间复杂度是O(log n)，因而，从平摊复杂度上看，二叉查找树也是一种平衡二叉树。另外，相比于其他树状数据结构（如红黑树，AVL树等），伸展树的空间要求与编程复杂度要小得多。</p><h1 id="splay算法解决的问题"><a href="#splay算法解决的问题" class="headerlink" title="splay算法解决的问题"></a>splay算法解决的问题</h1><p>考虑到局部性原理（刚被访问的内容下次可能仍会被访问，查找次数多的内容可能下一次会被访问），为了使整个查找时间更小，被查频率高的那些节点应当经常处于靠近树根的位置。这样，很容易得想到以下这个方案：每次查找节点之后对树进行重构，把被查找的节点搬移到树根，这种自调整形式的二叉查找树就是伸展树。每次对伸展树进行操作后，它均会通过旋转的方法把被访问节点旋转到树根的位置。</p><p>为了将当前被访问节点旋转到树根，我们通常将节点自底向上旋转，直至该节点成为树根为止。“旋转”的巧妙之处就是在不打乱数列中数据大小关系（指中序遍历结果是全序的）情况下，所有基本操作的平摊复杂度仍为O（log n）。</p><p>伸展树主要有三种旋转操作，分别为单旋转，一字形旋转和之字形旋转。为了便于解释，我们假设当前被访问节点为X，X的父亲节点为Y（如果X的父亲节点存在），X的祖父节点为Z（如果X的祖父节点存在）。</p><h2 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h2><p>节点X的父节点Y是根节点。这时，如果X是Y的左孩子，我们进行一次右旋操作；如果X 是Y 的右孩子，则我们进行一次左旋操作。经过旋转，X成为二叉查找树T的根节点，调整结束。</p><img src="/2020/08/15/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03%E4%BC%B8%E5%B1%95%E6%A0%91(splay)/1.jpeg" class=""><h2 id="一字型旋转"><a href="#一字型旋转" class="headerlink" title="一字型旋转"></a>一字型旋转</h2><p>节点X 的父节点Y不是根节点，Y 的父节点为Z，且X与Y同时是各自父节点的左孩子或者同时是各自父节点的右孩子。这时，我们进行一次左左旋转操作或者右右旋转操作。</p><img src="/2020/08/15/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03%E4%BC%B8%E5%B1%95%E6%A0%91(splay)/2.jpeg" class=""><h2 id="之字形旋转"><a href="#之字形旋转" class="headerlink" title="之字形旋转"></a>之字形旋转</h2><p>节点X的父节点Y不是根节点，Y的父节点为Z，X与Y中一个是其父节点的左孩子而另一个是其父节点的右孩子。这时，我们进行一次左右旋转操作或者右左旋转操作。</p><img src="/2020/08/15/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03%E4%BC%B8%E5%B1%95%E6%A0%91(splay)/3.jpeg" class=""><h1 id="伸展树区间操作"><a href="#伸展树区间操作" class="headerlink" title="伸展树区间操作"></a>伸展树区间操作</h1><p>在实际应用中，伸展树的中序遍历即为我们维护的数列，这就引出一个问题，怎么在伸展树中表示某个区间？比如我们要提取区间[a,b]，那么我们将a前面一个数对应的结点转到树根，将b 后面一个结点对应的结点转到树根的右边，那么根右边的左子树就对应了区间[a,b]。原因很简单，将a 前面一个数对应的结点转到树根后， a 及a 后面的数就在根的右子树上，然后又将b后面一个结点对应的结点转到树根的右边，那么[a,b]这个区间就是下图中B所示的子树。</p><img src="/2020/08/15/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03%E4%BC%B8%E5%B1%95%E6%A0%91(splay)/4.jpeg" class=""><p>利用区间操作我们可以实现线段树的一些功能，比如回答对区间的询问（最大值，最小值等）。具体可以这样实现，在每个结点记录关于以这个结点为根的子树的信息，然后询问时先提取区间，再直接读取子树的相关信息。还可以对区间进行整体修改，这也要用到与线段树类似的延迟标记技术，即对于每个结点，额外记录一个或多个标记，表示以这个结点为根的子树是否被进行了某种操作，并且这种操作影响其子结点的信息值，当进行旋转和其他一些操作时相应地将标记向下传递。</p><p>与线段树相比，伸展树功能更强大，它能解决以下两个线段树不能解决的问题：</p><p>（1） 在a后面插入一些数。方法是：首先利用要插入的数构造一棵伸展树，接着，将a 转到根，并将a 后面一个数对应的结点转到根结点的右边，最后将这棵新的子树挂到根右子结点的左子结点上。</p><p>（2）  删除区间[a,b]内的数。首先提取[a,b]区间，直接删除即可。</p><h1 id="已知应用"><a href="#已知应用" class="headerlink" title="已知应用"></a>已知应用</h1><ul><li>squid 4中的内存池使用了伸展树</li><li>轻量级web服务器lighttpd中用到数据结构splay tree<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><a href="http://dongxicheng.org/structure/splay-tree/">http://dongxicheng.org/structure/splay-tree/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02 [百度分享]频繁分配释放内存导致的性能问题分析</title>
    <link href="/2020/08/14/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/02%20%5B%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%5D%E9%A2%91%E7%B9%81%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/14/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/02%20%5B%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%5D%E9%A2%91%E7%B9%81%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="1-现象"><a href="#1-现象" class="headerlink" title="1. 现象"></a>1. 现象</h1><ol><li>压力测试过程中，发现被测对象性能不够理想，具体表现为：<br>进程的系统态CPU消耗20，用户态CPU消耗10，系统idle大约70 </li><li>用ps -o majflt,minflt -C program命令查看，发现majflt每秒增量为0，而minflt每秒增量大于10000。</li></ol><h1 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h1><h2 id="2-1-初步分析"><a href="#2-1-初步分析" class="headerlink" title="2.1 初步分析"></a>2.1 初步分析</h2><p>majflt代表major fault，中文名叫大错误，minflt代表minor fault，中文名叫小错误。<br>这两个数值表示一个进程自启动以来所发生的缺页中断的次数。<br>当一个进程发生缺页中断的时候，进程会陷入内核态，执行以下操作：<br>检查要访问的虚拟地址是否合法<br>查找/分配一个物理页<br>填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）<br>建立映射关系（虚拟地址到物理地址）<br>重新执行发生缺页中断的那条指令<br>如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。<br>此进程minflt如此之高，一秒10000多次，不得不怀疑它跟进程内核态cpu消耗大有很大关系。</p><h2 id="2-2-分析代码"><a href="#2-2-分析代码" class="headerlink" title="2.2 分析代码"></a>2.2 分析代码</h2><p>查看代码，发现是这么写的：一个请求来，用malloc分配2M内存，请求结束后free这块内存。看日志，发现分配内存语句耗时10us，平均一条请求处理耗时1000us 。 原因已找到！<br>虽然分配内存语句的耗时在一条处理请求中耗时比重不大，但是这条语句严重影响了性能。要解释清楚原因，需要先了解一下内存分配的原理。 </p><h2 id="2-3-内存分配的原理"><a href="#2-3-内存分配的原理" class="headerlink" title="2.3 内存分配的原理"></a>2.3 内存分配的原理</h2><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。brk是将数据段(.data)的最高地址指针_edata往高地址推，mmap是在进程的虚拟地址空间中（一般是堆和栈中间）找一块空闲的。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。<br>在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。<br>下面以一个例子来说明内存分配的原理：</p><img src="/2020/08/14/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/02%20%5B%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%5D%E9%A2%91%E7%B9%81%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/c_1.jpg" class=""><ol><li>进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。_edata指针（glibc里面定义）指向数据段的最高地址。 </li><li>进程调用A=malloc(30K)以后，内存空间如图2：malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。你可能会问：只要把_edata+30K就完成内存分配了？事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。 </li><li>进程调用B=malloc(40K)以后，内存空间如图3. <img src="/2020/08/14/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/02%20%5B%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%5D%E9%A2%91%E7%B9%81%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/c_2.jpg" class=""></li><li>进程调用C=malloc(200K)以后，内存空间如图4：默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。这样子做主要是因为brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的），而mmap分配的内存可以单独释放。当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。 </li><li>进程调用D=malloc(100K)以后，内存空间如图5. </li><li>进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放 <img src="/2020/08/14/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/02%20%5B%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%5D%E9%A2%91%E7%B9%81%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/c_3.jpg" class="">     </li><li>进程调用free(B)以后，如图7所示。B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。 </li><li>进程调用free(D)以后，如图8所示。B和D连接起来，变成一块140K的空闲内存。 </li><li>默认情况下：当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示。</li></ol><h1 id="2-4-真相大白"><a href="#2-4-真相大白" class="headerlink" title="2.4 真相大白"></a>2.4 真相大白</h1><p>说完内存分配的原理，那么被测模块在内核态cpu消耗高的原因就很清楚了：每次请求来都malloc一块2M的内存，默认情况下，malloc调用mmap分配内存，请求结束的时候，调用munmap释放内存。假设每个请求需要6个物理页，那么每个请求就会产生6个缺页中断，在2000的压力下，每秒就产生了10000多次缺页中断，这些缺页中断不需要读取磁盘解决，所以叫做minflt；缺页中断在内核态执行，因此进程的内核态cpu消耗很大。缺页中断分散在整个请求的处理过程中，所以表现为分配语句耗时（10us）相对于整条请求的处理时间（1000us）比重很小。</p><h1 id="3-解决办法"><a href="#3-解决办法" class="headerlink" title="3. 解决办法"></a>3. 解决办法</h1><p>将动态内存改为静态分配，或者启动的时候，用malloc为每个线程分配，然后保存在threaddata里面。但是，由于这个模块的特殊性，静态分配，或者启动时候分配都不可行。另外，Linux下默认栈的大小限制是10M，如果在栈上分配几M的内存，有风险。<br>禁止malloc调用mmap分配内存，禁止内存紧缩。<br>在进程启动时候，加入以下两行代码：<br>mallopt(M_MMAP_MAX, 0);         // 禁止malloc调用mmap分配内存<br>mallopt(M_TRIM_THRESHOLD, -1);  // 禁止内存紧缩<br>效果：加入这两行代码以后，用ps命令观察，压力稳定以后，majlt和minflt都为0。进程的系统态cpu从20降到10。</p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>可以用命令ps -o majflt minflt -C program来查看进程的majflt, minflt的值，这两个值都是累加值，从进程启动开始累加。在对高性能要求的程序做压力测试的时候，我们可以多关注一下这两个值。<br>如果一个进程使用了mmap将很大的数据文件映射到进程的虚拟地址空间，我们需要重点关注majflt的值，因为相比minflt，majflt对于性能的损害是致命的，随机读一次磁盘的耗时数量级在几个毫秒，而minflt只有在大量的时候才会对性能产生影响。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VIRT 与 RSE 占用分析</title>
    <link href="/2020/08/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/05VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/05VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p>在Linux命令行中执行top命令，可以查询到所有进程使用的VIRT虚拟内存、RES常驻内存和共享内存SHR。那么，什么是VIRT虚拟内存、RES常驻内存和共享内存SHR？我们编写的Linux C++程序如何影响它们呢？</p><h2 id="VIRT："><a href="#VIRT：" class="headerlink" title="VIRT："></a>VIRT：</h2><div class="code-wrapper"><pre><code class="hljs">- 进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等；- 假如进程新申请10MB的内存，但实际只使用了1MB，那么它会增长10MB，而不是实际的1MB使用量。- VIRT = SWAP + RES</code></pre></div><h2 id="RES："><a href="#RES：" class="headerlink" title="RES："></a>RES：</h2><div class="code-wrapper"><pre><code class="hljs">- 进程当前使用的内存大小，包括使用中的malloc、new分配的堆空间和分配的栈空间，但不包括swap out量；- 包含其他进程的共享；- 如果申请10MB的内存，实际使用1MB，它只增长1MB，与VIRT相反；- 关于库占用内存的情况，它只统计加载的库文件所占内存大小。- RES = CODE + DATA</code></pre></div><h2 id="SHR："><a href="#SHR：" class="headerlink" title="SHR："></a>SHR：</h2><div class="code-wrapper"><pre><code class="hljs">- 除了自身进程的共享内存，也包括其他进程的共享内存；- 虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小；- 计算某个进程所占的物理内存大小公式：RES – SHR；- swap out后，它将会降下来。</code></pre></div><h1 id="2、程序验证"><a href="#2、程序验证" class="headerlink" title="2、程序验证"></a>2、程序验证</h1><h2 id="2-1-申请但未使用的堆空间不占用RES，但占用VIRT"><a href="#2-1-申请但未使用的堆空间不占用RES，但占用VIRT" class="headerlink" title="2.1 申请但未使用的堆空间不占用RES，但占用VIRT"></a>2.1 申请但未使用的堆空间不占用RES，但占用VIRT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> * p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">512</span>];<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>top显示如下：</p><img src="/2020/08/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/05VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/1.png" class=""><p>VIRT包含了new出来的512MB空间，但是RES不包含该空间。即malloc或new出来的空间，如果没有使用，会放入SWAP中，并不在内容中真实的分配物理内存。</p><h2 id="2-2-申请且使用了的堆空间占用RES"><a href="#2-2-申请且使用了的堆空间占用RES" class="headerlink" title="2.2 申请且使用了的堆空间占用RES"></a>2.2 申请且使用了的堆空间占用RES</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> * p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">512</span>];<br>    <span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">512</span>); <span class="hljs-comment">//使用申请的空间</span><br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>top显示如下:</p><img src="/2020/08/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/05VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/2.png" class=""><p>VIRT包含new出来的512MB空间，RES包含目前使用的memset的512M空间。即new出来的空间被使用后，会真实分配物理内存。</p><p><strong>使用部分申请了的堆空间则RES显示使用的部分</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> * p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">512</span>];<br>    <span class="hljs-built_in">memset</span>(p + <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">128</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">128</span>);<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>top显示如下:</p><img src="/2020/08/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/05VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/3.png" class=""><p>VIRT包含new出来的512MB空间，RES包含目前使用的memset的128M空间。即new出来的空间，如果只使用部分，则只分配部分物理内存。</p><h2 id="2-3-申请但未使用的栈空间不占用RES，但占用VIRT"><a href="#2-3-申请但未使用的栈空间不占用RES，但占用VIRT" class="headerlink" title="2.3 申请但未使用的栈空间不占用RES，但占用VIRT"></a>2.3 申请但未使用的栈空间不占用RES，但占用VIRT</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> p[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">20</span>];<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>top显示如下：</p><img src="/2020/08/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/05VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/4.png" class=""><p>没有使用的栈空间，VIRT会包含（没有使用的栈空间会在SWAP中）。</p><h2 id="2-4-已经使用的栈空间，VIRT和RES都会包含"><a href="#2-4-已经使用的栈空间，VIRT和RES都会包含" class="headerlink" title="2.4 已经使用的栈空间，VIRT和RES都会包含"></a>2.4 已经使用的栈空间，VIRT和RES都会包含</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> p[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">20</span>];<br><span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>top显示如下：</p><img src="/2020/08/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/05VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/5.png" class=""><h2 id="2-5-局部申请的内存释放后RES并未减少"><a href="#2-5-局部申请的内存释放后RES并未减少" class="headerlink" title="2.5 局部申请的内存释放后RES并未减少"></a>2.5 局部申请的内存释放后RES并未减少</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_part_virt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = len+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*i*<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i=%d, p=%p\n&quot;</span>, i, p);<br>    <span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*i*<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">delete</span> [] p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//char * p = new char [1024*1024*512];</span><br>    <span class="hljs-keyword">char</span> p[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">20</span>];<br>    <span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; ++i) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">test_part_virt</span>(i%<span class="hljs-number">4</span>);<br>    &#125;<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>top显示如下：</p><img src="/2020/08/13/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/05VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/6.png" class=""><p>在 <code>currlwent i=1, p=0xfd0010 </code> 时RES开始增加，每次增加10M, 且一直占用，此问题主要由于Glibc的内存分配由brk和mmap两种内存内存分配策略导致。<br>    从操作系统的角度看，进程的内存分配由两个系统调用完成：brk和mmap。brk是将数据段(.data)的最高地址指针_edata往高地址推，mmap是在进程的虚拟地址空间中找一块空闲的。其中，mmap分配的内存由munmap释放，内存释放时将立即归还操作系统；而brk分配的内存需要等到高地址内存释放以后才能释放，可通过在程序启动时增加以下代码，修改内存分配方式来解决问题    </p><blockquote><p>mallopt(M_MMAP_MAX, 0); // 禁止malloc调用mmap分配内存<br>mallopt(M_TRIM_THRESHOLD, 0); // 禁止内存缩进，sbrk申请的内存释放后不会归还给操作系统</p></blockquote><p>修改后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test_part_virt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = len+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">char</span> p[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*i*<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*i*<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;currlwent i=%d, p=%p\n&quot;</span>, i, p);<br>    <span class="hljs-comment">//char *p = new char[1024*1024*i*10];</span><br>    <span class="hljs-comment">//printf(&quot;currlwent i=%d, p=%p\n&quot;, i, p);</span><br>    <span class="hljs-comment">//memset(p, 0, 1024*1024*i*10);</span><br>    <span class="hljs-comment">//delete [] p;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">mallopt</span>(M_MMAP_MAX, <span class="hljs-number">0</span>); <span class="hljs-comment">// 禁止malloc调用mmap分配内存</span><br>    <span class="hljs-comment">//char * p = new char [1024*1024*512];</span><br>    <span class="hljs-keyword">char</span> p[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">20</span>];<br>    <span class="hljs-built_in">memset</span>(p, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">20</span>; ++i) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">test_part_virt</span>(i%<span class="hljs-number">4</span>);<br>    &#125;<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过以上的代码修改程序RES内存稳定再20MB</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://blog.csdn.net/huyiyang2010/article/details/7815491#">https://blog.csdn.net/huyiyang2010/article/details/7815491#</a><br><a href="https://blog.csdn.net/hmylk/article/details/37761247">https://blog.csdn.net/hmylk/article/details/37761247</a><br><a href="https://bbs.csdn.net/topics/330179712">https://bbs.csdn.net/topics/330179712</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>getopt与getopt_long使用</title>
    <link href="/2020/08/03/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/01getopt%E4%B8%8Egetopt_long%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/03/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/01getopt%E4%B8%8Egetopt_long%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="解析命令行参数getopt和getopt-long"><a href="#解析命令行参数getopt和getopt-long" class="headerlink" title="解析命令行参数getopt和getopt_long"></a>解析命令行参数getopt和getopt_long</h1><p>在程序中一般都会用到命令行选项, 我们可以使用<strong>getopt 和getopt_long</strong>函数来解析命令行参数</p><h2 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h2><p>getopt主要用来处理短命令行选项, 例如<code>./test -v</code>中 -v 就是一个短选项. 使用该函数需要引入头文件&lt;unistd.h&gt;, 下面是该函数的定义<br><code>int getopt(int argc, char * const argv[], const char * optstring);</code></p><p>其中 <code>argc</code> 和 <code>argv</code> 是 <code>main</code> 函数中的传递的参数个数和内容, <code>optstring</code> 用来指定可以处理哪些选项, 下面是 <code>optstring</code> 的一个示例:<br><code>&quot;a:bc&quot;</code></p><p>该示例表明程序可以接受3个选项: -a -b -c, 其中 a 后面的 :表示该选项后面要跟一个参数, 即如 -a text的形式, 选项后面跟的参数会被保存到 optarg 变量中. 下面是一个使用示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ch;<br>    <span class="hljs-keyword">while</span>((ch = <span class="hljs-built_in">getopt</span>(argc, argv, <span class="hljs-string">&quot;a:b&quot;</span>)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(ch) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;option a: %s\n&quot;</span>, optarg);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;option b \n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: <span class="hljs-comment">// 输入未定义的选项, 都会将该选项的值变为 ?</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown option \n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;default \n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行 <code>./test -a aa -b -c</code> 输出结果如下:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">option</span> a: aa<br><span class="hljs-keyword">option</span> b <br><span class="hljs-type">unknown</span> <span class="hljs-keyword">option</span><br></code></pre></td></tr></table></figure><h2 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h2><p><code>getopt_long</code>支持长选项的命令行解析, 所为长选项就是诸如–help的形式, 使用该函数, 需要引入&lt;getopt.h&gt;下面是函数原型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;getopt.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt_long</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, </span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[],</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">const</span> struct option *longopts,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">int</span> *longindex)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getopt_long_only</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> argv[],</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">const</span> struct option *longopts,</span></span><br><span class="hljs-params"><span class="hljs-function">                    <span class="hljs-keyword">int</span> *longindex)</span></span>;<br></code></pre></td></tr></table></figure><p>其中 argc , argv , optstring 和getopt中的含义一样, 下面解释一下longopts 和longindex</p><h3 id="longopts"><a href="#longopts" class="headerlink" title="longopts"></a>longopts</h3><p><code>longopts</code> 指向一个 <code>struct option</code> 的数组, 下面是<code>option</code>的定义:</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sml"><span class="hljs-keyword">struct</span> <span class="hljs-built_in">option</span> &#123;<br>    const <span class="hljs-built_in">char</span> *name;<br>    <span class="hljs-built_in">int</span>         has_arg;<br>    <span class="hljs-built_in">int</span>        *flag;<br>    <span class="hljs-built_in">int</span>         <span class="hljs-keyword">val</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是各字段的含义<br>    name - 长选项的名称, 例如 help<br>    has_arg - 是否带参数, 0 不带参数, 1 必须带参数, 2 参数可选<br>    flag - 指定长选项如何返回结果, 如果flag为NULL, getopt_long() 会返回val. 如果flag不为NULL, getopt_long会返回0, 并且将val的值存储到flag中<br>    val - 将要被getopt_long返回或者存储到flag指向的变量中的值</p><p>下面是 <code>longopts</code> 的一个示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">opts</span>[] =</span> &#123;<br>    &#123;<span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;v&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;n&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;h&#x27;</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们来看<code>&#123;&quot;version&quot;, 0, NULL, &#39;v&#39;&#125;</code>, <code>version</code> 即为长选项的名称, 即按如下形式<code>--version</code>, 0 表示该选项后面不带参数, NULL 表示直接将v返回(字符v在ascii码中对应的数值), 即在使用getopt_long遍历到该条选项时, getopt_long 返回值为字符v对应的ascii码值.</p><h3 id="longindex"><a href="#longindex" class="headerlink" title="longindex"></a>longindex</h3><p><code>longindex</code> 表示长选项在<code>longopts</code> 中的位置, 例如在上面的示例中, <code>version</code> 对应的 <code>longindex</code> 为0, <code>name</code>对应的 <code>longindex</code> 为1, <code>help</code> 对应的 <code>longindex</code> 为2, 该项主要用于调试, 一般设为 NULL 即可.</p><p>下面是一个使用示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_getpot_long</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring = <span class="hljs-string">&quot;vn:h&quot;</span>;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">opts</span>[] =</span> &#123;<br>        &#123;<span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;v&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;n&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;h&#x27;</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">while</span>((c = <span class="hljs-built_in">getopt_long</span>(argc, argv, optstring, opts, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(c) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;username is %s\n&quot;</span>, optarg);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;version is 0.0.1\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is help\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown option\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the return val is 0\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------\n&quot;</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们运行程序 ./test –name aaaa –version –help –haha, 下面是运行结果:</p><div class="code-wrapper"><pre><code class="hljs">username is aaaaversion is 0.0.1this is help./test: unrecognized option &#39;--haha&#39;unknown option</code></pre></div><p>当然我们也可以使用短选项 ./test -n aaaa -v -h<br>下面我们对程序做一下修改, 这一次将 struct option 中的 flag 和 longindex 设为具体的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_getpot_long2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring = <span class="hljs-string">&quot;vn:h&quot;</span>;<br>    <span class="hljs-keyword">int</span> c;<br><br>    <span class="hljs-keyword">int</span> f_v = <span class="hljs-number">-1</span>, f_n = <span class="hljs-number">-1</span>, f_h = <span class="hljs-number">-1</span>, opt_index = <span class="hljs-number">-1</span>; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">opts</span>[] =</span> &#123;<br>        &#123;<span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-number">0</span>, &amp;f_v, <span class="hljs-string">&#x27;v&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">1</span>, &amp;f_n, <span class="hljs-string">&#x27;n&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-number">0</span>, &amp;f_h, <span class="hljs-string">&#x27;h&#x27;</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">while</span>((c = <span class="hljs-built_in">getopt_long</span>(argc, argv, optstring, opts, &amp;opt_index)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(c) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;username is %s\n&quot;</span>, optarg);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;version is 0.0.1\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is help\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown option\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;f_v is %d \n&quot;</span>, f_v);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;f_n is %d \n&quot;</span>, f_n);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;f_h is %d \n&quot;</span>, f_h);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;opt_index is %d\n\n&quot;</span>, opt_index);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序: ./test –name bbbb –version –help , 下面是运行结果:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">f_v <span class="hljs-keyword">is</span> <span class="hljs-number">-1</span> <br>f_n <span class="hljs-keyword">is</span> <span class="hljs-number">110</span> <br>f_h <span class="hljs-keyword">is</span> <span class="hljs-number">-1</span> <br>opt_index <span class="hljs-keyword">is</span> <span class="hljs-number">1</span><br><br>f_v <span class="hljs-keyword">is</span> <span class="hljs-number">118</span> <br>f_n <span class="hljs-keyword">is</span> <span class="hljs-number">110</span> <br>f_h <span class="hljs-keyword">is</span> <span class="hljs-number">-1</span> <br>opt_index <span class="hljs-keyword">is</span> <span class="hljs-number">0</span><br><br>f_v <span class="hljs-keyword">is</span> <span class="hljs-number">118</span> <br>f_n <span class="hljs-keyword">is</span> <span class="hljs-number">110</span> <br>f_h <span class="hljs-keyword">is</span> <span class="hljs-number">104</span> <br>opt_index <span class="hljs-keyword">is</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>我们可以看到当给 flag 指定具体的指针之后, getopt_long 会返回0, 因此会去执行case 0, 并且 val 的值赋给了 flag 指向的变量. 下面我们用短选项执行一下程序 ./test -n bbbb -v -h, 下面是运行结果</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d">username <span class="hljs-keyword">is</span> bbbb<br>opt_index <span class="hljs-keyword">is</span> -<span class="hljs-number">1</span><br><br><span class="hljs-keyword">version</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0.0</span><span class="hljs-number">.1</span><br>opt_index <span class="hljs-keyword">is</span> -<span class="hljs-number">1</span><br><br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> help<br>opt_index <span class="hljs-keyword">is</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们看到使用短选项的时候 getopt_long 就相当于 getopt , flag 和 longindex都不起作用了.</p><p>getopt_long 和 getopt_long_only<br>下面解释一下 getopt_long 和 getopt_long_only的区别, 首先用下列选项运行一下 use_getopt_long ./test -name zhangjkai -version -help , 下面是输出结果:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">username <span class="hljs-keyword">is</span> ame<br><span class="hljs-keyword">version</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0.0</span><span class="hljs-number">.1</span><br>./test: invalid <span class="hljs-keyword">option</span> <span class="hljs-comment">-- &#x27;e&#x27;</span><br><span class="hljs-type">unknown</span> <span class="hljs-keyword">option</span><br>./test: invalid <span class="hljs-keyword">option</span> <span class="hljs-comment">-- &#x27;r&#x27;</span><br><span class="hljs-type">unknown</span> <span class="hljs-keyword">option</span><br>./test: invalid <span class="hljs-keyword">option</span> <span class="hljs-comment">-- &#x27;s&#x27;</span><br><span class="hljs-type">unknown</span> <span class="hljs-keyword">option</span><br>./test: invalid <span class="hljs-keyword">option</span> <span class="hljs-comment">-- &#x27;i&#x27;</span><br><span class="hljs-type">unknown</span> <span class="hljs-keyword">option</span><br>./test: invalid <span class="hljs-keyword">option</span> <span class="hljs-comment">-- &#x27;o&#x27;</span><br><span class="hljs-type">unknown</span> <span class="hljs-keyword">option</span><br>username <span class="hljs-keyword">is</span> -help<br></code></pre></td></tr></table></figure><p>我们看到使用短选项标识符 - 指向长选项时, 程序还是会按短选项来处理, 即一个字符一个字符的解析. 下面我们将 use_getopt_long 做一下更改, 即将 getopt_long 改为 getopt_long_only , 如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_getpot_long3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *optstring = <span class="hljs-string">&quot;vn:h&quot;</span>;<br>    <span class="hljs-keyword">int</span> c;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">option</span> <span class="hljs-title">opts</span>[] =</span> &#123;<br>        &#123;<span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;v&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;n&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&#x27;h&#x27;</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">while</span>((c = <span class="hljs-built_in">getopt_long_only</span>(argc, argv, optstring, opts, <span class="hljs-literal">NULL</span>)) != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(c) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;username is %s\n&quot;</span>, optarg);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;version is 0.0.1\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is help\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown option\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> :<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the return val is 0\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------\n&quot;</span>);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面再运行程序 <code>./test -name cccc -version -help </code>, 下面是运行结果:</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs d">username <span class="hljs-keyword">is</span> cccc<br><span class="hljs-keyword">version</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0.0</span><span class="hljs-number">.1</span><br><span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> help<br></code></pre></td></tr></table></figure><p>即使用 <code>getopt_long_only</code> 时, - 和 –都可以作用于长选项, 而使用 <code>getopt_only</code> 时, 只有 –可以作用于长选项.</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式的六大原则</title>
    <link href="/2020/08/02/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/02/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-设计模式的六大原则"><a href="#1-设计模式的六大原则" class="headerlink" title="1. 设计模式的六大原则"></a>1. 设计模式的六大原则</h1><h2 id="1-1-开闭原则（Open-Close-Principle）"><a href="#1-1-开闭原则（Open-Close-Principle）" class="headerlink" title="1.1 开闭原则（Open Close Principle）"></a>1.1 开闭原则（Open Close Principle）</h2><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h2 id="1-2-里氏代换原则（Liskov-Substitution-Principle）"><a href="#1-2-里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="1.2 里氏代换原则（Liskov Substitution Principle）"></a>1.2 里氏代换原则（Liskov Substitution Principle）</h2><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h2 id="1-3-依赖倒转原则（Dependence-Inversion-Principle）"><a href="#1-3-依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="1.3 依赖倒转原则（Dependence Inversion Principle）"></a>1.3 依赖倒转原则（Dependence Inversion Principle）</h2><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h2 id="1-4-接口隔离原则（Interface-Segregation-Principle）"><a href="#1-4-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="1.4 接口隔离原则（Interface Segregation Principle）"></a>1.4 接口隔离原则（Interface Segregation Principle）</h2><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h2 id="1-5-迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#1-5-迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="1.5 迪米特法则，又称最少知道原则（Demeter Principle）"></a>1.5 迪米特法则，又称最少知道原则（Demeter Principle）</h2><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h2 id="1-6-合成复用原则（Composite-Reuse-Principle）"><a href="#1-6-合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="1.6 合成复用原则（Composite Reuse Principle）"></a>1.6 合成复用原则（Composite Reuse Principle）</h2><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2 设计模式"></a>2 设计模式</h1><h2 id="2-1-结构型"><a href="#2-1-结构型" class="headerlink" title="2.1 结构型"></a>2.1 结构型</h2><h3 id="2-1-1-Abstract-Factory-抽象工厂"><a href="#2-1-1-Abstract-Factory-抽象工厂" class="headerlink" title="2.1.1 Abstract Factory(抽象工厂)"></a>2.1.1 Abstract Factory(抽象工厂)</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</p><h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><ul><li>一个系统要独立于它的产品的创建、组合和表示时</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>当你要强调一系列相关的产品对象的设计以便进行联合使用时</li><li>当你提供一个产品类库，而只想显示他们的接口而不是实现时</li></ul><h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><img src="/2020/08/02/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/abs1.png" class=""><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WinButton</span> :</span> <span class="hljs-keyword">public</span> Button &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacButton</span> :</span> <span class="hljs-keyword">public</span> Button &#123;&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Border</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WinBorder</span> :</span> <span class="hljs-keyword">public</span> Border &#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacBorder</span> :</span> <span class="hljs-keyword">public</span> Border &#123;&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Button * <span class="hljs-title">CreateButton</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Border * <span class="hljs-title">CreateBorder</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WinFactory</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> WinButton * <span class="hljs-title">CreateButton</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WinButton; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> WinBorder * <span class="hljs-title">CreateBorder</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WinBorder; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MacFactory</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> MacButton * CreateButton &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MacButton; &#125;<br>    <span class="hljs-keyword">virtual</span> MacBorder * CreateBorder &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MacBorder; &#125;<br>&#125;;<br><br>客户端如下使用：<br>AbstractFactory * fac;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(style)<br>&#123;<br>    <span class="hljs-keyword">case</span> Mac: <br>        fac = <span class="hljs-keyword">new</span> MacFactory;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Win:<br>        fac = <span class="hljs-keyword">new</span> WinFactory;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span> :<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br>Button * button = fac-&gt;<span class="hljs-built_in">CreateButton</span>();  <span class="hljs-comment">//隐藏了细节实现，封装了多个产品</span><br>Border * border = fac-&gt;<span class="hljs-built_in">CreateBorder</span>();<br></code></pre></td></tr></table></figure><h3 id="2-1-2-Builder—生成器"><a href="#2-1-2-Builder—生成器" class="headerlink" title="2.1.2 Builder—生成器"></a>2.1.2 Builder—生成器</h3><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h4 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h4><ol><li>当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时</li><li>当构造过程必须允许被构造的对象有不同的表示时</li></ol><h4 id="结构图-1"><a href="#结构图-1" class="headerlink" title="结构图"></a>结构图</h4><img src="/2020/08/02/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/bld.png" class=""><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildProduct</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart1</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart2</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Produc *<span class="hljs-title">GetProduct</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreateBuilderA</span> :</span> <span class="hljs-keyword">public</span> Builder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        m_product = <span class="hljs-keyword">new</span> Porduct;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart1</span><span class="hljs-params">()</span> </span>&#123;<br>        m_product.<span class="hljs-built_in">setPart1</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">111</span>);<br>        .....<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart2</span><span class="hljs-params">()</span> </span>&#123;<br>        m_product.<span class="hljs-built_in">setPart2</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1333</span>);<br>        &#125;<br><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Produc *<span class="hljs-title">GetProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_product;<br>        &#125;<br><span class="hljs-keyword">private</span>:<br>    Produc * m_product;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreateBuilderB</span> :</span> <span class="hljs-keyword">public</span> Builder<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        m_product = <span class="hljs-keyword">new</span> Porduct;<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart1</span><span class="hljs-params">()</span> </span>&#123;<br>        m_product.<span class="hljs-built_in">setPart1</span>(xxxx,qqqqq,<span class="hljs-number">111</span>);<br>        &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart2</span><span class="hljs-params">()</span> </span>&#123;<br>        m_product.<span class="hljs-built_in">setPart2</span>(xxxxx,bbbb,<span class="hljs-number">1333</span>);<br>        &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Produc *<span class="hljs-title">GetProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m_product;<br>        &#125;<br><span class="hljs-keyword">private</span>:<br>    Produc * m_product;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Director</span>(Builder * builder)&#123; m_builder = builder; &#125;<br>    <br>    <span class="hljs-built_in">Construct</span>()<br>    &#123;<br>        m_builder-&gt;<span class="hljs-built_in">buildPart1</span>();<br>        m_builder-&gt;<span class="hljs-built_in">buildPart2</span>();<br>        m_builder-&gt;<span class="hljs-built_in">buildPart3</span>();<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    Builder * m_builder;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-2-结构型"><a href="#2-2-结构型" class="headerlink" title="2.2 结构型"></a>2.2 结构型</h2><h3 id="2-2-1-Adapter—适配器模式"><a href="#2-2-1-Adapter—适配器模式" class="headerlink" title="2.2.1 Adapter—适配器模式"></a>2.2.1 Adapter—适配器模式</h3><h4 id="意图："><a href="#意图：" class="headerlink" title="意图："></a>意图：</h4><p>将一个类的接口转换为客户希望的另外一个接口。此模式是的原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><h4 id="适用性："><a href="#适用性：" class="headerlink" title="适用性："></a>适用性：</h4><ol><li>想使用一个已经存在的类，而它的接口不符合你的需求。</li><li>想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作</li><li>想使用一些已经存在的类，但是不可能对每一个都进行子类化以匹配他们的接口。对象适配器可以适配他的父类接口</li></ol><h4 id="伪代码："><a href="#伪代码：" class="headerlink" title="伪代码："></a>伪代码：</h4><p>此模式较为简单，有两种实现方式，一种采用组合方式，另外一种采用继承方式</p><h4 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">public</span>：<br>        <span class="hljs-built_in">SpecificRequest</span>();<br>        ....other...<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Target</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span></span>; <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> :</span> <span class="hljs-keyword">public</span> Target<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_daptee.<span class="hljs-built_in">SpecificRequest</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    Adaptee m_daptee;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Target * mytarget = <span class="hljs-keyword">new</span> Adapter;<br>    mytarget-&gt;<span class="hljs-built_in">Request</span>();<br>    <span class="hljs-keyword">delete</span> mytarget;<br>    mytarget = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>直接将Adapter中的继承替换为多继承，继承Target，同时还继承Adaptee</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Adapter</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">Target</span>，<span class="hljs-symbol">public</span> <span class="hljs-symbol">Adaptee</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    virtual <span class="hljs-built_in">void</span> Request()<br>    &#123;<br>        SpecificRequest();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-3-行为型"><a href="#2-3-行为型" class="headerlink" title="2.3 行为型"></a>2.3 行为型</h2><h3 id="2-3-1-Strategy-策略"><a href="#2-3-1-Strategy-策略" class="headerlink" title="2.3.1 Strategy (策略)"></a>2.3.1 Strategy (策略)</h3><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><p>定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。也称为政策模式(Policy)。</p><h4 id="适用性-2"><a href="#适用性-2" class="headerlink" title="适用性"></a>适用性</h4><p>当存在以下情况时使用Strategy模式</p><ol><li>许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。</li><li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间 /时间权衡的算法。当这些变体实现为一个算法的类层次时 ,可以使用策略模式。</li><li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</li><li>一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句</li></ol><h4 id="结构图-2"><a href="#结构图-2" class="headerlink" title="结构图"></a>结构图</h4><img src="/2020/08/02/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/01%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/stra.jpeg" class=""><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Interface</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Strategy</span>() &#123; &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyA</span> :</span><span class="hljs-keyword">public</span> Strategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Interface</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ConcreteStrategyA::Interface...&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteStrategyB</span> :</span><span class="hljs-keyword">public</span> Strategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Interface</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ConcreteStrategyB::Interface...&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Context</span>(Strategy *stg) &#123;<br>        _stg = stg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoAction</span><span class="hljs-params">()</span> </span>&#123;<br>        _stg-&gt;<span class="hljs-built_in">Interface</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    Strategy *_stg;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Strategy *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteStrategyA</span>();<br>    Context *pc = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Context</span>(ps);<br>    pc-&gt;<span class="hljs-built_in">DoAction</span>();<br><br>    <span class="hljs-keyword">delete</span> pc;<br>    <span class="hljs-keyword">delete</span> ps;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>goreplay 引流测试工具</title>
    <link href="/2020/07/31/04DevOps/04goreplay%E5%BC%95%E6%B5%81%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/07/31/04DevOps/04goreplay%E5%BC%95%E6%B5%81%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/buger/g</span>oreplay<br></code></pre></td></tr></table></figure><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p><code>./goreplay  --input-raw :7001 --output-http http://ip:port</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 将当前data目录下所有的.gor 文件作为流量回放的开始点, 打到10.72.138.200的80端口服务上</span><br><span class="hljs-string">./gor</span> -input-file  <span class="hljs-string">&quot;./data/*.gor&quot;</span>  <span class="hljs-params">--output-http=</span><span class="hljs-string">&quot;http://10.72.138.200:80&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas"># --<span class="hljs-meta">input</span>-<span class="hljs-meta">file</span> 从文件中获取请求数据，重放的时候 100x 倍速<br># --<span class="hljs-meta">input</span>-<span class="hljs-meta">file</span>-loop 无限循环，而不是读完这个文件就停止<br># --<span class="hljs-meta">output</span>-http 发送请求到 10.72.138.200<br># --<span class="hljs-meta">output</span>-http-workers 并发 100 发请求<br># --stats --<span class="hljs-meta">output</span>-http-stats 每 5 秒输出一次 TPS 数据<br>$ ./gor --<span class="hljs-meta">input</span>-<span class="hljs-meta">file</span> <span class="hljs-string">&#x27;./data/*.gor|1000%&#x27;</span> --<span class="hljs-meta">input</span>-<span class="hljs-meta">file</span>-loop --<span class="hljs-meta">output</span>-http <span class="hljs-string">&#x27;http://10.72.138.200&#x27;</span> --<span class="hljs-meta">output</span>-http-workers 100 --stats --<span class="hljs-meta">output</span>-http-stats<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust 实用代码总结</title>
    <link href="/2020/07/31/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02Rust/00rust%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB/"/>
    <url>/2020/07/31/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02Rust/00rust%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="获取当前的时间戳"><a href="#获取当前的时间戳" class="headerlink" title="获取当前的时间戳"></a>获取当前的时间戳</h1><p>示例代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::time::&#123;SystemTime&#125;;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_timestamp</span></span>() -&gt; <span class="hljs-built_in">u64</span> &#123;<br>    <span class="hljs-keyword">match</span> SystemTime::now().duration_since(SystemTime::UNIX_EPOCH) &#123;<br>        <span class="hljs-literal">Ok</span>(now) =&gt; &#123;<br>            now.as_secs()<br>        &#125;,<br>        _ =&gt; &#123;<br>            std::<span class="hljs-built_in">u64</span>::MAX<br>        &#125;,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world! now=&#123;&#125;&quot;</span>, get_timestamp());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实现函数重载"><a href="#实现函数重载" class="headerlink" title="实现函数重载"></a>实现函数重载</h1><p>函数重载<br>rust本身不支持函数重载，但是可以用泛型trait实现类似于重载的效果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">With</span></span>&lt;T&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with</span></span>(value: T) -&gt; <span class="hljs-keyword">Self</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> &#123;<br>    bar: <span class="hljs-built_in">String</span>,<br>    baz: <span class="hljs-built_in">i32</span>,<br>    quux: <span class="hljs-built_in">bool</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-built_in">Default</span> <span class="hljs-keyword">for</span> Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">default</span></span>() -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Foo &#123;<br>            bar: <span class="hljs-string">&quot;&quot;</span>.to_string(),<br>            baz: <span class="hljs-number">0</span>,<br>            quux: <span class="hljs-literal">false</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Foo &#123;<br>            ..<span class="hljs-built_in">Default</span>::default()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> With&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">for</span> Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with</span></span>(x: <span class="hljs-built_in">String</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Foo &#123;<br>            bar: x,<br>            ..<span class="hljs-built_in">Default</span>::default()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> With&lt;<span class="hljs-built_in">i32</span>&gt; <span class="hljs-keyword">for</span> Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with</span></span>(x: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Foo &#123;<br>            baz: x,<br>            ..<span class="hljs-built_in">Default</span>::default()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> With&lt;<span class="hljs-built_in">bool</span>&gt; <span class="hljs-keyword">for</span> Foo &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">with</span></span>(x: <span class="hljs-built_in">bool</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        Foo &#123;<br>            quux: x,<br>            ..<span class="hljs-built_in">Default</span>::default()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#[test]</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">name</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> a = Foo::with(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="vec合并数据时防止出现拷贝的方法"><a href="#vec合并数据时防止出现拷贝的方法" class="headerlink" title="vec合并数据时防止出现拷贝的方法"></a>vec合并数据时防止出现拷贝的方法</h1><p>当结构体中使用Vec<u8>在头部插入一个新的Vec<u8>数据时可以通过mem::replace方法来减少数据的拷贝。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::mem;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Myvec</span></span> &#123;<br>    data: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;,<br>    count: <span class="hljs-built_in">usize</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> Myvec &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; Myvec &#123;<br>        Myvec &#123;<br>            data : <span class="hljs-built_in">Vec</span>::new(),<br>            count : <span class="hljs-number">0</span>,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">append</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, d:&amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) &#123;<br>        <span class="hljs-keyword">self</span>.data.append(d);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">pre_insert</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, d:<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;) &#123;<br>    <span class="hljs-comment">// 使用replace 逆向实现数据的插入，防止clone数据</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> old = mem::replace(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.data, d);<br>        <span class="hljs-keyword">self</span>.data.append(&amp;<span class="hljs-keyword">mut</span> old);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">push</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, u:<span class="hljs-built_in">u8</span>) &#123;<br>        <span class="hljs-keyword">self</span>.data.push(u);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">print</span></span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;data&#123;:#?&#125;&quot;</span>, <span class="hljs-keyword">self</span>.data);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v1 = Myvec::new();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v2:<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt; = <span class="hljs-built_in">Vec</span>::new();<br>    v2.push(<span class="hljs-number">3</span>);<br>    v2.push(<span class="hljs-number">4</span>);<br>    v1.push(<span class="hljs-number">1</span>);<br>    v1.push(<span class="hljs-number">2</span>);<br>    v1.pre_insert(v2);<br>    v1.print();<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="打印变量地址"><a href="#打印变量地址" class="headerlink" title="打印变量地址"></a>打印变量地址</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>()&#123;<br>    <span class="hljs-keyword">let</span> a:<span class="hljs-built_in">i32</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">//&amp;a先转成raw指针，然后再把指针转成usize，这个可以print的</span><br>    <span class="hljs-keyword">let</span> addr = &amp;a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">i32</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">usize</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;addr：0x&#123;:X&#125;&quot;</span>,addr);<br><br>    <span class="hljs-comment">//为了验证刚才的地址是不是正确的，我们修改这个指针指向的数据</span><br>    <span class="hljs-comment">//pa就是addr对应的raw指针</span><br>    <span class="hljs-keyword">let</span> pa = addr <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>;<br>    <span class="hljs-comment">//解引用，*pa其实就是&amp;mut a了，给他赋值100</span><br>    <span class="hljs-keyword">unsafe</span>&#123;*pa = <span class="hljs-number">100</span>&#125;;<br><br>    <span class="hljs-comment">//打印a，可以看到a已经变成100了</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;value:&#123;&#125;&quot;</span>,a);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="打印变量T的类型"><a href="#打印变量T的类型" class="headerlink" title="打印变量T的类型"></a>打印变量T的类型</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fn print_type_of&lt;T&gt;(_: &amp;T) &#123;<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, std::any::type_name::&lt;T&gt;<span class="hljs-literal">()</span>)<br>&#125;<br>fn main<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">let</span> s = String::from(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-built_in">bytes</span> = s.into<span class="hljs-constructor">_bytes()</span>;<br>    assert_eq!(&amp;<span class="hljs-literal">[<span class="hljs-number">104</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>]</span><span class="hljs-literal">[..]</span>, &amp;<span class="hljs-built_in">bytes</span><span class="hljs-literal">[..]</span>);<br>    print<span class="hljs-constructor">_type_of(&amp;<span class="hljs-params">bytes</span>)</span>;<br>    <span class="hljs-keyword">let</span> mut mb = <span class="hljs-built_in">bytes</span>;<br>    print<span class="hljs-constructor">_type_of(&amp;<span class="hljs-params">mb</span>)</span>;<br>    print<span class="hljs-constructor">_type_of(&amp;<span class="hljs-params">mut</span> <span class="hljs-params">mb</span>)</span>;<br>    <span class="hljs-keyword">let</span> mut x = &amp;mut mb;<br>    print<span class="hljs-constructor">_type_of(&amp;<span class="hljs-params">x</span>)</span>;<br>    <span class="hljs-keyword">let</span> y = &amp;mut x;<br>    print<span class="hljs-constructor">_type_of(&amp;<span class="hljs-params">y</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="同一个crate内-不同lib或程序间的引用"><a href="#同一个crate内-不同lib或程序间的引用" class="headerlink" title="同一个crate内 不同lib或程序间的引用"></a>同一个crate内 不同lib或程序间的引用</h1><p>在同一个大型项目中，可能会建立多个lib，有时候想要以外部调用库的方式测试其中的某个lib的某项功能，这时怎么修改Cargo.toml文件引用工程内的某个lib？<br>答案是修改Cargo.toml 文件中的[dependencies]</p><p>参考arnl/test_simple/test_redis/Cargo.toml</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;test_redis&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">authors</span> = [<span class="hljs-string">&quot;wanghaibin &lt;wanghaibin@qiyi.com&gt;&quot;</span>]<br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2018&quot;</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">redis</span> = &#123; path = <span class="hljs-string">&quot;../../src/libredis/&quot;</span> &#125;<br><br></code></pre></td></tr></table></figure><p>在非tests目录下的测试程序arnl/test_simple/test_redis/src内容如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> redis::&#123;redis_string, redis_client&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> stream = redis_client::RedisClient::new(<span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>, &amp;<span class="hljs-number">0</span>, &amp;<span class="hljs-number">3</span>).unwrap();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> rstr = redis_string::RedisString::new(&amp;<span class="hljs-keyword">mut</span> stream);<br>    <span class="hljs-keyword">let</span> key = <span class="hljs-string">&quot;incrbyfloat_test&quot;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;xxxx=&#123;:#?&#125;&quot;</span>,rstr.incrbyfloat(key, <span class="hljs-number">2.1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="有趣的所有权问题问题"><a href="#有趣的所有权问题问题" class="headerlink" title="有趣的所有权问题问题"></a>有趣的所有权问题问题</h1><p>代码1</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> first = &amp;v[<span class="hljs-number">0</span>];<br>    v.push(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!, first=&#123;&#125;&quot;</span>, first);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码2</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> first = &amp;v[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!, first=&#123;&#125;&quot;</span>, first);<br>    v.push(<span class="hljs-number">5</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述<code>代码1</code>会编译报错，提示<code>error[E0502]: cannot borrow </code>v<code> as mutable because it is also borrowed as immutable</code></p><p>而<code>代码2</code>却可以正常编译通过，为什么那？</p><p>个人认为这正是rust在在编译期发现问题的优点之一，代码1报借用和可变借用同时存在错误，是因为在print的时候使用first，这时进行所有权规则检查，发现了E0502错误。而<code>代码2</code>为什么没有报错，是因为在编译时，运行到print进行所有权检测，此时还没有发生所有权问题，而在检测后续的push时first已经没有任何引用或使用，所以相关所有权规则没有问题</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust 宏</title>
    <link href="/2020/07/31/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02Rust/rust%E5%AE%8F/"/>
    <url>/2020/07/31/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02Rust/rust%E5%AE%8F/</url>
    
    <content type="html"><![CDATA[<p>rust的宏分为两个种，一种为声明宏，另外一种为过程宏；</p><p>过程宏主要用于扩展和继承又分为三种</p><div class="code-wrapper"><pre><code class="hljs">- 自定义 #[derive] 宏在结构体和枚举上指定通过 derive 属性添加的代码- 类属性（Attribute）宏定义可用于任意项的自定义属性- 类函数宏看起来像函数不过作用于作为参数传递的 token</code></pre></div><p>本文来自《rust primer》，重点介绍声明宏(或叫示例宏)的使用方法和规则</p><h1 id="1-声明宏-简介"><a href="#1-声明宏-简介" class="headerlink" title="1. 声明宏 简介"></a>1. 声明宏 简介</h1><p>学过 C 语言的人都知道 #define 用来定义宏(macro)，而且大学很多老师都告诉你尽量少用宏，因为 C 里面的宏是一个很危险的东西-宏仅仅是简单的文本替换，完全不管语法，类型，非常容易出错。听说过或用过 Lisp 的人觉得宏极其强大，就连美国最大的创业孵化器公司创始人 Paul Gram 也极力鼓吹 Lisp 的宏是有多么强大。那么宏究竟是什么样的东西呢？这一章通过 Rust 的宏系统带你揭开宏(Macro)的神秘面纱。</p><p>Rust 中的宏几乎无处不在，其实你写的第一个 Rust 程序里面就已经用到了宏，对，就是那个有名的 hello-world。println!(“Hello, world!”) 这句看起来很像函数调用，但是在”函数名”后面加上了感叹号，这个是专门用来区分普通函数调用和宏调用的。另外从形式上看，与函数调用的另一个区别是参数可以用圆括号(())、花括号({})、方括号([])中的任意一种括起来，比如这行也可以写成 println![“Hello, world!”] 或 println!{“Hello, world!”}，不过对于 Rust 内置的宏都有约定俗成的括号，比如 vec! 用方括号，assert_eq! 用圆括号。</p><p>既然宏看起来与普通函数非常像，那么使用宏有什么好处呢？是否可以用函数取代宏呢？答案显然是否定的，首先 Rust 的函数不能接受任意多个参数，其次函数是不能操作语法单元的，即把语法元素作为参数进行操作，从而生成代码，例如 mod, crate 这些是 Rust 内置的关键词，是不可能直接用函数去操作这些的，而宏就有这个能力。</p><p>相比函数，宏是用来生成代码的，在调用宏的地方，编译器会先将宏进行展开，生成代码，然后再编译展开后的代码。</p><p>声明宏定义格式是： <code>macro_rules! macro_name &#123; macro_body &#125;</code>，其中 macro_body 与模式匹配很像， <code>pattern =&gt; do_something</code> ，所以 Rust 的宏又称为 Macro by example (基于例子的宏)。其中 pattern 和 do_something 都是用配对的括号括起来的，括号可以是圆括号、方括号、花括号中的任意一种。匹配可以有多个分支，每个分支以分号结束。</p><p>还是先来个简单的例子说明</p><figure class="highlight elixir"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs elixir">macro_rules! create_function &#123;<br>    (<span class="hljs-variable">$func_name</span><span class="hljs-symbol">:ident</span>) =&gt;; (<br>        <span class="hljs-keyword">fn</span> <span class="hljs-variable">$func_name</span>() &#123;<br>            println!(<span class="hljs-string">&quot;function &#123;:?&#125; is called&quot;</span>, stringify!(<span class="hljs-variable">$func_name</span>))<br>        &#125;<br>    )<br>&#125;<br><br><span class="hljs-keyword">fn</span> main() &#123;<br>    create_function!(foo);<br>    foo();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个简单的例子是用来创建函数，生成的函数可以像普通函数一样调用，这个函数可以打印自己的名字。编译器在看到 <code>create_function!(foo)</code> 时会从前面去找一个叫 <code>create_function</code> 的宏定义，找到之后，就会尝试将参数 <code>foo</code> 代入 <code>macro_body</code>，对每一条模式按顺序进行匹配，只要有一个匹配上，就会将 =&gt; 左边定义的参数代入右边进行替换，如果替换不成功，编译器就会报错而不会往下继续匹配，替换成功就会将右边替换后的代码放在宏调用的地方。这个例子中只有一个模式，即 <code>$func_name:ident</code>，表示匹配一个标识符，如果匹配上就把这个标识符赋值给 <code>$func_name</code>，宏定义里面的变量都是以 $ 开头的，相应的类型也是以冒号分隔说明，这里 ident 是变量 $func_name 的类型，表示这个变量是一个 <code>identifier</code>，这是语法层面的类型(designator)，而普通的类型如 <code>char, &amp;str, i32, f64</code> 这些是语义层面的类型。在 <code>main</code> 函数中传给宏调用 <code>create_function</code> 的参数 <code>foo</code> 正好是一个标识符(ident)，所以能匹配上  ，<code>$func_name</code> 就等于 foo，然后把 $func_name 的值代入 =&gt; 右边，成了下面这样的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;function &#123;:?&#125; is called&quot;</span>, <span class="hljs-built_in">stringify!</span>(foo))<br>&#125;<br></code></pre></td></tr></table></figure><p>所以最后编译器编译的实际代码是</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">fn</span> <span class="hljs-selector-tag">main</span>() &#123;<br>    <span class="hljs-selector-tag">fn</span> <span class="hljs-selector-tag">foo</span>() &#123;<br>        <span class="hljs-selector-tag">println</span>!(<span class="hljs-string">&quot;function &#123;:?&#125; is called&quot;</span>, stringify!(foo))<br>    &#125;<br>    <span class="hljs-selector-tag">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面定义了 <code>create_function</code> 这个宏之后，就可以随便用来生成函数了，比如调用 <code>create_function!(bar)</code> 就得到了一个名为 bar 的函数</p><p>通过上面这个例子，大家对宏应该有一个大致的了解了。下面就具体谈谈宏的各个组成部分。</p><h1 id="2-宏的结构"><a href="#2-宏的结构" class="headerlink" title="2. 宏的结构"></a>2. 宏的结构</h1><h2 id="2-1-宏名"><a href="#2-1-宏名" class="headerlink" title="2.1 宏名"></a>2.1 宏名</h2><p>宏名字的解析与函数略微有些不同，宏的定义必须出现在宏调用之前，即与 C 里面的函数类似–函数定义或声明必须在函数调用之前，只不过 Rust 宏没有单纯的声明，所以宏在调用之前需要先定义，而 Rust 函数则可以定义在函数调用后面。宏调用与宏定义顺序相关性包括从其它模块中引入的宏，所以引入其它模块中的宏时要特别小心，这个稍后会详细讨论。</p><p>下面这个例子宏定义在宏调用后面，编译器会报错说找不到宏定义，而函数则没问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fn <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-number">42</span>;<br>    foo(a);<br>    bar!(a);<br>&#125;<br><br>fn <span class="hljs-function"><span class="hljs-title">foo</span>(<span class="hljs-params">x: i32</span>)</span> &#123;<br>    println!(<span class="hljs-string">&quot;The argument you passed to function is &#123;&#125;&quot;</span>, x);<br>&#125;<br><br>macro_rules! bar &#123;<br>    <span class="hljs-function">(<span class="hljs-params">$x:ident</span>) =&gt;</span> &#123; println!(<span class="hljs-string">&quot;The argument you passed to macro is &#123;&#125;&quot;</span>, $x); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子中把宏定义挪到 <code>main</code> 函数之前或者 <code>main</code> 函数里面 <code>bar!(a)</code> 调用上面，就可以正常编译运行。</p><p>宏调用虽然与函数调用很像，但是宏的名字与函数名字是处于不同命名空间的，之所以提出来是因为在有些编程语言里面宏和函数是在同一个命名空间之下的。看过下面的例子就会明白</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sas">fn foo(<span class="hljs-meta">x</span>: i32) -<span class="hljs-variable">&amp;gt</span>; i32 &#123;<br>    <span class="hljs-meta">x</span> <span class="hljs-comment">* x</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">macro_rules! foo &#123;</span><br><span class="hljs-comment">    ($x:ident) =&amp;gt;</span> &#123; println!(<span class="hljs-variable">&amp;quot</span>;&#123;:?&#125;<span class="hljs-variable">&amp;quot</span>;, $<span class="hljs-meta">x</span>); &#125;<br>&#125;<br>fn ma<span class="hljs-meta">in(</span>) &#123;<br>    let a = 5;<br>    foo!(a);<br>    println!(<span class="hljs-variable">&amp;quot</span>;&#123;&#125;<span class="hljs-variable">&amp;quot</span>;, foo(a));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-指示符-designator"><a href="#2-2-指示符-designator" class="headerlink" title="2.2 指示符(designator)"></a>2.2 指示符(designator)</h2><p>宏里面的变量都是以$开头的，其余的都是按字面去匹配，以 $ 开头的变量都是用来表示语法(syntactic)元素，为了限定匹配什么类型的语法元素，需要用指示符(designator)加以限定，就跟普通的变量绑定一样用冒号将变量和类型分开，当前宏支持以下几种指示符：</p><ul><li>ident: 标识符，用来表示函数或变量名</li><li>expr: 表达式</li><li>block: 代码块，用花括号包起来的多个语句</li><li>pat: 模式，普通模式匹配（非宏本身的模式）中的模式，例如<code>Some(t), (3, &#39;a&#39;, _)</code></li><li>path: 路径，注意这里不是操作系统中的文件路径，而是用双冒号分隔的限定名(qualified name)，如<code>std::cmp::PartialOrd</code></li><li>tt: 单个语法树</li><li>ty: 类型，语义层面的类型，如 <code>i32, char</code></li><li>item: 条目，</li><li>meta: 元条目</li><li>stmt: 单条语句，如 <code>let a = 42;</code><br>加上这些类型限定后，宏在进行匹配时才不会漫无目的的乱匹配，例如在要求标识符的地方是不允许出现表达式的，否则编译器就会报错。而 C/C++ 语言中的宏则仅仅是简单的文本替换，没有语法层面的考虑，所以非常容易出错。</li></ul><h2 id="2-3-重复-repetition"><a href="#2-3-重复-repetition" class="headerlink" title="2.3 重复(repetition)"></a>2.3 重复(repetition)</h2><p>宏相比函数一个很大的不同是宏可以接受任意多个参数，例如 <code>println!</code> 和 <code>vec!</code>。这是怎么做到的呢？</p><p>没错，就是重复(repetition)。模式的重复不是通过程序里面的循环(for/while)去控制的，而是指定了两个特殊符号 <code>+</code> 和 <code>*</code>，类似于正则表达式，因为正则表达式也是不关心具体匹配对象是一个人名还是一个国家名。与正则表达式一样, <code>+</code> 表示一次或多次（至少一次），而<code>* </code>表示零次或多次。重复的模式需要用括号括起来，外面再加上 $，例如 <code> $(...)*</code>, <code>$(...)+</code>。需要说明的是这里的括号和宏里面其它地方一样都可以是三种括号中的任意一种，因为括号在这里仅仅是用来标记一个模式的开始和结束，大部分情况重复的模式是用逗号或分号分隔的，所以你会经常看到 <code>$(...),*</code>, <code>$(...);*</code>, <code>$(...),+</code>, <code>$(...);+</code> 这样的用来表示重复。</p><p>还是来看一个例子</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">macro_rules! vector &#123;<br>   <span class="hljs-function"> (<span class="hljs-params">$</span>(<span class="hljs-params">$x</span>:<span class="hljs-params">expr</span>),*) =&gt;</span> &#123;<br>        &#123;<br>            <span class="hljs-keyword">let</span> mut temp_vec = Vec::<span class="hljs-keyword">new</span><span class="hljs-literal">()</span>;<br>            <span class="hljs-constructor">$(<span class="hljs-params">temp_vec</span>.<span class="hljs-params">push</span>($<span class="hljs-params">x</span>)</span>;)*<br>            temp_vec<br>        &#125;<br>    &#125;;<br>&#125;<br><br>fn main<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">let</span> a = vector!<span class="hljs-literal">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>]</span>;<br>    println!(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子初看起来比较复杂，我们来分析一下。</p><p>首先看 <code>=&gt;</code>左边，最外层是圆括号，前面说过这个括号可以是圆括号、方括号、花括号中的任意一种，只要是配对的就行。然后再看括号里面 <code>$(...),*</code> 正是刚才提到的重复模式，重复的模式是用逗号分隔的，重复的内容是 <code>$x:expr</code>，即可以匹配零次或多次用逗号分隔的表达式，例如 <code>vector![]</code> 和 <code>vector![3, x*x, s-t]</code> 都可以匹配成功。</p><p>接着看 <code>=&gt;</code> 右边，最外层也是一个括号，末尾是分号表示这个分支结束。里面是花括号包起来的代码块，最后一行没有分号，说明这个 macro 的值是一个表达式，<code>temp_vec</code> 作为表达式的值返回。第一条语句就是普通的用 <code>Vec::new()</code> 生成一个空 <code>vector</code>，然后绑定到可变的变量 <code>temp_vec</code> 上面，第二句比较特殊，跟 <code>=&gt;</code> 左边差不多，也是用来表示重复的模式，而且是跟左边是一一对应的，即左边匹配到一个表达式(<code>expr</code>)，这里就会将匹配到的表达式用在 <code>temp_vec.push($x);</code> 里面，所以 <code>vector![3, x*x, s-t]</code> 调用就会展开成</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<br>    let mut temp_vec = Vec::new()<span class="hljs-comment">;</span><br>    temp_vec.push(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>    temp_vec.push(<span class="hljs-name">x*x</span>)<span class="hljs-comment">;</span><br>    temp_vec.push(<span class="hljs-name">s-t</span>)<span class="hljs-comment">;</span><br>    temp_vec<br>&#125;<br></code></pre></td></tr></table></figure><p>看着很复杂的宏，细细分析下来是不是很简单，不要被这些符号干扰了</p><h2 id="2-4-递归-recursion"><a href="#2-4-递归-recursion" class="headerlink" title="2.4 递归(recursion)"></a>2.4 递归(recursion)</h2><p>除了重复之外，宏还支持递归，即在宏定义时调用其自身，类似于递归函数。因为rust的宏本身是一种模式匹配，而模式匹配里面包含递归则是函数式语言里面最常见的写法了，有函数式编程经验的对这个应该很熟悉。下面看一个简单的例子：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs elixir">macro_rules! find_min &#123;<br>    (<span class="hljs-variable">$x</span><span class="hljs-symbol">:expr</span>) =&gt; (<span class="hljs-variable">$x</span>);<br>    (<span class="hljs-variable">$x</span><span class="hljs-symbol">:expr</span>, <span class="hljs-variable">$(</span><span class="hljs-variable">$y</span><span class="hljs-symbol">:expr</span>),+) =&gt; (<br>        std::cmp::min(<span class="hljs-variable">$x</span>, find_min!(<span class="hljs-variable">$(</span><span class="hljs-variable">$y</span>),+))<br>    )<br>&#125;<br><br><span class="hljs-keyword">fn</span> main() &#123;<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="hljs-number">1</span>u32));<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="hljs-number">1</span>u32 + <span class="hljs-number">2</span> , <span class="hljs-number">2</span>u32));<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, find_min!(<span class="hljs-number">5</span>u32, <span class="hljs-number">2</span>u32 * <span class="hljs-number">3</span>, <span class="hljs-number">4</span>u32));<br>&#125;<br></code></pre></td></tr></table></figure><p>因为模式匹配是按分支顺序匹配的，一旦匹配成功就不会再往下进行匹配（即使后面也能匹配上），所以模式匹配中的递归都是在第一个分支里写最简单情况，越往下包含的情况越多。这里也是一样，第一个分支     <code>($x:expr)</code> 只匹配一个表达式，第二个分支匹配两个或两个以上表达式，注意加号表示匹配一个或多个，然后里面是用标准库中的 min 比较两个数的大小，第一个表达式和剩余表达式中最小的一个，其中剩余表达式中最小的一个是递归调用 <code>find_min!</code> 宏，与递归函数一样，每次递归都是从上往下匹配，只到匹配到基本情况。我们来写写 <code>find_min!(5u32, 2u32 * 3, 4u32)</code> 宏展开过程</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">std</span>::cmp::min(<span class="hljs-number">5</span>u<span class="hljs-number">32</span>, find_min!(<span class="hljs-number">2</span>u<span class="hljs-number">32</span> * <span class="hljs-number">3</span>, <span class="hljs-number">4</span>u<span class="hljs-number">32</span>))<br><span class="hljs-attribute">std</span>::cmp::min(<span class="hljs-number">5</span>u<span class="hljs-number">32</span>, std::cmp::min(<span class="hljs-number">2</span>u<span class="hljs-number">32</span> * <span class="hljs-number">3</span>, find_min!(<span class="hljs-number">4</span>u<span class="hljs-number">32</span>)))<br><span class="hljs-attribute">std</span>::cmp::min(<span class="hljs-number">5</span>u<span class="hljs-number">32</span>, std::cmp::min(<span class="hljs-number">2</span>u<span class="hljs-number">32</span> * <span class="hljs-number">3</span>, <span class="hljs-number">4</span>u<span class="hljs-number">32</span>))<br></code></pre></td></tr></table></figure><p>分析起来与递归函数一样，也比较简单。</p><h2 id="2-5-卫生宏-hygienic-Macro"><a href="#2-5-卫生宏-hygienic-Macro" class="headerlink" title="2.5 卫生宏(hygienic Macro)"></a>2.5 卫生宏(hygienic Macro)</h2><p>有了重复和递归，组合起来就是一个很强大的武器，可以解决很多普通函数无法抽象的东西。但是这里面会有一个安全问题，也是 C/C++ 里面宏最容易出错的地方，不过 Rust 像 Scheme 一样引入了卫生(Hygiene)宏，有效地避免了这类问题的发生。</p><p>C/C++ 里面的宏仅仅是简单的文本替换，下面的 C 经过宏预处理后，宏外面定义的变量 a 就会与里面定义的混在一起，从而按作用域 shadow 外层的定义，这会导致一些非常诡异的问题，不去看宏具体定义仔细分析的话，很难发现这类 bug。这样的宏是不卫生的，不过也有些奇葩的 Hacker 觉得这是一个非常棒的特性，例如 CommanLisp 语言里面的宏本身很强大，但不是卫生的，而某些 Hacker 还以这个为傲，搞一些奇技淫巧故意制造出这样的 shadow 行为实现一些很 fancy 的效果。这里不做过多评论，对 C 比较熟悉的同学可以分析一下下面这段代码运行结果与第一印象是否一样。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">INCI(<span class="hljs-params">i</span>)</span> &#123;<span class="hljs-built_in">int</span> a=<span class="hljs-number">0</span>; ++i;&#125;<br><span class="hljs-built_in">int</span> main(void)<br>&#123;<br>    <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-constructor">INCI(<span class="hljs-params">a</span>)</span>;<br>    <span class="hljs-constructor">INCI(<span class="hljs-params">b</span>)</span>;<br>    printf(<span class="hljs-string">&quot;a is now %d, b is now %d\n&quot;</span>, a, b);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>卫生宏最开始是由 Scheme 语言引入的，后来好多语言基本都采用卫生宏，即编译器或运行时会保证宏里面定义的变量或函数不会与外面的冲突，在宏里面以普通方式定义的变量作用域不会跑到宏外面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">macro_rules! foo &#123;<br>    <span class="hljs-function">() =&gt;</span> (<span class="hljs-keyword">let</span> x = <span class="hljs-number">3</span>);<br>&#125;<br><br>macro_rules! bar &#123;<br>    <span class="hljs-function">(<span class="hljs-params">$v:ident</span>) =&gt;</span> (<span class="hljs-keyword">let</span> $v = <span class="hljs-number">3</span>);<br>&#125;<br><br>fn <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br>    foo!();<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>    bar!(a);<br>    println!(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中宏 foo! 里面的变量 x 是按普通方式定义的，所以其作用域限定在宏里面，宏调用结束后再引用 x 编译器就会报错。要想让宏里面定义的变量在宏调用结束后仍然有效，需要按 <code>bar!</code> 里面那样定义。不过对于 <code>item</code> 规则就有些不同，例如函数在宏里面以普通方式定义后，宏调用之后，这个函数依然可用，下面代码就可以正常编译。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">macro_rules! foo &#123;<br>    <span class="hljs-function">() =&gt;</span> (fn <span class="hljs-function"><span class="hljs-title">x</span>(<span class="hljs-params"></span>)</span> &#123; &#125;);<br>&#125;<br><br>fn <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br>    foo!();<br>    x();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-6-导入导出-import-export"><a href="#2-6-导入导出-import-export" class="headerlink" title="2.6 导入导出(import/export)"></a>2.6 导入导出(import/export)</h2><p>前面提到宏名是按顺序解析的，所以从其它模块中导入宏时与导入函数、trait 的方式不太一样，宏导入导出用 #[macro_use] 和 #[macro_export]。父模块中定义的宏对其下的子模块是可见的，要想子模块中定义的宏在其后面的父模块中可用，需要使用 #[macro_use]。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gcode">macro_rules! <span class="hljs-name">m1</span> &#123; <span class="hljs-comment">()</span> =&gt; <span class="hljs-comment">(()</span>) &#125;<br><br><span class="hljs-comment">// 宏 m1 在这里可用</span><br><br>mod foo &#123;<br>    <span class="hljs-comment">// 宏 m1 在这里可用</span><br><br>    <span class="hljs-attr">#[macro_export]</span><br><span class="hljs-attr">    macro_rules! m2</span> &#123; <span class="hljs-comment">()</span> =&gt; <span class="hljs-comment">(()</span>) &#125;<br><br>    <span class="hljs-comment">// 宏 m1 和 m2 在这里可用</span><br>&#125;<br><br><span class="hljs-comment">// 宏 m1 在这里可用</span><br><span class="hljs-attr">#[macro_export]</span><br><span class="hljs-attr">macro_rules! m3</span> &#123; <span class="hljs-comment">()</span> =&amp;<span class="hljs-keyword">gt</span>; <span class="hljs-comment">(()</span>) &#125;<br><br><span class="hljs-comment">// 宏 m1 和 m3 在这里可用</span><br><br><span class="hljs-attr">#[macro_use]</span><br><span class="hljs-attr">mod bar &#123;</span><br><span class="hljs-attr">    // 宏 m1</span> 和 <span class="hljs-name">m3</span> 在这里可用<br><br>    macro_rules! <span class="hljs-name">m4</span> &#123; <span class="hljs-comment">()</span> =&amp;<span class="hljs-keyword">gt</span>; <span class="hljs-comment">(()</span>) &#125;<br><br>    <span class="hljs-comment">// 宏 m1, m3, m4 在这里均可用</span><br>&#125;<br><span class="hljs-comment">// 宏 m1, m3, m4 均可用</span><br></code></pre></td></tr></table></figure><p>crate 之间只有被标为 <code>#[macro_export]</code> 的宏可以被其它 crate 导入。假设上面例子是 <code>foo</code> crate 中的部分代码，则只有 <code>m2</code> 和 <code>m3</code> 可以被其它 crate 导入。导入方式是在 <code>extern crate foo;</code> 前面加上 <code>#[macro_use]</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> foo;<br><span class="hljs-comment">// foo 中 m2, m3 都被导入</span><br></code></pre></td></tr></table></figure><p>如果只想导入 <code>foo crate</code> 中某个宏，比如 <code>m3</code>，就给 <code>#[macro_use] </code>加上参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_use(m3)]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> foo;<br><span class="hljs-comment">// foo 中只有 m3 被导入</span><br></code></pre></td></tr></table></figure><h2 id="2-7-调试"><a href="#2-7-调试" class="headerlink" title="2.7 调试"></a>2.7 调试</h2><p>虽然宏功能很强大，但是调试起来要比普通代码困难，因为编译器默认情况下给出的提示都是对宏展开之后的，而不是你写的原程序，要想在编译器错误与原程序之间建立联系比较困难，因为这要求你大脑能够人肉编译展开宏代码。不过还好编译器为我们提供了 <code>--pretty=expanded</code> 选项，能让我们看到展开后的代码，通过这个展开后的代码，往上靠就与你自己写的原程序有个直接对应关系，往下靠与编译器给出的错误也是直接对应关系。</p><p>目前将宏展开需要使用 <code>unstable option</code>，通过 <code>rustc -Z unstable-options --pretty=expanded hello.rs</code> 可以查看宏展开后的代码，如果是使用的 cargo 则通过 <code>cargo rustc -- -Z unstable-options --pretty=expanded</code> 将项目里面的宏都展开。不过目前是没法只展开部分宏的，而且由于 hygiene 的原因，会对宏里面的名字做些特殊的处理(mangle)，所以程序里面的宏全部展开后代码的可读性比较差，不过依然比依靠大脑展开靠谱。</p><p>下面可以看看最简单的 <code>hello-word</code> 程序里面的 <code>println!(&quot;Hello, world!&quot;)</code> 展开结果，为了 hygiene 这里内部临时变量用了 <code>__STATIC_FMTSTR</code> 这样的名字以避免名字冲突，即使这简单的一句展开后看起来也还是不那么直观的，具体这里就不详细分析了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust">$ rustc -Z unstable-options --pretty expanded hello.rs<br><span class="hljs-meta">#![feature(prelude_import)]</span><br><span class="hljs-meta">#![no_std]</span><br><span class="hljs-meta">#[prelude_import]</span><br><span class="hljs-keyword">use</span> std::prelude::v1::*;<br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> std <span class="hljs-keyword">as</span> std;<br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    ::std::io::_print(::std::fmt::Arguments::new_v1(&#123;<br>                                                        <span class="hljs-keyword">static</span> __STATIC_FMTSTR:<br>                                                               &amp;<span class="hljs-symbol">&#x27;static</span> [&amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span>]<br>                                                               =<br>                                                            &amp;[<span class="hljs-string">&quot;Hello, world!\n&quot;</span>];<br>                                                        __STATIC_FMTSTR<br>                                                    &#125;,<br>                                                    &amp;<span class="hljs-keyword">match</span> () &#123; () =&gt; [], &#125;));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo使用方法</title>
    <link href="/2020/07/30/06%E6%9D%82%E9%A1%B9/01hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/30/06%E6%9D%82%E9%A1%B9/01hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="运行-server"><a href="#运行-server" class="headerlink" title="运行 server"></a>运行 server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h1 id="Hexo的升级"><a href="#Hexo的升级" class="headerlink" title="Hexo的升级"></a>Hexo的升级</h1><p>全局升级hexo-cli，先hexo version查看当前版本，然后npm install -g hexo-cli，再次hexo version查看是否升级成功。如果hexo不能直接识别运行，改为npx hexo。</p><ul><li>使用npm-check，检查系统中的插件是否有升级的。</li><li>使用npm-upgrade，升级系统中的相关插件。</li><li>npm update -g，检查升级npm本身。<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g hexo-cli<br>hexo version<br><br><span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span>-check<br><span class="hljs-built_in">npm</span>-check<br><br><span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span>-upgrade<br><span class="hljs-built_in">npm</span>-upgrade<br><br><span class="hljs-built_in">npm</span> update -g<br><span class="hljs-built_in">npm</span> install -g <span class="hljs-built_in">npm</span><br><br>hexo clean <span class="hljs-comment">#清理hexo数据并重新生成页面并部署</span><br>hexo g -s<br>hexo d<br></code></pre></td></tr></table></figure>经过以上这些命令就可以了。</li></ul><h1 id="文章内常用标签"><a href="#文章内常用标签" class="headerlink" title="文章内常用标签"></a>文章内常用标签</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 插入图片</span><br><span class="hljs-template-variable">&#123;% asset_img abs1.png  %&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>awk常用方法</title>
    <link href="/2020/07/30/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/02awk%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/30/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/02awk%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="awk内建变量"><a href="#awk内建变量" class="headerlink" title="awk内建变量"></a>awk内建变量</h2><figure class="highlight gams"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$0</span> 当前记录（这个变量中存放着整个行的内容）</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">$1</span>~$n 当前记录的第n个字段，字段间由FS分隔</span><br>FS 输入字段分隔符 默认是空格或Tab<br>NF 当前记录中的字段个数，就是有多少列 ,<span class="hljs-symbol">$</span>(NF-n)为倒数第n个字段<br>NR 已经读出的记录数，就是行号，从<span class="hljs-number">1</span>开始，如果有多个文件话，这个值也是不断累加中。<br>FNR 当前记录数，与NR不同的是，这个值会是各个文件自己的行号<br>RS 输入的记录分隔符， 默认为换行符<br>OFS 输出字段分隔符， 默认也是空格<br>ORS 输出的记录分隔符，默认为换行符<br>FILENAME 当前输入文件的名字<br></code></pre></td></tr></table></figure><h2 id="BEGIN-EDN语法"><a href="#BEGIN-EDN语法" class="headerlink" title="BEGIN EDN语法"></a>BEGIN EDN语法</h2><ul><li>BEGIN{ 这里面放的是执行前的语句 }</li><li>{这里面放的是处理每一行时要执行的语句}</li><li>END {这里面放的是处理完所有的行后要执行的语句 }<br>示例如下:<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#运行前</span><br>BEGIN &#123;<br>math = <span class="hljs-number">0</span><br>english = <span class="hljs-number">0</span><br>computer = <span class="hljs-number">0</span><br><span class="hljs-keyword">printf</span><span class="hljs-string">&quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;</span>    <span class="hljs-keyword">printf</span><span class="hljs-string">&quot;---------------------------------------------\n&quot;</span><br>&#125;<br><span class="hljs-comment">#运行中</span><br>&#123;<br>math+=$3<br>english+=$4<br>computer+=$5<br><span class="hljs-keyword">printf</span><span class="hljs-string">&quot;%-6s %-6s %4d %8d %8d %8d\n&quot;</span>, $1, $2, $3,$4,$5, $3+$4+$5<br>&#125;<br><span class="hljs-comment">#运行后</span><br>END &#123;<br><span class="hljs-keyword">printf</span><span class="hljs-string">&quot;---------------------------------------------\n&quot;</span><br><span class="hljs-keyword">printf</span><span class="hljs-string">&quot;  TOTAL:%10d %8d %8d \n&quot;</span>, math, english, computer<br><span class="hljs-keyword">printf</span><span class="hljs-string">&quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;</span>, math/NR, english/NR, computer/NR<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><p><code>cat data|awk &#39;&#123;sum+=$1&#125; END &#123;print &quot;Sum = &quot;, sum&#125;&#39;</code></p><h4 id="求平均"><a href="#求平均" class="headerlink" title="求平均"></a>求平均</h4><p><code>cat data|awk &#39;&#123;sum+=$1&#125; END &#123;print &quot;Average = &quot;, sum/NR&#125;&#39;</code></p><h4 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h4><p><code>cat data|awk &#39;BEGIN &#123;max = 0&#125; &#123;if ($1&gt;max) max=$1 fi&#125; END &#123;print &quot;Max=&quot;, max&#125;&#39;</code></p><h4 id="求最小值（min的初始值设置一个超大数即可）"><a href="#求最小值（min的初始值设置一个超大数即可）" class="headerlink" title="求最小值（min的初始值设置一个超大数即可）"></a>求最小值（min的初始值设置一个超大数即可）</h4><p><code>awk &#39;BEGIN &#123;min = 1999999&#125; &#123;if ($1&lt;min) min=$1 fi&#125; END &#123;print &quot;Min=&quot;, min&#125;&#39;</code></p><h4 id="求访问次数的Top-10-Resource，可以根据此进行优化"><a href="#求访问次数的Top-10-Resource，可以根据此进行优化" class="headerlink" title="求访问次数的Top 10 Resource，可以根据此进行优化"></a>求访问次数的Top 10 Resource，可以根据此进行优化</h4><p><code>cat output/logs/cookie_logs/</code>date +%u<code>/cookie_log|grep -v &#39;172.16&#39;|grep -v &#39;127.0.0.1&#39; |awk -F&#39; &#39;  &#39;&#123; if(index($1,&quot;219.141.246&quot;)!=0) print $2; else print $1  &#125; &#39;|sort|uniq -c|sort -n |tail -n 10</code></p><h4 id="求最大最小值"><a href="#求最大最小值" class="headerlink" title="求最大最小值"></a>求最大最小值</h4><p><code>cat 1.log | awk &#39;BEGIN &#123;max=0; min=1000&#125; &#123;sum +=$9; num +=1; if($9&gt;max) max=$9 fi; if($9&lt;min) min=$9 fi;&#125; END &#123;print &quot;avg=&quot;,sum/num, &quot;\nmax=&quot;,max, &quot;\nmin=&quot;, min&#125;&#39;</code></p><h4 id="awk中执行shell命令"><a href="#awk中执行shell命令" class="headerlink" title="awk中执行shell命令"></a>awk中执行shell命令</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stata">awk &#x27;&#123;cmd=<span class="hljs-string">&quot;rm &quot;</span><span class="hljs-variable">$0</span>;system(cmd)&#125;&#x27; filename ----OK<br>下面的也ok<br>awk &#x27;&#123;cmd=<span class="hljs-string">&quot;rm &quot;</span><span class="hljs-variable">$0</span>;cmd|getline &#125;&#x27; filename ---- OK<br><span class="hljs-keyword">man</span> awk里面关于getline的说明，大意是说 运行command，同时会把输出存在<span class="hljs-variable">$0</span> 里面，或参数<span class="hljs-keyword">var</span>中。<br><br>command | getline [<span class="hljs-keyword">var</span>]<br><span class="hljs-keyword">Run</span> command piping the output either into <span class="hljs-variable">$0</span> or <span class="hljs-keyword">var</span>, <span class="hljs-keyword">as</span> above.<br>command |&amp; getline [<span class="hljs-keyword">var</span>]<br><span class="hljs-keyword">Run</span> command <span class="hljs-keyword">as</span> a co-process piping the output either into <span class="hljs-variable">$0</span> or <span class="hljs-keyword">var</span>, <span class="hljs-keyword">as</span> above.<br>Co-processes are a gawk extension.<br>ps -ef |grep CipRouter | grep -v <span class="hljs-string">&quot;grep&quot;</span> | awk -F&#x27; &#x27; &#x27;&#123;cmd=<span class="hljs-string">&quot;ls /proc/&quot;</span><span class="hljs-variable">$2</span><span class="hljs-string">&quot;/fd/ | wc -l &quot;</span>;system(cmd); &#125;&#x27;|awk &#x27;&#123;num+=<span class="hljs-variable">$1&#125;</span> END &#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;sum= &quot;</span>,num&#125;&#x27;<br>或者<br>ps -ef |grep CipRouter | grep -v <span class="hljs-string">&quot;grep&quot;</span> | awk -F&#x27; &#x27; &#x27;&#123;cmd=<span class="hljs-string">&quot;ls /proc/&quot;</span><span class="hljs-variable">$2</span><span class="hljs-string">&quot;/fd/ | wc -l &quot;</span>;cmd|getline; <span class="hljs-keyword">sum</span>+=<span class="hljs-variable">$0</span>;&#125; END &#123;<span class="hljs-keyword">print</span> <span class="hljs-keyword">sum</span>&#125;&#x27; <br></code></pre></td></tr></table></figure><h4 id="awk-多个进程号转为数组"><a href="#awk-多个进程号转为数组" class="headerlink" title="awk 多个进程号转为数组"></a>awk 多个进程号转为数组</h4><p><code>aaa=(</code>ps -ef |grep xxx |grep -v grep |awk ‘{print $2}’<code>) echo &quot;$&#123;aaa[@]&#125;&quot;</code></p><h4 id="awk-F-特殊字符"><a href="#awk-F-特殊字符" class="headerlink" title="awk -F 特殊字符"></a>awk -F 特殊字符</h4><p><code>,\&quot;dn\&quot;:\&quot;baiducdnct.inter.iqiyi.com\&quot;   以&quot;dn\&quot;:\来分割，因为\为特殊字符，所以需要转义，每4个\为一个过滤\ awk -F&#39;dn\\\\&quot;:\\\\&#39; &#39;&#123;print $2&#125;&#39; </code></p><h4 id="awk-打印从某一列到最后一列的内容"><a href="#awk-打印从某一列到最后一列的内容" class="headerlink" title="awk 打印从某一列到最后一列的内容"></a>awk 打印从某一列到最后一列的内容</h4><p><code>awk -F &quot; &quot; &#39;&#123;for (i=2;i&lt;=NF;i++)printf(&quot;%s &quot;, $i);print &quot;&quot;&#125;&#39;</code></p><h4 id="清理除第一行和最后一行的的bash进程"><a href="#清理除第一行和最后一行的的bash进程" class="headerlink" title="清理除第一行和最后一行的的bash进程"></a>清理除第一行和最后一行的的bash进程</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># awk 命令将第一行和最后一行给去掉了, NR&gt;2&#123;&#125;&#123;&#125; 的理解为当前行大于2时打印p的当前值并将当前行的$2赋值给p, 否则只将当前行的$2给p  , 不能使用$p</span><br><span class="hljs-comment"># xargs -r 其中-r参数为当xargs 参数为空是不执行任何命令</span><br>ps -ef --<span class="hljs-keyword">sort</span> start_time |<span class="hljs-keyword">grep</span> bash |<span class="hljs-keyword">grep</span> -v <span class="hljs-string">&quot;grep&quot;</span> |awk  <span class="hljs-string">&#x27;NR&gt;2&#123;printf p&quot; &quot;&#125;&#123;p=$2&#125;&#x27;</span>  |xargs -r <span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
      <tag>awk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vimrc配置文件</title>
    <link href="/2020/07/30/04DevOps/03vimrc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2020/07/30/04DevOps/03vimrc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>用户根目录下~/.vimrc 配置文件内容</p><figure class="highlight 1c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></div></td><td class="code"><pre><code class="hljs 1c">set nu<br>set tabstop=<span class="hljs-number">4</span><br>set softtabstop=<span class="hljs-number">4</span><br>set shiftwidth=<span class="hljs-number">4</span><br>set expandtab<br>set cinoptions=g0<br>set colorcolumn=<span class="hljs-number">81</span><br>set fileencodings=ucs-bom,utf-<span class="hljs-number">8</span>,cp936,gb18030,big5,euc-jp,euc-kr,latin1<br>set nocompatible            <span class="hljs-string">&quot; 关闭 vi 兼容模式</span><br>syntax on                   <span class="hljs-string">&quot; 自动语法高亮</span><br><span class="hljs-string">&quot;set paste                   &quot;</span> 取消粘贴自动注释<br>set number                  <span class="hljs-string">&quot; 显示行号</span><br>set cursorline              <span class="hljs-string">&quot; 突出显示当前行</span><br>set ruler                   <span class="hljs-string">&quot; 打开状态栏标尺</span><br>set nobackup                <span class="hljs-string">&quot; 覆盖文件时不备份</span><br>set autochdir               <span class="hljs-string">&quot; 自动切换当前目录为当前文件所在的目录</span><br>filetype plugin indent on   <span class="hljs-string">&quot; 开启插件</span><br>set backupcopy=yes          <span class="hljs-string">&quot; 设置备份时的行为为覆盖</span><br>set hlsearch                <span class="hljs-string">&quot; 搜索时高亮显示被找到的文本</span><br>set noerrorbells            <span class="hljs-string">&quot; 关闭错误信息响铃</span><br>set novisualbell            <span class="hljs-string">&quot; 关闭使用可视响铃代替呼叫</span><br>set t_vb=                   <span class="hljs-string">&quot; 置空错误铃声的终端代码</span><br>set showmatch               <span class="hljs-string">&quot; 插入括号时，短暂地跳转到匹配的对应括号</span><br>set matchtime=<span class="hljs-number">1</span>             <span class="hljs-string">&quot; 短暂跳转到匹配括号的时间</span><br>set magic                   <span class="hljs-string">&quot; 设置魔术</span><br>set guioptions-=T           <span class="hljs-string">&quot; 隐藏工具栏</span><br>set guioptions-=m           <span class="hljs-string">&quot; 隐藏菜单栏</span><br>set completeopt=menu        <span class="hljs-string">&quot; 关闭scratch 预览窗口</span><br>set backspace=indent,eol,start<br>set cmdheight=<span class="hljs-number">1</span>             <span class="hljs-string">&quot; 设定命令行的行数为</span><br>set t_Co=<span class="hljs-number">256</span>                <span class="hljs-string">&quot; 让xshell 也支持vim的256色配色方案</span><br>set nomodeline              <span class="hljs-string">&quot; 关闭 model</span><br>set tags=./.tags;,.tags<br><span class="hljs-string">&quot; set tags+=../.tag</span><br><span class="hljs-string">&quot; set tags+=../../.tag</span><br><span class="hljs-string">&quot; set tags+=../../../.tag</span><br><span class="hljs-string">&quot; set tags+=../*/.tag</span><br><span class="hljs-string">&quot; set tags+=../*/*/.tag</span><br><span class="hljs-string">&quot; set tags+=../../*/*/.tag</span><br>set foldcolumn=<span class="hljs-number">0</span><br>setlocal foldlevel=<span class="hljs-number">2</span><br>set foldclose=all <span class="hljs-string">&quot; 设置为折叠</span><br>set nofoldenable  <span class="hljs-string">&quot; 设置为自动关闭折叠</span><br>set laststatus=<span class="hljs-number">2</span>      <span class="hljs-string">&quot; 总是显示状态栏</span><br>nnoremap &lt;space&gt; @=((foldclosed(line(&#x27;.&#x27;)) &lt; <span class="hljs-number">0</span>) ? &#x27;zc&#x27; : &#x27;zo&#x27;)&lt;CR&gt;<br><span class="hljs-string">&quot; 用空格键来开关折叠</span><br><span class="hljs-string">&quot;让vim记忆上次编辑的位置</span><br>autocmd BufReadPost *<br>            \ if line(<span class="hljs-string">&quot;&#x27;\&quot;&quot;)&gt;0&amp;&amp;line(&quot;</span>&#x27;\&quot;&quot;)&lt;=line(&quot;$&quot;) |<br>            \ exe &quot;normal g&#x27;\<span class="hljs-string">&quot;&quot;</span> <span class="hljs-string">|</span><br>            \ endif<br><span class="hljs-string">&quot;让vim记忆上次编辑的位置</span><br><span class="hljs-string">&quot; 警戒线颜色设置</span><br>highlight ColorColumn ctermfg=green ctermbg=red<br>highlight LineNr cterm=none ctermfg=green ctermbg=darkblue<br>highlight SpellBad ctermfg=<span class="hljs-number">15</span> ctermbg=<span class="hljs-number">1</span> guifg=White guibg=Red<br><span class="hljs-string">&quot; 搜索背景色设置</span><br>highlight Search cterm=none ctermfg=yellow ctermbg=red<br><span class="hljs-string">&quot; 下拉菜单背景色设置</span><br>highlight Pmenu ctermbg=green<br><span class="hljs-string">&quot; 下拉菜单选择行的背景色设置</span><br>highlight PmenuSel ctermbg=red ctermfg=yellow<br><span class="hljs-string">&quot; vimdiff 背景色设置</span><br>highlight DiffAdd     term=bold ctermfg=<span class="hljs-number">232</span> ctermbg=<span class="hljs-number">214</span><br>highlight DiffChange  term=bold ctermbg=<span class="hljs-number">248</span><br>highlight DiffDelete  term=reverse ctermfg=<span class="hljs-number">15</span> ctermbg=<span class="hljs-number">2</span><br>highlight DiffText    term=reverse ctermfg=<span class="hljs-number">15</span> ctermbg=<span class="hljs-number">1</span> gui=undercurl guifg=White guibg=Red guisp=Red<br><span class="hljs-string">&quot;highlight DiffText    term=reverse cterm=bold ctermbg=9</span><br><br><span class="hljs-string">&quot; set the runtime path to include Vundle and initialize</span><br>set rtp+=<span class="hljs-symbol">~/.vim/bundle/Vundle.vim</span><br><span class="hljs-symbol">call vundle#begin()</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">&quot; 让vundle管理插件版本,必须</span><br><span class="hljs-symbol">Plugin &#x27;VundleVim/Vundle.vim&#x27;</span><br><span class="hljs-symbol">&quot; 自动生成ctags索引</span><br><span class="hljs-symbol">Plugin &#x27;ludovicchabant/vim-gutentags&#x27;</span><br><span class="hljs-symbol">&quot; 提供ctags数据库无缝切换</span><br><span class="hljs-symbol">Plugin &#x27;skywind3000/gutentags_plus&#x27;</span><br><span class="hljs-symbol">&quot; vim支持markdown</span><br><span class="hljs-symbol">&quot;Plugin &#x27;plasticboy/vim-markdown&#x27;</span><br><span class="hljs-symbol">&quot; vim markdown 生成表格</span><br><span class="hljs-symbol">Plugin &#x27;dhruvasagar/vim-table-mode&#x27;</span><br><span class="hljs-symbol">&quot; 配合snippets自动补全, 没有的话snippets不生效</span><br><span class="hljs-symbol">Plugin &#x27;SirVer/ultisnips&#x27;</span><br><span class="hljs-symbol">&quot; 支持代码片段</span><br><span class="hljs-symbol">Plugin &#x27;honza/vim-snippets&#x27;</span><br><span class="hljs-symbol">&quot; 状态栏显示不同颜色</span><br><span class="hljs-symbol">Plugin &#x27;Lokaltog/vim-powerline&#x27;</span><br><span class="hljs-symbol">&quot; 记录历史变量名或路径或符号，使用tab即可循环选择</span><br><span class="hljs-symbol">Plugin &#x27;ervandew/supertab&#x27;</span><br><span class="hljs-symbol">&quot; 支持语法检测和编码风格检测</span><br><span class="hljs-symbol">Plugin &#x27;scrooloose/syntastic&#x27;</span><br><span class="hljs-symbol">&quot; 设置对齐线</span><br><span class="hljs-symbol">Plugin &#x27;Yggdroot/indentLine&#x27;</span><br><span class="hljs-symbol">&quot; git项目编辑后在行前显示状态~ + - 等</span><br><span class="hljs-symbol">Plugin &#x27;airblade/vim-gitgutter&#x27;</span><br><span class="hljs-symbol">&quot; 代码对齐</span><br><span class="hljs-symbol">Plugin &#x27;godlygeek/tabular&#x27;</span><br><span class="hljs-symbol">&quot; nerdtree</span><br><span class="hljs-symbol">Plugin &#x27;scrooloose/nerdtree&#x27;</span><br><span class="hljs-symbol">&quot; git管理的项目在项目窗口中的状态标识</span><br><span class="hljs-symbol">Plugin &#x27;git</span>:<span class="hljs-comment">//github.com/Xuyuanp/nerdtree-git-plugin.git&#x27;</span><br><span class="hljs-string">&quot; 文件查找工具，使用\ t查找文件</span><br>Plugin &#x27;wincent/command-t&#x27;<br><span class="hljs-string">&quot; vim 状态栏插件</span><br>Plugin &#x27;bling/vim-airline&#x27;<br><span class="hljs-string">&quot; 代码格式化插件</span><br>Plugin &#x27;Chiel92/vim-autoformat&#x27;<br>Plugin &#x27;rdnetto/YCM-Generator&#x27;<br><span class="hljs-string">&quot; 代码补全</span><br>Plugin &#x27;Valloric/YouCompleteMe&#x27;<br><span class="hljs-string">&quot; rust</span><br>Plugin &#x27;rust-lang/rust.vim&#x27;<br><span class="hljs-string">&quot; toml文件语法</span><br>Plugin &#x27;cespare/vim-toml&#x27;<br><br>call vundle<span class="hljs-meta">#end()            &quot; 必须</span><br>filetype plugin indent on    <span class="hljs-string">&quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本</span><br><br>autocmd BufNewFile  *.c,*.cpp  <span class="hljs-number">0</span>r <span class="hljs-symbol">~/.vim/skeleton/c.ske</span><br><span class="hljs-symbol">autocmd BufNewFile  *.h,*.hpp  0r ~/.vim/skeleton/h.ske</span><br><span class="hljs-symbol">autocmd BufNewFile  *.sh       0r ~/.vim/skeleton/sh.ske</span><br><span class="hljs-symbol">autocmd BufNewFile * normal G</span><br><span class="hljs-symbol">autocmd BufNewFile *.[ch],*.sh,*.hpp,*.cpp ks|call CreatedTime()|&#x27;</span><br><span class="hljs-symbol">fun CreatedTime()</span><br><span class="hljs-symbol">    if line(&quot;$&quot;) &gt; 20</span><br><span class="hljs-symbol">        let l = 20</span><br><span class="hljs-symbol">    else</span><br><span class="hljs-symbol">        let l = line(&quot;$&quot;)</span><br><span class="hljs-symbol">    endif</span><br><span class="hljs-symbol">    exe &quot;1,&quot; . l . &quot;g/Date       </span>:.*/s<span class="hljs-comment">//Date       : &quot; .strftime(&quot;%c&quot;)</span><br>endfun<br><br><span class="hljs-string">&quot; 保存时自动删除行尾空白字符</span><br>function! StripTrailingWhitespace()<br>    normal mZ<br>    %s/\s\+$<span class="hljs-comment">//e</span><br>    if line(<span class="hljs-string">&quot;&#x27;Z&quot;</span>) != line(<span class="hljs-string">&quot;.&quot;</span>)<br>        echo <span class="hljs-string">&quot;Stripped whitespace\n&quot;</span><br>    endif<br>    normal `Z<br>endfunction<br>autocmd BufWritePre *.cpp,*.cxx,*.hpp,*.h,*.rs,*.toml :call StripTrailingWhitespace()<br><br><span class="hljs-string">&quot; 设置nerd窗口中git文件状态</span><br>let g:NERDTreeIndicatorMapCustom = &#123;<br>    \ <span class="hljs-string">&quot;Modified&quot;</span>  : <span class="hljs-string">&quot;✹&quot;</span>,<br>    \ <span class="hljs-string">&quot;Staged&quot;</span>    : <span class="hljs-string">&quot;✚&quot;</span>,<br>    \ <span class="hljs-string">&quot;Untracked&quot;</span> : <span class="hljs-string">&quot;✭&quot;</span>,<br>    \ <span class="hljs-string">&quot;Renamed&quot;</span>   : <span class="hljs-string">&quot;➜&quot;</span>,<br>    \ <span class="hljs-string">&quot;Unmerged&quot;</span>  : <span class="hljs-string">&quot;═&quot;</span>,<br>    \ <span class="hljs-string">&quot;Deleted&quot;</span>   : <span class="hljs-string">&quot;✖&quot;</span>,<br>    \ <span class="hljs-string">&quot;Dirty&quot;</span>     : <span class="hljs-string">&quot;✗&quot;</span>,<br>    \ <span class="hljs-string">&quot;Clean&quot;</span>     : <span class="hljs-string">&quot;✔︎&quot;</span>,<br>    \ <span class="hljs-string">&quot;Unknown&quot;</span>   : <span class="hljs-string">&quot;?&quot;</span><br>    \ &#125;<br><br><span class="hljs-string">&quot; 自动关闭选项预览窗口</span><br>autocmd InsertLeave * if pumvisible() == <span class="hljs-number">0</span><span class="hljs-string">|pclose|endif</span><br>autocmd CursorMovedI * if pumvisible() == <span class="hljs-number">0</span><span class="hljs-string">|pclose|endif</span><br><br><span class="hljs-string">&quot;YouCompleteMe相关设置</span><br><span class="hljs-string">&quot;let g:ycm_global_ycm_extra_conf=&#x27;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#x27;</span><br>let g:ycm_global_ycm_extra_conf=&#x27;~/.ycm_extra_conf.py&#x27;<br><span class="hljs-string">&quot;开启语义补全</span><br>let g:ycm_seed_identifiers_with_syntax=<span class="hljs-number">1</span><br><span class="hljs-string">&quot;不显示开启vim时检查ycm_extra_conf文件的信息</span><br>let g:ycm_confirm_extra_conf=<span class="hljs-number">0</span><br><span class="hljs-string">&quot;每次重新生成匹配项，禁止缓存匹配项</span><br>let g:ycm_cache_omnifunc=<span class="hljs-number">0</span><br><span class="hljs-string">&quot; 从第2个键入字符就开始罗列匹配项</span><br>let g:ycm_min_num_of_chars_for_completion=<span class="hljs-number">2</span>                 <span class="hljs-string">&quot;</span><br><span class="hljs-string">&quot;不查询ultisnips提供的代码模板补全，如果需要，设置成1即可</span><br>let g:ycm_use_ultisnips_completer=<span class="hljs-number">0</span><br>let g:ycm_key_list_select_completion = [&#x27;&lt;c-n&gt;&#x27;, &#x27;&lt;Down&gt;&#x27;]<br>let g:ycm_enable_diagnostic_signs = <span class="hljs-number">0</span><br>let g:ycm_enable_diagnostic_highlighting = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;设置对齐线的颜色</span><br>let g:indentLine_color_term = <span class="hljs-number">239</span><br><span class="hljs-string">&quot; 设置</span><br>let g:airline<span class="hljs-meta">#extensions#tabline#enabled = 1</span><br>let NERDTreeWinPos=<span class="hljs-number">1</span>   <span class="hljs-string">&quot; 右侧显示</span><br><br><span class="hljs-string">&quot; 设置markdown的table模式下使用|进行表格制作</span><br>let g:table_mode_corner=&#x27;|&#x27;<br><br><span class="hljs-string">&quot; gutentags 搜索工程目录的标志，碰到这些文件/目录名就停止向上一级目录递归</span><br>let g:gutentags_project_root = [&#x27;.root&#x27;, &#x27;.svn&#x27;, &#x27;.git&#x27;, &#x27;.hg&#x27;, &#x27;.project&#x27;]<br><br><span class="hljs-string">&quot; 所生成的数据文件的名称</span><br>let g:gutentags_ctags_tagfile = &#x27;.tags&#x27;<br><br><span class="hljs-string">&quot; 将自动生成的 tags 文件全部放入 ~/.cache/tags 目录中，避免污染工程目录</span><br>let s:vim_tags = expand(&#x27;~/.cache/tags&#x27;)<br>let g:gutentags_cache_dir = s:vim_tags<br><span class="hljs-string">&quot; 检测 ~/.cache/tags 不存在就新建 &quot;</span><br>if !isdirectory(s:vim_tags)<br>    silent! call mkdir(s:vim_tags, &#x27;p&#x27;)<br>endif<br><br><span class="hljs-string">&quot; 配置 ctags 的参数</span><br>let g:gutentags_ctags_extra_args = [&#x27;--fields=+niazS&#x27;, &#x27;--extra=+q&#x27;]<br>let g:gutentags_ctags_extra_args += [&#x27;--c++-kinds=+px&#x27;]<br>let g:gutentags_ctags_extra_args += [&#x27;--c-kinds=+px&#x27;]<br><br><span class="hljs-string">&quot; 设置NerdTree F3调出</span><br>map &lt;F3&gt; :NERDTreeMirror&lt;CR&gt;<br>map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;<br><span class="hljs-string">&quot; 设置f4为代码自动格式化，配合插件vim-autoformat使用</span><br>noremap &lt;F4&gt; :Autoformat&lt;CR&gt;<br><span class="hljs-string">&quot; 设置f9打开或关闭对齐线</span><br>map &lt;F9&gt; :IndentLinesToggle&lt;CR&gt;<br><span class="hljs-string">&quot; 设置,2 ,3 ,4 分别为vimdiff的获取2 3 4 窗口内容, 并更新vimdiff</span><br>map &lt;silent&gt; ,<span class="hljs-number">2</span> :diffget <span class="hljs-number">2</span>&lt;CR&gt; :diffupdate&lt;CR&gt;<br>map &lt;silent&gt; ,<span class="hljs-number">3</span> :diffget <span class="hljs-number">3</span>&lt;CR&gt; :diffupdate&lt;CR&gt;<br>map &lt;silent&gt; ,<span class="hljs-number">4</span> :diffget <span class="hljs-number">4</span>&lt;CR&gt; :diffupdate&lt;CR&gt;<br><br>autocmd BufEnter * if <span class="hljs-meta">&amp;filetype == &quot;&quot; | setlocal ft=cpp | endif</span><br>nnoremap &lt;leader&gt;jd :YcmCompleter GoToDeclaration&lt;CR&gt;<br><br><span class="hljs-string">&quot; 在输入模式下ctrl+hjkl  来移动光标, 一般需要修改xshell中属性终端里 127 把&lt;BS&gt;设置成 127，而 &lt;DEL&gt;设置成 VT220 Del</span><br>inoremap &lt;c-h&gt; &lt;left&gt;<br>inoremap &lt;c-j&gt; &lt;down&gt;<br>inoremap &lt;c-k&gt; &lt;up&gt;<br>inoremap &lt;c-l&gt; &lt;right&gt;<br><span class="hljs-string">&quot;inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i</span><br><span class="hljs-string">&quot;inoremap &quot;</span> <span class="hljs-string">&quot;&quot;</span>&lt;ESC&gt;i<br><span class="hljs-string">&quot; inoremap ( ()&lt;ESC&gt;i</span><br><span class="hljs-string">&quot; inoremap [ []&lt;ESC&gt;i</span><br><span class="hljs-string">&quot; inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发机部署</title>
    <link href="/2020/07/30/04DevOps/01%E5%BC%80%E5%8F%91%E6%9C%BA%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/07/30/04DevOps/01%E5%BC%80%E5%8F%91%E6%9C%BA%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="开发机部署"><a href="#开发机部署" class="headerlink" title="开发机部署"></a>开发机部署</h1><h3 id="修改服务器名"><a href="#修改服务器名" class="headerlink" title="修改服务器名"></a>修改服务器名</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>实际修改的是/proc/sys/kernel/hostname的内容</p><h3 id="安装开发包"><a href="#安装开发包" class="headerlink" title="安装开发包"></a>安装开发包</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">yum</span> <span class="hljs-comment">install</span> <span class="hljs-comment">gcc</span><span class="hljs-literal">-</span><span class="hljs-comment">c</span>++ <span class="hljs-comment">cmake</span> <br></code></pre></td></tr></table></figure><h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum update</span>  <br></code></pre></td></tr></table></figure><h3 id="安装python2-7"><a href="#安装python2-7" class="headerlink" title="安装python2.7"></a>安装python2.7</h3><p>安装python2.7的时候使用以下选项编译</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">./configure  --enable-shared <span class="hljs-attribute">CFLAGS</span>=-fPIC <span class="hljs-attribute">--enable-unicode</span>=ucs4<br></code></pre></td></tr></table></figure><p>然后再安装python</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> git<br></code></pre></td></tr></table></figure><h3 id="安装vim8"><a href="#安装vim8" class="headerlink" title="安装vim8"></a>安装vim8</h3><h5 id="先安装依赖包"><a href="#先安装依赖包" class="headerlink" title="先安装依赖包"></a>先安装依赖包</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">yum <span class="hljs-keyword">install </span>ncurses-devel<br>yum <span class="hljs-keyword">install </span>python-devel<br>yum <span class="hljs-keyword">install </span>perl-<span class="hljs-keyword">ExtUtils-Embed</span><br><span class="hljs-keyword"></span>yum <span class="hljs-keyword">install </span>ruby<br>yum <span class="hljs-keyword">install </span>ruby-devel<br>yum <span class="hljs-keyword">install </span>clang-devel<br></code></pre></td></tr></table></figure><h5 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h5><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./configure</span> <span class="hljs-params">--with-features=huge</span> <span class="hljs-params">--enable-multibyte</span>  <span class="hljs-params">--enable-pythoninterp</span> <span class="hljs-params">--enable-rubyinterp</span>  <span class="hljs-params">--enable-luainterp</span> <span class="hljs-params">--enable-cscope</span><br><br>make VIMRUNTIMEDIR=<span class="hljs-string">/usr/local/share/vim/vim80</span><br>make install<br><br>ubuntu 使用如下语法<br><span class="hljs-string">./configure</span> <span class="hljs-params">--with-features=huge</span> <span class="hljs-params">--enable-multibyte</span> <span class="hljs-params">--enable-rubyinterp=yes</span> <span class="hljs-params">--enable-python3interp=yes</span> <span class="hljs-params">--with-python3-config-dir=</span>$<span class="hljs-params">(python3-config --configdir)</span> <span class="hljs-params">--enable-perlinterp=yes</span> <span class="hljs-params">--enable-luainterp=yes</span> <span class="hljs-params">--enable-gui=gtk2</span> <span class="hljs-params">--enable-cscope</span><br><br></code></pre></td></tr></table></figure><h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><p>mkdir ~/.vim/bundle</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/gmarik/</span>vundle.git ~<span class="hljs-regexp">/.vim/</span>bundle/Vundle.vim<br></code></pre></td></tr></table></figure><h6 id="安装commond-t"><a href="#安装commond-t" class="headerlink" title="安装commond-t"></a>安装commond-t</h6><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/.vim/</span>bundle<span class="hljs-regexp">/command-t/</span>ruby<span class="hljs-regexp">/command-t/</span>ext<span class="hljs-regexp">/command-t/</span><br><br>ruby extconf.rb<br><br>make<br></code></pre></td></tr></table></figure><h6 id="安装YouCompleteMe"><a href="#安装YouCompleteMe" class="headerlink" title="安装YouCompleteMe"></a>安装YouCompleteMe</h6><p>上传clang+llvm-5.0.0-linux-x86_64-ubuntu14.04.tar.xz到.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/../clang_archives/ 目录下</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<span class="hljs-string">/.vim/bundle/YouCompleteMe</span><br><span class="hljs-string">./install.py</span> <span class="hljs-params">--clang-completer</span><br></code></pre></td></tr></table></figure><h3 id="安装gcc的debug调试信息"><a href="#安装gcc的debug调试信息" class="headerlink" title="安装gcc的debug调试信息"></a>安装gcc的debug调试信息</h3><ul><li><p>修改配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/yum</span>.repos.d/CentOS-Debuginfo.repo<br></code></pre></td></tr></table></figure><p>将其中的==enabled=0==修改为==enabled=1==</p></li><li><p>执行如下命令安装：</p></li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">debuginfo</span><span class="hljs-literal">-</span><span class="hljs-comment">install</span> <span class="hljs-comment">libgcc</span>  <span class="hljs-comment">libstdc</span>++  <span class="hljs-comment">nss</span><span class="hljs-literal">-</span><span class="hljs-comment">softokn</span><span class="hljs-literal">-</span><span class="hljs-comment">freebl</span>  <span class="hljs-comment">zlib</span> <br></code></pre></td></tr></table></figure><ul><li>gdb7.0多线程non-stop模式开启</li></ul><p>此模式可以保证只调试某个线程，在~/.gdbinit中添加以下内容</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">set</span> target-<span class="hljs-keyword">async</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">set</span> pagination <span class="hljs-keyword">off</span><br><span class="hljs-keyword">set</span> non-<span class="hljs-keyword">stop</span> <span class="hljs-keyword">on</span><br></code></pre></td></tr></table></figure><h3 id="部署c-的man帮助文档"><a href="#部署c-的man帮助文档" class="headerlink" title="部署c++的man帮助文档"></a>部署c++的man帮助文档</h3><ul><li>从站点下载libstdc++-api-4.5.2.man.tar压缩</li></ul><p><a href="">ftp://gcc.gnu.org/pub/gcc/libstdc++/doxygen/</a></p><ul><li>解压文件并拷贝内容到man3目录下<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -jxvf libstdc++-api-<span class="hljs-number">4</span>.<span class="hljs-number">5</span>.<span class="hljs-number">2</span>.man.tar<br><span class="hljs-attribute">cd</span> libstdc++-api-<span class="hljs-number">4</span>.<span class="hljs-number">5</span>.<span class="hljs-number">2</span>/man<span class="hljs-number">3</span>/<br><span class="hljs-attribute">cp</span> * /usr/share/man/man<span class="hljs-number">3</span>/<br></code></pre></td></tr></table></figure></li></ul><h1 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h1><div class="code-wrapper"><pre><code class="hljs">- 先更新系统，sudo apt-get update- 再按照centos部署方式进行部署</code></pre></div><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><div class="code-wrapper"><pre><code class="hljs">sudo apt-get install libncurses5-dev libgnome2-dev libgnomeui-dev libgtk2.0-dev libatk1.0-dev libbonoboui2-dev libcairo2-dev libx11-dev libxpm-dev libxt-dev python-dev  python3-dev ruby-dev lua5.1 liblua5.1-dev libperl-dev git  python-requests</code></pre></div><h2 id="ruby-安装"><a href="#ruby-安装" class="headerlink" title="ruby 安装"></a>ruby 安装</h2><div class="code-wrapper"><pre><code class="hljs">apt-get install rubyapt-get install ruby-dev</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多版本gcc部署</title>
    <link href="/2020/07/30/04DevOps/02%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/07/30/04DevOps/02%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="安装scl源："><a href="#安装scl源：" class="headerlink" title="安装scl源："></a>安装scl源：</h2><p>yum install centos-release-SCL scl-utils-build</p><h2 id="查看从-SCL-中安装的包的列表："><a href="#查看从-SCL-中安装的包的列表：" class="headerlink" title="查看从 SCL 中安装的包的列表："></a>查看从 SCL 中安装的包的列表：</h2><p>scl –list</p><h2 id="列出scl源有哪些包可以用："><a href="#列出scl源有哪些包可以用：" class="headerlink" title="列出scl源有哪些包可以用："></a>列出scl源有哪些包可以用：</h2><p>yum list all –enablerepo=’centos-sclo-rh’</p><h2 id="查看从-SCL-中安装的包的列表：-1"><a href="#查看从-SCL-中安装的包的列表：-1" class="headerlink" title="查看从 SCL 中安装的包的列表："></a>查看从 SCL 中安装的包的列表：</h2><p>scl –list</p><h2 id="安装5-3版本的gcc、gcc-c"><a href="#安装5-3版本的gcc、gcc-c" class="headerlink" title="安装5.3版本的gcc、gcc-c++"></a>安装5.3版本的gcc、gcc-c++</h2><p>yum install devtoolset-4-gcc.x86_64 devtoolset-4-gcc-c++.x86_64</p><h2 id="切换到devtoolset-4环境："><a href="#切换到devtoolset-4环境：" class="headerlink" title="切换到devtoolset-4环境："></a>切换到devtoolset-4环境：</h2><p>scl enable devtoolset-4 bash</p><h2 id="安装6-3版本gcc-gcc-c-等"><a href="#安装6-3版本gcc-gcc-c-等" class="headerlink" title="安装6.3版本gcc,gcc-c++ 等"></a>安装6.3版本gcc,gcc-c++ 等</h2><p>yum install devtoolset-6-gcc.x86_64 devtoolset-6-gcc-c++.x86_64 devtoolset-6-gcc-gdb-plugin.x86_64 devtoolset-6-libasan-devel.x86_64 libasan3-6.3.1-3.1.el7.x86_64 -y</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gcc,</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pika 运维命令</title>
    <link href="/2020/07/29/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/02%20Pika/pika%20%E8%BF%90%E7%BB%B4%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/29/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/02%20Pika/pika%20%E8%BF%90%E7%BB%B4%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、运维经验"><a href="#一、运维经验" class="headerlink" title="一、运维经验"></a>一、运维经验</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-number">1</span>、可能的话将整个pika目录放到ssd磁盘<br><span class="hljs-number">2</span>、从节点全量同步数据的时候会将主节点所有数据同步到<span class="hljs-keyword">var</span>/dbsync目录下，所以此空间一定足够<br><span class="hljs-number">3</span>、<br></code></pre></td></tr></table></figure><h1 id="二、命令"><a href="#二、命令" class="headerlink" title="二、命令"></a>二、命令</h1><h2 id="pika-停止命令"><a href="#pika-停止命令" class="headerlink" title="pika 停止命令"></a>pika 停止命令</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./redis-cli</span> -h 127.0.0.1 -p 9221 <span class="hljs-keyword">shutdown</span><br></code></pre></td></tr></table></figure><h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/whb/</span>pika<span class="hljs-regexp">/sbin/</span>pika -c <span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/whb/</span>pika<span class="hljs-regexp">/conf/</span>pika.conf<br></code></pre></td></tr></table></figure><h2 id="内存碎片整理"><a href="#内存碎片整理" class="headerlink" title="内存碎片整理"></a>内存碎片整理</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">./redis-cli -h <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> -p <span class="hljs-number">9221</span> tcmalloc free<br></code></pre></td></tr></table></figure><h2 id="将从节点与主节点断开"><a href="#将从节点与主节点断开" class="headerlink" title="将从节点与主节点断开"></a>将从节点与主节点断开</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">登录从节点后执行<br>slaveof <span class="hljs-keyword">no</span> <span class="hljs-keyword">one</span><br></code></pre></td></tr></table></figure><h2 id="从新将节点加入为主节点的从"><a href="#从新将节点加入为主节点的从" class="headerlink" title="从新将节点加入为主节点的从"></a>从新将节点加入为主节点的从</h2><p>执行从与主断开后执行以下语句</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"># ip <span class="hljs-keyword">port</span> 为master节点信息<br>slaveof ip <span class="hljs-keyword">port</span>  <br></code></pre></td></tr></table></figure><h1 id="三、编译"><a href="#三、编译" class="headerlink" title="三、编译"></a>三、编译</h1><p>使用 gperftools-2.7</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>数据库</tag>
      
      <tag>pika</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Shell命令获取IP地址</title>
    <link href="/2020/07/27/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/09%E5%88%A9%E7%94%A8Shell%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80/"/>
    <url>/2020/07/27/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/09%E5%88%A9%E7%94%A8Shell%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="获取单个网卡的IPv4地址，方法如下："><a href="#获取单个网卡的IPv4地址，方法如下：" class="headerlink" title="获取单个网卡的IPv4地址，方法如下："></a>获取单个网卡的IPv4地址，方法如下：</h1><ul><li><p>方法一：<br>  <code>$/sbin/ifconfig ethX | awk &#39;/inet addr/ &#123;print $2&#125;&#39; | cut -f2 -d &quot;:&quot;</code></p></li><li><p>方法二：<br>  <code> $/sbin/ifconfig ethX | awk &#39;/inet addr/ &#123;print $2&#125;&#39; | awk -F: &#39;&#123;print $2&#125;&#39;</code></p></li><li><p>方法三：<br>  <code>$/sbin/ifconfig ethX | sed -ne &#39;s/\(.*\)addr:\([[:digit:].]*\)\(.*\)/\2/p&#39;</code></p></li></ul><p>把ethX中的X替换为需要查看网卡的序号，如eth0,eth1…</p><h1 id="获得本机所有网卡的IPv4地址，方法如下："><a href="#获得本机所有网卡的IPv4地址，方法如下：" class="headerlink" title="获得本机所有网卡的IPv4地址，方法如下："></a>获得本机所有网卡的IPv4地址，方法如下：</h1><div class="code-wrapper"><pre><code class="hljs">`$/sbin/ifconfig | awk &#39;&#123;if ( $1 == &quot;inet&quot; &amp;&amp; $3 ~ /^Bcast/) print $2&#125;&#39; | cut -f2 -d &quot;:&quot;`</code></pre></div><p>如果是IPv6网络，把上面的命令做简单修改即可，如：</p><p>$/sbin/ifconfig | awk ‘/inet6/ {print $3}’ —-全部<br>$/sbin/ifconfig ethX | awk ‘/inet6/ {print $3}’ —-单个</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MD5算法原理</title>
    <link href="/2020/07/27/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02MD5%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <url>/2020/07/27/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02MD5%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>MD5算法是一种消息摘要算法(Message Digest Algorithm)，此算法以任意长度的信息(message)作为输入进行计算，产生一个128-bit(16-byte)的指纹或报文摘要(fingerprint or message digest)。两个不同的message产生相同message digest的几率相当小，从一个给定的message digest逆向产生原始message更是困难(不过据说我国的某个教授很善于从message digest构造message)，因此MD5算法适合用在数字签名应用中。MD5实现简单，在32位的机器上运行速度也相当快，当然实际应用也不仅仅局限于数字签名。</p><h1 id="2-MD5-Algorithm-Description"><a href="#2-MD5-Algorithm-Description" class="headerlink" title="2. MD5 Algorithm Description"></a>2. MD5 Algorithm Description</h1><p>假设输入信息(input message)的长度为b(bit)，我们想要产生它的报文摘要，在此处b为任意的非负整数：b也可能为0，也不一定为8的整数倍，且可能是任意大的长度。设该信息的比特流表示如下：</p><p>M[0] M[1] M[2] … M[b-1]</p><p>计算此信息的报文摘要需要如下5步：</p><h2 id="2-1-Append-Padding-Bits"><a href="#2-1-Append-Padding-Bits" class="headerlink" title="2.1 Append Padding Bits"></a>2.1 Append Padding Bits</h2><p>信息计算前先要进行位补位，设补位后信息的长度为LEN(bit)，则LEN%512 = 448(bit)，即数据扩展至<br>K<em>512+448(bit)。即K</em>64+56(byte)，K为整数。补位操作始终要执行，即使补位前信息的长度对512求余的结果是448。具体补位操作：补一个1，然后补0至满足上述要求。总共最少要补1bit，最多补512bit。</p><h2 id="2-2-Append-Length"><a href="#2-2-Append-Length" class="headerlink" title="2.2 Append Length"></a>2.2 Append Length</h2><p>将输入信息的原始长度b(bit)表示成一个64-bit的数字，把它添加到上一步的结果后面(在32位的机器上，这64位将用2个字来表示并且低位在前)。当遇到b大于2^64这种极少的情况时，b的高位被截去，仅使用b的低64位。经过上面两步，数据就被填补成长度为512(bit)的倍数。也就是说，此时的数据长度是16个字(32byte)的整数倍。此时的数据表示为：</p><p>M[0 … N-1]</p><p>其中的N是16的倍数。</p><h2 id="2-3-Initialize-MD-Buffer"><a href="#2-3-Initialize-MD-Buffer" class="headerlink" title="2.3 Initialize MD Buffer"></a>2.3 Initialize MD Buffer</h2><p>用一个四个字的缓冲器(A，B，C，D)来计算报文摘要，A,B,C,D分别是32位的寄存器，初始化使用的是十六进制表示的数字，注意低字节在前：</p><p>word A: 01 23 45 67<br>word B: 89 ab cd ef<br>word C: fe dc ba 98<br>word D: 76 54 32 10</p><h2 id="2-4-Process-Message-in-16-Word-Blocks"><a href="#2-4-Process-Message-in-16-Word-Blocks" class="headerlink" title="2.4 Process Message in 16-Word Blocks"></a>2.4 Process Message in 16-Word Blocks</h2><p>首先定义4个辅助函数，每个函数的输入是三个32位的字，输出是一个32位的字：</p><p>F(X,Y,Z) = XY v not(X) Z<br>G(X,Y,Z) = XZ v Y not(Z)<br>H(X,Y,Z) = X xor Y xor Z<br>I(X,Y,Z) = Y xor (X v not(Z))</p><p>NOTE：not(X)代表X的按位补运算，X v Y 表示X和Y的按位或运算，X xor Y代表X和Y的按位异或运算，XY代表X和Y的按位与运算。</p><p>具体过程如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-comment">/* Process each 16-word block. */</span><br><span class="hljs-symbol">For</span> i = <span class="hljs-number">0</span> to <span class="hljs-symbol">N</span>/<span class="hljs-number">16</span><span class="hljs-number">-1</span> do<br><br><span class="hljs-comment">/* Copy block i into X. */</span><br><span class="hljs-symbol">For</span> j = <span class="hljs-number">0</span> to <span class="hljs-number">15</span> do<br><span class="hljs-symbol">Set</span> <span class="hljs-symbol">X</span>[j] to <span class="hljs-symbol">M</span>[i*<span class="hljs-number">16</span>+j].<br>end <span class="hljs-comment">/* of loop on j */</span><br><br><span class="hljs-comment">/* Save A as AA, B as BB, C as CC, and D as DD. */</span><br><span class="hljs-symbol">AA</span> = <span class="hljs-symbol">A</span><br><span class="hljs-symbol">BB</span> = <span class="hljs-symbol">B</span><br><span class="hljs-symbol">CC</span> = <span class="hljs-symbol">C</span><br><span class="hljs-symbol">DD</span> = <span class="hljs-symbol">D</span><br><br><span class="hljs-comment">/* Round 1. */</span><br><span class="hljs-comment">/* Let [abcd k s i] denote the operation</span><br><span class="hljs-comment">a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */</span><br><span class="hljs-comment">/* Do the following 16 operations. */</span><br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">1</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">1</span> <span class="hljs-number">12</span> <span class="hljs-number">2</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">2</span> <span class="hljs-number">17</span> <span class="hljs-number">3</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">3</span> <span class="hljs-number">22</span> <span class="hljs-number">4</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">5</span> <span class="hljs-number">12</span> <span class="hljs-number">6</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">6</span> <span class="hljs-number">17</span> <span class="hljs-number">7</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">7</span> <span class="hljs-number">22</span> <span class="hljs-number">8</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">10</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">10</span> <span class="hljs-number">17</span> <span class="hljs-number">11</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">11</span> <span class="hljs-number">22</span> <span class="hljs-number">12</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">12</span> <span class="hljs-number">7</span> <span class="hljs-number">13</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">13</span> <span class="hljs-number">12</span> <span class="hljs-number">14</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">14</span> <span class="hljs-number">17</span> <span class="hljs-number">15</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">15</span> <span class="hljs-number">22</span> <span class="hljs-number">16</span>]<br><br><span class="hljs-comment">/* Round 2. */</span><br><span class="hljs-comment">/* Let [abcd k s i] denote the operation</span><br><span class="hljs-comment">a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */</span><br><span class="hljs-comment">/* Do the following 16 operations. */</span><br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">17</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">18</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">11</span> <span class="hljs-number">14</span> <span class="hljs-number">19</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">21</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">10</span> <span class="hljs-number">9</span> <span class="hljs-number">22</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">15</span> <span class="hljs-number">14</span> <span class="hljs-number">23</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">4</span> <span class="hljs-number">20</span> <span class="hljs-number">24</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span> <span class="hljs-number">25</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">14</span> <span class="hljs-number">9</span> <span class="hljs-number">26</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">3</span> <span class="hljs-number">14</span> <span class="hljs-number">27</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">8</span> <span class="hljs-number">20</span> <span class="hljs-number">28</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">13</span> <span class="hljs-number">5</span> <span class="hljs-number">29</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span> <span class="hljs-number">30</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">7</span> <span class="hljs-number">14</span> <span class="hljs-number">31</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">12</span> <span class="hljs-number">20</span> <span class="hljs-number">32</span>]<br><br><span class="hljs-comment">/* Round 3. */</span><br><span class="hljs-comment">/* Let [abcd k s t] denote the operation</span><br><span class="hljs-comment">a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */</span><br><span class="hljs-comment">/* Do the following 16 operations. */</span><br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">33</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">8</span> <span class="hljs-number">11</span> <span class="hljs-number">34</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">11</span> <span class="hljs-number">16</span> <span class="hljs-number">35</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">14</span> <span class="hljs-number">23</span> <span class="hljs-number">36</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">37</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">4</span> <span class="hljs-number">11</span> <span class="hljs-number">38</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">7</span> <span class="hljs-number">16</span> <span class="hljs-number">39</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">10</span> <span class="hljs-number">23</span> <span class="hljs-number">40</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">13</span> <span class="hljs-number">4</span> <span class="hljs-number">41</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">0</span> <span class="hljs-number">11</span> <span class="hljs-number">42</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">3</span> <span class="hljs-number">16</span> <span class="hljs-number">43</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">6</span> <span class="hljs-number">23</span> <span class="hljs-number">44</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">45</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">12</span> <span class="hljs-number">11</span> <span class="hljs-number">46</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">47</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">2</span> <span class="hljs-number">23</span> <span class="hljs-number">48</span>]<br><br><span class="hljs-comment">/* Round 4. */</span><br><span class="hljs-comment">/* Let [abcd k s t] denote the operation</span><br><span class="hljs-comment">a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt;&lt;&lt; s). */</span><br><span class="hljs-comment">/* Do the following 16 operations. */</span><br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">0</span> <span class="hljs-number">6</span> <span class="hljs-number">49</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">50</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">51</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">5</span> <span class="hljs-number">21</span> <span class="hljs-number">52</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">12</span> <span class="hljs-number">6</span> <span class="hljs-number">53</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">3</span> <span class="hljs-number">10</span> <span class="hljs-number">54</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">10</span> <span class="hljs-number">15</span> <span class="hljs-number">55</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">1</span> <span class="hljs-number">21</span> <span class="hljs-number">56</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span> <span class="hljs-number">57</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> <span class="hljs-number">58</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">6</span> <span class="hljs-number">15</span> <span class="hljs-number">59</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">13</span> <span class="hljs-number">21</span> <span class="hljs-number">60</span>]<br>[<span class="hljs-symbol">ABCD</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">61</span>] [<span class="hljs-symbol">DABC</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">62</span>] [<span class="hljs-symbol">CDAB</span> <span class="hljs-number">2</span> <span class="hljs-number">15</span> <span class="hljs-number">63</span>] [<span class="hljs-symbol">BCDA</span> <span class="hljs-number">9</span> <span class="hljs-number">21</span> <span class="hljs-number">64</span>]<br><br><span class="hljs-comment">/* Then perform the following additions. (That is increment each</span><br><span class="hljs-comment">of the four registers by the value it had before this block</span><br><span class="hljs-comment">was started.) */</span><br><span class="hljs-symbol">A</span> = <span class="hljs-symbol">A</span> + <span class="hljs-symbol">AA</span><br><span class="hljs-symbol">B</span> = <span class="hljs-symbol">B</span> + <span class="hljs-symbol">BB</span><br><span class="hljs-symbol">C</span> = <span class="hljs-symbol">C</span> + <span class="hljs-symbol">CC</span><br><span class="hljs-symbol">D</span> = <span class="hljs-symbol">D</span> + <span class="hljs-symbol">DD</span><br><br>end <span class="hljs-comment">/* of loop on i */</span><br></code></pre></td></tr></table></figure><h2 id="2-5-Output"><a href="#2-5-Output" class="headerlink" title="2.5 Output"></a>2.5 Output</h2><p>报文摘要的产生后的形式为：A，B，C，D。也就是低位字节A开始，高位字节D结束。</p><h1 id="3-C-Implementation"><a href="#3-C-Implementation" class="headerlink" title="3. C++ Implementation"></a>3. C++ Implementation</h1><p>有了上面5个步骤的算法描述，用C++实现起来就很直接了。需要注意的是在具体实现的时候上述5个步骤的顺序会有所变动，因为在大多数情况下我们都无法或很难提前计算出输入信息的长度b(如输入信息来自文件或网络)。因此在具体实现时Append Padding Bits和Append Length这两步会放在最后面。</p><h1 id="4-Test-Suite"><a href="#4-Test-Suite" class="headerlink" title="4. Test Suite"></a>4. Test Suite</h1><p>由于实现代码比较长，在这里就不贴出来了，在本文后面会提供下载。MD5类的public接口如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino">md5.h<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MD5</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MD5</span>();<br><span class="hljs-built_in">MD5</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* input, <span class="hljs-keyword">size_t</span> length);<br><span class="hljs-built_in">MD5</span>(<span class="hljs-keyword">const</span> string&amp; str);<br><span class="hljs-built_in">MD5</span>(ifstream &amp;in);<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* input, <span class="hljs-keyword">size_t</span> length)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; str)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(ifstream&amp; in)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">byte</span>* <span class="hljs-title">digest</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">string <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span></span>;<br> ...<br> &#125;;<br></code></pre></td></tr></table></figure><p>下面简单介绍一下具体用法：</p><h2 id="4-1-计算字符串的MD5值"><a href="#4-1-计算字符串的MD5值" class="headerlink" title="4.1 计算字符串的MD5值"></a>4.1 计算字符串的MD5值</h2><p>下面的代码计算字符串”abc”的MD5值并用cout输出：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">MD5 md5;<br>md5.update(<span class="hljs-string">&quot;abc&quot;</span>);<br>cout &lt;&lt; md5.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> &lt;&lt; endl;<br><span class="hljs-comment">//或者更简单点</span><br>cout &lt;&lt; <span class="hljs-constructor">MD5(<span class="hljs-string">&quot;abc&quot;</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="4-2-计算文件的MD5值"><a href="#4-2-计算文件的MD5值" class="headerlink" title="4.2 计算文件的MD5值"></a>4.2 计算文件的MD5值</h2><p>下面的代码计算文本文件”D:\test.txt”的MD5值并用cout输出，如果是二进制文件打开的时候记得要指定ios::binary模式。另外需要注意的是用来计算的文件必须存在，所以最好在计算前先判断下ifstream的状态。<br>(本来判断ifstream是否有效不该是客户的责任，原本想在ifstream无效时用文件名做参数抛出FileNotFoundException之类的异常，后来却发现从ifstream中居然无法得到文件名…)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">MD5 md5;<br>md5.update(ifstream(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>));<br>cout &lt;&lt; md5.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> &lt;&lt; endl;<br><span class="hljs-comment">//或者更简单点</span><br>cout &lt;&lt; <span class="hljs-constructor">MD5(<span class="hljs-params">ifstream</span>(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>)</span>).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h2 id="4-3-最基本的用法"><a href="#4-3-最基本的用法" class="headerlink" title="4.3 最基本的用法"></a>4.3 最基本的用法</h2><p>上面的用来计算字符串和文件MD5值的接口都是为了方便才提供的，其实最基本的接口是：<br>void update(const void *input, size_t length);<br>update的另外两个重载都是基于它来实现的，下面的代码用上述接口来实现FileDigest函数，该函数用来计算文件的MD5值：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">string <span class="hljs-title">FileDigest</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string&amp; file)</span> </span>&#123;<br><span class="hljs-function">ifstream <span class="hljs-title">in</span><span class="hljs-params">(file.c_str(), ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!in) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>MD5 md5;<br>std::streamsize length;<br><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span> (!in.<span class="hljs-built_in">eof</span>()) &#123;<br>in.<span class="hljs-built_in">read</span>(buffer, <span class="hljs-number">1024</span>);<br>length = in.<span class="hljs-built_in">gcount</span>();<br><span class="hljs-keyword">if</span> (length &gt; <span class="hljs-number">0</span>)<br>md5.<span class="hljs-built_in">update</span>(buffer, length);<br>&#125;<br>in.<span class="hljs-built_in">close</span>();<br><span class="hljs-keyword">return</span> md5.<span class="hljs-built_in">toString</span>();<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-下面看看测试代码："><a href="#4-4-下面看看测试代码：" class="headerlink" title="4.4 下面看看测试代码："></a>4.4 下面看看测试代码：</h2><p>test.cpp</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs q">#include <span class="hljs-string">&quot;md5.h&quot;</span><br>#include &lt;iostream&gt;<br><br>using namespace std;<br>void PrintMD5(const <span class="hljs-built_in">string</span>&amp; str, MD5&amp; <span class="hljs-built_in">md5</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;MD5(\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot;) = &quot;</span> &lt;&lt; <span class="hljs-built_in">md5</span>.toString() &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br>MD5 <span class="hljs-built_in">md5</span>;<br><span class="hljs-built_in">md5</span>.<span class="hljs-keyword">update</span>(<span class="hljs-string">&quot;&quot;</span>);<br>PrintMD5(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-built_in">md5</span>);<br><br><span class="hljs-built_in">md5</span>.<span class="hljs-keyword">update</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>PrintMD5(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">md5</span>);<br><br><span class="hljs-built_in">md5</span>.<span class="hljs-keyword">update</span>(<span class="hljs-string">&quot;bc&quot;</span>);<br>PrintMD5(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-built_in">md5</span>);<br><br><span class="hljs-built_in">md5</span>.<span class="hljs-keyword">update</span>(<span class="hljs-string">&quot;defghijklmnopqrstuvwxyz&quot;</span>);<br>PrintMD5(<span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>, <span class="hljs-built_in">md5</span>);<br><br><span class="hljs-built_in">md5</span>.reset();<br><span class="hljs-built_in">md5</span>.<span class="hljs-keyword">update</span>(<span class="hljs-string">&quot;message digest&quot;</span>);<br>PrintMD5(<span class="hljs-string">&quot;message digest&quot;</span>, <span class="hljs-built_in">md5</span>);<br><br><span class="hljs-built_in">md5</span>.reset();<br><span class="hljs-built_in">md5</span>.<span class="hljs-keyword">update</span>(ifstream(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>));<br>PrintMD5(<span class="hljs-string">&quot;D:\\test.txt&quot;</span>, <span class="hljs-built_in">md5</span>);<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MD5</span>(<span class="hljs-string">&quot;&quot;</span>) = d<span class="hljs-number">41</span>d<span class="hljs-number">8</span>cd<span class="hljs-number">98</span>f<span class="hljs-number">00</span>b<span class="hljs-number">204</span>e<span class="hljs-number">9800998</span>ecf<span class="hljs-number">8427</span>e<br><span class="hljs-attribute">MD5</span>(<span class="hljs-string">&quot;a&quot;</span>) = <span class="hljs-number">0</span>cc<span class="hljs-number">175</span>b<span class="hljs-number">9</span>c<span class="hljs-number">0</span>f<span class="hljs-number">1</span>b<span class="hljs-number">6</span>a<span class="hljs-number">831</span>c<span class="hljs-number">399</span>e<span class="hljs-number">269772661</span><br><span class="hljs-attribute">MD5</span>(<span class="hljs-string">&quot;abc&quot;</span>) = <span class="hljs-number">900150983</span>cd<span class="hljs-number">24</span>fb<span class="hljs-number">0</span>d<span class="hljs-number">6963</span>f<span class="hljs-number">7</span>d<span class="hljs-number">28</span>e<span class="hljs-number">17</span>f<span class="hljs-number">72</span><br><span class="hljs-attribute">MD5</span>(<span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>) = c<span class="hljs-number">3</span>fcd<span class="hljs-number">3</span>d<span class="hljs-number">76192</span>e<span class="hljs-number">4007</span>dfb<span class="hljs-number">496</span>cca<span class="hljs-number">67</span>e<span class="hljs-number">13</span>b<br><span class="hljs-attribute">MD5</span>(<span class="hljs-string">&quot;message digest&quot;</span>) = f<span class="hljs-number">96</span>b<span class="hljs-number">697</span>d<span class="hljs-number">7</span>cb<span class="hljs-number">7938</span>d<span class="hljs-number">525</span>a<span class="hljs-number">2</span>f<span class="hljs-number">31</span>aaf<span class="hljs-number">161</span>d<span class="hljs-number">0</span><br><span class="hljs-attribute">MD5</span>(<span class="hljs-string">&quot;D:\test.txt&quot;</span>) = <span class="hljs-number">7</span>ac<span class="hljs-number">66</span>c<span class="hljs-number">0</span>f<span class="hljs-number">148</span>de<span class="hljs-number">9519</span>b<span class="hljs-number">8</span>bd<span class="hljs-number">264312</span>c<span class="hljs-number">4</span>d<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><h1 id="5-测试程序"><a href="#5-测试程序" class="headerlink" title="5 测试程序"></a>5 测试程序</h1><a href="/2020/07/27/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02MD5%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/md5_test.rar" title="md5_test">md5_test</a>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用git命令</title>
    <link href="/2020/07/27/04DevOps/00%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/27/04DevOps/00%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><h3 id="1-远程主机操作"><a href="#1-远程主机操作" class="headerlink" title="1. 远程主机操作"></a>1. 远程主机操作</h3><div class="code-wrapper"><pre><code class="hljs">// 查看该主机的详细信息$ git remote show &lt;主机名&gt;// 添加远程主机，添加后通过《 8.取回远程主机某个分支的更新》来建立本地新的分支$ git remote add &lt;主机名&gt; &lt;网址&gt;// 删除远程主机$ git remote rm &lt;主机名&gt;远程主机的改名$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></pre></div><h3 id="2-checkout-远端指定分支"><a href="#2-checkout-远端指定分支" class="headerlink" title="2.checkout 远端指定分支"></a>2.checkout 远端指定分支</h3><div class="code-wrapper"><pre><code class="hljs">$ git checkout -b xxxx&lt;本地分支名称&gt; yyyy&lt;远端分支名&gt;</code></pre></div><h3 id="3-合并多个commit"><a href="#3-合并多个commit" class="headerlink" title="3.合并多个commit"></a>3.合并多个commit</h3><div class="code-wrapper"><pre><code class="hljs">$ git rebase -i HEAD~n  // 将commit的前n个合并，在出现的窗口中将要合并的pick修改为squash$ git push -f</code></pre></div><h3 id="4-清理远端已经删除的本地分支"><a href="#4-清理远端已经删除的本地分支" class="headerlink" title="4.清理远端已经删除的本地分支"></a>4.清理远端已经删除的本地分支</h3><div class="code-wrapper"><pre><code class="hljs">$ git pull -p// 等同于下面的命令$ git fetch --prune origin $ git fetch -p</code></pre></div><h3 id="5-删除远端分支"><a href="#5-删除远端分支" class="headerlink" title="5.删除远端分支"></a>5.删除远端分支</h3><div class="code-wrapper"><pre><code class="hljs">$ git push origin :xxx// 等同于$ git push origin --delete xxx</code></pre></div><h3 id="6-清理本地没有的tag"><a href="#6-清理本地没有的tag" class="headerlink" title="6.清理本地没有的tag"></a>6.清理本地没有的tag</h3><div class="code-wrapper"><pre><code class="hljs">// 先清理本地所有tag再获取远端的tag$ git tag -l | xargs git tag -d$ git fetch -t -p -f</code></pre></div><h3 id="7-推送到远端"><a href="#7-推送到远端" class="headerlink" title="7.推送到远端"></a>7.推送到远端</h3><div class="code-wrapper"><pre><code class="hljs">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;// 将本地分支推送到远端特定分支时出错先使用merge命令将远程分支合并到本地并解决冲突后提交, 然后再使用push命令$ git merge &lt;远程主机名&gt;/&lt;远程分支名&gt;</code></pre></div><h3 id="8-取回远程主机某个分支的更新"><a href="#8-取回远程主机某个分支的更新" class="headerlink" title="8.取回远程主机某个分支的更新"></a>8.取回远程主机某个分支的更新</h3><div class="code-wrapper"><pre><code class="hljs">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre></div><h3 id="9-撤销commit，但未git-push的命令"><a href="#9-撤销commit，但未git-push的命令" class="headerlink" title="9.撤销commit，但未git push的命令"></a>9.撤销commit，但未git push的命令</h3><div class="code-wrapper"><pre><code class="hljs">// 完成撤销,同时将代码恢复到前一commit_id 对应的版本$ git reset --hard id // 完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改$ git reset id // 撤销当前的所有修改$ git reset --hard HEAD</code></pre></div><h3 id="10-master-回退服务端到特定版本"><a href="#10-master-回退服务端到特定版本" class="headerlink" title="10. master 回退服务端到特定版本"></a>10. master 回退服务端到特定版本</h3><div class="code-wrapper"><pre><code class="hljs">// checkout 要回退的当前最新版(如源名是upstream)$ git checkout -b upstream_master upstream/master// 回退到2295c189c22b960e2852f5b0495c7173b404b270 $ git reset --hard 2295c189c22b960e2852f5b0495c7173b404b270// 强制推送当前版本到主干$ git push upstream HEAD:master</code></pre></div><h3 id="11-比较两个版本间的差异"><a href="#11-比较两个版本间的差异" class="headerlink" title="11.比较两个版本间的差异"></a>11.比较两个版本间的差异</h3><div class="code-wrapper"><pre><code class="hljs">$ git diff commit_id_old commit_id_new</code></pre></div><h3 id="12-更改远端分支"><a href="#12-更改远端分支" class="headerlink" title="12.更改远端分支"></a>12.更改远端分支</h3><div class="code-wrapper"><pre><code class="hljs">// 先删除老的分支$ git push --delete origin old_branch// 修改本地的分支名$ git branch -m old_branch new_branch// 推送本地的新分支到远端$ git push origin new_branch:new_branch</code></pre></div><h3 id="13-生成patch"><a href="#13-生成patch" class="headerlink" title="13.生成patch"></a>13.生成patch</h3><div class="code-wrapper"><pre><code class="hljs">// 生成从commitid为xxx到当前提交的patch，每个提交一个patch文件, 存放在当前的dir目录下$ git format-patch xxx -o dir</code></pre></div><h3 id="14-应用patch"><a href="#14-应用patch" class="headerlink" title="14.应用patch"></a>14.应用patch</h3><div class="code-wrapper"><pre><code class="hljs">// 先检测xxx.patch文件是否和当前的版本有冲突$ git apply --check xxx.patch// 再将xxx.patch合并到当前的分支中$ git apply xxx.patch</code></pre></div><h3 id="15-修改源地址"><a href="#15-修改源地址" class="headerlink" title="15.修改源地址"></a>15.修改源地址</h3><div class="code-wrapper"><pre><code class="hljs">$ git remove set-url origin newaddr</code></pre></div><h3 id="16-合并某个commit到当前aa分支上"><a href="#16-合并某个commit到当前aa分支上" class="headerlink" title="16.合并某个commit到当前aa分支上"></a>16.合并某个commit到当前aa分支上</h3><div class="code-wrapper"><pre><code class="hljs">// 其中commit_id是某个非aa分支上的commit_id$ git checkout aa$ git cherry-pick commit_id</code></pre></div><h3 id="17-修改分支名"><a href="#17-修改分支名" class="headerlink" title="17. 修改分支名"></a>17. 修改分支名</h3><div class="code-wrapper"><pre><code class="hljs">$ git  branch -m old_branch new_branch</code></pre></div><h3 id="18-合并分支多个commit到主分支，使主分支只有有一个干净清晰的log"><a href="#18-合并分支多个commit到主分支，使主分支只有有一个干净清晰的log" class="headerlink" title="18. 合并分支多个commit到主分支，使主分支只有有一个干净清晰的log"></a>18. 合并分支多个commit到主分支，使主分支只有有一个干净清晰的log</h3><div class="code-wrapper"><pre><code class="hljs">$ git checkout master //切换回主分支$ git pull origin master //拉取远端master代码$ git merge --squash 分支名  //如遇冲突就解决冲突$ git commit -m &quot;这里是注释&quot;$ git push origin master //提交master代码到远端</code></pre></div><h3 id="19-git-submodule-添加子仓库"><a href="#19-git-submodule-添加子仓库" class="headerlink" title="19.git submodule 添加子仓库"></a>19.git submodule 添加子仓库</h3><p>Git Submodule 允许一个git仓库，作为另一个git仓库的子目录，并且保持父项目和子项目相互独立</p><div class="code-wrapper"><pre><code class="hljs">// 查看子模块git submodule// 为当前工程添加指定分支 xx 的 submodulegit submodule add -b xx &lt;仓库地址&gt; &lt;本地路径&gt;// 为当前工程添加submodulegit submodule add &lt;仓库地址&gt; &lt;本地路径&gt;// 下载的工程带有submodule,使用以下命令下载子模块内容git submodule update --init --recursive// 更新子模块为远程项目的最新版本git submodule update --remote// 删除子模块需要经过以下4步, 以删除assets文件夹为例    // 1. 删除子模块文件夹    git rm --cached assets    // 2. 删除.gitmodules文件中相关子模块信息    // 3. 删除.git/config中的相关子模块信息    // 4. 删除.git/modules/src/文件夹中的相关子模块文件</code></pre></div><h3 id="20-更新源地址"><a href="#20-更新源地址" class="headerlink" title="20 更新源地址"></a>20 更新源地址</h3><div class="code-wrapper"><pre><code class="hljs">$ git remote set-url origin &lt;new_addr&gt;</code></pre></div><h3 id="21-创建空白分支"><a href="#21-创建空白分支" class="headerlink" title="21 创建空白分支"></a>21 创建空白分支</h3><div class="code-wrapper"><pre><code class="hljs">利用git checkout的 --orphan参数来建立一个没有任何历史记录的空分支// 1. 建立命令为空分支git checkout --orphan test_empty// 2. 删除所有文件, 注意后面的.git rm -rf .// 3. 添加新的文件, 未添加新的文件则分支 test_empty 不可见git add xxxgit ci -a &quot;add xxx file&quot;// 4. 推送到远端git push --set-upstream origin test_empty</code></pre></div><h3 id="22-查看当前配置信息"><a href="#22-查看当前配置信息" class="headerlink" title="22 查看当前配置信息"></a>22 查看当前配置信息</h3><div class="code-wrapper"><pre><code class="hljs">// 查看全局配置信息git config --system --list// 查看当前用户的global全局配置git config --global --list// 查看当前仓库配置信息git config --local --list</code></pre></div><h2 id="二-tag-操作"><a href="#二-tag-操作" class="headerlink" title="二. tag 操作"></a>二. tag 操作</h2><h3 id="1-显示本地-tag"><a href="#1-显示本地-tag" class="headerlink" title="1. 显示本地 tag"></a>1. 显示本地 tag</h3><div class="code-wrapper"><pre><code class="hljs">git tag</code></pre></div><h3 id="2-删除本地tag"><a href="#2-删除本地tag" class="headerlink" title="2. 删除本地tag"></a>2. 删除本地tag</h3><div class="code-wrapper"><pre><code class="hljs">// 删除名为tag_name的一个标签git tag -d tag_name// 删除本地所有标签git tag -d $(git tag -l)</code></pre></div><h3 id="3-删除远端某个tag"><a href="#3-删除远端某个tag" class="headerlink" title="3. 删除远端某个tag"></a>3. 删除远端某个tag</h3><div class="code-wrapper"><pre><code class="hljs">// 删除远端名为release-3.0.0-13的taggit push origin :refs/tags/release-3.0.0-13// 删除远端所有的标签git push origin --delete $(git tag -l)</code></pre></div><h3 id="4-批量删除远端tag"><a href="#4-批量删除远端tag" class="headerlink" title="4.批量删除远端tag"></a>4.批量删除远端tag</h3><div class="code-wrapper"><pre><code class="hljs">//删除远端所有以release-开头的taggit show-ref --tag | awk &#39;/release-/ &#123;print &quot;:&quot; $2&#125;&#39; |xargs git push origin</code></pre></div><h3 id="5-批量删除本地分支"><a href="#5-批量删除本地分支" class="headerlink" title="5. 批量删除本地分支"></a>5. 批量删除本地分支</h3><div class="code-wrapper"><pre><code class="hljs">// 删除以release-开头的本地taggit tag -l | awk &#39;/release-/&#39; |  xargs git tag -d</code></pre></div><h3 id="6-添加标签"><a href="#6-添加标签" class="headerlink" title="6.添加标签"></a>6.添加标签</h3><div class="code-wrapper"><pre><code class="hljs">// 添加一个名为xxx的标签$git tag -a xxx -m&quot;xxxxxxx&quot;// 将标签推送到服务器$git push origin tag-names</code></pre></div><h2 id="三-遇到问题及解决方法"><a href="#三-遇到问题及解决方法" class="headerlink" title="三. 遇到问题及解决方法"></a>三. 遇到问题及解决方法</h2><h3 id="1-git-push-或者-clone-出错"><a href="#1-git-push-或者-clone-出错" class="headerlink" title="1. git push 或者 clone 出错"></a>1. git push 或者 clone 出错</h3><p>出错代码:<br>    <figure class="highlight subunit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>RPC failed; curl 56 OpenSSL SSL_read: error:1408F119:SSL routines:ssl3_get_record:decryption failed or bad record mac, errno 0<br>fatal: the remote end hung up unexpectedly<br>fatal: early EOF<br>fatal: index-pack failed<br></code></pre></td></tr></table></figure></p><p>解决方法：增大 postbuffer<br>    <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global http.postBuffer 1048576000</span><br></code></pre></td></tr></table></figure></p><h3 id="2-git-archive-时没有同步submodule"><a href="#2-git-archive-时没有同步submodule" class="headerlink" title="2. git archive 时没有同步submodule"></a>2. git archive 时没有同步submodule</h3><p>在使用 git archive的时候，发现并没有把项目里的submodule里的文件归档过去，只有一个submodule的文件夹</p><p>解决思路：1、先在父目录使用git archive后，再通过git submodule foreach遍历submodule，对sudmodule里的文件进行git archive，这样最后，所有文件都能归档到一个地方了</p><div class="code-wrapper"><pre><code class="hljs"><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 函数第一个参数为项目名</span><br>function pack() &#123;<br><span class="hljs-attribute">PKG_NAME</span>=<span class="hljs-variable">$&#123;1&#125;</span><br><span class="hljs-attribute">PKG_VERSION</span>=$(grep <span class="hljs-string">&#x27;^Version:&#x27;</span> <span class="hljs-variable">$&#123;PKG_NAME&#125;</span>.spec | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)<br>cd <span class="hljs-built_in">..</span><br><span class="hljs-attribute">curDir</span>=`pwd`<br><span class="hljs-attribute">PROJECT_NAME</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;PKG_NAME&#125;</span>-<span class="hljs-variable">$&#123;PKG_VERSION&#125;</span>&quot;</span><br>git archive <span class="hljs-attribute">--format</span>=tar <span class="hljs-attribute">--prefix</span>=<span class="hljs-variable">$PROJECT_NAME</span>/ HEAD | (tar xpf -) #归档父项目后解压到指定目录<br>git submodule <span class="hljs-keyword">foreach</span> | <span class="hljs-keyword">while</span> read subdir; <span class="hljs-keyword">do</span> <br><span class="hljs-attribute">subdir</span>=<span class="hljs-variable">$&#123;subdir#*\&#x27;&#125;</span>; #去除最左边的单引号<br><span class="hljs-attribute">subdir</span>=<span class="hljs-variable">$&#123;subdir%*\&#x27;&#125;</span>; #去除最右边的单引号<br>[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;subdir&#125;</span>&quot;</span> = <span class="hljs-string">&quot;&quot;</span> ] &amp;&amp; continue; #加一步判断，subdir为<span class="hljs-string">&quot;&quot;</span>则continue<br>echo Running git archive submodules<span class="hljs-built_in">..</span>. <span class="hljs-variable">$&#123;subdir&#125;</span><br>(cd <span class="hljs-variable">$&#123;subdir&#125;</span> &amp;&amp; git archive <span class="hljs-attribute">--format</span>=tar <span class="hljs-attribute">--prefix</span>=<span class="hljs-variable">$&#123;subdir&#125;</span>/ HEAD | (cd <span class="hljs-variable">$&#123;curDir&#125;</span>/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>/ &amp;&amp; tar xpf -)); #归档submodule后解压到父目录<br>done<br><br>tar zcpf <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>.tar.gz <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>/bin/mv -f <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>.tar.gz packaging<br>rm -rf <span class="hljs-variable">$&#123;PKG_NAME&#125;</span>-<span class="hljs-variable">$&#123;PKG_VERSION&#125;</span><br>cd -<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h3 id="3-git-status-中文显示乱码"><a href="#3-git-status-中文显示乱码" class="headerlink" title="3. git status 中文显示乱码"></a>3. git status 中文显示乱码</h3><p><strong>原因:</strong></p><p>在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。</p><p><strong>解决办法:</strong></p><p>将git配置文件 core.quotepath项设置为false。quotepath表示引用路径，加上–global表示全局配置</p><p>git bash终端输入命令:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 常用命令</title>
    <link href="/2020/07/27/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/00%20%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/00%20mysql/mysql%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/27/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/00%20%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/00%20mysql/mysql%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li><p>显示当前的缓存状态<br><code>show variables like &#39;%query_cache%&#39;; </code></p></li><li><p>显示当前的存储类型<br><code>show engines;</code></p></li><li><p>删除数据库test_db下所有表<br><code>select concat(&#39;drop table &#39;,table_name,&#39;;&#39;) from information_schema.tables where table_schema=&#39;test_db&#39;;</code></p></li><li><p>清空表数据<br>truncate tablename;</p></li><li><p>查询库csgw中所有表的记录数<br><code>use information_schema</code><br><code>select table_name,table_rows from tables where TABLE_SCHEMA=&#39;csgw&#39; order by table_rows desc;</code></p></li><li><p>显示当前数据库的user表结构<br>show columns from user;</p></li><li><p>切换当前数据库到whb_test<br><code>user whb_test;</code></p></li><li><p>创建一个user表，主键为name，20字符，passwd字段为64字符不能为空<br><code>CREATE TABLE user(name VARCHAR(20) not null primary key, passwd VARCHAR(64) not null, id int(4));</code></p></li><li><p>给一个用户赋予数据库权限</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs sql">语法：mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">grant</span> 权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2</span>,...权限n <span class="hljs-keyword">on</span> 数据库名称.表名称 <span class="hljs-keyword">to</span> 用户名@用户地址 identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;连接口令&#x27;</span>;<br>权限<span class="hljs-number">1</span>,权限<span class="hljs-number">2</span>,...权限n代表<br><span class="hljs-keyword">select</span>,<span class="hljs-keyword">insert</span>,update,<span class="hljs-keyword">delete</span>,<span class="hljs-keyword">create</span>,<span class="hljs-keyword">drop</span>,index,<span class="hljs-keyword">alter</span>,<span class="hljs-keyword">grant</span>,<span class="hljs-keyword">references</span>,reload,shutdown,process,file等<span class="hljs-number">14</span>个权限<br><br>实例：mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>,<span class="hljs-keyword">insert</span>,update,<span class="hljs-keyword">delete</span>,<span class="hljs-keyword">create</span>,<span class="hljs-keyword">drop</span> <span class="hljs-keyword">on</span> whb_test.employee <span class="hljs-keyword">to</span> joe<span class="hljs-variable">@10</span><span class="hljs-number">.163</span><span class="hljs-number">.225</span><span class="hljs-number">.87</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>给来自<span class="hljs-number">10.163</span><span class="hljs-number">.225</span><span class="hljs-number">.87</span>的用户joe分配可对数据库whb_test的employee表进行<span class="hljs-keyword">select</span>,<span class="hljs-keyword">insert</span>,update,<span class="hljs-keyword">delete</span>,<span class="hljs-keyword">create</span>,<span class="hljs-keyword">drop</span>等操作的权限，并设定口令为<span class="hljs-number">123456</span>。<br>mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> whb_test.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> whb<span class="hljs-variable">@10</span><span class="hljs-number">.163</span><span class="hljs-number">.225</span><span class="hljs-number">.87</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>给来自<span class="hljs-number">10.163</span><span class="hljs-number">.225</span><span class="hljs-number">.87</span>的用户whb分配可对数据库whb_test所有表进行所有操作的权限，并设定口令为<span class="hljs-number">123</span>。<br>mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> joe<span class="hljs-variable">@10</span><span class="hljs-number">.163</span><span class="hljs-number">.225</span><span class="hljs-number">.87</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br>给来自<span class="hljs-number">10.163</span><span class="hljs-number">.225</span><span class="hljs-number">.87</span>的用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为<span class="hljs-number">123</span>。<br>mysql<span class="hljs-operator">&gt;</span><span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> privileges <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> joe<span class="hljs-variable">@localhost</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br>给本机用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为<span class="hljs-number">123</span>。<br><br>刷新权限：<br>FLUSH   PRIVILEGES;<br></code></pre></td></tr></table></figure></li><li><p>创建一个名为whb_test的数据库<br><code>CREATE DATABASE whb_test CHARACTER SET &#39;utf8&#39; COLLATE &#39;utf8_general_ci&#39;;</code></p></li><li><p>用whb用户登录172.16.1.110服务器的mysql：<br><code>         mysql -uwhb -p -h 172.16.1.110</code><br>使用此方法登录必须有ip</p></li><li><p>删除一个用户名为whb的用户</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;whb&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>; <br>flush <span class="hljs-keyword">privileges</span>; <br></code></pre></td></tr></table></figure></li><li><p>创建一个用户名为whb，密码为123456的用户<br><code>create user whb identified by &#39;123456&#39;;</code></p></li><li><p> 创建一个密码为123456的用户test_user，对所有数据库有操作权限<br><code>grant select,insert,update,delete on *.* to test_user@&quot;%&quot; Identified by &quot;123456&quot;;</code></p></li><li><p>登录方法：<br><code>mysql -uxxxx -pxxxx --host=192.168.1.110  </code></p></li><li><p>root登录</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mysql</span> -uroot -p<span class="hljs-number">123456</span> mysql<br><span class="hljs-attribute">mysql</span> -utest_user -p<span class="hljs-number">123456</span> -h <span class="hljs-number">192.168.188.125</span> -P <span class="hljs-number">3306</span><br></code></pre></td></tr></table></figure></li><li><p>查看mytable表编码格式<br><code>show create table mytable; </code></p></li><li><p>查看test数据库的编码格式<br><code>show create database test;</code></p></li></ul><p>设置数据库db_name默认为utf8:<br>???</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML类图图示样例</title>
    <link href="/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA%E6%A0%B7%E4%BE%8B/"/>
    <url>/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA%E6%A0%B7%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<img src="/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA%E6%A0%B7%E4%BE%8B/uml.png" class="" title="样例">]]></content>
    
    
    <categories>
      
      <category>架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时序图、活动图、状态图、协作图的区别</title>
    <link href="/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><p>时序图用于描述对象之间的传递消息的时间顺序, 即用例中的行为顺序.当执行一个用例时, 时序图中的每条消息对应了一个类操作或者引起转换的触发事件.<br>在 UML 中, 时序图表示为一个二维的关系图, 其中, 纵轴是时间轴, 时间延竖线向下延伸. 横轴代表在协作中各个独立的对象. 当对象存在时, 生命线用一条虚线表示, 消息用从一个对象的生命线到另一个对象的生命线的箭头表示. 箭头以时间的顺序在图中上下排列.</p><img src="/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB/1.gif" class="" title="图1. ATM 用户成功登陆的时序图"><p>时序图中的基本概念</p><ul><li>对象: 时序图中对象使用矩形表示, 并且对象名称下有下划线. 将对象置于时序图的顶部说明在交互开始时对象就已经存在了. 如果对象的位置不在顶部, 表示对象是在交互的过程中被创建的.</li><li>生命线: 生命线是一条垂直的虚线. 表示时序图中的对象在一段生命周期内存在. 每个对象底部中心的位置都带有生命线.</li><li>消息: 两个对象之间的单路通信. 从发送方指向接收方. 在时序图中很少使用返回消息.</li><li>激活: 时序图可以描述对象的激活和钝化. 激活表示该对象被占用以完成某个任务. 钝化指对象处于空闲状态, 等待消息. 在 UML 中, 对象激活时将对象的生命线拓宽为矩形来表示的. 矩形称为计划条或控制期. 对象就是在激活条的顶部被激活的. 对象在完成自己的工作后被钝化.<br>对象的创建和销毁: 在时序图中, 对象的默认位置是在图的顶部. 这说明对象在交互开始之前就已经存在了. 如果对象是在交互过程中创建的, 那么就应该将对象放到中间部分. 如果要撤销一个对象, 在其生命线终止点处放置 “ X” 符号.<br>  练习:  <img src="/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB/2.gif" class="" title="图2.孙中山的......"></li></ul><h1 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h1><p>在 UML 中, 活动图本质上就是流程图. 它用于描述系统的活动, 判定点和分支等.</p><img src="/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB/3.gif" class="" title="图3.活动图"><p>活动图中的基本概念：</p><ul><li>动作状态: 原子的, 不可中断的动作, 并在此动作完成之后向另一个动作转变. 在 UML 中动作状态用圆角矩形 表示, 动作状态所表示的动作写在圆角矩形内部.</li><li>分支与合并: 分支在软件系统中很常见. 一般用于表示对象类所具有的条件行为. 用一个布尔型表达式的真假来判定动作的流向. 条件行为用分支和合并表达.在活动图中, 分支用空心小菱形 表示. 分支包括一个入转换和两个带条件的出转换, 出转换的条件应该是互斥的, 须保证只有一条出转换能够被触发. 合并包含两个带条件的入转换和一个出转换.</li></ul><h1 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h1><p>状态图: 通过建立对象的生存周期模型来描述对象随时间变化的动态行为.</p><img src="/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB/4.gif" class="" title="图 4.状态图"><p>状态图中的基本概念</p><ul><li>状态: 用圆角矩形表示. 状态名称表示状态的名字, 通常用字符串表示. 一个状态的名称在状态图所在的上下文中应该是唯一的.</li><li>转换: 用带箭头的直线表示. 一端连着源状态, 一端连着目标状态.</li><li>初始状态: 每个状态图都有一个初始状态. 此状态代表状态图的起始位置. 初始状态只能作为转换的源, 不能作为转换的目标, 并且在状态图中只能有一个. 初始状态用一个实心圆表示.</li><li>终止状态: 模型元素的最后状态, 是一个状态图的终止点. 终止状态在一个状态图中可以有多个.</li></ul><h1 id="协作图"><a href="#协作图" class="headerlink" title="协作图"></a>协作图</h1><p>协作图(也叫合作图)是一种交互图.<br>时序图主要侧重于对象间消息传递在时间上的先后关系, 而协作图表达对象间的交互过程及对象间的关联关系</p><img src="/2020/07/27/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/02%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB/5.gif" class="" title="图 5 协作图">]]></content>
    
    
    <categories>
      
      <category>架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定位程序cpu 100%方法</title>
    <link href="/2020/07/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/00%E5%AE%9A%E4%BD%8Dcpu%20100_p%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/06%E5%BC%80%E5%8F%91%E5%88%86%E6%9E%90/00%E5%AE%9A%E4%BD%8Dcpu%20100_p%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="使用perf-定位"><a href="#使用perf-定位" class="headerlink" title="使用perf 定位"></a>使用perf 定位</h1><figure class="highlight elixir"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># -g开启调用关系分析，-p指定php-fpm的进程号94806</span><br><span class="hljs-variable">$ </span>perf top -g -p <span class="hljs-number">94806</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sqlite3 客户端操作命令</title>
    <link href="/2020/07/26/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/00%20%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/01%20sqlite/sqlite3%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/26/05%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/00%20%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/01%20sqlite/sqlite3%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>导出查询内容到文件中</p><figure class="highlight lua"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs lua">sqlite3 www_cache.db;<br>sqlite&gt; .<span class="hljs-built_in">output</span> <span class="hljs-number">1.</span>txt<br>sqlite&gt; <span class="hljs-built_in">select</span> <span class="hljs-built_in">path</span>,size from file_info;<br>sqlite&gt; .<span class="hljs-built_in">output</span> <span class="hljs-built_in">stdout</span><br></code></pre></td></tr></table></figure><h1 id="直接执行后面的sql语句"><a href="#直接执行后面的sql语句" class="headerlink" title="直接执行后面的sql语句"></a>直接执行后面的sql语句</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sqlite3 data1<span class="hljs-regexp">/www/u</span>ri_meta.db <span class="hljs-string">&quot;select count(*) from uri_meta&quot;</span><br></code></pre></td></tr></table></figure><p>#查询表结构信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sqlite3 <span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/cachedb/</span>data<span class="hljs-regexp">/data1/</span>www/uri_meta.db <span class="hljs-string">&quot;select * from sqlite_master &quot;</span><br></code></pre></td></tr></table></figure><p>#统计记录数，通过查询mtime列快速查询记录数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sqlite3 <span class="hljs-regexp">/opt/</span>soft<span class="hljs-regexp">/cachedb/</span>data<span class="hljs-regexp">/data1/</span>www/uri_meta.db <span class="hljs-string">&quot;select count(mtime) from uri_meta &quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>sqlite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大端-小端对齐判定函数</title>
    <link href="/2020/07/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/02%E5%A4%A7%E7%AB%AF-%E5%B0%8F%E7%AB%AF%E5%AF%B9%E9%BD%90%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0/"/>
    <url>/2020/07/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/01c_cpp/02%E5%A4%A7%E7%AB%AF-%E5%B0%8F%E7%AB%AF%E5%AF%B9%E9%BD%90%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>大端-小端对齐判定方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span> </span>&#123;<br>(<span class="hljs-keyword">void</span>)argc;<br>(<span class="hljs-keyword">void</span>)argv;<br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-keyword">short</span> s;<br><span class="hljs-keyword">char</span> c[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">short</span>)];<br>&#125;un;<br>un.s = <span class="hljs-number">0x0102</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">short</span>)!=<span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof(short)=%d\n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">short</span>));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>== un.c[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-number">2</span>==un.c[<span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Big end\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>==un.c[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-number">1</span>==un.c[<span class="hljs-number">1</span>]) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Little end\n&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unknown \n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么函数参数提示《remove this mut》</title>
    <link href="/2020/07/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02Rust/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%8F%90%E7%A4%BAremovte_this_mut/"/>
    <url>/2020/07/26/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02Rust/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%8F%90%E7%A4%BAremovte_this_mut/</url>
    
    <content type="html"><![CDATA[<p>翻译自《<a href="https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust%E3%80%8B">https://www.snoyman.com/blog/2020/05/no-mutable-parameters-in-rust》</a></p><p>在回顾Begin Rust书中的倒数第二章时，出现了一个稍微高级的话题。这个话题引起了我一段时间的兴趣，特别是因为它展示了Rust和Haskell如何处理可变性的一些根本差异。该主题对于本书而言太高了，但是我想提供一个外部资源，以供有好奇心的人参考。就是这里！</p><p>让我们逐步构建它。以下程序可以编译吗？</p><figure class="highlight sas"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs sas">fn ma<span class="hljs-meta">in(</span>) &#123;<br>    let <span class="hljs-meta">x</span> = 5;<br>    <span class="hljs-meta">x</span> += 1;<br>    println!(<span class="hljs-string">&quot;x == &#123;&#125;&quot;</span>, <span class="hljs-meta">x</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>答：不！x是一个不可变的变量，因此不能+= 1在其上使用。解决这个问题很容易：add mut：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">5</span>;<br>    x += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x == &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是由于加1和打印在我的应用程序中是如此重要（是的，这很讽刺），所以我决定将其提取为自己的函数。告诉我，这段代码可以编译吗？</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">fn add_and_print(<span class="hljs-keyword">x</span>: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-keyword">x</span> +<span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    println!(<span class="hljs-string">&quot;x == &#123;&#125;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不，并且出于与第一个示例相同的原因：x是不可变的。修复也很容易：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">fn add_and_print(mut <span class="hljs-keyword">x</span>: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-keyword">x</span> +<span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    println!(<span class="hljs-string">&quot;x == &#123;&#125;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们的函数<code>add_and_print</code>拥有唯一的参数x,它的类型是i32，并且是可变的。嗯不错。最后，我们可以在  <code>main    </code>中调用此函数。告诉我，该程序可以编译并运行吗？是否和预想的一样没有任何警告吗？</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sas">fn ma<span class="hljs-meta">in(</span>) &#123;<br>    let mut <span class="hljs-meta">x</span> = 5;<br>    add_and_p<span class="hljs-meta">rint(</span><span class="hljs-meta">x</span>);<br>&#125;<br><br>fn add_and_p<span class="hljs-meta">rint(</span>mut <span class="hljs-meta">x</span>: i32) &#123;<br>    <span class="hljs-meta">x</span> += 1;<br>    println!(<span class="hljs-string">&quot;x == &#123;&#125;&quot;</span>, <span class="hljs-meta">x</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>答：它会编译，运行并生成输出x == 6。但是，它确实有一个警告：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">warning: variable does not need to be mutable<br> --&gt; src/main.rs:2:9<br>  |<span class="hljs-string"></span><br><span class="hljs-string">2 </span>|<span class="hljs-string">     let mut x = 5;</span><br><span class="hljs-string">  </span>|<span class="hljs-string">         ----^</span><br><span class="hljs-string">  </span>|<span class="hljs-string">         </span>|<br>  |<span class="hljs-string">         help: remove this `mut`</span><br><span class="hljs-string">  </span>|<br></code></pre></td></tr></table></figure><p>最初，至少对于我来说，这确实令人惊讶。<code>add_and_prin</code>t需要接收一个可变变量i32作为其第一个参数。我们为其提供了可变的i32。然后编译器说<code>mut</code>在 <code>main</code>中是不必要的。这是什么情况？</p><p>我上面的解释有一个错误。函数<code>add_and_print</code>，可能非常令人困惑，不用将可变变量i32作为参数。“但是前面说需要mut的！！！”，而现在又说mut是不必要的。 确实如此。mut详细信息位于函数内部，而不是其类型签名的一部分。这听起来令人困惑，所以让我解释一下。</p><p>在Rust中有一个模式，我称之为rust的3条规则。这涵盖了以下事实：在许多情况下，我们最终会得到三个“版本”的事物：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">An immutable <span class="hljs-keyword">borrow </span>  <span class="hljs-comment"># 不可变借用</span><br>A mutable <span class="hljs-keyword">borrow </span> <span class="hljs-comment"># 可变借用</span><br>A <span class="hljs-keyword">move </span> <span class="hljs-comment"># 移动</span><br></code></pre></td></tr></table></figure><p>这可以应用于函数参数，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">immutable_borrow</span>(<span class="hljs-params">x: &amp;<span class="hljs-keyword">String</span></span>)</span><br><span class="hljs-function"><span class="hljs-title">fn</span> <span class="hljs-title">mutable_borrow</span>(<span class="hljs-params">x: &amp;mut <span class="hljs-keyword">String</span></span>)</span><br><span class="hljs-function"><span class="hljs-title">fn</span> <span class="hljs-title">move</span>(<span class="hljs-params">x: <span class="hljs-keyword">String</span></span>)</span><br></code></pre></td></tr></table></figure><p>请注意，差异完全在冒号之后。冒号后的内容是3个不同的<code>类型</code>，而<code>类型</code>构成了<code>函数签名</code>。</p><p>但是，示例中的<code>x</code>冒号前的内容对<code>函数签名</code>没有影响。<code>变量名称</code>与函数的签名无关。一旦冒号右边传递一个<code>值</code>函数即可决定要调用的内容。</p><p>此规则不仅适用于变量名称。也适用于<code>可变变量</code>。<code>mutable</code>是rust中<code>变量</code>的一个feature而不是<code>值</code>的feature。当使用let mut x = 5时，表示的是 “创建一个叫x的<code>变量</code>，它指向一个<code>值</code>5，并且允许用x来对该<code>值</code>进行改变。” 如果没有mut，将不再被允许通过<code>变量</code>x对该<code>值</code>进行改变。</p><p>您可能会有一个直觉的反应，如果您无法修改<code>变量</code>，那你就只能只读它了。一般直觉应该就是这样。但Rust中并非如此。您还可以做另一件事：将<code>值</code>移到另一个作用域。<code>add_and_print</code>通过<code>move</code>接受<code>值</code>，即使x是一个不可变的<code>变量</code>，我仍然可以移动它所指向的<code>值</code>。</p><p>一旦移动了<code>值</code>，那就完全取决于<code>add_and_print</code>如何处理它。即使原始<code>变量</code>是不可变的，也可以将其变为可变的。这是因为在函数调用中<code>值</code>本身被传递过来，而不是变量。而值可以根据需要来变为可变的。</p><p>因此，该程序的无警告版本为：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sas">fn ma<span class="hljs-meta">in(</span>) &#123;<br>    let <span class="hljs-meta">x</span> = 5;<br>    add_and_p<span class="hljs-meta">rint(</span><span class="hljs-meta">x</span>);<br>&#125;<br><br>fn add_and_p<span class="hljs-meta">rint(</span>mut <span class="hljs-meta">x</span>: i32) &#123;<br>    <span class="hljs-meta">x</span> += 1;<br>    println!(<span class="hljs-string">&quot;x == &#123;&#125;&quot;</span>, <span class="hljs-meta">x</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，即使没有函数调用，move后为可变的也是可能发生的。例如，您可以在单个函数中将不可变变量“升级”为可变变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> y = x;<br>    y += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;y == &#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>“等一下” 您抱怨道，“你不能将不可变的引用“升级”为可变的引用！” ，对于我的解释或许还有其他类似的关于抱怨。我在这里稍加修饰的是: 当涉及到引用时，可变性被转化为值的可变性。那是因为对于类似x: &amp;i32这种形式的引用，x自身并没有任何数值，它<code>引用</code>了一个数字。对于可变或不可变是对<code>引用</code>本身来说的，因为<code>引用</code>自身是一种类型。因此，您不能简单地将不可变引用升级为可变引用。此代码已损坏：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x: <span class="hljs-built_in">i32</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> y: &amp;<span class="hljs-built_in">i32</span> = &amp;x;<br>    <span class="hljs-keyword">let</span> z: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span> = y; <span class="hljs-comment">// 不能简单的将y升级为可变的</span><br><br>    *z += <span class="hljs-number">1</span>;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x == &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，总结一下：</p><ul><li>您可以拥有<code>值</code>，或<code>值</code>的<code>不变引用</code>或<code>值</code>的<code>可变引用</code></li><li><code>值</code>只有2种状态，要么可变的，要么不可变</li><li>相似的<code>变量</code>也只有2种状态，要么可变的，要么不可变</li><li>当将<code>值</code>移动到新<code>变量</code>中（通过 let或函数调用）时，可以更改<code>变量</code>的可变性</li><li>函数签名中<code>变量</code>的可变性和名称并不影响函数签名</li><li>引用的可变性内置在类型本身中，因此您不能将不可变的引用“升级”为可变的引用</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下IO应用详解</title>
    <link href="/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/07linux%E4%B8%8BIO%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/07linux%E4%B8%8BIO%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一-对于I-O的概述"><a href="#一-对于I-O的概述" class="headerlink" title="一. 对于I/O的概述"></a>一. 对于I/O的概述</h2><p>Linux磁盘I/O分为Buffered IO和Direct IO，这两者有何区别？</p><p>Buffered IO：<br>当应用程序尝试读取某块数据的时候，如果这块数据已经存放在了页缓存（page cache）中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未被存放在页缓存中，那么就需要先将数据从磁盘读到页缓存中去。对于写操作来说，应用程序也会将数据先写到页缓存中去，数据是否被立即写到磁盘上去取决于应用程序所采用的写操作机制：如果用户采用的是同步写机制（ synchronous writes ），那么数据会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（ deferred writes ），那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了。在延迟写机制的情况下，操作系统会定期地将放在页缓存中的数据刷到磁盘上。与异步写机制（ asynchronous writes ）不同的是，<font color="#ff0000"><code>延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候是会返回给应用程序的。所以延迟写机制本身是存在数据丢失的风险的</code></font>，而异步写机制则不会有这方面的担心。</p><p>总结下，Buffered IO的特点是使用了内存缓存，如：</p><ul><li>读操作：硬盘-&gt;内核页缓存-&gt;用户缓冲区</li><li>写操作：用户缓冲区-&gt;内核页缓存-&gt;硬盘</li></ul><p>对Buffered IO，数据在传输过程中需要在应用程序地址空间和页缓存之间进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><p>对于某些特殊的应用程序（如数据库）来说，避开操作系统内核缓冲区而直接在应用程序地址空间和磁盘之间传输数据会比使用操作系统内核缓冲区获取更好的性能。</p><p>Direct IO:<br>Direct-io的目的在于绕过文件系统（ext）的cache，直接对block设备上的文件进行读写。但不经内核缓冲区，直接写磁盘，必然会引起阻塞。所以通常DIRECT-io与AIO（异步IO）会一起出现。</p><h2 id="二-I-O模型的类比"><a href="#二-I-O模型的类比" class="headerlink" title="二. I/O模型的类比"></a>二. I/O模型的类比</h2><p>Linux下的I/O模型。</p><img src="/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/07linux%E4%B8%8BIO%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/aio1.gif" class="" title="图 1. 基本 Linux I&#x2F;O 模型的简单矩阵"><p>如图每个 I/O 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。下面一一来介绍：</p><h3 id="2-1-同步阻塞-I-O-模型"><a href="#2-1-同步阻塞-I-O-模型" class="headerlink" title="2.1 同步阻塞 I/O 模型"></a>2.1 同步阻塞 I/O 模型</h3><img src="/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/07linux%E4%B8%8BIO%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/aio2.gif" class="" title="图 2. 同步阻塞 I&#x2F;O 模型的典型流程"><p>在这个模型中，用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成为止（数据传输完成或发生错误）。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</p><h3 id="2-2-同步非阻塞-I-O"><a href="#2-2-同步非阻塞-I-O" class="headerlink" title="2.2 同步非阻塞 I/O"></a>2.2 同步非阻塞 I/O</h3><img src="/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/07linux%E4%B8%8BIO%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/aio2.gif" class="" title="图 3. 同步非阻塞 I&#x2F;O 模型的典型流程"><p>同步阻塞 I/O 的一种效率稍低的变种是同步非阻塞 I/O。在这种模型中，设备是以非阻塞的形式打开的。这意味着 I/O 操作不会立即完成，read操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）</p><h3 id="2-3-异步阻塞-I-O"><a href="#2-3-异步阻塞-I-O" class="headerlink" title="2.3 异步阻塞 I/O"></a>2.3 异步阻塞 I/O</h3><img src="/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/07linux%E4%B8%8BIO%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/aio2.gif" class="" title="图 4. 异步阻塞 I&#x2F;O 模型的典型流程 (select)"><p>IO多路复用(复用的select线程)。I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。对于每个提示符来说，我们可以获取这个描述符可以写数据、有读数据可用以及是否发生错误的通知。</p><h4 id="epoll总结："><a href="#epoll总结：" class="headerlink" title="epoll总结："></a>epoll总结：</h4><p>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知.</p><h4 id="epoll的优点"><a href="#epoll的优点" class="headerlink" title="epoll的优点:"></a>epoll的优点:</h4><ul><li><p> 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p></li><li><p> 效率提升，不是轮询的方式,只管你“活跃”的连接，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数。</p></li><li><p> 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p></li></ul><blockquote><blockquote><blockquote><p>表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p></blockquote></blockquote></blockquote><h3 id="2-4-异步非阻塞-I-O（AIO）"><a href="#2-4-异步非阻塞-I-O（AIO）" class="headerlink" title="2.4 异步非阻塞 I/O（AIO）"></a>2.4 异步非阻塞 I/O（AIO）</h3><img src="/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/07linux%E4%B8%8BIO%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/aio2.gif" class="" title="图 5. 异步非阻塞 I&#x2F;O 模型的典型流程"><p>异步非阻塞 I/O 模型是一种CPU处理与 I/O 重叠进行的模型。读请求会立即返回，说明 read 请求已经成功发起了。在后台完成读操作时，应用程序然后会执行其他处理操作。当 read 的响应到达时，就会产生一个信号或执行一个基于线程的回调函数来完成这次 I/O 处理过程。</p><h2 id="三-AIO编程介绍："><a href="#三-AIO编程介绍：" class="headerlink" title="三. AIO编程介绍："></a>三. AIO编程介绍：</h2><p>aio异步读写是在Linux内核2.6之后才正式纳入其标准。之所以会增加此模块，是因为众所周知我们计算机CPU的执行速度远大于I/O读写的执行速度，如果我们用传统的阻塞式或非阻塞式来操作I/O的话，那么我们在同一个程序中(不用多线程或多进程)就不能同时操作俩个以上的文件I/O，每次只能对一个文件进行I/O操作，很明显这样效率很低下(因为CPU速度远大于I/O操作的速度，所以当执行I/O时，CPU其实还可以做更多的事)。因此就诞生了相对高效的异步I/O。<br>在 Linux 系统上有三种方式来实现 AIO：</p><ul><li>内核系统调用</li><li>对内核系统调用进行封装进而在用户空间提供服务，例如 libaio</li><li>完全在用户空间实现 AIO，并且不使用内核支持，例如librt和部分libc </li></ul><h3 id="3-1-内核系统调用"><a href="#3-1-内核系统调用" class="headerlink" title="3.1 内核系统调用"></a>3.1 内核系统调用</h3><p>内核提供的API有io_setup, io_submit, io_getevents, io_destroy，<br>所使用的参数是 aio_context_t 而非libaio中的 io_context_t<br>一般不采用此方式直接调用，一般使用的是libaio库进行调用。</p><h3 id="3-2-libaio"><a href="#3-2-libaio" class="headerlink" title="3.2 libaio"></a>3.2 libaio</h3><p>libaio提供的API有：io_setup, io_submit, io_getevents, io_destroy</p><p>使用时需要独立安装相关的 libaio-devel 开发库<br><code>yum install libaio-devel</code></p><h4 id="3-2-1-相关结构体"><a href="#3-2-1-相关结构体" class="headerlink" title="3.2.1 相关结构体"></a>3.2.1 相关结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iocb</span> &#123;</span>　　　　　　　　<span class="hljs-comment">// 描述IO请求</span><br><br>        <span class="hljs-keyword">void</span>     *data;  <span class="hljs-comment">/* Return in the io completion event */</span><br>        <span class="hljs-keyword">unsigned</span> key;   <span class="hljs-comment">/*r use in identifying io requests */</span><br>        <span class="hljs-keyword">short</span>           aio_lio_opcode;　　<span class="hljs-comment">// 操作的类型：IO_CMD_PWRITE | IO_CMD_PREAD</span><br>        <span class="hljs-keyword">short</span>           aio_reqprio;<br>        <span class="hljs-keyword">int</span>             aio_fildes;　　　　<span class="hljs-comment">// 操作的文件fd</span><br>        <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_iocb_common</span>           <span class="hljs-title">c</span>;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_iocb_vector</span>           <span class="hljs-title">v</span>;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_iocb_poll</span>             <span class="hljs-title">poll</span>;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_iocb_sockaddr</span> <span class="hljs-title">saddr</span>;</span><br>        &#125; u;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_iocb_common</span> &#123;</span>　　<br>        <span class="hljs-keyword">void</span>            *buf;　　<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>   nbytes;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>       offset;<br>        <span class="hljs-keyword">unsigned</span>        flags;<br>        <span class="hljs-keyword">unsigned</span>        resfd;<br>&#125;;<br><br>　　<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_event</span> &#123;</span>　　　　<span class="hljs-comment">// 描述返回结果</span><br>　　　　<span class="hljs-keyword">void</span> *data;<br>　　　　<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iocb</span> *<span class="hljs-title">obj</span>;</span>　　<span class="hljs-comment">// 提交的任务</span><br>　　　　<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> res;　　<span class="hljs-comment">// IO任务完成的状态</span><br>　　　<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> res2;　　<span class="hljs-comment">// 同上</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-应用步骤"><a href="#3-2-2-应用步骤" class="headerlink" title="3.2.2 应用步骤"></a>3.2.2 应用步骤</h4><h5 id="3-2-2-1-建立IO任务"><a href="#3-2-2-1-建立IO任务" class="headerlink" title="3.2.2.1 建立IO任务"></a>3.2.2.1 建立IO任务</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">io_setup</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">io_context_t</span> *ctxp)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p>io_context_t对应内核中一个结构，为异步IO请求提供上下文环境。<br>注意: 在调用 io_setup 前必须将 io_context_t 初始化为0。<br>也需要open打开文件的时候设置 <em><strong>O_DIRECT</strong></em> 标志。</p></blockquote><h5 id="3-2-2-2-提交IO任务"><a href="#3-2-2-2-提交IO任务" class="headerlink" title="3.2.2.2 提交IO任务"></a>3.2.2.2 提交IO任务</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">io_submit</span> <span class="hljs-params">(<span class="hljs-keyword">io_context_t</span> ctx_id, <span class="hljs-keyword">long</span> nr, struct iocb **iocbpp)</span></span>;<br></code></pre></td></tr></table></figure><p>提交任务之前必须先填充iocb结构体，libaio提供的包装函数说明了需要完成的工作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void io<span class="hljs-constructor">_prep_pread(<span class="hljs-params">struct</span> <span class="hljs-params">iocb</span> <span class="hljs-operator">*</span><span class="hljs-params">iocb</span>, <span class="hljs-params">int</span> <span class="hljs-params">fd</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">count</span>, <span class="hljs-params">long</span> <span class="hljs-params">long</span> <span class="hljs-params">offset</span>)</span><br>&#123;<br>　　memset(iocb, <span class="hljs-number">0</span>, sizeof(*iocb));<br>　　iocb-&gt;aio_fildes = fd;<br>　　iocb-&gt;aio_lio_opcode = IO_CMD_PREAD;<br>　　iocb-&gt;aio_reqprio = <span class="hljs-number">0</span>;<br>　　iocb-&gt;u.c.buf = buf;<br>　　iocb-&gt;u.c.nbytes = count;<br>　　iocb-&gt;u.c.offset = offset;<br>&#125;<br><br>void io<span class="hljs-constructor">_prep_pwrite(<span class="hljs-params">struct</span> <span class="hljs-params">iocb</span> <span class="hljs-operator">*</span><span class="hljs-params">iocb</span>, <span class="hljs-params">int</span> <span class="hljs-params">fd</span>, <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">buf</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">count</span>, <span class="hljs-params">long</span> <span class="hljs-params">long</span> <span class="hljs-params">offset</span>)</span><br>&#123;<br>　　memset(iocb, <span class="hljs-number">0</span>, sizeof(*iocb));<br>　　iocb-&gt;aio_fildes = fd;<br>　　iocb-&gt;aio_lio_opcode = IO_CMD_PWRITE;<br>　　iocb-&gt;aio_reqprio = <span class="hljs-number">0</span>;<br>　　iocb-&gt;u.c.buf = buf;<br>　　iocb-&gt;u.c.nbytes = count;<br>　　iocb-&gt;u.c.offset = offset;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里注意读写的buf都必须是按扇区对齐的，可以用posix_memalign来分配。</p><p>详细代码内容可参考 <em><a href="https://pagure.io/libaio/blob/master/f/src/libaio.h">https://pagure.io/libaio/blob/master/f/src/libaio.h</a></em></p><h5 id="3-2-2-3-获取完成的IO"><a href="#3-2-2-3-获取完成的IO" class="headerlink" title="3.2.2.3 获取完成的IO"></a>3.2.2.3 获取完成的IO</h5><p>io_getevents 系统调用尝试从 ctx_id 指定的AIO上下文的完成队列中读取至少min_nr, 最多nr个事件,<br>timeout指定等待IO完成的超时时间，为NULL时一直等待到至少看到min_nr个事件为止;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">io_getevents</span> <span class="hljs-params">(<span class="hljs-keyword">io_context_t</span> ctx_id, <span class="hljs-keyword">long</span> min_nr, <span class="hljs-keyword">long</span> nr, struct io_event *events, struct timespec *timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>这里最重要的就是提供一个io_event数组给内核来copy完成的IO请求到这里，数组的大小是io_setup时指定的maxevents。</p><h5 id="3-2-2-4-销毁IO任务"><a href="#3-2-2-4-销毁IO任务" class="headerlink" title="3.2.2.4 销毁IO任务"></a>3.2.2.4 销毁IO任务</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">io_destroy</span> <span class="hljs-params">(<span class="hljs-keyword">io_context_t</span> ctx)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="3-2-3-libaio和epoll的结合"><a href="#3-2-3-libaio和epoll的结合" class="headerlink" title="3.2.3 libaio和epoll的结合"></a>3.2.3 libaio和epoll的结合</h4><p>在异步编程中，任何一个环节的阻塞都会导致整个程序的阻塞，所以一定要避免在 io_getevents 调用时阻塞式的等待。还记得 io_iocb_common 中的 flags 和 resfd 吗？看看libaio是如何提供io_getevents和事件循环的结合：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void io<span class="hljs-constructor">_set_eventfd(<span class="hljs-params">struct</span> <span class="hljs-params">iocb</span> <span class="hljs-operator">*</span><span class="hljs-params">iocb</span>, <span class="hljs-params">int</span> <span class="hljs-params">eventfd</span>)</span> &#123;<br>    iocb-&gt;u.c.flags <span class="hljs-pattern-match">|= (1 &lt;&lt; 0) <span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-constructor">IOCB_FLAG_RESFD</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span>;</span><br><span class="hljs-pattern-match">    iocb-&gt;u.c.resfd = eventfd;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的resfd是通过系统调用eventfd生成的。<br><code>int eventfd(unsigned int initval, int flags);</code><br>eventfd 函数是linux 2.6.22内核之后加进来的syscall，作用是内核用来通知应用程序发生的事件的数量，从而使应用程序不用频繁地去轮询内核是否有时间发生，而是有内核将发生事件的数量写入到该fd，应用程序发现fd可读后，从fd读取该数值，并马上去内核读取。</p><p>有了eventfd，就可以很好地将libaio和epoll事件循环结合起来：</p><div class="code-wrapper"><pre><code class="hljs">1. 创建一个eventfd    efd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);2. 将eventfd设置到iocb中, 将eventfd和iocb进行关联    io_set_eventfd(iocb, efd);3. 交接AIO请求    io_submit(ctx, NUM_EVENTS, iocb);4. 创建一个epollfd，并将eventfd加到epoll中    epfd = epoll_create(1);    epoll_ctl(epfd, EPOLL_CTL_ADD, efd, &amp;epevent);    epoll_wait(epfd, &amp;epevent, 1, -1);5. 当 `eventfd` 可读时，从 `eventfd` 读出完成IO请求的数量，并调用 `io_getevents` 获取这些IO    read(efd, &amp;finished_aio, sizeof(finished_aio);    r = io_getevents(ctx, 1, NUM_EVENTS, events, &amp;tms);</code></pre></div><h4 id="3-2-4-epoll-aio-eventfd结合使用的简单例子"><a href="#3-2-4-epoll-aio-eventfd结合使用的简单例子" class="headerlink" title="3.2.4 epoll/aio/eventfd结合使用的简单例子"></a>3.2.4 epoll/aio/eventfd结合使用的简单例子</h4><p>make时需要增加-laio 库引用<br><code>g++ main.cpp -o aiolib -laio</code></p><p>main.cpp内容如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libaio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/eventfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEST_FILE   <span class="hljs-meta-string">&quot;aio_test_file&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEST_FILE_SIZE  (127 * 1024)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_EVENTS  128</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ALIGN_SIZE  512</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RD_WR_SIZE  1024</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">custom_iocb</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iocb</span> <span class="hljs-title">iocb</span>;</span><br>    <span class="hljs-keyword">int</span> nth_request;<br>&#125;;<br><br><span class="hljs-comment">// aio 完成后的回调函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aio_callback</span><span class="hljs-params">(<span class="hljs-keyword">io_context_t</span> ctx, struct iocb *iocb, <span class="hljs-keyword">long</span> res, <span class="hljs-keyword">long</span> res2)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">custom_iocb</span> *<span class="hljs-title">iocbp</span> =</span> (struct custom_iocb *)iocb;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nth_request: %d, request_type: %s, offset: %lld, length: %lu, res: %ld, res2: %ld\n&quot;</span>,<br>            iocbp-&gt;nth_request, (iocb-&gt;aio_lio_opcode == IO_CMD_PREAD) ? <span class="hljs-string">&quot;READ&quot;</span> : <span class="hljs-string">&quot;WRITE&quot;</span>,<br>            iocb-&gt;u.c.offset, iocb-&gt;u.c.nbytes, res, res2);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  eventfd 被epoll触发后的事件处理</span><br><span class="hljs-comment"> *  @param ctx io操作上下文</span><br><span class="hljs-comment"> *  @param efd 被epoll触发的eventfd</span><br><span class="hljs-comment"> *  @return &gt;0 返回完成的事件个数 &lt;0 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">epoll_eventfd_hanlder</span><span class="hljs-params">(<span class="hljs-keyword">io_context_t</span> ctx, <span class="hljs-keyword">int</span> efd)</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">io_event</span> <span class="hljs-title">events</span>[64];</span> <span class="hljs-comment">//事件列表, 每次最多处理64个</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">tms</span>;</span><br>    <span class="hljs-keyword">uint64_t</span> finished_aio = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">read</span>(efd, &amp;finished_aio, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(finished_aio)) != <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(finished_aio)) &#123; <span class="hljs-comment">// 读取当前完成的aio读取事件个数</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> iret = (<span class="hljs-keyword">int</span>)finished_aio;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;finished io number: %ld\n&quot;</span>, finished_aio);<br>    <span class="hljs-keyword">while</span> (finished_aio &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 循环处理所有已完成aio事件</span><br>        tms.tv_sec = <span class="hljs-number">0</span>;<br>        tms.tv_nsec = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">io_getevents</span>(ctx, <span class="hljs-number">1</span>, <span class="hljs-number">64</span>, events, &amp;tms); <span class="hljs-comment">// 每次最多处理64个任务</span><br>        <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;@@@ get io_event num=%d,\n&quot;</span>, r);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;r; ++j) &#123;<br>                ((<span class="hljs-keyword">io_callback_t</span>)(events[j].data))(ctx, events[j].obj, events[j].res, events[j].res2);<br>            &#125;<br>            finished_aio -= r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> iret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> efd=<span class="hljs-number">-1</span>, fd=<span class="hljs-number">-1</span>, epfd=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">io_context_t</span> ctx;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">custom_iocb</span> <span class="hljs-title">iocbs</span>[<span class="hljs-title">NUM_EVENTS</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iocb</span> *<span class="hljs-title">iocbps</span>[<span class="hljs-title">NUM_EVENTS</span>];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">custom_iocb</span> *<span class="hljs-title">iocbp</span>;</span><br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">void</span> *buf;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epevent</span>;</span><br><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-number">0</span>&gt;(efd=<span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC)) ) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;eventfd&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>&gt;(fd = <span class="hljs-built_in">open</span>(TEST_FILE, O_RDWR | O_CREAT | O_DIRECT, <span class="hljs-number">0644</span>))) &#123; <span class="hljs-comment">//注意添加O_DIRECT</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>    <span class="hljs-built_in">ftruncate</span>(fd, TEST_FILE_SIZE);<br><br>    <span class="hljs-built_in">memset</span>(&amp;ctx, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ctx)); <span class="hljs-comment">// 注意必须初始化为0</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">io_setup</span>(<span class="hljs-number">8192</span>, &amp;ctx)) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;io_setup&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">posix_memalign</span>(&amp;buf, ALIGN_SIZE, RD_WR_SIZE)) &#123; <span class="hljs-comment">// 申请内存对齐的空间,类似malloc 需调用free释放空间</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;posix_memalign&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;buf: %p\n&quot;</span>, buf);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, iocbp = iocbs; i &lt; NUM_EVENTS; ++i, ++iocbp) &#123;<br>        iocbps[i] = &amp;iocbp-&gt;iocb;<br>        <span class="hljs-built_in">io_prep_pread</span>(&amp;iocbp-&gt;iocb, fd, buf, RD_WR_SIZE, i * RD_WR_SIZE);<br>        <span class="hljs-built_in">io_set_eventfd</span>(&amp;iocbp-&gt;iocb, efd);<br>        <span class="hljs-built_in">io_set_callback</span>(&amp;iocbp-&gt;iocb, aio_callback);<br>        iocbp-&gt;nth_request = i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">io_submit</span>(ctx, NUM_EVENTS, iocbps) != NUM_EVENTS) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;io_submit&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>&gt;(epfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll_create&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    &#125;<br><br>    epevent.events = EPOLLIN | EPOLLET;<br>    epevent.data.ptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, efd, &amp;epevent)) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll_ctl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    &#125;<br><br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; NUM_EVENTS) &#123; <span class="hljs-comment">//如果是服务端，此处应该一直循环</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> != <span class="hljs-built_in">epoll_wait</span>(epfd, &amp;epevent, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll_wait&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> iok = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span>&lt;(iok=<span class="hljs-built_in">epoll_eventfd_hanlder</span>(ctx, efd))) &#123;<br>            i += iok;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>(epfd);<br>    <span class="hljs-built_in">free</span>(buf);<br>    <span class="hljs-built_in">io_destroy</span>(ctx);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-built_in">close</span>(efd);<br>    <span class="hljs-built_in">remove</span>(TEST_FILE);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-POSIX-AIO"><a href="#3-3-POSIX-AIO" class="headerlink" title="3.3 POSIX AIO"></a>3.3 POSIX AIO</h3><p>当前的Linux POSIX AIO由glibc在用户空间中实现。POSIX AIO 有许多限制，最值得注意的是，维护多个线程来执行I/O操作是昂贵的，并且可扩展性很差。在基于内核状态机的 AIO 实现上已经进行了一段时间的工作，但是这个实现还没有成熟到可以使用内核系统调用完全重新实现POSIX AIO实现的程度。</p><h4 id="3-3-1-函数说明"><a href="#3-3-1-函数说明" class="headerlink" title="3.3.1 函数说明"></a>3.3.1 函数说明</h4><table><thead><tr><th>API函数</th><th>函数说明</th></tr></thead><tbody><tr><td>aio_read</td><td>异步读操作</td></tr><tr><td>aio_write</td><td>异步写操作</td></tr><tr><td>aio_error</td><td>检查异步请求的状态</td></tr><tr><td>aio_return</td><td>获得异步请求完成时的返回值</td></tr><tr><td>aio_suspend</td><td>挂起调用进程，直到一个或多个异步请求已完成</td></tr><tr><td>aio_cancel</td><td>取消异步请求</td></tr><tr><td>lio_list</td><td>发起一系列异步I/O请求</td></tr></tbody></table><h4 id="3-3-2-库"><a href="#3-3-2-库" class="headerlink" title="3.3.2 库"></a>3.3.2 库</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">librt libc</span> <br></code></pre></td></tr></table></figure><p>linux内核中aiocd结构体原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;aiocb.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> &#123;</span><br>    <span class="hljs-comment">/* The order of these fields is implementation-dependent */</span><br><br>    <span class="hljs-keyword">int</span>             aio_fildes;     <span class="hljs-comment">/* File descriptor */</span><br>    <span class="hljs-keyword">off_t</span>           aio_offset;     <span class="hljs-comment">/* File offset */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">void</span>  *aio_buf;        <span class="hljs-comment">/* Location of buffer */</span><br>    <span class="hljs-keyword">size_t</span>          aio_nbytes;     <span class="hljs-comment">/* Length of transfer */</span><br>    <span class="hljs-keyword">int</span>             aio_reqprio;    <span class="hljs-comment">/* Request priority */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigevent</span> <span class="hljs-title">aio_sigevent</span>;</span>   <span class="hljs-comment">/* Notification method */</span><br>    <span class="hljs-keyword">int</span>             aio_lio_opcode; <span class="hljs-comment">/* Operation to be performed;</span><br><span class="hljs-comment">                                       lio_listio() only */</span><br><br>    <span class="hljs-comment">/* Various implementation-internal fields not shown */</span><br>&#125;;<br><span class="hljs-comment">/* Operation codes for &#x27;aio_lio_opcode&#x27;: */</span><br>     <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> LIO_READ, LIO_WRITE, LIO_NOP &#125;;<br></code></pre></td></tr></table></figure><ul><li>aio_filedes  要执行io操作的文件描述符</li><li>aio_offset  要执行io操作的文件的偏移量</li><li>aio_buf 读写传输数据的缓冲区空间</li><li>aio_nbytes 指定的aio_buf缓冲区的大小</li><li>aio_reqprio   该字段指定从调用线程的实时优先级中减去的值，以确定执行此I / O请求的优先级（请参阅pthread_setschedparam（3））。 指定的值必须在0到sysconf（_SC_AIO_PRIO_DELTA_MAX）返回的值之间。 对于文件同步操作，将忽略此字段。</li><li>aio_sigevent 指定异步io操作完成时的通知方式， aio_sigevent.sigev_notify 的值可能是SIGEV_NONE, SIGEV_SIGNAL和 SIGEV_THREAD，相信信息可参考 sigevent(7)</li><li>aio_lio_opcode 要执行的操作类型； 仅用于lio_listio</li></ul><h4 id="3-3-3-API详细介绍及实例："><a href="#3-3-3-API详细介绍及实例：" class="headerlink" title="3.3.3 API详细介绍及实例："></a>3.3.3 API详细介绍及实例：</h4><h5 id="1-aio-read"><a href="#1-aio-read" class="headerlink" title="1. aio_read()"></a>1. aio_read()</h5><p><code>aio_read</code> 函数请求对一个有效的文件描述符进行异步读操作。这个文件描述符可以表示一个文件、套接字甚至管道。<code>aio_read</code> 函数的原型如下:</p><p><code>int aio_read(struct aiocb *aiocbp);</code></p><p> <code>aio_read</code> 函数在请求进行排队之后会立即返回。如果执行成功，返回值就为 0；如果出现错误，返回值就为 -1，并设置 errno 的值。</p><h5 id="2-aio-error"><a href="#2-aio-error" class="headerlink" title="2. aio_error()"></a>2. aio_error()</h5><p><code>aio_error</code> 函数被用来确定请求的状态。</p><p><code>int aio_error( struct aiocb *aiocbp );</code></p><p>返回值：<br>EINPROGRESS，说明请求尚未完成</p><p>ECANCELLED，说明请求被应用程序取消了<br>-1，说明发生了错误，具体错误原因可以查阅 errno<br>0 ,说明完成当前请求</p><h5 id="3-aio-return"><a href="#3-aio-return" class="headerlink" title="3. aio_return()"></a>3. aio_return()</h5><p>异步 I/O 和标准块 I/O 之间的另外一个区别是我们不能立即访问这个函数的返回状态，因为我们并没有阻塞在 <code>read</code> 调用上。在标准的 <code>read</code> 调用中，返回状态是在该函数返回时提供的。但是在异步 I/O 中，我们要使用     <code>aio_return</code> 函数。这个函数的原型如下：</p><p><code>ssize_t aio_return( struct aiocb *aiocbp );</code></p><p>对以上三个API的源码实例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;aio.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br><span class="hljs-keyword">int</span> MAX_LIST = <span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> <span class="hljs-title">rd</span>;</span> <span class="hljs-comment">//aio操作所需结构体</span><br>    <span class="hljs-keyword">int</span> fd,ret,couter;<br><br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDONLY, <span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//将rd结构体清空</span><br>    <span class="hljs-built_in">bzero</span>(&amp;rd,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(rd));<br><br>    rd.aio_buf = <span class="hljs-built_in">malloc</span>(BUFFER_SIZE + <span class="hljs-number">1</span>); <span class="hljs-comment">//为rd.aio_buf分配空间</span><br>    <span class="hljs-comment">//填充rd结构体</span><br>    rd.aio_fildes = fd;<br>    rd.aio_nbytes = BUFFER_SIZE;<br>    rd.aio_offset = <span class="hljs-number">0</span>;<br><br>    ret = <span class="hljs-built_in">aio_read</span>(&amp;rd); <span class="hljs-comment">//进行异步读操作</span><br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;aio_read&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//do other things</span><br><br>    couter = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//  循环等待异步读操作结束</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">aio_error</span>(&amp;rd) == EINPROGRESS) &#123; <span class="hljs-comment">//一直不停的查询(消耗cpu)</span><br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第%d次\n&quot;</span>,++couter);<br>    &#125;<br><br>    <span class="hljs-comment">//获取异步读返回值</span><br>    ret = <span class="hljs-built_in">aio_return</span>(&amp;rd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n返回值为:%d\n&quot;</span>,ret);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,rd.aio_buf);<br>    <span class="hljs-built_in">free</span>((<span class="hljs-keyword">char</span>*)rd.aio_buf);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-aio-write"><a href="#4-aio-write" class="headerlink" title="4. aio_write()"></a>4. aio_write()</h5><p><code>aio_write</code> 函数用来请求一个异步写操作。其函数原型如下：</p><p><code>intaio_write( struct aiocb *aiocbp );</code></p><p> <code>aio_write</code> 函数会立即返回，说明请求已经进行排队（成功时返回值为 0，失败时返回值为 -1，并相应地设置 errno）。</p><p> 这与 read 系统调用类似，但是有一点不一样的行为需要注意。回想一下对于 read 调用来说，要使用的偏移量是非常重要的。然而，对于 write 来说，这个偏移量只有在没有设置 O_APPEND 选项的文件上下文中才会非常重要。如果设置了 O_APPEND，那么这个偏移量就会被忽略，数据都会被附加到文件的末尾。否则，aio_offset 域就确定了数据在要写入的文件中的偏移量.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;aio.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-comment">//定义aio控制块结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> <span class="hljs-title">wr</span>;</span> <br>    <span class="hljs-keyword">int</span> ret,fd; <br>    <span class="hljs-keyword">char</span> str[<span class="hljs-number">20</span>] = &#123;<span class="hljs-string">&quot;hello,world&quot;</span>&#125;;    <br>    <span class="hljs-built_in">bzero</span>(&amp;wr,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(wr));<span class="hljs-comment">//置零wr结构体</span><br> <br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,O_WRONLY | O_APPEND, <span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">//为aio.buf申请空间</span><br>    wr.aio_buf = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(BUFFER_SIZE);<br>    <span class="hljs-keyword">if</span>(wr.aio_buf == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;buf&quot;</span>);<br>    &#125;<br> <br>    wr.aio_buf = str;<br> <br>    <span class="hljs-comment">//填充aiocb结构</span><br>    wr.aio_fildes = fd;<br>    wr.aio_nbytes = <span class="hljs-number">1024</span>;<br> <br>    ret = <span class="hljs-built_in">aio_write</span>(&amp;wr); <span class="hljs-comment">//异步写操作</span><br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;aio_write&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">//等待异步写完成</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">aio_error</span>(&amp;wr) == EINPROGRESS)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello,world\n&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-comment">//获得异步写的返回值</span><br>    ret = <span class="hljs-built_in">aio_return</span>(&amp;wr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n\n返回值为:%d\n&quot;</span>,ret);<br>    <span class="hljs-built_in">free</span>((<span class="hljs-keyword">char</span>*)wr.aio_buf);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-aio-suspend"><a href="#5-aio-suspend" class="headerlink" title="5. aio_suspend()"></a>5. aio_suspend()</h5><ul><li>aio_suspend函数可以时当前进程挂起，直到有向其注册的异步事件完成为止 </li><li>阻塞</li><li>当有AIO请求返程后，该函数返回</li></ul><p><code>int aio_suspend(const struct aiocb *const cblist[],int n,const struct timespec *timeout);</code></p><p> 第一个参数是个保存了<code>aiocb</code>块地址的数组，我们可以向其内添加想要等待阻塞的异步事件，第二个参数为向<code>cblist</code>注册的<code>aiocb</code>个数,第三个参数为等待阻塞的超时时间，NULL为无限等待.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;aio.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br> <br><span class="hljs-keyword">int</span> MAX_LIST = <span class="hljs-number">2</span>;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-comment">//aio操作所需结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> <span class="hljs-title">rd</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> <span class="hljs-title">wd</span>;</span><br>    <span class="hljs-keyword">int</span> fd,ret,couter;<br> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> *<span class="hljs-title">aiocb_list</span>[2];</span><span class="hljs-comment">//cblist链表</span><br> <br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDONLY, <span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-built_in">bzero</span>(&amp;rd,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(rd));<span class="hljs-comment">//将rd结构体清空</span><br> <br>    rd.aio_buf = <span class="hljs-built_in">malloc</span>(BUFFER_SIZE + <span class="hljs-number">1</span>);<span class="hljs-comment">//为rd.aio_buf分配空间</span><br> <br>    <span class="hljs-comment">//填充rd结构体</span><br>    rd.aio_fildes = fd;<br>    rd.aio_nbytes =  BUFFER_SIZE;<br>    rd.aio_offset = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">//将读fd的事件注册</span><br>    aiocb_list[<span class="hljs-number">0</span>] = &amp;rd;<br> <br>    <span class="hljs-comment">//进行异步读操作</span><br>    ret = <span class="hljs-built_in">aio_read</span>(&amp;rd);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;aio_read&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我要开始等待异步读事件完成\n&quot;</span>);<br>    ret = <span class="hljs-built_in">aio_suspend</span>(aiocb_list,MAX_LIST,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//阻塞等待异步读事件完成</span><br>    ret = <span class="hljs-built_in">aio_return</span>(&amp;rd);<span class="hljs-comment">//获取异步读返回值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\n返回值为:%d\n&quot;</span>,ret);<br><span class="hljs-built_in">free</span>((<span class="hljs-keyword">char</span>*)rd.aio_buf);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-lio-listio"><a href="#6-lio-listio" class="headerlink" title="6.lio_listio()"></a>6.lio_listio()</h5><p>aio同时还为我们提供了一个可以发起多个或多种I/O请求的接口lio_listio </p><p>这个函数效率很高，因为我们只需一次系统调用(一次内核上下位切换)就可以完成大量的I/O操作</p><p><code>int lio_listio(int mode,struct aiocb *list[],int nent,struct sigevent *sig);</code></p><p> 第一个参数<code>mode</code>可以有两个实参，<code>LIO_WAIT</code>和<code>LIO_NOWAIT</code>，前一个会阻塞该调用直到所有I/O都完成为止，后一个则会挂入队列就返回</p><ul><li>LIO_WAIT 阻塞发起</li><li>LIO_NOWAIT  非阻塞发起<blockquote><p>批量发起AIO的两种方法</p></blockquote></li><li>阻塞等到所有发起的AIO全部完成后，才会返回</li><li>发起后立即返回，通过绑定的信号来通知</li></ul><p>LIO_WAIT  demo::</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;aio.h&gt;</span></span><br> <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1025</span><br><span class="hljs-keyword">int</span> MAX_LIST = <span class="hljs-number">2</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> *<span class="hljs-title">listio</span>[2];</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> <span class="hljs-title">rd</span>,<span class="hljs-title">wr</span>;</span><br>    <span class="hljs-keyword">int</span> fd,ret;<br> <br>    <span class="hljs-comment">//异步读事件</span><br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test1.txt&quot;</span>,O_RDONLY, <span class="hljs-number">0644</span>);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;test1.txt&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-built_in">bzero</span>(&amp;rd,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(rd));<br> <br>    rd.aio_buf = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(BUFFER_SIZE);<br>    <span class="hljs-keyword">if</span>(rd.aio_buf == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;aio_buf&quot;</span>);<br>    &#125;<br> <br>    rd.aio_fildes = fd;<br>    rd.aio_nbytes = <span class="hljs-number">1024</span>;<br>    rd.aio_offset = <span class="hljs-number">0</span>;<br>    rd.aio_lio_opcode = LIO_READ;   <span class="hljs-comment">///lio操作类型为异步读</span><br> <br>    listio[<span class="hljs-number">0</span>] = &amp;rd;<span class="hljs-comment">//将异步读事件添加到list中</span><br> <br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test2.txt&quot;</span>,O_WRONLY | O_APPEND, <span class="hljs-number">0644</span>); <span class="hljs-comment">//异步些事件</span><br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;test2.txt&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-built_in">bzero</span>(&amp;wr,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(wr));<br> <br>    wr.aio_buf = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(BUFFER_SIZE);<br>    <span class="hljs-keyword">if</span>(wr.aio_buf == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;aio_buf&quot;</span>);<br>    &#125;<br> <br>    wr.aio_fildes = fd;<br>    wr.aio_nbytes = <span class="hljs-number">1024</span>;<br>    wr.aio_lio_opcode = LIO_WRITE;   <span class="hljs-comment">///lio操作类型为异步写</span><br> <br>    <span class="hljs-comment">//将异步写事件添加到list中</span><br>    listio[<span class="hljs-number">1</span>] = &amp;wr;<br> <br>    ret = <span class="hljs-built_in">lio_listio</span>(LIO_WAIT,listio,MAX_LIST,<span class="hljs-literal">NULL</span>);  <span class="hljs-comment">//使用lio_listio发起一系列请求</span><br>    ret = <span class="hljs-built_in">aio_return</span>(&amp;rd);  <span class="hljs-comment">//当异步读写都完成时获取他们的返回值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n读返回值:%d&quot;</span>,ret);<br> <br>    ret = <span class="hljs-built_in">aio_return</span>(&amp;wr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n写返回值:%d&quot;</span>,ret);<br><span class="hljs-built_in">free</span>((<span class="hljs-keyword">char</span>*)wr.aio_buf);<br><span class="hljs-built_in">free</span>((<span class="hljs-keyword">char</span>*)rd.aio_buf);<br>    <span class="hljs-built_in">close</span>(rd.aio_fildes);<br><span class="hljs-built_in">close</span>(wr.aio_fildes);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>LIO_NOWAIT demo::</p><p>当我们的异步IO操作完成之时，我们可以通过信号通知我们的进程也可用回调函数来进行异步通知，接下来我会为大家主要介绍以下回调函数来进行异步通知</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigevent</span> &#123;</span><br><span class="hljs-keyword">int</span>           sigev_notify;            <span class="hljs-comment">//Notification type. </span><br><span class="hljs-keyword">int</span>           sigev_signo;            <span class="hljs-comment">//Signal number. </span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">sigval</span>  <span class="hljs-title">sigev_value</span>;</span>             <span class="hljs-comment">//Signal value. </span><br><span class="hljs-built_in"><span class="hljs-keyword">void</span></span>         (*sigev_notify_function)(<span class="hljs-keyword">union</span> sigval); <span class="hljs-comment">//Notification function. </span><br><span class="hljs-keyword">pthread_attr_t</span> *sigev_notify_attributes;  <span class="hljs-comment">//Notification attributes. </span><br>&#125;; <br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;aio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1025</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aio_completion_handler</span><span class="hljs-params">(<span class="hljs-keyword">sigval_t</span> sigval)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//用来获取读aiocb结构的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> *<span class="hljs-title">prd</span>;</span><br>    <span class="hljs-keyword">int</span> ret;<br><br>    prd = (struct aiocb *)sigval.sival_ptr;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>    <span class="hljs-comment">//获取返回值</span><br>    ret = <span class="hljs-built_in">aio_return</span>(prd);<br><span class="hljs-built_in">free</span>(prd-&gt;aio_buf);<br><span class="hljs-built_in">close</span>(prd-&gt;aio_fildes);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> fd,ret;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aiocb</span> <span class="hljs-title">rd</span>;</span><br> <br>    fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">bzero</span>(&amp;rd,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(rd));<span class="hljs-comment">//填充aiocb的基本内容</span><br> <br>    rd.aio_fildes = fd;<br>    rd.aio_buf = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(BUFFER_SIZE + <span class="hljs-number">1</span>));<br>    rd.aio_nbytes = BUFFER_SIZE;<br>    rd.aio_offset = <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">//填充aiocb中有关回调通知的结构体sigevent</span><br>    rd.aio_sigevent.sigev_notify = SIGEV_THREAD;<span class="hljs-comment">//使用线程回调通知</span><br>    rd.aio_sigevent.sigev_notify_function = aio_completion_handler;<span class="hljs-comment">//设置回调函数</span><br>    rd.aio_sigevent.sigev_notify_attributes = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//使用默认属性</span><br>    rd.aio_sigevent.sigev_value.sival_ptr = &amp;rd;<span class="hljs-comment">//在aiocb控制块中加入自己的引用</span><br> <br>    <span class="hljs-comment">//异步读取文件</span><br>    ret = <span class="hljs-built_in">aio_read</span>(&amp;rd);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;aio_read&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;异步读以开始\n&quot;</span>);<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;异步读结束\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-参考"><a href="#四-参考" class="headerlink" title="四. 参考"></a>四. 参考</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/l-async/index.html">https://www.ibm.com/developerworks/cn/linux/l-async/index.html</a><br><a href="https://blog.csdn.net/abraham_1/article/details/79824350">https://blog.csdn.net/abraham_1/article/details/79824350</a><br><a href="https://man7.org/linux/man-pages/man7/aio.7.html">https://man7.org/linux/man-pages/man7/aio.7.html</a><br><a href="http://guleilab.com/2019/01/30/linux-aio/">http://guleilab.com/2019/01/30/linux-aio/</a><br><a href="https://www.cnblogs.com/chenny7/p/4362910.html">https://www.cnblogs.com/chenny7/p/4362910.html</a><br><a href="https://pagure.io/libaio/blob/master/f/src">https://pagure.io/libaio/blob/master/f/src</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust - 为什么不能将u32转换为char</title>
    <link href="/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02Rust/rust-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%B0%86u32%E8%BD%AC%E6%8D%A2%E4%B8%BAchar%EF%BC%9F/"/>
    <url>/2020/07/25/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/02Rust/rust-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%B0%86u32%E8%BD%AC%E6%8D%A2%E4%B8%BAchar%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>来源 <a href="https://www.coder.work/article/2553893">https://www.coder.work/article/2553893</a></p><p>我正在努力学习Rust，我开始思考chars是如何4字节宽的。我可以将char通过as转换 为u32并且它可以工作（它们都是4字节宽的），但是，当我将u32通过as转换为achar时，Rust抱怨道：</p><figure class="highlight rust"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> pizza_hex: <span class="hljs-built_in">u32</span> = <span class="hljs-number">0x1f355</span>;<br>    <span class="hljs-keyword">let</span> pizza: <span class="hljs-built_in">char</span> = &#x27;🍕&#x27;; <span class="hljs-comment">// (pizza char: http://www.fileformat.info/info/unicode/char/1f355/index.htm)</span><br><br>    <span class="hljs-comment">// pizza as hex = 1f355</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;pizza as hex = &#123;:x&#125;&quot;</span>, pizza <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>);<br><br>    <span class="hljs-comment">// size of pizza = 4</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;size of pizza = &#123;&#125;&quot;</span>, std::mem::size_of_val(&amp;pizza));<br><br>    <span class="hljs-comment">// This doesn&#x27;t work super well</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; == &#123;&#125;&quot;</span>, pizza_hex <span class="hljs-keyword">as</span> <span class="hljs-built_in">char</span>, pizza);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0604]: only `<span class="hljs-built_in">u8</span>` can be cast <span class="hljs-keyword">as</span> `<span class="hljs-built_in">char</span>`, not `<span class="hljs-built_in">u32</span>`<br>  --&gt; src/main.rs:<span class="hljs-number">12</span>:<span class="hljs-number">26</span><br>   |<br><span class="hljs-number">12</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; == &#123;&#125;&quot;</span>, pizza_hex <span class="hljs-keyword">as</span> <span class="hljs-built_in">char</span>, pizza);<br>   |                          ^^^^^^^^^^^^^^^^^<br></code></pre></td></tr></table></figure><p>你知道为什么吗？<br>最佳答案</p><p>每个char都是有效的u32值，但不是每个u32值都是有效的char。<br>包含有效Unicode码位的chars的属性：<br>未定义的行为<br>基元类型中的值无效，即使在私有字段和局部变量中也是如此：<br>Achar中的值，它是代理项或大于char::MAX的值。<br>要在运行时将au32转换为achar，请尝试以下操作：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">if</span> let <span class="hljs-title">Some</span><span class="hljs-params">(pizza_from_hex)</span> </span>= std::<span class="hljs-keyword">char</span>::<span class="hljs-built_in">from_u32</span>(pizza_hex) &#123;<br>    println!(<span class="hljs-string">&quot;&#123;&#125; == &#123;&#125;&quot;</span>, pizza_from_hex, pizza);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果您不想在字符文本中使用令人毛骨悚然的Unicode标志符号，可以使用Unicode转义序列：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> pizza_from_hex = &#x27;\u&#123;<span class="hljs-number">01</span>f<span class="hljs-number">355</span>&#125;&#x27;;<br><br><span class="hljs-attribute">println</span>!(<span class="hljs-string">&quot;&#123;&#125; == &#123;&#125;&quot;</span>, pizza_from_hex, pizza);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见架构模式</title>
    <link href="/2020/07/25/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/00%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/07/25/01%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/00%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分层模式"><a href="#1-分层模式" class="headerlink" title="1. 分层模式"></a>1. 分层模式</h1><h1 id="2-客户端-服务器模式"><a href="#2-客户端-服务器模式" class="headerlink" title="2. 客户端-服务器模式"></a>2. 客户端-服务器模式</h1><h1 id="3-主从设备模式"><a href="#3-主从设备模式" class="headerlink" title="3. 主从设备模式"></a>3. 主从设备模式</h1><h1 id="4-管道-过滤器模式"><a href="#4-管道-过滤器模式" class="headerlink" title="4. 管道-过滤器模式"></a>4. 管道-过滤器模式</h1><h1 id="5-代理模式"><a href="#5-代理模式" class="headerlink" title="5. 代理模式"></a>5. 代理模式</h1><h1 id="6-点对点模式"><a href="#6-点对点模式" class="headerlink" title="6. 点对点模式"></a>6. 点对点模式</h1><h1 id="7-事件总线模式"><a href="#7-事件总线模式" class="headerlink" title="7. 事件总线模式"></a>7. 事件总线模式</h1><h1 id="8-MVC模式"><a href="#8-MVC模式" class="headerlink" title="8. MVC模式"></a>8. MVC模式</h1><h1 id="9-黑板模式"><a href="#9-黑板模式" class="headerlink" title="9. 黑板模式"></a>9. 黑板模式</h1><h1 id="10-解释器模式"><a href="#10-解释器模式" class="headerlink" title="10. 解释器模式"></a>10. 解释器模式</h1>]]></content>
    
    
    <categories>
      
      <category>架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>监控指定进程的句柄信息</title>
    <link href="/2018/11/30/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/08%E7%9B%91%E6%8E%A7%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%A5%E6%9F%84%E4%BF%A1%E6%81%AF/"/>
    <url>/2018/11/30/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/08%E7%9B%91%E6%8E%A7%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%A5%E6%9F%84%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>脚本内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">################################################################################</span><br><span class="hljs-comment">#  Copyright (C) 2015-2018 whb All rights reserved.</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">#  Author     : 王海斌</span><br><span class="hljs-comment">#  E-mail     : fly542@gmail.com</span><br><span class="hljs-comment">#  Version    :</span><br><span class="hljs-comment">#  Date       : Fri 30 Nov 2018 11:06:41 AM CST</span><br><span class="hljs-comment">#  Destription: 监控指定过滤程序的句柄数，每2秒输出一次相关内容</span><br><span class="hljs-comment">#  usage      : 使用方法 ./watch_fd.sh /a/b/c/d</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">################################################################################</span><br><span class="hljs-built_in">cd</span> `dirname <span class="hljs-variable">$0</span>`<br><br>keyInfo=<span class="hljs-variable">$1</span><br>proc_num=<span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment"># 获取到的最新进程id</span><br>sleep_idle=2   <span class="hljs-comment"># 监控间隔</span><br>outSeq=1       <span class="hljs-comment"># 输出行数</span><br>procInfoInt=20 <span class="hljs-comment"># 进程启动信息输出记录行数，</span><br><br>startTime=0<br><br><span class="hljs-comment"># 获取进程的启动时间</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">GetProcStartTime</span></span>() <br>&#123; <br>    <span class="hljs-built_in">local</span> PID=<span class="hljs-variable">$1</span><br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$&#123;PID&#125;</span> ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;usage <span class="hljs-variable">$&#123;0&#125;</span> pid&quot;</span><br>        <span class="hljs-built_in">return</span> 0    <br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">local</span> STARTTIME=$(awk <span class="hljs-string">&#x27;&#123;print int($22 /100)&#125;&#x27;</span> /proc/<span class="hljs-variable">$PID</span>/<span class="hljs-built_in">stat</span>)<br>    <span class="hljs-built_in">local</span> UT=$(awk <span class="hljs-string">&#x27;&#123;print int($1)&#125;&#x27;</span> /proc/uptime)<br>    <span class="hljs-built_in">local</span> NOW=$(date +%s)<br>    startTime=$((NOW - (UT - STARTTIME)))<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;proc <span class="hljs-variable">$PID</span> start at : `date -d @<span class="hljs-variable">$startTime</span>`&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 获取最新进程的进程id</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">GetLatestPid</span></span>()<br>&#123; <br>    proc_num_all=(`ps -ef |grep <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;keyInfo&#125;</span>&quot;</span> |grep -v grep |awk <span class="hljs-string">&#x27;&#123;print $2,$8&#125;&#x27;</span> |grep <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;keyInfo&#125;</span>&quot;</span> |awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>`)<br>    proc_num=<span class="hljs-variable">$&#123;proc_num_all[@]&#125;</span><br>    <span class="hljs-keyword">for</span> tmpPid <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;proc_num_all[@]&#125;</span>&quot;</span><br>    <span class="hljs-keyword">do</span><br>        oldTime=<span class="hljs-variable">$&#123;startTime&#125;</span><br>        GetProcStartTime <span class="hljs-variable">$&#123;tmpPid&#125;</span><br>        <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$&#123;oldTime&#125;</span> -lt <span class="hljs-variable">$&#123;startTime&#125;</span> ]<br>        <span class="hljs-keyword">then</span><br>            proc_num=<span class="hljs-variable">$&#123;tmpPid&#125;</span><br>        <span class="hljs-keyword">fi</span><br>    <span class="hljs-keyword">done</span><br>&#125;<br><br><span class="hljs-comment"># 检测key的合法性</span><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">CheckKeyInfo</span></span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;-&quot;</span> == <span class="hljs-string">&quot;-<span class="hljs-variable">$&#123;keyInfo&#125;</span>&quot;</span> ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;must input param&quot;</span><br>        <span class="hljs-built_in">exit</span> 0<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;keyInfo&#125;</span>&quot;</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br>CheckKeyInfo<br>GetLatestPid<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    sleep <span class="hljs-variable">$&#123;sleep_idle&#125;</span><br>    <span class="hljs-keyword">if</span> [ ! -d /proc/<span class="hljs-variable">$&#123;proc_num&#125;</span> ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;proc <span class="hljs-variable">$&#123;proc_num&#125;</span> is dead&quot;</span><br>    <span class="hljs-keyword">else</span> <br>        proInfo=`ls /proc/<span class="hljs-variable">$&#123;proc_num&#125;</span>/fd -l 2&gt;&amp;1 |awk <span class="hljs-string">&#x27;</span><br><span class="hljs-string">        BEGIN &#123;sum=0; sock=0; efd=0; ep=0; fd=0;&#125; </span><br><span class="hljs-string">        &#123; </span><br><span class="hljs-string">            sum += 1; </span><br><span class="hljs-string">            if($0~&quot;socket&quot;) &#123; sock+=1; &#125; </span><br><span class="hljs-string">            else if($0~&quot;eventfd&quot;) &#123; efd+=1; &#125; </span><br><span class="hljs-string">            else if($0~&quot;eventpoll&quot;) &#123; ep+=1; &#125; </span><br><span class="hljs-string">            else &#123; fd+=1; &#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        END &#123;print &quot;total_fd=&quot;sum, &quot;sock_num=&quot;sock, &quot;eventfd_num=&quot;efd, &quot;eventpool_num=&quot;ep, &quot;file_fd=&quot;fd &#125;&#x27;</span><br>        `<br>        vmInfo=`cat /proc/<span class="hljs-variable">$&#123;proc_num&#125;</span>/status |awk <span class="hljs-string">&#x27;BEGIN&#123;vm=&quot;&quot;; rss=&quot;&quot;;&#125; &#123; if($0~&quot;VmSize&quot;) vm=$2$3 fi; if($0~&quot;VmRSS&quot;) rss=$2$3 fi;&#125; END &#123;print &quot;VmSize=&quot;vm, &quot;VmRSS=&quot;rss&#125;&#x27;</span>`<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;`date &quot;</span>+%Y-%m-%d %T<span class="hljs-string">&quot;` pid=<span class="hljs-variable">$&#123;proc_num&#125;</span> <span class="hljs-variable">$&#123;proInfo&#125;</span> <span class="hljs-variable">$&#123;vmInfo&#125;</span>&quot;</span><br>        outSeq=$((<span class="hljs-variable">$&#123;outSeq&#125;</span>+<span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">if</span> [ $(( <span class="hljs-variable">$outSeq</span> % <span class="hljs-variable">$&#123;procInfoInt&#125;</span> )) -eq 0 ]<br>        <span class="hljs-keyword">then</span><br>            GetProcStartTime <span class="hljs-variable">$&#123;proc_num&#125;</span><br>        <span class="hljs-keyword">fi</span><br><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">exit</span> 0<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地文件映射为磁盘</title>
    <link href="/2018/05/03/04DevOps/07%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E4%B8%BA%E7%A3%81%E7%9B%98/"/>
    <url>/2018/05/03/04DevOps/07%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E4%B8%BA%E7%A3%81%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># pur @ 创建文件映射挂载点</span><br><span class="hljs-comment"># date @ 2018.05.03</span><br><br><span class="hljs-comment">#映射文件</span><br>diskFile=<span class="hljs-variable">$1</span><br><span class="hljs-comment">#挂载路径</span><br>mountDir=<span class="hljs-variable">$2</span><br><br><span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;diskFile&#125;</span>&quot;</span> -o -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;mountDir&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;useage: <span class="hljs-variable">$0</span> mapfile mountdir&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;eg: <span class="hljs-variable">$0</span> /root/data.img /dir1&quot;</span><br>    <span class="hljs-built_in">exit</span> 0<br><span class="hljs-keyword">fi</span><br><br><br><span class="hljs-comment"># 1、 安装mkfs.ext4或xfs系统格式化工具</span><br>yum install -y e4fsprogs<br><span class="hljs-comment">#yum -y install xfsprogs</span><br><span class="hljs-comment"># 2、查询当前可用设备</span><br>curDevice=`losetup -f`<br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-variable">$&#123;mountDir&#125;</span> ] ; <span class="hljs-keyword">then</span><br>    mkdir -p <span class="hljs-variable">$&#123;mountDir&#125;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ ! -b <span class="hljs-variable">$&#123;curDevice&#125;</span> ] ; <span class="hljs-keyword">then</span><br>    seq=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;curDevice&#125;</span> |awk -F<span class="hljs-string">&#x27;loop&#x27;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> `<br>    mknod -m 0660 <span class="hljs-variable">$&#123;curDevice&#125;</span> b 7 <span class="hljs-variable">$&#123;seq&#125;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;not exist <span class="hljs-variable">$&#123;curDevice&#125;</span>, seq=<span class="hljs-variable">$&#123;seq&#125;</span>&quot;</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;exist <span class="hljs-variable">$&#123;curDevice&#125;</span>&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># 3、创建镜像文件</span><br>dd <span class="hljs-keyword">if</span>=/dev/zero of=<span class="hljs-variable">$&#123;diskFile&#125;</span> bs=1M count=1024<br><span class="hljs-comment"># 4、使用 losetup将磁盘镜像文件虚拟成块设备</span><br>losetup <span class="hljs-variable">$&#123;curDevice&#125;</span> <span class="hljs-variable">$&#123;diskFile&#125;</span><br><span class="hljs-comment"># 5、在块设备上创建文件系统</span><br>mkfs.ext4 <span class="hljs-variable">$&#123;curDevice&#125;</span><br><span class="hljs-comment"># 6、mount挂载文件系统, 加上sync，确保文件可以及时地写入到映像中</span><br>mount <span class="hljs-variable">$&#123;diskFile&#125;</span> <span class="hljs-variable">$&#123;mountDir&#125;</span> -o sync<br><span class="hljs-comment"># 7、卸载回环设置</span><br>losetup -d <span class="hljs-variable">$&#123;curDevice&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>scons实用说明</title>
    <link href="/2014/08/01/04DevOps/05scons%E5%AE%9E%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2014/08/01/04DevOps/05scons%E5%AE%9E%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>还在为写一个makefile发愁吗？还在为难记的make参数而苦恼吗？有了scons一切都边的简单了。最近研究了下scons，发现和makefile相比，soncs编译c和c++程序真的太方便了。搞程序什么做好，当然是简单实用最好下面大家就一起感受下简单的scons吧。</p><h2 id="1-使用scons编译程序"><a href="#1-使用scons编译程序" class="headerlink" title="1. 使用scons编译程序"></a>1. 使用scons编译程序</h2><p>在程序目录下执行命令如下：（前提是你已经安装scons了哟）</p><p><code>scons</code>     </p><p>噢，噢，这个好像没啥简单的哈，和make差不多嘛。是吗？那就继续瞧好吧您.</p><h2 id="2-清空编译程序"><a href="#2-清空编译程序" class="headerlink" title="2. 清空编译程序"></a>2. 清空编译程序</h2><p>在程序目录下执行命令如下</p><p><code>scons -c</code></p><p>这个嘛，，没什么吧，和make clean也没简单多少呀，不就少了几个字母吗，是吗？那咱还继续吧</p><h2 id="3-将cpp或c文件编译为执行文件"><a href="#3-将cpp或c文件编译为执行文件" class="headerlink" title="3. 将cpp或c文件编译为执行文件"></a>3. 将cpp或c文件编译为执行文件</h2><p> 在源文件目录中创建一个SConstruct的文件，并在其中添加如下内容</p><p><code>Program(&#39;testPro1&#39;, Glob(&#39;*.cpp&#39;))</code></p><p> 保存后执行1中的scons命令</p><p> 这就完事了？？是的！这就完事了，只要你程序的语法没错，应该会生成一个名字叫testPro1的程序，如果在window下会生成一个testPro1.exe的程序哟，有没有很酷？</p><p>  将cpp或c文件编译为执行文件有如下2中方式</p><p><strong>方式1：</strong></p><p>   <code>Program(&#39;程序名&#39;, Split(&#39;程序文件序列* *空格分隔&#39;))</code></p><p><strong>方式2：</strong></p><p>  <code>Program(&#39;程序名&#39;, Glob(&#39;*.cpp&#39;))</code></p><h2 id="4-编译的时候想添加上-g-O2-Wall参数"><a href="#4-编译的时候想添加上-g-O2-Wall参数" class="headerlink" title="4. 编译的时候想添加上-g -O2 -Wall参数"></a>4. 编译的时候想添加上-g -O2 -Wall参数</h2><p>使用环境变量</p><p> <code>env=Environment(CCFLAGS = [&#39;-g&#39;,&#39;-O3&#39;,&#39;-Wall&#39;])</code> </p><p>生成程序的时候使用env.Program(。。。。)即可<br>例如：</p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">env</span>=Environment(CCFLAGS = [<span class="hljs-string">&#x27;-g&#x27;</span>,<span class="hljs-string">&#x27;-O3&#x27;</span>,<span class="hljs-string">&#x27;-Wall&#x27;</span>])<br><span class="hljs-keyword">env</span>.Program(<span class="hljs-string">&#x27;程序名&#x27;</span>, Glob(<span class="hljs-string">&#x27;*.cpp&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="5-编译生成静态库"><a href="#5-编译生成静态库" class="headerlink" title="5. 编译生成静态库"></a>5. 编译生成静态库</h2><p>  <strong>方法1：使用Library关键字</strong></p><p>  <code>Library(&#39;库名&#39;, Split(&#39;程序文件序列,空格分隔&#39;)</code></p><p>  或</p><p>  <code>Library(&#39;库名&#39;, Glob(&#39;\*.cpp&#39;))</code></p><p>  <strong>方法2：使用显示关键字StaticLibrary</strong></p><p>  <code>StaticLibrary(&#39;库名&#39;, Split(&#39;程序文件序列,空格分隔&#39;))</code></p><p>  或</p><p>  <code>StaticLibrary(&#39;库名&#39;, Glob(&#39;\*.cpp&#39;))</code></p><p>  说明：库名不要前面的lib和后缀，如库libtestdota.a生成时的库名为testdota</p><h2 id="6-编译生成动态库"><a href="#6-编译生成动态库" class="headerlink" title="6. 编译生成动态库"></a>6. 编译生成动态库</h2><p>  使用关键字<code>SharedLibrary</code></p><p>  <code>SharedLibrary(&#39;库名&#39;, Split(&#39;程序文件序列,空格分隔&#39;))</code></p><p>  或</p><p>  <code>SharedLibrary(&#39;库名&#39;, Glob(&#39;\*.cpp&#39;))</code></p><p>  说明：库名不要前面的lib和后缀，如库libtestso.so生成时的库名为testso</p><h2 id="7-程序或库中引用已有的库"><a href="#7-程序或库中引用已有的库" class="headerlink" title="7. 程序或库中引用已有的库"></a>7. 程序或库中引用已有的库</h2><p>  使用关键字LIBS和LIBPATH</p><p>  LIBS后跟程序需要引用的库名</p><p>  LIBPATH后跟程序引用库的时候所需的库文件路径</p><p>  如：</p><p> <code>Program(&#39;testPro&#39;,&#39;prog.c&#39;, LIBS = [&#39;m&#39;,&#39;m2&#39;], LIBPATH = [&#39;/usr/lib&#39;, &#39;/usr/local/lib&#39;])</code></p><p>  生成的testPro程序要引用库libm.so和libm2.so，库文件路径在/usr/lib和/usr/local/lib下</p><h2 id="8-指定程序编译过程中需要查找的头文件路径"><a href="#8-指定程序编译过程中需要查找的头文件路径" class="headerlink" title="8. 指定程序编译过程中需要查找的头文件路径"></a>8. 指定程序编译过程中需要查找的头文件路径</h2><p> 使用关键字CPPPATH</p><p> 例如：</p><p> <code>Program(&#39;hello&#39;,&#39;hello.c&#39;, CPPPATH = [&#39;include&#39;, &#39;/home/project/inc&#39;])</code></p><p> 生成hello程序的时候hello.c可能引用了其他的头文件，在编译hello.c的时候会查找./include和/home/project/inc下是否有需要的头文件</p><p> 到此一些常用的makefile的功能基本都有了，有没有觉得很简单那，后面会继续写一些实用的相对复杂一些的功能，希望大家能够喜欢！</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scons</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>(转载) 一致性hash算法（consistent hashing）</title>
    <link href="/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/"/>
    <url>/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/</url>
    
    <content type="html"><![CDATA[<p>一致性hash算法 consistent hashing算法早在1997年就在论文**<a href="http://portal.acm.org/citation.cfm?id=258660">Consistent hashing and random trees</a>**中被提出，目前在cache系统中应用越来越广泛；</p><h2 id="1-基本场景"><a href="#1-基本场景" class="headerlink" title="1 基本场景"></a>1 基本场景</h2><p>比如你有N个cache服务器（后面简称cache），那么如何将一个对象object映射到N个cache上呢，你很可能会采用类似下面的通用方法计算object的hash值，然后均匀的映射到到N个cache；</p><p>hash(object)%N </p><p>一切都运行正常，再考虑如下的两种情况；</p><p>1 一个cache服务器m down掉了（在实际应用中必须要考虑这种情况），这样所有映射到cache m的对象都会失效，怎么办，需要把cache m从cache中移除，这时候cache是N-1台，映射公式变成了hash(object)%(N-1)；</p><p>2 由于访问加重，需要添加cache，这时候cache是N+1台，映射公式变成了hash(object)%(N+1)；</p><p>1和2意味着什么？这意味着突然之间几乎所有的cache都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；</p><p>再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的hash算法也做不到。</p><p>有什么方法可以改变这个状况呢，这就是consistent hashing…</p><h2 id="2-hash算法和单调性"><a href="#2-hash算法和单调性" class="headerlink" title="2 hash算法和单调性"></a>2 hash算法和单调性</h2><p>　　Hash算法的一个衡量指标是单调性（Monotonicity），定义如下：</p><p>　　单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p><p>容易看到，上面的简单hash算法hash(object)%N难以满足单调性要求。</p><h2 id="3-consistent-hashing算法的原理"><a href="#3-consistent-hashing算法的原理" class="headerlink" title="3 consistent hashing算法的原理"></a>3 consistent hashing算法的原理</h2><p>consistent hashing是一种hash算法，简单的说，在移除/添加一个cache时，它能够尽可能小的改变已存在key映射关系，尽可能的满足单调性的要求。</p><p>下面就来按照5个步骤简单讲讲consistent hashing算法的基本原理。</p><h3 id="3-1环形hash空间"><a href="#3-1环形hash空间" class="headerlink" title="3.1环形hash空间"></a>3.1环形hash空间</h3><p>考虑通常的hash算法都是将value映射到一个32为的key值，也即是0~2^32-1次方的数值空间；我们可以将这个空间想象成一个首（0）尾（2^32-1）相接的圆环，如下面图1所示的那样。</p><img src="/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/circle.jpg" class="" title="图1. 环形hash空间"><h3 id="3-2-把对象映射到hash空间"><a href="#3-2-把对象映射到hash空间" class="headerlink" title="3.2 把对象映射到hash空间"></a>3.2 把对象映射到hash空间</h3><p>接下来考虑4个对象object1~object4，通过hash函数计算出的hash值key在环上的分布如图2所示。</p><p>hash(object1) = key1;</p><p>… …</p><p>hash(object4) = key4;</p><img src="/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/object.jpg" class="" title="图2. 4个对象的key值分布"><h3 id="3-3-把cache映射到hash空间"><a href="#3-3-把cache映射到hash空间" class="headerlink" title="3.3 把cache映射到hash空间"></a>3.3 把cache映射到hash空间</h3><p>Consistent hashing的基本思想就是将对象和cache都映射到同一个hash数值空间中，并且使用相同的hash算法。</p><p>假设当前有A,B和C共3台cache，那么其映射结果将如图3所示，他们在hash空间中，以对应的hash值排列。</p><p>hash(cache A) = key A;</p><p>… …</p><p>hash(cache C) = key C;</p><img src="/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/cache.jpg" class="" title="图3 cache和对象的key值分布"><p>说到这里，顺便提一下cache的hash计算，一般的方法可以使用cache机器的IP地址或者机器名作为hash输入。</p><h3 id="3-4-把对象映射到cache"><a href="#3-4-把对象映射到cache" class="headerlink" title="3.4 把对象映射到cache"></a>3.4 把对象映射到cache</h3><p>现在cache和对象都已经通过同一个hash算法映射到hash数值空间中了，接下来要考虑的就是如何将对象映射到cache上面了。</p><p>在这个环形空间中，如果沿着顺时针方向从对象的key值出发，直到遇见一个cache，那么就将该对象存储在这个cache上，因为对象和cache的hash值是固定的，因此这个cache必然是唯一和确定的。这样不就找到了对象和cache的映射方法了吗？！</p><p>依然继续上面的例子（参见图3），那么根据上面的方法，对象object1将被存储到cache A上；object2和object3对应到cache C；object4对应到cache B；</p><h3 id="3-5-考察cache的变动"><a href="#3-5-考察cache的变动" class="headerlink" title="3.5 考察cache的变动"></a>3.5 考察cache的变动</h3><p>前面讲过，通过 hash然后求余的方法带来的最大问题就在于不能满足单调性，当cache有所变动时，cache会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析consistent hashing算法。</p><h4 id="3-5-1-移除cache"><a href="#3-5-1-移除cache" class="headerlink" title="3.5.1 移除cache"></a>3.5.1 移除cache</h4><p>考虑假设cache B挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿cache B逆时针遍历直到下一个cache（cache C）之间的对象，也即是本来映射到cache B上的那些对象。</p><p>因此这里仅需要变动对象object4，将其重新映射到cache C上即可；参见图4。</p><img src="/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/remove.jpg" class="" title="图4 CacheB被移除后的cache映射"><h4 id="3-5-2-添加cache"><a href="#3-5-2-添加cache" class="headerlink" title="3.5.2 添加cache"></a>3.5.2 添加cache</h4><p>再考虑添加一台新的cache D的情况，假设在这个环形hash空间中，cache D被映射在对象object2和object3之间。这时受影响的将仅是那些沿cache D逆时针遍历直到下一个cache（cache B）之间的对象（它们是也本来映射到cache C上对象的一部分），将这些对象重新映射到cache D上即可。</p><p>因此这里仅需要变动对象object2，将其重新映射到cache D上；参见图5。</p><img src="/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/add.jpg" class="" title="图5. 添加cacheD后的映射关系"><h2 id="4-虚拟节点"><a href="#4-虚拟节点" class="headerlink" title="4 虚拟节点"></a>4 虚拟节点</h2><p>考量Hash算法的另一个指标是平衡性(Balance)，定义如下：</p><p>平衡性</p><p>　　平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p><p>hash算法并不是保证绝对的平衡，如果cache较少的话，对象并不能被均匀的映射到cache上，比如在上面的例子中，仅部署cache A和cache C的情况下，在4个对象中，cache A仅存储了object1，而cache C则存储了object2、object3和object4；分布是很不均衡的。</p><p>为了解决这种情况，consistent hashing引入了“虚拟节点”的概念，它可以如下定义：</p><p>“虚拟节点”（virtual node）是实际节点在hash空间的复制品（replica），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在hash空间中以hash值排列。</p><p>仍以仅部署cache A和cache C的情况为例，在图4中我们已经看到，cache分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为2，这就意味着一共会存在4个“虚拟节点”， cache A1, cache A2代表了cache A；cache C1, cache C2代表了cache C；假设一种比较理想的情况，参见图6。</p><img src="/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/virtual.jpg" class="" title="图6. 引入“虚拟节点”后的映射关系"><p>此时，对象到“虚拟节点”的映射关系为：</p><p>objec1-&gt;cache A2；objec2-&gt;cache A1；objec3-&gt;cache C1；objec4-&gt;cache C2；</p><p>因此对象object1和object2都被映射到了cache A上，而object3和object4映射到了cache C上；平衡性有了很大提高。</p><p>引入“虚拟节点”后，映射关系就从{对象-&gt;节点}转换到了{对象-&gt;虚拟节点}。查询物体所在cache时的映射关系如图7所示。</p><img src="/2014/08/01/00%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/map.jpg" class="" title="图7. 查询对象所在cache"><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设cache A的IP地址为202.168.14.241。</p><p>引入“虚拟节点”前，计算cache A的hash值：</p><p>Hash(“202.168.14.241”);</p><p>引入“虚拟节点”后，计算“虚拟节”点cache A1和cache A2的hash值：</p><p>Hash(“202.168.14.241#1”); // cache A1</p><p>Hash(“202.168.14.241#2”); // cache A2</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p>Consistent hashing的基本原理就是这些，具体的分布性等理论分析应该是很复杂的，不过一般也用不到。</p><p><a href="http://weblogs.java.net/blog/2007/11/27/consistent-hashing%E4%B8%8A%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AAjava%E7%89%88%E6%9C%AC%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E3%80%82">http://weblogs.java.net/blog/2007/11/27/consistent-hashing上面有一个java版本的例子，可以参考。</a></p><p><a href="http://blog.csdn.net/mayongzhan/archive/2009/06/25/4298834.aspx%E8%BD%AC%E8%BD%BD%E4%BA%86%E4%B8%80%E4%B8%AAPHP%E7%89%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E3%80%82">http://blog.csdn.net/mayongzhan/archive/2009/06/25/4298834.aspx转载了一个PHP版的实现代码。</a></p><p><a href="http://www.codeproject.com/KB/recipes/lib-conhash.aspx">http://www.codeproject.com/KB/recipes/lib-conhash.aspx</a> C语言版本</p><p>一些参考资料地址：</p><p><a href="http://portal.acm.org/citation.cfm?id=258660">http://portal.acm.org/citation.cfm?id=258660</a></p><p><a href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></p><p><a href="http://www.spiteful.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/">http://www.spiteful.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/</a></p><p><a href="http://weblogs.java.net/blog/2007/11/27/consistent-hashing">http://weblogs.java.net/blog/2007/11/27/consistent-hashing</a></p><p><a href="http://tech.idv2.com/2008/07/24/memcached-004/">http://tech.idv2.com/2008/07/24/memcached-004/</a></p><p><a href="http://blog.csdn.net/mayongzhan/archive/2009/06/25/4298834.aspx">http://blog.csdn.net/mayongzhan/archive/2009/06/25/4298834.aspx</a></p>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hash, 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh跳转无密码登录或执行命令</title>
    <link href="/2012/03/20/04DevOps/06ssh%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E6%88%96%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"/>
    <url>/2012/03/20/04DevOps/06ssh%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E6%88%96%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>我们在使用linux开发过程中，经常需要在不同服务器间进行跳转，通过ssh，每次都需要输入密码，比较繁琐，今天从网上找了相关的方法，但是实验过程中发现还是有些问题，特将一些细节整理如下：</p><p>比如我有机器192.168.1.100 和192.168.1.200两台服务器，我想从100登录到200中利用ssh不输入密码，所以我需要进行如下的步骤</p><ol><li><p>首先在ip为<strong>100</strong>的机器上执行ssh-keygen 命令，一路回车，这样，就在当前用户目录下的.ssh文件夹下生成了两个文件id_rsa和id_rsa.pub文件</p></li><li><p>将id_rsa.pub利用scp命令传送到200机器上，，如scp id_rsa.pub <a href="mailto:root@192.168.1.200:/root/.ssh/100.put">root@192.168.1.200:/root/.ssh/100.put</a></p></li></ol><p>如果在200的/root/.ssh/目录下有 authorized_keys 这个文件的话，则直接利用cat命令将100.put文件内容添加到 authorized_keys后， 命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span> <span class="hljs-number">100</span>.pub &gt;&gt; authorized_keys<br></code></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>注意，不能利用手工的拷贝，否则会导致失败，只能用cat &gt;&gt; （这点让我尝试了很多次）</p></blockquote></blockquote></blockquote><ol start="3"><li>修改authorized_keys 的权限为600，如下：chmod 600 authorized_keys</li></ol><p>然后删除100.pub就可以了，大功告成，赶紧到100的机器上试试 ssh <a href="mailto:root@192.168.1.200">root@192.168.1.200</a> ，看看直接进去了吧，不用再输入密码了！</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
