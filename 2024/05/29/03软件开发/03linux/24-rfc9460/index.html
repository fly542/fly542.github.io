

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Fly542">
  <meta name="keywords" content="">
  
    <meta name="description" content="RFC 9460Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records) 通过DNS进行服务绑定和参数指定 SVCB 和 HTTPS 资源记录 AbstractThis document specifies the “SVCB” (“Service Binding”) and">
<meta property="og:type" content="article">
<meta property="og:title" content="RFC9460(通过DNS进行服务绑定和参数指定 SVCB 和 HTTPS 资源记录)">
<meta property="og:url" content="http://fly542.cn/2024/05/29/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/03linux/24-rfc9460/index.html">
<meta property="og:site_name" content="Fly542 技术沉淀">
<meta property="og:description" content="RFC 9460Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records) 通过DNS进行服务绑定和参数指定 SVCB 和 HTTPS 资源记录 AbstractThis document specifies the “SVCB” (“Service Binding”) and">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-29T02:11:57.000Z">
<meta property="article:modified_time" content="2024-05-29T02:54:27.748Z">
<meta property="article:author" content="Fly542">
<meta property="article:tag" content="dns">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>RFC9460(通过DNS进行服务绑定和参数指定 SVCB 和 HTTPS 资源记录) - Fly542 技术沉淀</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"fly542.cn","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fly542 技术沉淀</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="RFC9460(通过DNS进行服务绑定和参数指定 SVCB 和 HTTPS 资源记录)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-05-29 10:11" pubdate>
        2024年5月29日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      61k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      505 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">RFC9460(通过DNS进行服务绑定和参数指定 SVCB 和 HTTPS 资源记录)</h1>
            
            <div class="markdown-body">
              <p>RFC 9460<br>Service Binding and Parameter Specification via the DNS (SVCB and HTTPS Resource Records)</p>
<p>通过DNS进行服务绑定和参数指定 SVCB 和 HTTPS 资源记录</p>
<p><strong>Abstract</strong><br>This document specifies the “SVCB” (“Service Binding”) and “HTTPS” DNS resource record (RR) types to facilitate the lookup of information needed to make connections to network services, such as for HTTP origins. SVCB records allow a service to be provided from multiple alternative endpoints, each with associated parameters (such as transport protocol configuration), and are extensible to support future uses (such as keys for encrypting the TLS ClientHello). They also enable aliasing of apex domains, which is not possible with CNAME. The HTTPS RR is a variation of SVCB for use with HTTP (see RFC 9110, “HTTP Semantics”). By providing more information to the client before it attempts to establish a connection, these records offer potential benefits to both performance and privacy.</p>
<p><strong>Status of This Memo</strong><br>This is an Internet Standards Track document.</p>
<p>This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.</p>
<p>Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc9460">https://www.rfc-editor.org/info/rfc9460</a>.</p>
<p>**Copyright Notice **<br>Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust’s Legal Provisions Relating to IETF Documents (<a target="_blank" rel="noopener" href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.</p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>The SVCB (“Service Binding”) and HTTPS resource records (RRs) provide clients with complete instructions for access to a service. This information enables improved performance and privacy by avoiding transient connections to a suboptimal default server, negotiating a preferred protocol, and providing relevant public keys.</p>
<p>For example, HTTP clients currently resolve only A and/or AAAA records for the origin hostname, learning only its IP addresses. If an HTTP client learns more about the origin before connecting, it may be able to upgrade “http” URLs to “https”, enable HTTP/3 or Encrypted ClientHello [ECH], or switch to an operationally preferable endpoint. It is highly desirable to minimize the number of round trips and lookups required to learn this additional information.</p>
<p>The SVCB and HTTPS RRs also help when the operator of a service wishes to delegate operational control to one or more other domains, e.g., aliasing the origin “<a target="_blank" rel="noopener" href="https://example.com&quot;/">https://example.com&quot;</a> to a service operator endpoint at “svc.example.net”. While this case can sometimes be handled by a CNAME, that does not cover all use cases. CNAME is also inadequate when the service operator needs to provide a bound collection of consistent configuration parameters through the DNS (such as network location, protocol, and keying information).</p>
<p>This document first describes the SVCB RR as a general-purpose RR that can be applied directly and efficiently to a wide range of services (Section 2). It also describes the rules for defining other SVCB-compatible RR types (Section 6), starting with the HTTPS RR type (Section 9), which provides improved efficiency and convenience with HTTP by avoiding the need for an Attrleaf label [Attrleaf] (Section 9.1).</p>
<p>The SVCB RR has two modes: 1) “AliasMode”, which simply delegates operational control for a resource and 2) “ServiceMode”, which binds together configuration information for a service endpoint. ServiceMode provides additional key=value parameters within each RDATA set.</p>
<h2 id="1-1-Goals"><a href="#1-1-Goals" class="headerlink" title="1.1. Goals"></a>1.1. Goals</h2><p>The goal of the SVCB RR is to allow clients to resolve a single additional DNS RR in a way that:</p>
<ul>
<li>Provides alternative endpoints that are authoritative for the service, along with parameters associated with each of these endpoints.</li>
<li>Does not assume that all alternative endpoints have the same parameters or capabilities, or are even operated by the same entity. This is important, as DNS does not provide any way to tie together multiple RRsets for the same name. For example, if “<a target="_blank" rel="noopener" href="http://www.example.com&quot;/">www.example.com&quot;</a> is a CNAME alias that switches between one of three Content Delivery Networks (CDNs) or hosting environments, successive queries for that name may return records that correspond to different environments.</li>
<li>Enables CNAME-like functionality at a zone apex (such as “example.com”) for participating protocols and generally enables extending operational authority for a service identified by a domain name to other instances with alternate names.</li>
</ul>
<p>Additional goals specific to HTTPS RRs and the HTTP use cases include:</p>
<ul>
<li>Connecting directly to HTTP/3 (QUIC transport) alternative endpoints [HTTP/3].</li>
<li>Supporting non-default TCP and UDP ports.</li>
<li>Enabling SRV-like benefits (e.g., apex aliasing, as mentioned above) for HTTP, where SRV [SRV] has not been widely adopted.</li>
<li>Providing an indication signaling that the “https” scheme should be used instead of “http” for all HTTP requests to this host and port, similar to HTTP Strict Transport Security [HSTS] (see Section 9.5).</li>
<li>Enabling the conveyance of Encrypted ClientHello keys [ECH] associated with an alternative endpoint.</li>
</ul>
<h2 id="1-2-Overview-of-the-SVCB-RR"><a href="#1-2-Overview-of-the-SVCB-RR" class="headerlink" title="1.2. Overview of the SVCB RR"></a>1.2. Overview of the SVCB RR</h2><p>This subsection briefly describes the SVCB RR with forward references to the full exposition of each component. (As discussed in Section 6, this all applies equally to the HTTPS RR, which shares the same encoding, format, and high-level semantics.)</p>
<p>The SVCB RR has two modes: 1) AliasMode (Section 2.4.2), which aliases a name to another name and 2) ServiceMode (Section 2.4.3), which provides connection information bound to a service endpoint domain. Placing both forms in a single RR type allows clients to fetch the relevant information with a single query (Section 2.3).</p>
<p>The SVCB RR has two required fields and one optional field. The fields are:</p>
<ul>
<li>SvcPriority (Section 2.4.1): The priority of this record (relative to others, with lower values preferred). A value of 0 indicates AliasMode.</li>
<li>TargetName: The domain name of either the alias target (for AliasMode) or the alternative endpoint (for ServiceMode).</li>
<li>SvcParams (optional):A list of key=value pairs describing the alternative endpoint at TargetName (only used in ServiceMode and otherwise ignored). SvcParams are described in Section 2.1.</li>
</ul>
<p>Cooperating DNS recursive resolvers will perform subsequent record resolution (for SVCB, A, and AAAA records) and return them in the Additional section of the response (Section 4.2). Clients either use responses included in the Additional section returned by the recursive resolver or perform necessary SVCB, A, and AAAA record resolutions (Section 3). DNS authoritative servers can attach in-bailiwick SVCB, A, AAAA, and CNAME records in the Additional section to responses for a SVCB query (Section 4.1).</p>
<p>In ServiceMode, the SvcParams of the SVCB RR provide an extensible data model for describing alternative endpoints that are authoritative for a service, along with parameters associated with each of these alternative endpoints (Section 7).</p>
<p>For HTTP use cases, the HTTPS RR (Section 9) enables many of the benefits of Alt-Svc [AltSvc] without waiting for a full HTTP connection initiation (multiple round trips) before learning of the preferred alternative, and without necessarily revealing the user’s intended destination to all entities along the network path.</p>
<h2 id="1-3-Terminology"><a href="#1-3-Terminology" class="headerlink" title="1.3. Terminology"></a>1.3. Terminology</h2><p>Terminology in this document is based on the common case where the SVCB record is used to access a resource identified by a URI whose authority field contains a DNS hostname as the host.</p>
<ul>
<li>The “service” is the information source identified by the authority and scheme of the URI, capable of providing access to the resource. For “https” URIs, the “service” corresponds to an “origin” [RFC6454].</li>
<li>The “service name” is the host portion of the authority.</li>
<li>The “authority endpoint” is the authority’s hostname and a port number implied by the scheme or specified in the URI.</li>
<li>An “alternative endpoint” is a hostname, port number, and other associated instructions to the client on how to reach an instance of a service.</li>
<li>Additional DNS terminology intends to be consistent with [DNSTerm].</li>
</ul>
<p>SVCB is a contraction of “service binding”. The SVCB RR, HTTPS RR, and future RR types that share SVCB’s formats and registry are collectively known as SVCB-compatible RR types. The contraction “SVCB” is also used to refer to this system as a whole.</p>
<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.</p>
<h1 id="2-The-SVCB-Record-Type"><a href="#2-The-SVCB-Record-Type" class="headerlink" title="2. The SVCB Record Type"></a>2. The SVCB Record Type</h1><p>The SVCB DNS RR type (RR type 64) is used to locate alternative endpoints for a service.</p>
<p>The algorithm for resolving SVCB records and associated address records is specified in Section 3.</p>
<p>Other SVCB-compatible RR types can also be defined as needed (see Section 6). In particular, the HTTPS RR (RR type 65) provides special handling for the case of “https” origins as described in Section 9.</p>
<p>SVCB RRs are extensible by a list of SvcParams, which are pairs consisting of a SvcParamKey and a SvcParamValue. Each SvcParamKey has a presentation name and a registered number. Values are in a format specific to the SvcParamKey. Each SvcParam has a specified presentation format (used in zone files) and wire encoding (e.g., domain names, binary data, or numeric values). The initial SvcParamKeys and their formats are defined in Section 7.</p>
<h2 id="2-1-Zone-File-Presentation-Format"><a href="#2-1-Zone-File-Presentation-Format" class="headerlink" title="2.1. Zone-File Presentation Format"></a>2.1. Zone-File Presentation Format</h2><p>The presentation format <RDATA> of the record ([RFC1035], Section 5.1) has the form:</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SvcPriority TargetName SvcParams</span><br></code></pre></td></tr></table></figure>

<p>The SVCB record is defined specifically within the Internet (“IN”) Class ([RFC1035], Section 3.2.4).</p>
<p>SvcPriority is a number in the range 0-65535, TargetName is a <domain-name> ([RFC1035], Section 5.1), and the SvcParams are a whitespace-separated list with each SvcParam consisting of a SvcParamKey=SvcParamValue pair or a standalone SvcParamKey. SvcParamKeys are registered by IANA (Section 14.3).</p>
<p>Each SvcParamKey SHALL appear at most once in the SvcParams. In presentation format, SvcParamKeys are lowercase alphanumeric strings. Key names contain 1-63 characters from the ranges “a”-“z”, “0”-“9”, and “-“. In ABNF [RFC5234],</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">alpha-lc</span>      = %x61-<span class="hljs-number">7</span>A   <span class="hljs-comment">; a-z</span><br><span class="hljs-attr">SvcParamKey</span>   = <span class="hljs-number">1</span>*<span class="hljs-number">63</span>(alpha-lc / DIGIT / <span class="hljs-string">&quot;-&quot;</span>)<br><span class="hljs-attr">SvcParam</span>      = SvcParamKey [<span class="hljs-string">&quot;=&quot;</span> SvcParamValue]<br><span class="hljs-attr">SvcParamValue</span> = char-string <span class="hljs-comment">; See Appendix A.</span><br><span class="hljs-attr">value</span>         = *OCTET <span class="hljs-comment">; Value before key-specific parsing</span><br></code></pre></td></tr></table></figure>

<p>The SvcParamValue is parsed using the character-string decoding algorithm (Appendix A), producing a value. The value is then validated and converted into wire format in a manner specific to each key.</p>
<p>When the optional “=” and SvcParamValue are omitted, the value is interpreted as empty.</p>
<p>Arbitrary keys can be represented using the unknown-key presentation format “keyNNNNN” where NNNNN is the numeric value of the key type without leading zeros. A SvcParam in this form SHALL be parsed as specified above, and the decoded value SHALL be used as its wire-format encoding.</p>
<p>For some SvcParamKeys, the value corresponds to a list or set of items. Presentation formats for such keys SHOULD use a comma-separated list (Appendix A.1).</p>
<p>SvcParams in presentation format MAY appear in any order, but keys MUST NOT be repeated.</p>
<h2 id="2-2-RDATA-Wire-Format"><a href="#2-2-RDATA-Wire-Format" class="headerlink" title="2.2. RDATA Wire Format"></a>2.2. RDATA Wire Format</h2><p>The RDATA for the SVCB RR consists of:</p>
<ul>
<li>a 2-octet field for SvcPriority as an integer in network byte order.</li>
<li>the uncompressed, fully qualified TargetName, represented as a sequence of length-prefixed labels per Section 3.1 of [RFC1035].</li>
<li>the SvcParams, consuming the remainder of the record (so smaller than 65535 octets and constrained by the RDATA and DNS message sizes).</li>
</ul>
<p>When the list of SvcParams is non-empty, it contains a series of SvcParamKey=SvcParamValue pairs, represented as:</p>
<ul>
<li>a 2-octet field containing the SvcParamKey as an integer in network byte order. (See Section 14.3.2 for the defined values.)</li>
<li>a 2-octet field containing the length of the SvcParamValue as an integer between 0 and 65535 in network byte order.</li>
<li>an octet string of this length whose contents are the SvcParamValue in a format determined by the SvcParamKey.</li>
</ul>
<p>SvcParamKeys SHALL appear in increasing numeric order.</p>
<p>Clients MUST consider an RR malformed if:</p>
<ul>
<li>the end of the RDATA occurs within a SvcParam.</li>
<li>SvcParamKeys are not in strictly increasing numeric order.</li>
<li>the SvcParamValue for a SvcParamKey does not have the expected format.</li>
</ul>
<p>Note that the second condition implies that there are no duplicate SvcParamKeys.</p>
<p>If any RRs are malformed, the client MUST reject the entire RRset and fall back to non-SVCB connection establishment.</p>
<h2 id="2-3-SVCB-Query-Names"><a href="#2-3-SVCB-Query-Names" class="headerlink" title="2.3. SVCB Query Names"></a>2.3. SVCB Query Names</h2><p>When querying the SVCB RR, a service is translated into a QNAME by prepending the service name with a label indicating the scheme, prefixed with an underscore, resulting in a domain name like “_examplescheme.api.example.com.”. This follows the Attrleaf naming pattern [Attrleaf], so the scheme MUST be registered appropriately with IANA (see Section 11).</p>
<p>Protocol mapping documents MAY specify additional underscore-prefixed labels to be prepended. For schemes that specify a port (Section 3.2.3 of [URI]), one reasonable possibility is to prepend the indicated port number if a non-default port number is specified. This document terms this behavior “Port Prefix Naming” and uses it in the examples throughout.</p>
<p>See Section 9.1 for information regarding HTTPS RR behavior.</p>
<p>When a prior CNAME or SVCB record has aliased to a SVCB record, each RR SHALL be returned under its own owner name, as in ordinary CNAME processing ([RFC1034], Section 3.6.2). For details, see the recommendations regarding aliases for clients (Section 3), servers (Section 4), and zones (Section 10).</p>
<p>Note that none of these forms alter the origin or authority for validation purposes. For example, TLS clients MUST continue to validate TLS certificates for the original service name.</p>
<p>As an example, the owner of “example.com” could publish this record:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">_8443._foo<span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>. <span class="hljs-number">7200</span> IN SVCB <span class="hljs-number">0</span> svc4<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>.<br></code></pre></td></tr></table></figure>

<p>This record would indicate that “foo://api.example.com:8443” is aliased to “svc4.example.net”. The owner of “example.net”, in turn, could publish this record:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">svc4<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>.  <span class="hljs-number">7200</span>  IN SVCB <span class="hljs-number">3</span> svc4<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>. (<br>    alpn=<span class="hljs-string">&quot;bar&quot;</span> port=<span class="hljs-string">&quot;8004&quot;</span> )<br></code></pre></td></tr></table></figure>

<p>This record would indicate that these services are served on port number 8004, which supports the protocol “bar” and its associated transport in addition to the default transport protocol for “foo://“.</p>
<p>(Parentheses are used to ignore a line break in DNS zone-file presentation format, per Section 5.1 of [RFC1035].)</p>
<h2 id="2-4-Interpretation"><a href="#2-4-Interpretation" class="headerlink" title="2.4. Interpretation"></a>2.4. Interpretation</h2><h3 id="2-4-1-SvcPriority"><a href="#2-4-1-SvcPriority" class="headerlink" title="2.4.1. SvcPriority"></a>2.4.1. SvcPriority</h3><p>When SvcPriority is 0, the SVCB record is in AliasMode (Section 2.4.2). Otherwise, it is in ServiceMode (Section 2.4.3).</p>
<p>Within a SVCB RRset, all RRs SHOULD have the same mode. If an RRset contains a record in AliasMode, the recipient MUST ignore any ServiceMode records in the set.</p>
<p>RRsets are explicitly unordered collections, so the SvcPriority field is used to impose an ordering on SVCB RRs. A smaller SvcPriority indicates that the domain owner recommends the use of this record over ServiceMode RRs with a larger SvcPriority value.</p>
<p>When receiving an RRset containing multiple SVCB records with the same SvcPriority value, clients SHOULD apply a random shuffle within a priority level to the records before using them, to ensure uniform load balancing.</p>
<h3 id="2-4-2-AliasMode"><a href="#2-4-2-AliasMode" class="headerlink" title="2.4.2. AliasMode"></a>2.4.2. AliasMode</h3><p>In AliasMode, the SVCB record aliases a service to a TargetName. SVCB RRsets SHOULD only have a single RR in AliasMode. If multiple AliasMode RRs are present, clients or recursive resolvers SHOULD pick one at random.</p>
<p>The primary purpose of AliasMode is to allow aliasing at the zone apex, where CNAME is not allowed (see, for example, [RFC1912], Section 2.4). In AliasMode, the TargetName will be the name of a domain that resolves to SVCB, AAAA, and/or A records. (See Section 6 for aliasing of SVCB-compatible RR types.) Unlike CNAME, AliasMode records do not affect the resolution of other RR types and apply only to a specific service, not an entire domain name.</p>
<p>The AliasMode TargetName SHOULD NOT be equal to the owner name, as this would result in a loop. In AliasMode, recipients MUST ignore any SvcParams that are present. Zone-file parsers MAY emit a warning if an AliasMode record has SvcParams. The use of SvcParams in AliasMode records is currently not defined, but a future specification could extend AliasMode records to include SvcParams.</p>
<p>For example, the operator of “foo://example.com:8080” could point requests to a service operating at “foosvc.example.net” by publishing:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">_8080._foo<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>. <span class="hljs-number">3600</span> IN SVCB <span class="hljs-number">0</span> foosvc<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>.<br></code></pre></td></tr></table></figure>

<p>Using AliasMode maintains a separation of concerns: the owner of “foosvc.example.net” can add or remove ServiceMode SVCB records without requiring a corresponding change to “example.com”. Note that if “foosvc.example.net” promises to always publish a SVCB record, this AliasMode record can be replaced by a CNAME at the same owner name.</p>
<p>AliasMode is especially useful for SVCB-compatible RR types that do not require an underscore prefix, such as the HTTPS RR type. For example, the operator of “<a target="_blank" rel="noopener" href="https://example.com&quot;/">https://example.com&quot;</a> could point requests to a server at “svc.example.net” by publishing this record at the zone apex:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">example<span class="hljs-selector-class">.com</span>. <span class="hljs-number">3600</span> IN HTTPS <span class="hljs-number">0</span> svc<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>.<br></code></pre></td></tr></table></figure>

<p>Note that the SVCB record’s owner name MAY be the canonical name of a CNAME record, and the TargetName MAY be the owner of a CNAME record. Clients and recursive resolvers MUST follow CNAMEs as normal.</p>
<p>To avoid unbounded alias chains, clients and recursive resolvers MUST impose a limit on the total number of SVCB aliases they will follow for each resolution request. This limit MUST NOT be zero, i.e., implementations MUST be able to follow at least one AliasMode record. The exact value of this limit is left to implementations.</p>
<p>Zones that require following multiple AliasMode records could encounter compatibility and performance issues.</p>
<p>As legacy clients will not know to use this record, service operators will likely need to retain fallback AAAA and A records alongside this SVCB record, although in a common case the target of the SVCB record might offer better performance, and therefore would be preferable for clients implementing this specification to use.</p>
<p>AliasMode records only apply to queries for the specific RR type. For example, a SVCB record cannot alias to an HTTPS record or vice versa.</p>
<h3 id="2-4-3-ServiceMode"><a href="#2-4-3-ServiceMode" class="headerlink" title="2.4.3. ServiceMode"></a>2.4.3. ServiceMode</h3><p>In ServiceMode, the TargetName and SvcParams within each RR associate an alternative endpoint for the service with its connection parameters.</p>
<p>Each protocol scheme that uses SVCB MUST define a protocol mapping that explains how SvcParams are applied for connections of that scheme. Unless specified otherwise by the protocol mapping, clients MUST ignore any SvcParam that they do not recognize.</p>
<p>Some SvcParams impose requirements on other SvcParams in the RR. A ServiceMode RR is called “self-consistent” if its SvcParams all comply with each other’s requirements. Clients MUST reject any RR whose recognized SvcParams are not self-consistent and MAY reject the entire RRset. To help zone operators avoid this condition, zone-file implementations SHOULD enforce self-consistency as well.</p>
<h2 id="2-5-Special-Handling-of-“-”-in-TargetName"><a href="#2-5-Special-Handling-of-“-”-in-TargetName" class="headerlink" title="2.5. Special Handling of “.” in TargetName"></a>2.5. Special Handling of “.” in TargetName</h2><p>If TargetName has the value “.” (represented in the wire format as a zero-length label), special rules apply.</p>
<h3 id="2-5-1-AliasMode"><a href="#2-5-1-AliasMode" class="headerlink" title="2.5.1. AliasMode"></a>2.5.1. AliasMode</h3><p>For AliasMode SVCB RRs, a TargetName of “.” indicates that the service is not available or does not exist. This indication is advisory: clients encountering this indication MAY ignore it and attempt to connect without the use of SVCB.</p>
<h3 id="2-5-2-ServiceMode"><a href="#2-5-2-ServiceMode" class="headerlink" title="2.5.2. ServiceMode"></a>2.5.2. ServiceMode</h3><p>For ServiceMode SVCB RRs, if TargetName has the value “.”, then the owner name of this record MUST be used as the effective TargetName. If the record has a wildcard owner name in the zone file, the recipient SHALL use the response’s synthesized owner name as the effective TargetName.</p>
<p>Here, for example, “svc2.example.net” is the effective TargetName:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">example</span>.com.      <span class="hljs-number">7200</span>  IN HTTPS <span class="hljs-number">0</span> svc.example.net.<br><span class="hljs-attribute">svc</span>.example.net.  <span class="hljs-number">7200</span>  IN CNAME svc<span class="hljs-number">2</span>.example.net.<br><span class="hljs-attribute">svc2</span>.example.net. <span class="hljs-number">7200</span>  IN HTTPS <span class="hljs-number">1</span> . port=<span class="hljs-number">8002</span><br><span class="hljs-attribute">svc2</span>.example.net. <span class="hljs-number">300</span>   IN A     <span class="hljs-number">192.0.2.2</span><br><span class="hljs-attribute">svc2</span>.example.net. <span class="hljs-number">300</span>   IN AAAA  <span class="hljs-number">2001</span>:db<span class="hljs-number">8</span>::<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h1 id="3-Client-Behavior"><a href="#3-Client-Behavior" class="headerlink" title="3. Client Behavior"></a>3. Client Behavior</h1><p>“SVCB resolution” is the process of enumerating and ordering the available endpoints for a service, as performed by the client. SVCB resolution is implemented as follows:</p>
<ol>
<li>Let $QNAME be the service name plus appropriate prefixes for the scheme (see Section 2.3).</li>
<li>Issue a SVCB query for $QNAME.</li>
<li>If an AliasMode SVCB record is returned for $QNAME (after following CNAMEs as normal), set $QNAME to its TargetName (without additional prefixes) and loop back to Step 2, subject to chain length limits and loop detection heuristics (see Section 3.1).</li>
<li>If one or more “compatible” (Section 8) ServiceMode records are returned, these represent the alternative endpoints. Sort the records by ascending SvcPriority.</li>
<li>Otherwise, SVCB resolution has failed, and the list of available endpoints is empty.</li>
</ol>
<p>This procedure does not rely on any recursive or authoritative DNS server to comply with this specification or have any awareness of SVCB.</p>
<p>A client is called “SVCB-optional” if it can connect without the use of ServiceMode records; otherwise, it is called “SVCB-reliant”. Clients for pre-existing protocols (e.g., HTTP) SHALL implement SVCB-optional behavior (except as noted in Section 3.1 or when modified by future specifications).</p>
<p>SVCB-optional clients SHOULD issue in parallel any other DNS queries that might be needed for connection establishment if the SVCB record is absent, in order to minimize delay in that case and enable the optimizations discussed in Section 5.</p>
<p>Once SVCB resolution has concluded, whether successful or not, if at least one AliasMode record was processed, SVCB-optional clients SHALL append to the list of endpoints an endpoint consisting of the final value of $QNAME, the authority endpoint’s port number, and no SvcParams. (This endpoint will be attempted before falling back to non-SVCB connection modes. This ensures that SVCB-optional clients will make use of an AliasMode record whose TargetName has A and/or AAAA records but no SVCB records.)</p>
<p>The client proceeds with connection establishment using this list of endpoints. Clients SHOULD try higher-priority alternatives first, with fallback to lower-priority alternatives. Clients resolve AAAA and/or A records for the selected TargetName and MAY choose between them using an approach such as Happy Eyeballs [HappyEyeballsV2].</p>
<p>If the client is SVCB-optional and connecting using this list of endpoints has failed, the client now attempts to use non-SVCB connection modes.</p>
<p>Some important optimizations are discussed in Section 5 to avoid additional latency in comparison to ordinary AAAA/A lookups.</p>
<h2 id="3-1-Handling-Resolution-Failures"><a href="#3-1-Handling-Resolution-Failures" class="headerlink" title="3.1. Handling Resolution Failures"></a>3.1. Handling Resolution Failures</h2><p>If DNS responses are cryptographically protected (e.g., using DNSSEC or TLS [DoT] [DoH]) and SVCB resolution fails due to an authentication error, SERVFAIL response, transport error, or timeout, the client SHOULD abandon its attempt to reach the service, even if the client is SVCB-optional. Otherwise, an active attacker could mount a downgrade attack by denying the user access to the SvcParams.</p>
<p>A SERVFAIL error can occur if the domain is DNSSEC-signed, the recursive resolver is DNSSEC-validating, and the attacker is between the recursive resolver and the authoritative DNS server. A transport error or timeout can occur if an active attacker between the client and the recursive resolver is selectively dropping SVCB queries or responses, based on their size or other observable patterns.</p>
<p>If the client enforces DNSSEC validation on A/AAAA responses, it SHOULD apply the same validation policy to SVCB. Otherwise, an attacker could defeat the A/AAAA protection by forging SVCB responses that direct the client to other IP addresses.</p>
<p>If DNS responses are not cryptographically protected, clients MAY treat SVCB resolution failure as fatal or nonfatal.</p>
<p>If the client is unable to complete SVCB resolution due to its chain length limit, the client MUST fall back to the authority endpoint, as if the service’s SVCB record did not exist.</p>
<h2 id="3-2-Clients-Using-a-Proxy"><a href="#3-2-Clients-Using-a-Proxy" class="headerlink" title="3.2. Clients Using a Proxy"></a>3.2. Clients Using a Proxy</h2><p>Clients using a domain-oriented transport proxy like HTTP CONNECT ([RFC7231], Section 4.3.6) or SOCKS5 [RFC1928] have the option of using named destinations, in which case the client does not perform any A or AAAA queries for destination domains. If the client is configured to use named destinations with a proxy that does not provide SVCB query capability (e.g., through an affiliated DNS resolver), the client would have to perform SVCB resolution separately, likely disclosing the destinations to additional parties and not just the proxy. Clients in this configuration SHOULD arrange for a separate SVCB resolution procedure with appropriate privacy properties. If this is not possible, SVCB-optional clients MUST disable SVCB resolution entirely, and SVCB-reliant clients MUST treat the configuration as invalid.</p>
<p>If the client does use SVCB and named destinations, the client SHOULD follow the standard SVCB resolution process, selecting the smallest-SvcPriority option that is compatible with the client and the proxy. When connecting using a SVCB record, clients MUST provide the final TargetName and port to the proxy, which will perform any required A and AAAA lookups.</p>
<p>This arrangement has several benefits:</p>
<ul>
<li>Compared to disabling SVCB:<ul>
<li>It allows the client to use the SvcParams, if present, which are only usable with a specific TargetName. The SvcParams may include information that enhances performance (e.g., supported protocols) and privacy.</li>
<li>It allows a service on an apex domain to use aliasing.</li>
</ul>
</li>
<li>Compared to providing the proxy with an IP address:<ul>
<li>It allows the proxy to select between IPv4 and IPv6 addresses for the server according to its configuration.</li>
<li>It ensures that the proxy receives addresses based on its network geolocation, not the client’s.</li>
<li>It enables faster fallback for TCP destinations with multiple addresses of the same family.</li>
</ul>
</li>
</ul>
<h1 id="4-DNS-Server-Behavior"><a href="#4-DNS-Server-Behavior" class="headerlink" title="4. DNS Server Behavior"></a>4. DNS Server Behavior</h1><h2 id="4-1-Authoritative-Servers"><a href="#4-1-Authoritative-Servers" class="headerlink" title="4.1. Authoritative Servers"></a>4.1. Authoritative Servers</h2><p>When replying to a SVCB query, authoritative DNS servers SHOULD return A, AAAA, and SVCB records in the Additional section for any TargetNames that are in the zone. If the zone is signed, the server SHOULD also include DNSSEC records authenticating the existence or nonexistence of these records in the Additional section.</p>
<p>See Section 4.4 for exceptions.</p>
<h2 id="4-2-Recursive-Resolvers"><a href="#4-2-Recursive-Resolvers" class="headerlink" title="4.2. Recursive Resolvers"></a>4.2. Recursive Resolvers</h2><p>Whether the recursive resolver is aware of SVCB or not, the normal response construction process used for unknown RR types [RFC3597] generates the Answer section of the response. Recursive resolvers that are aware of SVCB SHOULD help the client to execute the procedure in Section 3 with minimum overall latency by incorporating additional useful information into the Additional section of the response as follows:</p>
<div class="code-wrapper"><pre><code class="hljs">- Incorporate the results of SVCB resolution. If the recursive resolver&#39;s local chain length limit (which may be different from the client&#39;s limit) has been reached, terminate.
- If any of the resolved SVCB records are in AliasMode, choose one of them at random, and resolve SVCB, A, and AAAA records for its TargetName.
    - If any SVCB records are resolved, go to Step 1.
    - Otherwise, incorporate the results of A and AAAA resolution, and terminate.
- All the resolved SVCB records are in ServiceMode. Resolve A and AAAA queries for each TargetName (or for the owner name if TargetName is &quot;.&quot;), incorporate all the results, and terminate.
</code></pre></div>
<p>In this procedure, “resolve” means the resolver’s ordinary recursive resolution procedure, as if processing a query for that RRset. This includes following any aliases that the resolver would ordinarily follow (e.g., CNAME, DNAME [DNAME]). Errors or anomalies in obtaining additional records MAY cause this process to terminate but MUST NOT themselves cause the resolver to send a failure response.</p>
<p>See Section 2.4.2 for additional safeguards for recursive resolvers to implement to mitigate loops.</p>
<p>See Section 5.2 for possible optimizations of this procedure.</p>
<h3 id="4-2-1-DNS64"><a href="#4-2-1-DNS64" class="headerlink" title="4.2.1. DNS64"></a>4.2.1. DNS64</h3><p>DNS64 resolvers synthesize responses to AAAA queries for names that only have an A record (Section 5.1.7 of [RFC6147]). SVCB-aware DNS64 resolvers SHOULD apply the same synthesis logic when resolving AAAA records for the TargetName for inclusion in the Additional section (Step 2 in Section 4.2) and MAY omit the A records from this section.</p>
<p>DNS64 resolvers MUST NOT extrapolate the AAAA synthesis logic to the IP hints in the SvcParams (Section 7.3). Modifying the IP hints would break DNSSEC validation for the SVCB record and would not improve performance when the above recommendation is implemented.</p>
<h2 id="4-3-General-Requirements"><a href="#4-3-General-Requirements" class="headerlink" title="4.3. General Requirements"></a>4.3. General Requirements</h2><p>Recursive resolvers MUST be able to convey SVCB records with unrecognized SvcParamKeys. Resolvers MAY accomplish this by treating the entire SvcParams portion of the record as opaque, even if the contents are invalid. If a recognized SvcParamKey is followed by a value that is invalid according to the SvcParam’s specification, a recursive resolver MAY report an error such as SERVFAIL instead of returning the record. For complex value types whose interpretation might differ between implementations or have additional future allowed values added (e.g., URIs or “alpn”), resolvers SHOULD limit validation to specified constraints.</p>
<p>When responding to a query that includes the DNSSEC OK bit [RFC3225], DNSSEC-capable recursive and authoritative DNS servers MUST accompany each RRset in the Additional section with the same DNSSEC-related records that they would send when providing that RRset as an Answer (e.g., RRSIG, NSEC, NSEC3).</p>
<p>According to Section 5.4.1 of [RFC2181], “Unauthenticated RRs received and cached from … the additional data section … should not be cached in such a way that they would ever be returned as answers to a received query. They may be returned as additional information where appropriate.” Recursive resolvers therefore MAY cache records from the Additional section for use in populating Additional section responses and MAY cache them for general use if they are authenticated by DNSSEC.</p>
<h2 id="4-4-EDNS-Client-Subnet-ECS"><a href="#4-4-EDNS-Client-Subnet-ECS" class="headerlink" title="4.4. EDNS Client Subnet (ECS)"></a>4.4. EDNS Client Subnet (ECS)</h2><p>The EDNS Client Subnet (ECS) option [RFC7871] allows recursive resolvers to request IP addresses that are suitable for a particular client IP range. SVCB records may contain IP addresses (in ipv*hint SvcParams) or direct users to a subnet-specific TargetName, so recursive resolvers SHOULD include the same ECS option in SVCB queries as in A/AAAA queries.</p>
<p>According to Section 7.3.1 of [RFC7871], “Any records from [the Additional section] MUST NOT be tied to a network.” Accordingly, when processing a response whose QTYPE is SVCB-compatible, resolvers SHOULD treat any records in the Additional section as having SOURCE PREFIX-LENGTH set to zero and SCOPE PREFIX-LENGTH as specified in the ECS option. Authoritative servers MUST omit such records if they are not suitable for use by any stub resolvers that set SOURCE PREFIX-LENGTH to zero. This will cause the resolver to perform a follow-up query that can receive a properly tailored ECS. (This is similar to the usage of CNAME with the ECS option as discussed in [RFC7871], Section 7.2.1.)</p>
<p>Authoritative servers that omit Additional records can avoid the added latency of a follow-up query by following the advice in Section 10.2.</p>
<h1 id="5-Performance-Optimizations"><a href="#5-Performance-Optimizations" class="headerlink" title="5. Performance Optimizations"></a>5. Performance Optimizations</h1><p>For optimal performance (i.e., minimum connection setup time), clients SHOULD implement a client-side DNS cache. Responses in the Additional section of a SVCB response SHOULD be placed in cache before performing any follow-up queries. With this behavior, and with conforming DNS servers, using SVCB does not add network latency to connection setup.</p>
<p>To improve performance when using a non-conforming recursive resolver, clients SHOULD issue speculative A and/or AAAA queries in parallel with each SVCB query, based on a predicted value of TargetName (see Section 10.2).</p>
<p>After a ServiceMode RRset is received, clients MAY try more than one option in parallel and MAY prefetch A and AAAA records for multiple TargetNames.</p>
<h2 id="5-1-Optimistic-Pre-connection-and-Connection-Reuse"><a href="#5-1-Optimistic-Pre-connection-and-Connection-Reuse" class="headerlink" title="5.1. Optimistic Pre-connection and Connection Reuse"></a>5.1. Optimistic Pre-connection and Connection Reuse</h2><p>If an address response arrives before the corresponding SVCB response, the client MAY initiate a connection as if the SVCB query returned NODATA but MUST NOT transmit any information that could be altered by the SVCB response until it arrives. For example, future SvcParamKeys could be defined that alter the TLS ClientHello.</p>
<p>Clients implementing this optimization SHOULD wait for 50 milliseconds before starting optimistic pre-connection, as per the guidance in [HappyEyeballsV2].</p>
<p>A SVCB record is consistent with a connection if the client would attempt an equivalent connection when making use of that record. If a SVCB record is consistent with an active or in-progress connection C, the client MAY prefer that record and use C as its connection. For example, suppose the client receives this SVCB RRset for a protocol that uses TLS over TCP:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">_1234</span>._bar.example.com. <span class="hljs-number">300</span> IN SVCB <span class="hljs-number">1</span> svc<span class="hljs-number">1</span>.example.net. (ipv<span class="hljs-number">6</span>hint=<span class="hljs-number">2001</span>:db<span class="hljs-number">8</span>::<span class="hljs-number">1</span> port=<span class="hljs-number">1234</span> )<br>                               <span class="hljs-attribute">SVCB</span> <span class="hljs-number">2</span> svc<span class="hljs-number">2</span>.example.net. (ipv<span class="hljs-number">6</span>hint=<span class="hljs-number">2001</span>:db<span class="hljs-number">8</span>::<span class="hljs-number">2</span> port=<span class="hljs-number">1234</span> )<br></code></pre></td></tr></table></figure>

<p>If the client has an in-progress TCP connection to [2001:db8::2]:1234, it MAY proceed with TLS on that connection, even though the other record in the RRset has higher priority.</p>
<p>If none of the SVCB records are consistent with any active or in-progress connection, clients proceed with connection establishment as described in Section 3.</p>
<h2 id="5-2-Generating-and-Using-Incomplete-Responses"><a href="#5-2-Generating-and-Using-Incomplete-Responses" class="headerlink" title="5.2. Generating and Using Incomplete Responses"></a>5.2. Generating and Using Incomplete Responses</h2><p>When following the procedure in Section 4.2, recursive resolvers MAY terminate the procedure early and produce a reply that omits some of the associated RRsets. This is REQUIRED when the chain length limit is reached (Step 1 in Section 4.2) but might also be appropriate when the maximum response size is reached or when responding before fully chasing dependencies would improve performance. When omitting certain RRsets, recursive resolvers SHOULD prioritize information for smaller-SvcPriority records.</p>
<p>As discussed in Section 3, clients MUST be able to fetch additional information that is required to use a SVCB record, if it is not included in the initial response. As a performance optimization, if some of the SVCB records in the response can be used without requiring additional DNS queries, the client MAY prefer those records, regardless of their priorities.</p>
<h1 id="6-SVCB-Compatible-RR-Types"><a href="#6-SVCB-Compatible-RR-Types" class="headerlink" title="6. SVCB-Compatible RR Types"></a>6. SVCB-Compatible RR Types</h1><p>An RR type is called “SVCB-compatible” if it permits an implementation that is identical to SVCB in its:</p>
<ul>
<li>RDATA presentation format</li>
<li>RDATA wire format</li>
<li>IANA registry used for SvcParamKeys</li>
<li>Authoritative server Additional section processing</li>
<li>Recursive resolution process</li>
<li>Relevant Class (i.e., Internet (“IN”) [RFC1035])</li>
</ul>
<p>This allows authoritative and recursive DNS servers to apply identical processing to all SVCB-compatible RR types.</p>
<p>All other behaviors described as applying to the SVCB RR also apply to all SVCB-compatible RR types unless explicitly stated otherwise. When following an AliasMode record (Section 2.4.2) of RR type $T, the follow-up query to the TargetName MUST also be for type $T.</p>
<p>This document defines one SVCB-compatible RR type (other than SVCB itself): the HTTPS RR type (Section 9), which avoids Attrleaf label prefixes [Attrleaf] in order to improve compatibility with wildcards and CNAMEs, which are widely used with HTTP.</p>
<p>Standards authors should consider carefully whether to use SVCB or define a new SVCB-compatible RR type, as this choice cannot easily be reversed after deployment.</p>
<h1 id="7-Initial-SvcParamKeys"><a href="#7-Initial-SvcParamKeys" class="headerlink" title="7. Initial SvcParamKeys"></a>7. Initial SvcParamKeys</h1><p>A few initial SvcParamKeys are defined here. These keys are useful for the “https” scheme, and most are expected to be generally applicable to other schemes as well.</p>
<p>Each new protocol mapping document MUST specify which keys are applicable and safe to use. Protocol mappings MAY alter the interpretation of SvcParamKeys but MUST NOT alter their presentation or wire formats.</p>
<h2 id="7-1-“alpn”-and-“no-default-alpn”"><a href="#7-1-“alpn”-and-“no-default-alpn”" class="headerlink" title="7.1. “alpn” and “no-default-alpn”"></a>7.1. “alpn” and “no-default-alpn”</h2><p>The “alpn” and “no-default-alpn” SvcParamKeys together indicate the set of Application-Layer Protocol Negotiation (ALPN) protocol identifiers [ALPN] and associated transport protocols supported by this service endpoint (the “SVCB ALPN set”).</p>
<p>As with Alt-Svc [AltSvc], each ALPN protocol identifier is used to identify the application protocol and associated suite of protocols supported by the endpoint (the “protocol suite”). The presence of an ALPN protocol identifier in the SVCB ALPN set indicates that this service endpoint, described by TargetName and the other parameters (e.g., “port”), offers service with the protocol suite associated with this ALPN identifier.</p>
<p>Clients filter the set of ALPN identifiers to match the protocol suites they support, and this informs the underlying transport protocol used (such as QUIC over UDP or TLS over TCP). ALPN protocol identifiers that do not uniquely identify a protocol suite (e.g., an Identification Sequence that can be used with both TLS and DTLS) are not compatible with this SvcParamKey and MUST NOT be included in the SVCB ALPN set.</p>
<h3 id="7-1-1-Representation"><a href="#7-1-1-Representation" class="headerlink" title="7.1.1. Representation"></a>7.1.1. Representation</h3><p>ALPNs are identified by their registered “Identification Sequence” (alpn-id), which is a sequence of 1-255 octets.</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">alpn-id</span> = <span class="hljs-number">1</span>*<span class="hljs-number">255</span><span class="hljs-keyword">OCTET</span><br></code></pre></td></tr></table></figure>

<p>For “alpn”, the presentation value SHALL be a comma-separated list (Appendix A.1) of one or more alpn-ids. Zone-file implementations MAY disallow the “,” and “&quot; characters in ALPN IDs instead of implementing the value-list escaping procedure, relying on the opaque key format (e.g., key1=\002h2) in the event that these characters are needed.</p>
<p>The wire-format value for “alpn” consists of at least one alpn-id prefixed by its length as a single octet, and these length-value pairs are concatenated to form the SvcParamValue. These pairs MUST exactly fill the SvcParamValue; otherwise, the SvcParamValue is malformed.</p>
<p>For “no-default-alpn”, the presentation and wire-format values MUST be empty. When “no-default-alpn” is specified in an RR, “alpn” must also be specified in order for the RR to be “self-consistent” (Section 2.4.3).</p>
<p>Each scheme that uses this SvcParamKey defines a “default set” of ALPN IDs that are supported by nearly all clients and servers; this set MAY be empty. To determine the SVCB ALPN set, the client starts with the list of alpn-ids from the “alpn” SvcParamKey, and it adds the default set unless the “no-default-alpn” SvcParamKey is present.</p>
<h3 id="7-1-2-Use"><a href="#7-1-2-Use" class="headerlink" title="7.1.2. Use"></a>7.1.2. Use</h3><p>To establish a connection to the endpoint, clients MUST</p>
<ul>
<li>Let SVCB-ALPN-Intersection be the set of protocols in the SVCB ALPN set that the client supports.</li>
<li>Let Intersection-Transports be the set of transports (e.g., TLS, DTLS, QUIC) implied by the protocols in SVCB-ALPN-Intersection.</li>
<li>For each transport in Intersection-Transports, construct a ProtocolNameList containing the Identification Sequences of all the client’s supported ALPN protocols for that transport, without regard to the SVCB ALPN set.</li>
</ul>
<p>For example, if the SVCB ALPN set is [“http/1.1”, “h3”] and the client supports HTTP/1.1, HTTP/2, and HTTP/3, the client could attempt to connect using TLS over TCP with a ProtocolNameList of [“http/1.1”, “h2”] and could also attempt a connection using QUIC with a ProtocolNameList of [“h3”].</p>
<p>Once the client has constructed a ClientHello, protocol negotiation in that handshake proceeds as specified in [ALPN], without regard to the SVCB ALPN set.</p>
<p>Clients MAY implement a fallback procedure, using a less-preferred transport if more-preferred transports fail to connect. This fallback behavior is vulnerable to manipulation by a network attacker who blocks the more-preferred transports, but it may be necessary for compatibility with existing networks.</p>
<p>With this procedure in place, an attacker who can modify DNS and network traffic can prevent a successful transport connection but cannot otherwise interfere with ALPN protocol selection. This procedure also ensures that each ProtocolNameList includes at least one protocol from the SVCB ALPN set.</p>
<p>Clients SHOULD NOT attempt connection to a service endpoint whose SVCB ALPN set does not contain any supported protocols.</p>
<p>To ensure consistency of behavior, clients MAY reject the entire SVCB RRset and fall back to basic connection establishment if all of the compatible RRs indicate “no-default-alpn”, even if connection could have succeeded using a non-default ALPN protocol.</p>
<p>Zone operators SHOULD ensure that at least one RR in each RRset supports the default transports. This enables compatibility with the greatest number of clients.</p>
<h2 id="7-2-“port”"><a href="#7-2-“port”" class="headerlink" title="7.2. “port”"></a>7.2. “port”</h2><p>The “port” SvcParamKey defines the TCP or UDP port that should be used to reach this alternative endpoint. If this key is not present, clients SHALL use the authority endpoint’s port number.</p>
<p>The presentation value of the SvcParamValue is a single decimal integer between 0 and 65535 in ASCII. Any other value (e.g., an empty value) is a syntax error. To enable simpler parsing, this SvcParamValue MUST NOT contain escape sequences.</p>
<p>The wire format of the SvcParamValue is the corresponding 2-octet numeric value in network byte order.</p>
<p>If a port-restricting firewall is in place between some client and the service endpoint, changing the port number might cause that client to lose access to the service, so operators should exercise caution when using this SvcParamKey to specify a non-default port.</p>
<h2 id="7-3-“ipv4hint”-and-“ipv6hint”"><a href="#7-3-“ipv4hint”-and-“ipv6hint”" class="headerlink" title="7.3. “ipv4hint” and “ipv6hint”"></a>7.3. “ipv4hint” and “ipv6hint”</h2><p>The “ipv4hint” and “ipv6hint” keys convey IP addresses that clients MAY use to reach the service. If A and AAAA records for TargetName are locally available, the client SHOULD ignore these hints. Otherwise, clients SHOULD perform A and/or AAAA queries for TargetName per Section 3, and clients SHOULD use the IP address in those responses for future connections. Clients MAY opt to terminate any connections using the addresses in hints and instead switch to the addresses in response to the TargetName query. Failure to use A and/or AAAA response addresses could negatively impact load balancing or other geo-aware features and thereby degrade client performance.</p>
<p>The presentation value SHALL be a comma-separated list (Appendix A.1) of one or more IP addresses of the appropriate family in standard textual format [RFC5952] [RFC4001]. To enable simpler parsing, this SvcParamValue MUST NOT contain escape sequences.</p>
<p>The wire format for each parameter is a sequence of IP addresses in network byte order (for the respective address family). Like an A or AAAA RRset, the list of addresses represents an unordered collection, and clients SHOULD pick addresses to use in a random order. An empty list of addresses is invalid.</p>
<p>When selecting between IPv4 and IPv6 addresses to use, clients may use an approach such as Happy Eyeballs [HappyEyeballsV2]. When only “ipv4hint” is present, NAT64 clients may synthesize IPv6 addresses as specified in [RFC7050] or ignore the “ipv4hint” key and wait for AAAA resolution (Section 3). For best performance, server operators SHOULD include an “ipv6hint” parameter whenever they include an “ipv4hint” parameter.</p>
<p>These parameters are intended to minimize additional connection latency when a recursive resolver is not compliant with the requirements in Section 4 and SHOULD NOT be included if most clients are using compliant recursive resolvers. When TargetName is the service name or the owner name (which can be written as “.”), server operators SHOULD NOT include these hints, because they are unlikely to convey any performance benefit.</p>
<h2 id="7-4-“mandatory”"><a href="#7-4-“mandatory”" class="headerlink" title="7.4. “mandatory”"></a>7.4. “mandatory”</h2><p>See Section 8.</p>
<h1 id="8-ServiceMode-RR-Compatibility-and-Mandatory-Keys"><a href="#8-ServiceMode-RR-Compatibility-and-Mandatory-Keys" class="headerlink" title="8. ServiceMode RR Compatibility and Mandatory Keys"></a>8. ServiceMode RR Compatibility and Mandatory Keys</h1><p>In a ServiceMode RR, a SvcParamKey is considered “mandatory” if the RR will not function correctly for clients that ignore this SvcParamKey. Each SVCB protocol mapping SHOULD specify a set of keys that are “automatically mandatory”, i.e., mandatory if they are present in an RR. The SvcParamKey “mandatory” is used to indicate any mandatory keys for this RR, in addition to any automatically mandatory keys that are present.</p>
<p>A ServiceMode RR is considered “compatible” by a client if the client recognizes all the mandatory keys and their values indicate that successful connection establishment is possible. Incompatible RRs are ignored (see step 5 of the procedure defined in Section 3).</p>
<p>The presentation value SHALL be a comma-separated list (Appendix A.1) of one or more valid SvcParamKeys, either by their registered name or in the unknown-key format (Section 2.1). Keys MAY appear in any order but MUST NOT appear more than once. For self-consistency (Section 2.4.3), listed keys MUST also appear in the SvcParams.</p>
<p>To enable simpler parsing, this SvcParamValue MUST NOT contain escape sequences.</p>
<p>For example, the following is a valid list of SvcParams:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">ipv6hint</span>=... <span class="hljs-attribute">key65333</span>=ex1 <span class="hljs-attribute">key65444</span>=ex2 <span class="hljs-attribute">mandatory</span>=key65444,ipv6hint<br></code></pre></td></tr></table></figure>

<p>In wire format, the keys are represented by their numeric values in network byte order, concatenated in strictly increasing numeric order.</p>
<p>This SvcParamKey is always automatically mandatory and MUST NOT appear in its own value-list. Other automatically mandatory keys SHOULD NOT appear in the list either. (Including them wastes space and otherwise has no effect.)</p>
<h1 id="9-Using-Service-Bindings-with-HTTP"><a href="#9-Using-Service-Bindings-with-HTTP" class="headerlink" title="9. Using Service Bindings with HTTP"></a>9. Using Service Bindings with HTTP</h1><p>The use of any protocol with SVCB requires a protocol-specific mapping specification. This section specifies the mapping for the “http” and “https” URI schemes [HTTP].</p>
<p>To enable special handling for HTTP use cases, the HTTPS RR type is defined as a SVCB-compatible RR type, specific to the “https” and “http” schemes. Clients MUST NOT perform SVCB queries or accept SVCB responses for “https” or “http” schemes.</p>
<p>The presentation format of the record is:</p>
<p>Name TTL IN HTTPS SvcPriority TargetName SvcParams<br>All the SvcParamKeys defined in Section 7 are permitted for use in HTTPS RRs. The default set of ALPN IDs is the single value “http/1.1”. The “automatically mandatory” keys (Section 8) are “port” and “no-default-alpn”. (As described in Section 8, clients must either implement these keys or ignore any RR in which they appear.) Clients that restrict the destination port in “https” URIs (e.g., using the “bad ports” list from [FETCH]) SHOULD apply the same restriction to the “port” SvcParam.</p>
<p>The presence of an HTTPS RR for an origin also indicates that clients should connect securely and use the “https” scheme, as discussed in Section 9.5. This allows HTTPS RRs to apply to pre-existing “http” scheme URLs, while ensuring that the client uses a secure and authenticated connection.</p>
<p>The HTTPS RR parallels the concepts introduced in “HTTP Alternative Services” [AltSvc]. Clients and servers that implement HTTPS RRs are not required to implement Alt-Svc.</p>
<h2 id="9-1-Query-Names-for-HTTPS-RRs"><a href="#9-1-Query-Names-for-HTTPS-RRs" class="headerlink" title="9.1. Query Names for HTTPS RRs"></a>9.1. Query Names for HTTPS RRs</h2><p>The HTTPS RR uses Port Prefix Naming (Section 2.3), with one modification: if the scheme is “https” and the port is 443, then the client’s original QNAME is equal to the service name (i.e., the origin’s hostname), without any prefix labels.</p>
<p>By removing the Attrleaf labels [Attrleaf] used in SVCB, this construction enables offline DNSSEC signing of wildcard domains, which are commonly used with HTTP. Using the service name as the owner name of the HTTPS record, without prefixes, also allows the targets of existing CNAME chains (e.g., CDN hosts) to start returning HTTPS RR responses without requiring origin domains to configure and maintain an additional delegation.</p>
<p>The procedure for following HTTPS AliasMode RRs and CNAME aliases is unchanged from SVCB (as described in Sections 2.4.2 and 3).</p>
<p>Clients always convert “http” URLs to “https” before performing an HTTPS RR query using the process described in Section 9.5, so domain owners MUST NOT publish HTTPS RRs with a prefix of “_http”.</p>
<p>Note that none of these forms alter the HTTPS origin or authority. For example, clients MUST continue to validate TLS certificate hostnames based on the origin.</p>
<h2 id="9-2-Comparison-with-Alt-Svc"><a href="#9-2-Comparison-with-Alt-Svc" class="headerlink" title="9.2. Comparison with Alt-Svc"></a>9.2. Comparison with Alt-Svc</h2><p>Publishing a ServiceMode HTTPS RR in DNS is intended to be similar to transmitting an Alt-Svc field value over HTTP, and receiving an HTTPS RR is intended to be similar to receiving that field value over HTTP. However, there are some differences in the intended client and server behavior.</p>
<h3 id="9-2-1-ALPN-Usage"><a href="#9-2-1-ALPN-Usage" class="headerlink" title="9.2.1. ALPN Usage"></a>9.2.1. ALPN Usage</h3><p>Unlike Alt-Svc field values, HTTPS RRs can contain multiple ALPN IDs. The meaning and use of these IDs are discussed in Section 7.1.2.</p>
<h3 id="9-2-2-Untrusted-Channels"><a href="#9-2-2-Untrusted-Channels" class="headerlink" title="9.2.2. Untrusted Channels"></a>9.2.2. Untrusted Channels</h3><p>HTTPS records do not require or provide any assurance of authenticity. (DNSSEC signing and verification, which would provide such assurance, are OPTIONAL.) The DNS resolution process is modeled as an untrusted channel that might be controlled by an attacker, so Alt-Svc parameters that cannot be safely received in this model MUST NOT have a corresponding defined SvcParamKey. For example, there is no SvcParamKey corresponding to the Alt-Svc “persist” parameter, because this parameter is not safe to accept over an untrusted channel.</p>
<h3 id="9-2-3-Cache-Lifetime"><a href="#9-2-3-Cache-Lifetime" class="headerlink" title="9.2.3. Cache Lifetime"></a>9.2.3. Cache Lifetime</h3><p>There is no SvcParamKey corresponding to the Alt-Svc “ma” (max age) parameter. Instead, server operators encode the expiration time in the DNS TTL.</p>
<p>The appropriate TTL value might be different from the “ma” value used for Alt-Svc, depending on the desired efficiency and agility. Some DNS caches incorrectly extend the lifetime of DNS records beyond the stated TTL, so server operators cannot rely on HTTPS RRs expiring on time. Shortening the TTL to compensate for incorrect caching is NOT RECOMMENDED, as this practice impairs the performance of correctly functioning caches and does not guarantee faster expiration from incorrect caches. Instead, server operators SHOULD maintain compatibility with expired records until they observe that nearly all connections have migrated to the new configuration.</p>
<h3 id="9-2-4-Granularity"><a href="#9-2-4-Granularity" class="headerlink" title="9.2.4. Granularity"></a>9.2.4. Granularity</h3><p>Sending Alt-Svc over HTTP allows the server to tailor the Alt-Svc field value specifically to the client. When using an HTTPS RR, groups of clients will necessarily receive the same SvcParams. Therefore, HTTPS RRs are not suitable for uses that require single-client granularity.</p>
<h2 id="9-3-Interaction-with-Alt-Svc"><a href="#9-3-Interaction-with-Alt-Svc" class="headerlink" title="9.3. Interaction with Alt-Svc"></a>9.3. Interaction with Alt-Svc</h2><p>Clients that implement support for both Alt-Svc and HTTPS records and are making a connection based on a cached Alt-Svc response SHOULD retrieve any HTTPS records for the Alt-Svc alt-authority and ensure that their connection attempts are consistent with both the Alt-Svc parameters and any received HTTPS SvcParams. If present, the HTTPS record’s TargetName and port are used for connection establishment (per Section 3). For example, suppose that “<a target="_blank" rel="noopener" href="https://example.com&quot;/">https://example.com&quot;</a> sends an Alt-Svc field value of:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Alt-Svc: <span class="hljs-attribute">h2</span>=<span class="hljs-string">&quot;alt.example:443&quot;</span>, <span class="hljs-attribute">h2</span>=<span class="hljs-string">&quot;alt2.example:443&quot;</span>, <span class="hljs-attribute">h3</span>=<span class="hljs-string">&quot;:8443&quot;</span><br></code></pre></td></tr></table></figure>

<p>The client would retrieve the following HTTPS records:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">alt.example.              <span class="hljs-keyword">IN</span> HTTPS 1 . <span class="hljs-attribute">alpn</span>=h2,h3 <span class="hljs-attribute">foo</span>=...<br>alt2.example.             <span class="hljs-keyword">IN</span> HTTPS 1 alt2b.example. <span class="hljs-attribute">alpn</span>=h3 <span class="hljs-attribute">foo</span>=...<br>_8443._https.example.com. <span class="hljs-keyword">IN</span> HTTPS 1 alt3.example. (<span class="hljs-attribute">port</span>=9443 <span class="hljs-attribute">alpn</span>=h2,h3 <span class="hljs-attribute">foo</span>=... )<br></code></pre></td></tr></table></figure>

<p>Based on these inputs, the following connection attempts would always be allowed:</p>
<ul>
<li>HTTP/2 to alt.example:443</li>
<li>HTTP/3 to alt3.example:9443</li>
<li>Fallback to the client’s non-Alt-Svc connection behavior</li>
<li>The following connection attempts would not be allowed:</li>
</ul>
<p>HTTP/3 to alt.example:443 (not consistent with Alt-Svc)<br>Any connection to alt2b.example (no ALPN ID consistent with both the HTTPS record and Alt-Svc)<br>HTTPS over TCP to any port on alt3.example (not consistent with Alt-Svc)<br>Suppose that “foo” is a SvcParamKey that renders the client SVCB-reliant. The following Alt-Svc-only connection attempts would be allowed only if the client does not support “foo”, as they rely on SVCB-optional fallback behavior:</p>
<ul>
<li>HTTP/2 to alt2.example:443</li>
<li>HTTP/3 to example.com:8443</li>
</ul>
<p>Alt-authorities SHOULD carry the same SvcParams as the origin unless a deviation is specifically known to be safe. As noted in Section 2.4 of [AltSvc], clients MAY disallow any Alt-Svc connection according to their own criteria, e.g., disallowing Alt-Svc connections that lack support for privacy features that are available on the authority endpoint.</p>
<h2 id="9-4-Requiring-Server-Name-Indication"><a href="#9-4-Requiring-Server-Name-Indication" class="headerlink" title="9.4. Requiring Server Name Indication"></a>9.4. Requiring Server Name Indication</h2><p>Clients MUST NOT use an HTTPS RR response unless the client supports the TLS Server Name Indication (SNI) extension and indicates the origin name in the TLS ClientHello (which might be encrypted via a future specification such as [ECH]). This supports the conservation of IP addresses.</p>
<p>Note that the TLS SNI (and also the HTTP “Host” or “:authority”) will indicate the origin, not the TargetName.</p>
<h2 id="9-5-HTTP-Strict-Transport-Security-HSTS"><a href="#9-5-HTTP-Strict-Transport-Security-HSTS" class="headerlink" title="9.5. HTTP Strict Transport Security (HSTS)"></a>9.5. HTTP Strict Transport Security (HSTS)</h2><p>An HTTPS RR directs the client to communicate with this host only over a secure transport, similar to HSTS [HSTS]. Prior to making an “http” scheme request, the client SHOULD perform a lookup to determine if any HTTPS RRs exist for that origin. To do so, the client SHOULD construct a corresponding “https” URL as follows:</p>
<ol>
<li>Replace the “http” scheme with “https”.</li>
<li>If the “http” URL explicitly specifies port 80, specify port 443.</li>
<li>Do not alter any other aspect of the URL.</li>
</ol>
<p>This construction is equivalent to Section 8.3 of [HSTS], Step 5.</p>
<p>If an HTTPS RR query for this “https” URL returns any AliasMode HTTPS RRs or any compatible ServiceMode HTTPS RRs (see Section 8), the client SHOULD behave as if it has received an HTTP 307 (Temporary Redirect) status code with this “https” URL in the “Location” field. (Receipt of an incompatible ServiceMode RR does not trigger the redirect behavior.) Because HTTPS RRs are received over an often-insecure channel (DNS), clients MUST NOT place any more trust in this signal than if they had received a 307 (Temporary Redirect) response over cleartext HTTP.</p>
<p>Publishing an HTTPS RR can potentially lead to unexpected results or a loss in functionality in cases where the “http” resource neither redirects to the “https” resource nor references the same underlying resource.</p>
<p>When an “https” connection fails due to an error in the underlying secure transport, such as an error in certificate validation, some clients currently offer a “user recourse” that allows the user to bypass the security error and connect anyway. When making an “https” scheme request to an origin with an HTTPS RR, either directly or via the above redirect, such a client MAY remove the user recourse option. Origins that publish HTTPS RRs therefore MUST NOT rely on user recourse for access. For more information, see Sections 8.4 and 12.1 of [HSTS].</p>
<h2 id="9-6-Use-of-HTTPS-RRs-in-Other-Protocols"><a href="#9-6-Use-of-HTTPS-RRs-in-Other-Protocols" class="headerlink" title="9.6. Use of HTTPS RRs in Other Protocols"></a>9.6. Use of HTTPS RRs in Other Protocols</h2><p>All HTTP connections to named origins are eligible to use HTTPS RRs, even when HTTP is used as part of another protocol or without an explicit HTTP-related URI scheme (Section 4.2 of [HTTP]). For example, clients that support HTTPS RRs and implement [WebSocket] using the altered opening handshake from [FETCH-WEBSOCKETS] SHOULD use HTTPS RRs for the requestURL.</p>
<p>When HTTP is used in a context where URLs or redirects are not applicable (e.g., connections to an HTTP proxy), clients that find a corresponding HTTPS RR SHOULD implement security upgrade behavior equivalent to that specified in Section 9.5.</p>
<p>Such protocols MAY define their own SVCB mappings, which MAY be defined to take precedence over HTTPS RRs.</p>
<h1 id="10-Zone-Structures"><a href="#10-Zone-Structures" class="headerlink" title="10. Zone Structures"></a>10. Zone Structures</h1><h2 id="10-1-Structuring-Zones-for-Flexibility"><a href="#10-1-Structuring-Zones-for-Flexibility" class="headerlink" title="10.1. Structuring Zones for Flexibility"></a>10.1. Structuring Zones for Flexibility</h2><p>Each ServiceMode RRset can only serve a single scheme. The scheme is indicated by the owner name and the RR type. For the generic SVCB RR type, this means that each owner name can only be used for a single scheme. The underscore prefixing requirement (Section 2.3) ensures that this is true for the initial query, but it is the responsibility of zone owners to choose names that satisfy this constraint when using aliases, including CNAME and AliasMode records.</p>
<p>When using the generic SVCB RR type with aliasing, zone owners SHOULD choose alias target names that indicate the scheme in use (e.g., “foosvc.example.net” for “foo” schemes). This will help to avoid confusion when another scheme needs to be added to the configuration. When multiple port numbers are in use, it may be helpful to repeat the prefix labels in the alias target name (e.g., “_1234._foo.svc.example.net”).</p>
<h2 id="10-2-Structuring-Zones-for-Performance"><a href="#10-2-Structuring-Zones-for-Performance" class="headerlink" title="10.2. Structuring Zones for Performance"></a>10.2. Structuring Zones for Performance</h2><p>To avoid a delay for clients using a non-conforming recursive resolver, domain owners SHOULD minimize the use of AliasMode records and SHOULD choose TargetName according to a predictable convention that is known to the client, so that clients can issue A and/or AAAA queries for TargetName in advance (see Section 5). Unless otherwise specified, the convention is to set TargetName to the service name for an initial ServiceMode record, or to “.” if it is reached via an alias.</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-meta">$ORIGIN</span> example.com. <span class="hljs-comment">; Origin</span><br>foo                  <span class="hljs-number">3600</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CNAME</span> foosvc.example.net.<br>_8080._foo.foo       <span class="hljs-number">3600</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CNAME</span> foosvc.example.net.<br>bar                   <span class="hljs-number">300</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8::2</span><br>_9090._bar.bar       <span class="hljs-number">3600</span> <span class="hljs-keyword">IN</span> SVCB <span class="hljs-number">1</span> bar key65444=...<br><br><span class="hljs-meta">$ORIGIN</span> example.net. <span class="hljs-comment">; Service provider zone</span><br>foosvc               <span class="hljs-number">3600</span> <span class="hljs-keyword">IN</span> SVCB <span class="hljs-number">1</span> . key65333=...<br>foosvc                <span class="hljs-number">300</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8::1</span><br></code></pre></td></tr></table></figure>

<p>Figure 1: “foo://foo.example.com:8080” Is Available at “foosvc.example.net”, but “bar://bar.example.com:9090” Is Served Locally</p>
<p>Domain owners SHOULD avoid using a TargetName that is below a DNAME, as this is likely unnecessary and makes responses slower and larger. Also, zone structures that require following more than eight aliases (counting both AliasMode and CNAME records) are NOT RECOMMENDED.</p>
<h2 id="10-3-Operational-Considerations"><a href="#10-3-Operational-Considerations" class="headerlink" title="10.3. Operational Considerations"></a>10.3. Operational Considerations</h2><p>Some authoritative DNS servers may not allow A or AAAA records on names starting with an underscore (e.g., [BIND-CHECK-NAMES]). This could create an operational issue when the TargetName contains an Attrleaf label, or when using a TargetName of “.” if the owner name contains an Attrleaf label.</p>
<h2 id="10-4-Examples"><a href="#10-4-Examples" class="headerlink" title="10.4. Examples"></a>10.4. Examples</h2><h3 id="10-4-1-Protocol-Enhancements"><a href="#10-4-1-Protocol-Enhancements" class="headerlink" title="10.4.1. Protocol Enhancements"></a>10.4.1. Protocol Enhancements</h3><p>Consider a simple zone of the form:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-meta">$ORIGIN</span> simple.example. <span class="hljs-comment">; Simple example zone</span><br>@ <span class="hljs-number">300</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">A</span>    <span class="hljs-number">192.0.2.1</span><br>         <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8::1</span><br></code></pre></td></tr></table></figure>

<p>The domain owner could add this record:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">@ 7200 <span class="hljs-keyword">IN</span> HTTPS 1 . <span class="hljs-attribute">alpn</span>=h3<br></code></pre></td></tr></table></figure>

<p>This record would indicate that “<a target="_blank" rel="noopener" href="https://simple.example&quot;/">https://simple.example&quot;</a> supports QUIC in addition to HTTP/1.1 over TLS over TCP (the implicit default). The record could also include other information (e.g., a non-standard port). For “<a href="https://simple.example:8443&quot;">https://simple.example:8443&quot;</a>, the record would be:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">_8443</span>._https <span class="hljs-number">7200</span> IN HTTPS <span class="hljs-number">1</span> . alpn=h<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>These records also respectively tell clients to replace the scheme with “https” when loading “<a target="_blank" rel="noopener" href="http://simple.example&quot;/">http://simple.example&quot;</a> or “<a href="http://simple.example:8443&quot;">http://simple.example:8443&quot;</a>.</p>
<h3 id="10-4-2-Apex-Aliasing"><a href="#10-4-2-Apex-Aliasing" class="headerlink" title="10.4.2. Apex Aliasing"></a>10.4.2. Apex Aliasing</h3><p>Consider a zone that is using CNAME aliasing:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-meta">$ORIGIN</span> aliased.example. <span class="hljs-comment">; A zone that is using a hosting service</span><br><span class="hljs-comment">; Subdomain aliased to a high-performance server pool</span><br>www             <span class="hljs-number">7200</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CNAME</span> pool.svc.example.<br><span class="hljs-comment">; Apex domain on fixed IPs because CNAME is not allowed at the apex</span><br>@                <span class="hljs-number">300</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">A</span>     <span class="hljs-number">192.0.2.1</span><br>                     <span class="hljs-keyword">IN</span> <span class="hljs-keyword">AAAA</span>  <span class="hljs-number">2001:db8::1</span><br></code></pre></td></tr></table></figure>
<p>With HTTPS RRs, the owner of aliased.example could alias the apex by adding one additional record:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">@               <span class="hljs-number">7200</span> IN HTTPS <span class="hljs-number">0</span> pool<span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.example</span>.<br></code></pre></td></tr></table></figure>
<p>With this record in place, HTTPS-RR-aware clients will use the same server pool for aliased.example and <a target="_blank" rel="noopener" href="http://www.aliased.example/">www.aliased.example</a>. (They will also upgrade “<a target="_blank" rel="noopener" href="http://aliased.example/...&quot;">http://aliased.example/...&quot;</a> to “https”.) Non-HTTPS-RR-aware clients will just ignore the new record.</p>
<p>Similar to CNAME, HTTPS RRs have no impact on the origin name. When connecting, clients will continue to treat the authoritative origins as “<a target="_blank" rel="noopener" href="https://www.aliased.example&quot;/">https://www.aliased.example&quot;</a> and “<a target="_blank" rel="noopener" href="https://aliased.example&quot;/">https://aliased.example&quot;</a>, respectively, and will validate TLS server certificates accordingly.</p>
<h3 id="10-4-3-Parameter-Binding"><a href="#10-4-3-Parameter-Binding" class="headerlink" title="10.4.3. Parameter Binding"></a>10.4.3. Parameter Binding</h3><p>Suppose that svc.example’s primary server pool supports HTTP/3 but its backup server pool does not. This can be expressed in the following form:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-meta">$ORIGIN</span> svc.example. <span class="hljs-comment">; A hosting provider</span><br>pool  <span class="hljs-number">7200</span> <span class="hljs-keyword">IN</span> HTTPS <span class="hljs-number">1</span> . alpn=h2,h3<br>              HTTPS <span class="hljs-number">2</span> backup alpn=h2 port=<span class="hljs-number">8443</span><br>pool   <span class="hljs-number">300</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">A</span>        <span class="hljs-number">192.0.2.2</span><br>              <span class="hljs-keyword">AAAA</span>     <span class="hljs-number">2001:db8::2</span><br>backup <span class="hljs-number">300</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">A</span>        <span class="hljs-number">192.0.2.3</span><br>              <span class="hljs-keyword">AAAA</span>     <span class="hljs-number">2001:db8::3</span><br></code></pre></td></tr></table></figure>

<p>This configuration is entirely compatible with the “apex aliasing” example, whether the client supports HTTPS RRs or not. If the client does support HTTPS RRs, all connections will be upgraded to HTTPS, and clients will use HTTP/3 if they can. Parameters are “bound” to each server pool, so each server pool can have its own protocol, port number, etc.</p>
<h3 id="10-4-4-Multi-CDN-Configuration"><a href="#10-4-4-Multi-CDN-Configuration" class="headerlink" title="10.4.4. Multi-CDN Configuration"></a>10.4.4. Multi-CDN Configuration</h3><p>The HTTPS RR is intended to support HTTPS services operated by multiple independent entities, such as different CDNs or different hosting providers. This includes the case where a service is migrated from one operator to another, as well as the case where the service is multiplexed between multiple operators for performance, redundancy, etc.</p>
<p>This example shows such a configuration, with <a target="_blank" rel="noopener" href="http://www.customer.example/">www.customer.example</a> having different DNS responses to different queries, either over time or due to logic within the authoritative DNS server:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-comment">; This zone contains/returns different CNAME records</span><br><span class="hljs-comment">; at different points in time.  The RRset for &quot;www&quot; can</span><br><span class="hljs-comment">; only ever contain a single CNAME.</span><br><br><span class="hljs-comment">; Sometimes the zone has:</span><br><span class="hljs-meta">$ORIGIN</span> customer.example.  <span class="hljs-comment">; A multi-CDN customer domain</span><br>www <span class="hljs-number">900</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CNAME</span> cdn1.svc1.example.<br><br><span class="hljs-comment">; and other times it contains:</span><br><span class="hljs-meta">$ORIGIN</span> customer.example.<br>www <span class="hljs-number">900</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CNAME</span> customer.svc2.example.<br><br><span class="hljs-comment">; and yet other times it contains:</span><br><span class="hljs-meta">$ORIGIN</span> customer.example.<br>www <span class="hljs-number">900</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">CNAME</span> cdn3.svc3.example.<br><br><span class="hljs-comment">; With the following remaining constant and always included:</span><br><span class="hljs-meta">$ORIGIN</span> customer.example.  <span class="hljs-comment">; A multi-CDN customer domain</span><br><span class="hljs-comment">; The apex is also aliased to www to match its configuration.</span><br>@     <span class="hljs-number">7200</span> <span class="hljs-keyword">IN</span> HTTPS <span class="hljs-number">0</span> www<br><span class="hljs-comment">; Non-HTTPS-aware clients use non-CDN IPs.</span><br>              <span class="hljs-keyword">A</span>    <span class="hljs-number">203.0.113.82</span><br>              <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8:203::2</span><br><br><span class="hljs-comment">; Resolutions following the cdn1.svc1.example</span><br><span class="hljs-comment">; path use these records.</span><br><span class="hljs-comment">; This CDN uses a different alternative service for HTTP/3.</span><br><span class="hljs-meta">$ORIGIN</span> svc1.example.  <span class="hljs-comment">; domain for CDN 1</span><br>cdn1     <span class="hljs-number">1800</span> <span class="hljs-keyword">IN</span> HTTPS <span class="hljs-number">1</span> h3pool alpn=h3<br>                 HTTPS <span class="hljs-number">2</span> . alpn=h2<br>                 <span class="hljs-keyword">A</span>    <span class="hljs-number">192.0.2.2</span><br>                 <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8:192::4</span><br>h3pool <span class="hljs-number">300</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">A</span> <span class="hljs-number">192.0.2.3</span><br>           <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8:192:7::3</span><br><br><span class="hljs-comment">; Resolutions following the customer.svc2.example</span><br><span class="hljs-comment">; path use these records.</span><br><span class="hljs-comment">; Note that this CDN only supports HTTP/2.</span><br><span class="hljs-meta">$ORIGIN</span> svc2.example. <span class="hljs-comment">; domain operated by CDN 2</span><br>customer <span class="hljs-number">300</span> <span class="hljs-keyword">IN</span> HTTPS <span class="hljs-number">1</span> . alpn=h2<br>          <span class="hljs-number">60</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">A</span>    <span class="hljs-number">198.51.100.2</span><br>                <span class="hljs-keyword">A</span>    <span class="hljs-number">198.51.100.3</span><br>                <span class="hljs-keyword">A</span>    <span class="hljs-number">198.51.100.4</span><br>                <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8:198::7</span><br>                <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8:198::12</span><br><br><span class="hljs-comment">; Resolutions following the cdn3.svc3.example</span><br><span class="hljs-comment">; path use these records.</span><br><span class="hljs-comment">; Note that this CDN has no HTTPS records.</span><br><span class="hljs-meta">$ORIGIN</span> svc3.example. <span class="hljs-comment">; domain operated by CDN 3</span><br>cdn3      <span class="hljs-number">60</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">A</span>    <span class="hljs-number">203.0.113.8</span><br>                <span class="hljs-keyword">AAAA</span> <span class="hljs-number">2001:db8:113::8</span><br></code></pre></td></tr></table></figure>
<p>Note that in the above example, the different CDNs have different configurations and different capabilities, but clients will use HTTPS RRs as a bound-together unit.</p>
<p>Domain owners should be cautious when using a multi-CDN configuration, as it introduces a number of complexities highlighted by this example:</p>
<ul>
<li>If CDN 1 supports a desired protocol or feature and CDN 2 does not, the client is vulnerable to downgrade by a network adversary who forces clients to get CDN 2 records.</li>
<li>Aliasing the apex to its subdomain simplifies the zone file but likely increases resolution latency, especially when using a non-HTTPS-aware recursive resolver. An alternative would be to alias the zone apex directly to a name managed by a CDN.</li>
<li>The A, AAAA, and HTTPS resolutions are independent lookups, so resolvers may observe and follow different CNAMEs to different CDNs. Clients may thus find that the A and AAAA responses do not correspond to the TargetName in the HTTPS response; these clients will need to perform additional queries to retrieve the correct IP addresses. Including ipv6hint and ipv4hint will reduce the performance impact of this case.</li>
<li>If not all CDNs publish HTTPS records, clients will sometimes receive NODATA for HTTPS queries (as with cdn3.svc3.example above) but could receive A/AAAA records from a different CDN. Clients will attempt to connect to this CDN without the benefit of its HTTPS records.</li>
</ul>
<h3 id="10-4-5-Non-HTTP-Uses"><a href="#10-4-5-Non-HTTP-Uses" class="headerlink" title="10.4.5. Non-HTTP Uses"></a>10.4.5. Non-HTTP Uses</h3><p>For protocols other than HTTP, the SVCB RR and an Attrleaf label [Attrleaf] will be used. For example, to reach an example resource of “baz://api.example.com:8765”, the following SVCB record would be used to alias it to “svc4-baz.example.net.”, which in turn could return AAAA/A records and/or SVCB records in ServiceMode:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">_8765._baz<span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>. <span class="hljs-number">7200</span> IN SVCB <span class="hljs-number">0</span> svc4-baz<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.net</span>.<br>HTTPS RRs use similar Attrleaf labels <span class="hljs-keyword">if</span> the origin contains <span class="hljs-selector-tag">a</span> non-default port.<br></code></pre></td></tr></table></figure>

<h1 id="11-Interaction-with-Other-Standards"><a href="#11-Interaction-with-Other-Standards" class="headerlink" title="11. Interaction with Other Standards"></a>11. Interaction with Other Standards</h1><p>This standard is intended to reduce connection latency and improve user privacy. Server operators implementing this standard SHOULD also implement TLS 1.3 [RFC8446] and Online Certificate Status Protocol (OCSP) Stapling (i.e., Certificate Status Request in Section 8 of [RFC6066]), both of which confer substantial performance and privacy benefits when used in combination with SVCB records.</p>
<p>To realize the greatest privacy benefits, this proposal is intended for use over a privacy-preserving DNS transport (like DNS over TLS [DoT] or DNS over HTTPS [DoH]). However, performance improvements, and some modest privacy improvements, are possible without the use of those standards.</p>
<p>Any specification for the use of SVCB with a protocol MUST have an entry for its scheme under the SVCB RR type in the IANA DNS “Underscored and Globally Scoped DNS Node Names” registry [Attrleaf]. The scheme MUST have an entry in the “Uniform Resource Identifier (URI) Schemes” registry [RFC7595] and MUST have a defined specification for use with SVCB.</p>
<h1 id="12-Security-Considerations"><a href="#12-Security-Considerations" class="headerlink" title="12. Security Considerations"></a>12. Security Considerations</h1><p>SVCB/HTTPS RRs permit distribution over untrusted channels, and clients are REQUIRED to verify that the alternative endpoint is authoritative for the service (similar to Section 2.1 of [AltSvc]). Therefore, DNSSEC signing and validation are OPTIONAL for publishing and using SVCB and HTTPS RRs.</p>
<p>Clients MUST ensure that their DNS cache is partitioned for each local network, or flushed on network changes, to prevent a local adversary in one network from implanting a forged DNS record that allows them to track users or hinder their connections after they leave that network.</p>
<p>An attacker who can prevent SVCB resolution can deny clients any associated security benefits. A hostile recursive resolver can always deny service to SVCB queries, but network intermediaries can often prevent resolution as well, even when the client and recursive resolver validate DNSSEC and use a secure transport. These downgrade attacks can prevent the “https” upgrade provided by the HTTPS RR (Section 9.5) and can disable any other protections coordinated via SvcParams. To prevent downgrades, Section 3.1 recommends that clients abandon the connection attempt when such an attack is detected.</p>
<p>A hostile DNS intermediary might forge AliasMode “.” records (Section 2.5.1) as a way to block clients from accessing particular services. Such an adversary could already block entire domains by forging erroneous responses, but this mechanism allows them to target particular protocols or ports within a domain. Clients that might be subject to such attacks SHOULD ignore AliasMode “.” records.</p>
<p>A hostile DNS intermediary or authoritative server can return SVCB records indicating any IP address and port number, including IP addresses inside the local network and port numbers assigned to internal services. If the attacker can influence the client’s payload (e.g., TLS session ticket contents) and an internal service has a sufficiently lax parser, the attacker could gain access to the internal service. (The same concerns apply to SRV records, HTTP Alt-Svc, and HTTP redirects.) As a mitigation, SVCB mapping documents SHOULD indicate any port number restrictions that are appropriate for the supported transports.</p>
<h1 id="13-Privacy-Considerations"><a href="#13-Privacy-Considerations" class="headerlink" title="13. Privacy Considerations"></a>13. Privacy Considerations</h1><p>Standard address queries reveal the user’s intent to access a particular domain. This information is visible to the recursive resolver, and to many other parties when plaintext DNS transport is used. SVCB queries, like queries for SRV records and other specific RR types, additionally reveal the user’s intent to use a particular protocol. This is not normally sensitive information, but it should be considered when adding SVCB support in a new context.</p>
<h1 id="14-IANA-Considerations"><a href="#14-IANA-Considerations" class="headerlink" title="14. IANA Considerations"></a>14. IANA Considerations</h1><h2 id="14-1-SVCB-RR-Type"><a href="#14-1-SVCB-RR-Type" class="headerlink" title="14.1. SVCB RR Type"></a>14.1. SVCB RR Type</h2><p>IANA has registered the following new DNS RR type in the “Resource Record (RR) TYPEs” registry on the “Domain Name System (DNS) Parameters” page:</p>
<p>Type: SVCB<br>Value: 64<br>Meaning: General-purpose service binding<br>Reference: RFC 9460</p>
<h2 id="14-2-HTTPS-RR-Type"><a href="#14-2-HTTPS-RR-Type" class="headerlink" title="14.2. HTTPS RR Type"></a>14.2. HTTPS RR Type</h2><p>IANA has registered the following new DNS RR type in the “Resource Record (RR) TYPEs” registry on the “Domain Name System (DNS) Parameters” page:</p>
<p>Type: HTTPS<br>Value: 65<br>Meaning: SVCB-compatible type for use with HTTP<br>Reference: RFC 9460</p>
<h2 id="14-3-New-Registry-for-Service-Parameters"><a href="#14-3-New-Registry-for-Service-Parameters" class="headerlink" title="14.3. New Registry for Service Parameters"></a>14.3. New Registry for Service Parameters</h2><p>IANA has created the “Service Parameter Keys (SvcParamKeys)” registry in the “Domain Name System (DNS) Parameters” category on a new page entitled “DNS Service Bindings (SVCB)”. This registry defines the namespace for parameters, including string representations and numeric SvcParamKey values. This registry is shared with other SVCB-compatible RR types, such as the HTTPS RR.</p>
<h3 id="14-3-1-Procedure"><a href="#14-3-1-Procedure" class="headerlink" title="14.3.1. Procedure"></a>14.3.1. Procedure</h3><p>A registration MUST include the following fields:</p>
<p>Number: Wire-format numeric identifier (range 0-65535)<br>Name: Unique presentation name<br>Meaning: A short description<br>Reference: Location of specification or registration source<br>Change Controller: Person or entity, with contact information if appropriate</p>
<p>The characters in the registered Name field entry MUST be lowercase alphanumeric or “-“ (Section 2.1). The name MUST NOT start with “key” or “invalid”.</p>
<p>The registration policy for new entries is Expert Review ([RFC8126], Section 4.5). The designated expert MUST ensure that the reference is stable and publicly available and that it specifies how to convert the SvcParamValue’s presentation format to wire format. The reference MAY be any individual’s Internet-Draft or a document from any other source with similar assurances of stability and availability. An entry MAY specify a reference of the form “Same as (other key name)” if it uses the same presentation and wire formats as an existing key.</p>
<p>This arrangement supports the development of new parameters while ensuring that zone files can be made interoperable.</p>
<h3 id="14-3-2-Initial-Contents"><a href="#14-3-2-Initial-Contents" class="headerlink" title="14.3.2. Initial Contents"></a>14.3.2. Initial Contents</h3><p>The “Service Parameter Keys (SvcParamKeys)” registry has been populated with the following initial registrations:</p>
<table>
<thead>
<tr>
<th>Number</th>
<th>Name</th>
<th>Meaning</th>
<th>Reference</th>
<th>Change Controller</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>mandatory</td>
<td>Mandatory keys in this RR</td>
<td>RFC 9460, Section 8</td>
<td>IETF</td>
</tr>
<tr>
<td>1</td>
<td>alpn</td>
<td>Additional supported protocols</td>
<td>RFC 9460, Section 7.1</td>
<td>IETF</td>
</tr>
<tr>
<td>2</td>
<td>no-default-alpn</td>
<td>No support for default protocol</td>
<td>RFC 9460, Section 7.1</td>
<td>IETF</td>
</tr>
<tr>
<td>3</td>
<td>port</td>
<td>Port for alternative endpoint</td>
<td>RFC 9460, Section 7.2</td>
<td>IETF</td>
</tr>
<tr>
<td>4</td>
<td>ipv4hint</td>
<td>IPv4 address hints</td>
<td>RFC 9460, Section 7.3</td>
<td>IETF</td>
</tr>
<tr>
<td>5</td>
<td>ech</td>
<td>RESERVED (held for Encrypted ClientHello)</td>
<td>N/A</td>
<td>IETF</td>
</tr>
<tr>
<td>6</td>
<td>ipv6hint</td>
<td>IPv6 address hints</td>
<td>RFC 9460, Section 7.3</td>
<td>IETF</td>
</tr>
<tr>
<td>65280-65534</td>
<td>N/A</td>
<td>Reserved for Private Use</td>
<td>RFC 9460</td>
<td>IETF</td>
</tr>
<tr>
<td>65535</td>
<td>N/A</td>
<td>Reserved (“Invalid key”)</td>
<td>RFC 9460</td>
<td>IETF</td>
</tr>
</tbody></table>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/devops/">devops</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/dns/">dns</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/17/03%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/07%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6/bind%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">
                        <span class="hidden-mobile">bind中view和zone的区别</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
