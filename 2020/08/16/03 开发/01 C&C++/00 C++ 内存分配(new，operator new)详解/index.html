<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	<link rel="stylesheet" href="/css/highlight/styles/vs2015.css">
	<!-- title -->
	
	<title>
	
		(转载)C++ 内存分配(new，operator new)详解 | 
	 
	Fly542 技术积累
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	
  

	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">


	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Fly542 技术积累</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">关于我</a>
		</li>
		
		<li class="menu-item">
			<a href="https://fly542.cn" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>


	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="search...">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										00 操作系统
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/25/00%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E4%B8%8BIO%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/">
										linux下IO应用详解
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 架构设计与软件工程
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										00 架构设计
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/25/01%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/00%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/%E5%B8%B8%E8%A7%81%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">
										常见架构模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 软件工程
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/27/01%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/01%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/UML%E7%B1%BB%E5%9B%BE%E5%9B%BE%E7%A4%BA%E6%A0%B7%E4%BE%8B/">
										UML类图图示样例
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/27/01%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/01%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%97%B6%E5%BA%8F%E5%9B%BE%E3%80%81%E6%B4%BB%E5%8A%A8%E5%9B%BE%E3%80%81%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%81%E5%8D%8F%E4%BD%9C%E5%9B%BE%E7%9A%84%E5%8C%BA%E5%88%AB/">
										时序图、活动图、状态图、协作图的区别
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 设计模式
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/08/02/01%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/">
										00 设计模式的六大原则
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 创建型
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/08/01/01%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01%20%E5%88%9B%E5%BB%BA%E5%9E%8B/01%20Abstract%20Factory(%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82)/">
										01 Abstract Factory(抽象工厂)
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/02/01%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01%20%E5%88%9B%E5%BB%BA%E5%9E%8B/02%20Builder%20(%E7%94%9F%E6%88%90%E5%99%A8)/">
										02 Builder (生成器)
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 结构型
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/27/01%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02%20%E7%BB%93%E6%9E%84%E5%9E%8B/01%20Adapter---%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">
										01 Adapter---适配器模式
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										03 行为型
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/08/01/01%20%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/02%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03%20%E8%A1%8C%E4%B8%BA%E5%9E%8B/09%20Strategy%20(%E7%AD%96%E7%95%A5)/">
										09 Strategy (策略)
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 DevOps
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 程序运维
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/26/02%20DevOps/01%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E7%BB%B4/00%20%E5%AE%9A%E4%BD%8Dcpu%20100_p%E7%9A%84%E6%96%B9%E6%B3%95/">
										00 定位cpu 100_p的方法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/13/02%20DevOps/01%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E7%BB%B4/01%20VIRT%E4%B8%8ERES%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/">
										01 VIRT与RES占用分析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/14/02%20DevOps/01%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E7%BB%B4/02%20%5B%E7%99%BE%E5%BA%A6%E5%88%86%E4%BA%AB%5D%E9%A2%91%E7%B9%81%E5%88%86%E9%85%8D%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/">
										02 [百度分享]频繁分配释放内存导致的性能问题分析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 常用软件
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/27/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/00%20%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/">
										00 常用git命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/30/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/01%20%E5%BC%80%E5%8F%91%E6%9C%BA%E9%83%A8%E7%BD%B2/">
										01 开发机部署
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/30/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/02%20%E5%A4%9A%E7%89%88%E6%9C%ACgcc%E9%83%A8%E7%BD%B2/">
										02 多版本gcc部署
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/30/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/03%20vimrc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">
										03 vimrc配置文件
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/04%20goreplay%20%E5%BC%95%E6%B5%81%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/">
										04 goreplay 引流测试工具
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2014/08/01/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/05%20scons%E5%AE%9E%E7%94%A8%E8%AF%B4%E6%98%8E/">
										05 scons实用说明
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2012/03/20/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/06%20ssh%E8%B7%B3%E8%BD%AC%E6%97%A0%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E6%88%96%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/">
										06 ssh跳转无密码登录或执行命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2018/05/03/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/07%20%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E4%B8%BA%E7%A3%81%E7%9B%98/">
										07 本地文件映射为磁盘
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/27/02%20DevOps/02%20%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/08%20Python%20%E5%86%85%E7%BD%AE%E7%9A%84SimpleHTTPServer%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">
										08 Python 内置的SimpleHTTPServer使用指南
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										03 工具参考
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/08/20/02%20DevOps/03%20%E5%B7%A5%E5%85%B7%E5%8F%82%E8%80%83/00%20objdump%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/">
										00 objdump 二进制文件分析
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/20/02%20DevOps/03%20%E5%B7%A5%E5%85%B7%E5%8F%82%E8%80%83/01%20lsof%20%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6/">
										01 lsof 一切皆文件
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/20/02%20DevOps/03%20%E5%B7%A5%E5%85%B7%E5%8F%82%E8%80%83/02%20strace%20%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">
										02 strace 跟踪进程中的系统调用
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/20/02%20DevOps/03%20%E5%B7%A5%E5%85%B7%E5%8F%82%E8%80%83/03%20pstack%20%E8%B7%9F%E8%B8%AA%E8%BF%9B%E7%A8%8B%E6%A0%88/">
										03 pstack 跟踪进程栈
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										03 开发
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										00 算法与数据结构
									</a>
									
							<ul>
								<li class="file">
									<a href="/2014/08/01/03%20%E5%BC%80%E5%8F%91/00%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01%20(%E8%BD%AC%E8%BD%BD)%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95(consistent%20hashing)/">
										01 (转载)一致性hash算法(consistent hashing)
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/27/03%20%E5%BC%80%E5%8F%91/00%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02%20MD5%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">
										02 MD5算法原理
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/15/03%20%E5%BC%80%E5%8F%91/00%20%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03%20%E4%BC%B8%E5%B1%95%E6%A0%91(splay)/">
										03 伸展树(splay)
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 C&C++
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2020/08/16/03%20%E5%BC%80%E5%8F%91/01%20C&C++/00%20C++%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D(new%EF%BC%8Coperator%20new)%E8%AF%A6%E8%A7%A3/">
										00 C++ 内存分配(new，operator new)详解
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/03/03%20%E5%BC%80%E5%8F%91/01%20C&C++/01%20getopt%E4%B8%8Egetopt_long%E4%BD%BF%E7%94%A8/">
										01 getopt与getopt_long使用
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/26/03%20%E5%BC%80%E5%8F%91/01%20C&C++/02%20%E5%A4%A7%E7%AB%AF-%E5%B0%8F%E7%AB%AF%E5%AF%B9%E9%BD%90%E5%88%A4%E5%AE%9A%E5%87%BD%E6%95%B0/">
										02 大端-小端对齐判定函数
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 Rust
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										00 fun_code
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/00%20fun_code/rust%20%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/">
										rust 实现函数重载
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/00%20fun_code/rust%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/">
										rust 获取当前的时间戳
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/00%20fun_code/vec%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE%E6%97%B6%E9%98%B2%E6%AD%A2%E5%87%BA%E7%8E%B0%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95/">
										vec合并数据时防止出现拷贝的方法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/00%20fun_code/%E5%90%8C%E4%B8%80%E4%B8%AAcrate%E5%86%85%E4%B8%8D%E5%90%8Clib%E6%88%96%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8/">
										同一个crate内不同lib或程序间的引用
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/00%20fun_code/%E6%89%93%E5%8D%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B/">
										打印参数类型
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/00%20fun_code/%E6%89%93%E5%8D%B0%E5%8F%98%E9%87%8F%E5%9C%B0%E5%9D%80/">
										打印变量地址
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/00%20fun_code/%E6%9C%89%E8%B6%A3%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E9%97%AE%E9%A2%98%E9%97%AE%E9%A2%98/">
										有趣的所有权问题问题
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/rust%20%E5%AE%8F/">
										rust 宏
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/25/03%20%E5%BC%80%E5%8F%91/02%20Rust/rust-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%B0%86u32%E8%BD%AC%E6%8D%A2%E4%B8%BAchar%EF%BC%9F/">
										rust-为什么不能将u32转换为char？
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/31/03%20%E5%BC%80%E5%8F%91/02%20Rust/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%8F%90%E7%A4%BA%E3%80%8Aremove%20this%20mut%E3%80%8B/">
										为什么函数参数提示《remove this mut》
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										03 Shell
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/30/03%20%E5%BC%80%E5%8F%91/03%20Shell/awk%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/">
										awk常用方法
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/27/03%20%E5%BC%80%E5%8F%91/03%20Shell/%E5%88%A9%E7%94%A8Shell%E5%91%BD%E4%BB%A4%E8%8E%B7%E5%8F%96IP%E5%9C%B0%E5%9D%80/">
										利用Shell命令获取IP地址
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2018/11/30/03%20%E5%BC%80%E5%8F%91/03%20Shell/%E7%9B%91%E6%8E%A7%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8F%A5%E6%9F%84%E4%BF%A1%E6%81%AF/">
										监控指定进程的句柄信息
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										04 网络
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										00 DNS
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/08/26/04%20%E7%BD%91%E7%BB%9C/00%20DNS/00%20DNS%E5%8D%8F%E8%AE%AE/">
										00 DNS协议
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/26/04%20%E7%BD%91%E7%BB%9C/00%20DNS/01%20DNS%E4%B8%ADRR%E4%BB%8B%E7%BB%8D/">
										01 DNS中RR介绍
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/07/27/04%20%E7%BD%91%E7%BB%9C/hello-world/">
										hello-world
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										05 分布式及数据库
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										00 传统数据库
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										00 mysql
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/27/05%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/00%20%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/00%20mysql/mysql%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
										mysql 常用命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										01 sqlite
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/26/05%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/00%20%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/01%20sqlite/sqlite3%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/">
										sqlite3 客户端操作命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										02 Pika
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/07/29/05%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/02%20Pika/pika%20%E8%BF%90%E7%BB%B4%E5%91%BD%E4%BB%A4/">
										pika 运维命令
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										03 squid
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/08/16/05%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/00%20squid%20%E5%86%85%E5%AD%98%E6%B1%A0%E7%A0%94%E7%A9%B6/">
										00 squid 内存池研究
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/08/22/05%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/01%20suqid%20%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E7%A0%94%E7%A9%B6/">
										01 suqid 存储模型研究
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										04 scylladb&&cassandra
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/08/19/05%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/04%20scylladb&&cassandra/00%20scylladb/">
										00 scylladb
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										06 杂项
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/08/19/06%20%E6%9D%82%E9%A1%B9/00%20%E7%A0%94%E5%8F%91%E9%A1%B9%E7%9B%AE%E4%BA%A4%E6%8E%A5%E5%86%85%E5%AE%B9/">
										00 研发项目交接内容
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	00 C++ 内存分配(new，operator new)详解
</h1>
<div class="article-meta">
	
	<span>Fly542</span>
	<span>2020-08-16 20:03:15</span>
    
		<div id="article-categories">
            
		</div>
    
</div>

<div id="article-content">
	<p>本文转载自《<a href="https://blog.csdn.net/WUDAIJUN/article/details/9273339》" target="_blank" rel="noopener">https://blog.csdn.net/WUDAIJUN/article/details/9273339》</a></p>
<p>本文主要讲述C++ new关键字和operator new, placement new之间的种种关联，new的底层实现，以及operator new的重载和一些在内存池，STL中的应用。</p>
<h1 id="一-new-operator-和-operator-new"><a href="#一-new-operator-和-operator-new" class="headerlink" title="一. new operator 和 operator new"></a>一. new operator 和 operator new</h1><p>new operator：指我们在C++里通常用到的关键字，比如A* a = new A;<br>operator new：它是一个操作符，并且可被重载(类似加减乘除的操作符重载)<br>关于这两者的关系，我找到一段比较经典的描述（来自于<a href="http://www.cplusplus.com" target="_blank" rel="noopener">www.cplusplus.com</a> 见参考文献：</p>
<p><code>operator new can be called explicitly as a regular function, but in C++, new is an operator with a very specific behavior: An expression with the new operator, first calls function operator new (i.e., this function) with the size of its type specifier as first argument, and if this is successful, it then automatically initializes or constructs the object (if needed). Finally, the expression evaluates as a pointer to the appropriate type.</code></p>
<p>比如我们写如下代码：</p>
<pre><code>A* a = new A；</code></pre><p>我们知道这里分为三步：1.分配内存，2.调用A()构造对象，3. 返回分配指针。事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，否则调用全局::operator new(size_t )，后者由C++默认提供。因此前面的步骤也就是：</p>
<p>调用operator new (sizeof(A))<br>调用A:A()<br>返回指针<br>这里再一次提出来是因为后面关于这两步会有一些变形，在关于placement new那里会讲到。先举个简单例子</p>
<pre><code>#include&lt;iostream&gt;
class A
{
public:
     A(){
          std::cout&lt;&lt;&quot;call A constructor&quot;&lt;&lt;std::endl;
     }

     ~A(){
          std::cout&lt;&lt;&quot;call A destructor&quot;&lt;&lt;std::endl;
     }
}

int _tmain(int argc, _TCHAR* argv[])
{

     A* a = new A;
     delete a;

     system(&quot;pause&quot;);
     return 0;
}</code></pre><p>下面我们跟踪一下A反汇编代码，由于Debug版本反汇编跳转太多，因此此处通过Release版本在A* a = new A;处设断点反汇编：<br>在Release版本中，构造函数和析构函数都是直接展开的。</p>
<pre><code>A* a = new A;
01301022  push        1    ;不含数据成员的类占用一字节空间，此处压入sizeof(A)
01301024  call        operator new (13013C2h) ;调用operator new(size_t size)
01301029  mov         esi,eax ;返回值保存到esi
0130102B  add         esp,4 ;平衡栈
0130102E  mov         dword ptr [esp+8],esi ;
01301032  mov         dword ptr [esp+14h],0 
0130103A  test        esi,esi ;在operator new之后，检查其返回值，如果为空(分配失败)，则不调用A()构造函数
0130103C  je          wmain+62h (1301062h) ;为空 跳过构造函数部分
0130103E  mov         eax,dword ptr [__imp_std::endl (1302038h)] ;构造函数内部，输出字符串
01301043  mov         ecx,dword ptr [__imp_std::cout (1302050h)] 
01301049  push        eax  
0130104A  push        offset string &quot;call A constructor&quot; (1302134h) 
0130104F  push        ecx  
01301050  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (13011F0h) 
01301055  add         esp,8 
01301058  mov         ecx,eax 
0130105A  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (1302040h)] 
01301060  jmp         wmain+64h (1301064h) ;构造完成，跳过下一句
01301062  xor         esi,esi ;将esi置空，这里的esi即为new A的返回值
01301064  mov         dword ptr [esp+14h],0FFFFFFFFh 
    delete a;
0130106C  test        esi,esi ;检查a是否为空
0130106E  je          wmain+9Bh (130109Bh) ;如果为空，跳过析构函数和operator delete
01301070  mov         edx,dword ptr [__imp_std::endl (1302038h)] ;析构函数 输出字符串
01301076  mov         eax,dword ptr [__imp_std::cout (1302050h)] 
0130107B  push        edx  
0130107C  push        offset string &quot;call A destructor&quot; (1302148h) 
01301081  push        eax  
01301082  call        std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt; (13011F0h) 
01301087  add         esp,8 
0130108A  mov         ecx,eax 
0130108C  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (1302040h)] 
01301092  push        esi  ;压入a 
01301093  call        operator delete (13013BCh) ;调用operator delete 
01301098  add         esp,4 </code></pre><p>通过反汇编可以确认A* = new A的三个步骤，delete a类似<br>，包含了~A()和operator delete(a)两个步骤。</p>
<h1 id="二-operator-new的三种形式"><a href="#二-operator-new的三种形式" class="headerlink" title="二. operator new的三种形式"></a>二. operator new的三种形式</h1><p>operator new有三种形式：</p>
<pre><code>throwing (1)    
void* operator new (std::size_t size) throw (std::bad_alloc);
nothrow (2) 
void* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) throw();
placement (3)   
void* operator new (std::size_t size, void* ptr) throw();</code></pre><p>(1)(2)的区别仅是是否抛出异常，当分配失败时，前者会抛出bad_alloc异常，后者返回null，不会抛出异常。它们都分配一个固定大小的连续内存。</p>
<p>A* a = new A; //调用throwing(1)<br>A* a = new(std::nothrow) A; //调用nothrow(2)<br>(3)是<code>placement new</code>，它也是对<code>operator new</code>的一个重载，定义于#include <new>中，它多接收一个ptr参数，但它只是简单地返回ptr。其在new.h下的源代码如下：</p>
<pre><code>#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
        {return (_P); }
#if     _MSC_VER &gt;= 1200
inline void __cdecl operator delete(void *, void *)
    {return; }
#endif
#endif</code></pre><p>那么它究竟有什么用呢？事实上，它可以实现在ptr所指地址上构建一个对象(通过调用其构造函数)，这在内存池技术上有广泛应用。<br>它的调用形式为：</p>
<p>new(p) A(); //也可用A(5)等有参构造函数<br>placement new本身只是返回指针p，new(p) A()调用placement new之后，还会在p上调用A:A()，这里的p可以是动态分配的内存，也可以是栈中缓冲，如char buf[100]; new(buf) A(); </p>
<p>我们仍然可以通过一个例子来验证：</p>
<pre><code>#include &lt;iostream&gt;
class A
{
public:
    A() {
        std::cout&lt;&lt;&quot;call A constructor&quot;&lt;&lt;std::endl;
    }

    ~A() {
        std::cout&lt;&lt;&quot;call A destructor&quot;&lt;&lt;std::endl;
    }
};

int _tmain(int argc, _TCHAR* argv[]) {

    A* p = (A*)::operator new(sizeof(A)); //分配
    new(p) A(); //构造
    p-&gt;~A();   //析构
    ::operator delete(p); //释放
    system(&quot;pause&quot;);
    return 0;
}</code></pre><p>上面的代码将对象的分配，构造，析构和释放分离开来，这也是new和delete关键字两句就能完成的操作。<br>先直接运行可以看到程序输出：</p>
<pre><code>call A constructor
call A destructor</code></pre><p>再分别注释掉new(a) A();和a-&gt;~A();两句，可以看到对应的构造和析构函数将不会被调用。</p>
<p>然后查看反汇编：</p>
<pre><code>//平台: Visual Studio 2008 Debug版
    A* a = (A*)::operator new(sizeof(A)); //分配
00F9151D  push        1    
00F9151F  call        operator new (0F91208h) ;调用::operator new(size_t size)也就是throwing(1)版本
00F91524  add         esp,4 
00F91527  mov         dword ptr [ebp-14h],eax ;返回地址放入[ebp-14h] 即为p

    new(a) A(); //构造
00F9152A  mov         eax,dword ptr [ebp-14h] 
00F9152D  push        eax  
00F9152E  push        1    ;压入p
00F91530  call        operator new (0F91280h);调用operator new(size_t, void* p)即placement(3)版本 只是简单返回p
00F91535  add         esp,8 
00F91538  mov         dword ptr [ebp-0E0h],eax ;将p放入[ebp-0E0h]
00F9153E  mov         dword ptr [ebp-4],0 
00F91545  cmp         dword ptr [ebp-0E0h],0   ;判断p是否为空
00F9154C  je          wmain+81h (0F91561h)     ;如果为空 跳过构造函数
00F9154E  mov         ecx,dword ptr [ebp-0E0h] ;取出p到ecx
00F91554  call        A::A (0F91285h)          ;调用构造函数 根据_thiscall调用约定 this指针通过ecx寄存器传递
00F91559  mov         dword ptr [ebp-0F4h],eax ;将返回值(this指针)放入[ebp-0F4h]中
00F9155F  jmp         wmain+8Bh (0F9156Bh)     ;跳过下一句
00F91561  mov         dword ptr [ebp-0F4h],0   ;将[ebp-0F4h]置空 当前面判断p为空时执行此语句
00F9156B  mov         ecx,dword ptr [ebp-0F4h] ;[ebp-0F4h]为最终构造完成后的this指针(或者为空) 放入ecx
00F91571  mov         dword ptr [ebp-0ECh],ecx ;又将this放入[ebp-0ECh] 这些都是调试所用
00F91577  mov         dword ptr [ebp-4],0FFFFFFFFh 

    a-&gt;~A();   //析构
00F9157E  push        0    
00F91580  mov         ecx,dword ptr [ebp-14h] ;从[ebp-14h]中取出p
00F91583  call        A::`scalar deleting destructor&#39; (0F91041h) ;调用析构函数(跟踪进去比较复杂 如果在Release下，构造析构函数都是直接展开的)

    ::operator delete(a); //释放
00F91588  mov         eax,dword ptr [ebp-14h]   ;将p放入eax
00F9158B  push        eax           ;压入p
00F9158C  call        operator delete (0F910B9h);调用operator delete(void* )
00F91591  add         esp,4</code></pre><p>从反汇编中可以看出，其实operator new调用了两次，只不过每一次调用不同的重载函数，并且placement new的主要作用只是将p放入ecx，并且调用其构造函数。<br>事实上，在指定地址上构造对象还有另一种方法，即手动调用构造函数：p-&gt;A::A(); 这里要加上A::作用域，用p-&gt;A::A();替换掉new(p) A();仍然能达到同样的效果，反汇编：</p>
<pre><code>    A* a = (A*)::operator new(sizeof(A)); //分配
010614FE  push        1    
01061500  call        operator new (1061208h) 
01061505  add         esp,4 
01061508  mov         dword ptr [a],eax 
    //new(a) A();   //构造
    a-&gt;A::A();
0106150B  mov         ecx,dword ptr [a] 
0106150E  call        operator new (1061285h) 

    a-&gt;~A();   //析构
01061513  push        0    
01061515  mov         ecx,dword ptr [a] 
01061518  call        A::`scalar deleting destructor&#39; (1061041h) 

    ::operator delete(a); //释放
0106151D  mov         eax,dword ptr [a] 
01061520  push        eax  
01061521  call        operator delete (10610B9h) 
01061526  add         esp,4</code></pre><p>比之前的方法更加简洁高效(不需要调用placement new)。不知道手动调用构造函数是否有违C++标准或有什么隐晦，我在其他很多有名的内存池(包括SGI STL alloc)实现上看到都是用的placement new，而不是手动调用构造函数。</p>
<h1 id="三-operator-new重载"><a href="#三-operator-new重载" class="headerlink" title="三. operator new重载"></a>三. operator new重载</h1><p>前面简单提到过A* p = new A;所发生的事情：先调用operator new，如果类A重载了operator new，那么就使用该重载版本，否则使用全局版本::operatro new(size_t size)。</p>
<p>上面提到的throwing(1)和nothrow(2)的operator new是可以被重载的，比如：</p>
<pre><code>#include &lt;iostream&gt;
class A
{
public:
    A() {
        std::cout&lt;&lt;&quot;call A constructor&quot;&lt;&lt;std::endl;
    }

    ~A() {
        std::cout&lt;&lt;&quot;call A destructor&quot;&lt;&lt;std::endl;
    }
    void* operator new(size_t size) {
        std::cout&lt;&lt;&quot;call A::operator new&quot;&lt;&lt;std::endl;
        return malloc(size);
    }

    void* operator new(size_t size, const std::nothrow_t&amp; nothrow_value) {
        std::cout&lt;&lt;&quot;call A::operator new nothrow&quot;&lt;&lt;std::endl;
        return malloc(size);
    }
};

int _tmain(int argc, _TCHAR* argv[]) {
    A* p1 = new A;
    delete p1;

    A* p2 = new(std::nothrow) A;
    delete p2;

    system(&quot;pause&quot;);
    return 0;
}</code></pre><p>运行结果：</p>
<pre><code>call A::operator new
call A constructor
call A destructor
call A::operator new nothrow
call A constructor
call A destructor</code></pre><p>如果类A中没有对operator new的重载，那么new A和new(std::nothrow) A; 都将会使用全局operator new(size_t size)。可将A中两个operator new注释掉，并且在A外添加一个全局operator new重载：</p>
<pre><code>void* ::operator new(size_t size)
{
    std::cout&lt;&lt;&quot;call global operator new&quot;&lt;&lt;std::endl;
    return malloc(size);
}</code></pre><p>程序输出：</p>
<pre><code>call global operator new
call A constructor
call A destructor
call global operator new
call A constructor
call A destructor</code></pre><p>注意，这里的重载遵循作用域覆盖原则，即在里向外寻找operator new的重载时，只要找到operator new()函数就不再向外查找，如果参数符合则通过，如果参数不符合则报错，而不管全局是否还有相匹配的函数原型。比如如果这里只将A中operator new(size_t, const std::nothrow_t&amp;)删除掉，就会报错：</p>
<p>error C2660: “A::operator new”: 函数不接受 2 个参数。<br>对operator new的重载还可以添加自定义参数，如在类A中添加</p>
<pre><code>void* operator new(size_t size, int x, int y, int z)
{
    std::cout&lt;&lt;&quot;X=&quot;&lt;&lt;x&lt;&lt;&quot;  Y=&quot;&lt;&lt;y&lt;&lt;&quot; Z=&quot;&lt;&lt;z&lt;&lt;std::endl;
    return malloc(size);
}</code></pre><p>这种重载看起来没有什么大作用，因为它operator new需要完成的任务只是分配内存，但是通过对这类重载的巧妙应用，可以让它在动态分配内存调试和检测中大展身手。这将在后面operator new重载运用技巧中展现。</p>
<p>至于placement new，它本身就是operator new的一个重载，不需也尽量不要对它进行改写，因为它一般是搭配 new(p) A(); 工作的，它的职责只需简单返回指针。</p>
<h1 id="四-operator-new运用技巧和一些实例探索"><a href="#四-operator-new运用技巧和一些实例探索" class="headerlink" title="四. operator new运用技巧和一些实例探索"></a>四. operator new运用技巧和一些实例探索</h1><h2 id="4-1-operator-new重载运用于调试："><a href="#4-1-operator-new重载运用于调试：" class="headerlink" title="4.1. operator new重载运用于调试："></a>4.1. operator new重载运用于调试：</h2><p>前面提到如何operator new的重载是可以有自定义参数的，那么我们如何利用自定义参数获取更多的信息呢，这里一个很有用的做法就是给operator new添加两个参数:char* file, int line,这两个参数记录new关键字的位置，然后再在new时将文件名和行号传入，这样我们就能在分配内存失败时给出提示：输出文件名和行号。</p>
<p>那么如何获取当前语句所在文件名和行号呢，windows提供两个宏：<strong>FILE</strong>和<strong>LINE</strong>。利用它们可以直接获取到文件名和行号，也就是 new(<strong>FILE</strong>, <strong>LINE</strong>) 由于这些都是不变的，因此可以再定义一个宏：#define new new(<strong>FILE</strong>, <strong>LINE</strong>)。这样我们就只需要定义这个宏，然后重载operator new即可。</p>
<p>源代码如下，这里只是简单输出new的文件名和行号。</p>
<pre><code>//A.h
class A
{
public:
    A() {
        std::cout&lt;&lt;&quot;call A constructor&quot;&lt;&lt;std::endl;
    }

    ~A() {
        std::cout&lt;&lt;&quot;call A destructor&quot;&lt;&lt;std::endl;
    }

    void* operator new(size_t size, const char* file, int line) {
        std::cout&lt;&lt;&quot;call A::operator new on file:&quot;&lt;&lt;file&lt;&lt;&quot;  line:&quot;&lt;&lt;line&lt;&lt;std::endl;
        return malloc(size);
        return NULL;
    }

};
//Test.cpp
#include &lt;iostream&gt;
#include &quot;A.h&quot;
#define new new(__FILE__, __LINE__)

int _tmain(int argc, _TCHAR* argv[]) {
    A* p1 = new A;
    delete p1;

    system(&quot;pause&quot;);
    return 0;
}</code></pre><p>输出：</p>
<pre><code>call A::operator new on file:d:\desktop\test\test.cpp line:8
call A constructor
call A destructor</code></pre><p>注意：需要将类的声明实现与new的使用隔离开来。并且将类头文件放在宏定义之前。否则在类A中的operator new重载中的new会被宏替换，整个函数就变成了：void* operator new(<strong>FILE</strong>, <strong>LINE</strong>)(size_t size, char* file, int line)，编译器自然会报错。</p>
<h2 id="4-2-内存池优化"><a href="#4-2-内存池优化" class="headerlink" title="4.2. 内存池优化"></a>4.2. 内存池优化</h2><p>operator new的另一个大用处就是内存池优化，内存池的一个常见策略就是分配一次性分配一块大的内存作为内存池(buffer或pool)，然后重复利用该内存块，每次分配都从内存池中取出，释放则将内存块放回内存池。在我们客户端调用的是new关键字，我们可以改写operator new函数，让它从内存池中取出(当内存池不够时，再从系统堆中一次性分配一块大的)，至于构造和析构则在取出的内存上进行，然后再重载operator delete，它将内存块放回内存池。关于内存池和operator new在参考文献中有一篇很好的文章。这里就不累述了。</p>
<h2 id="4-3-STL中的new"><a href="#4-3-STL中的new" class="headerlink" title="4.3. STL中的new"></a>4.3. STL中的new</h2><p>在SGI STL源码中,defalloc.h和stl_construct.h中提供了最简单的空间配置器(allocator)封装，见《STL源码剖析》P48。它将对象的空间分配和构造分离开来，虽然在defalloc.h中仅仅是对::operator new和::operator delete的一层封装，但是它仍然给STL容器提供了更加灵活的接口。SGI STL真正使用的并不是defalloc.h中的分配器，而是stl_alloc.h中的SGI精心打造的”双层级配置器”，它将内存池技术演绎得淋漓尽致，值得细细琢磨。顺便提一下，在stl_alloc.h中并没有使用::operator new/delete 而直接使用malloc和free。具体缘由均可参见《STL源码剖析》。</p>
<h1 id="五-delete的使用"><a href="#五-delete的使用" class="headerlink" title="五. delete的使用"></a>五. delete的使用</h1><p>delete的使用基本和new一致，包括operator delete的重载方式这些都相似，只不过它的参数是void*，返回值为void。但是有一点需要注意，operator delete的自定义参数重载并不能手动调用。比如</p>
<pre><code>void* operator new(size_t size, int x)
{
    cout&lt;&lt;&quot; x = &quot;&lt;&lt;x&lt;&lt;endl;
    return malloc(size);    
}
void operator delete(void* p, int x)
{
    cout&lt;&lt;&quot; x = &quot;&lt;&lt;x&lt;&lt;endl;
    free(p);
}</code></pre><p>如下调用是无法通过的：</p>
<pre><code>A* p = new(3) A;//ok
delete(3) p;//error C2541: “delete”: 不能删除不是指针的对象</code></pre><p>那么重载operator delete有什么作用？如何调用？事实上以上自定义参数operator delete 只在一种情况下被调用：当new关键字抛出异常时。</p>
<p>可以这样理解，只有在new关键字中，编译器才知道你调用的operator new形式，然后它会调用对应的operator delete。一旦出了new关键字，编译器对于这块内存是如何分配的一无所知，因此它只会调用默认的operator delete，而至于为什么不能主动调用自定义delete(而只能老老实实delete p)，这个就不知道了。</p>
<p>细心观察的话，上面operator new用于调试的例子代码中，由于我们没有给出operator new对应的operator delete。在VS2008下会有如下警告：</p>
<pre><code>warning C4291: “void *A::operator new(size_t,const char *,int)”: 未找到匹配的删除运算符；如果初始化引发异常，则不会释放内存</code></pre><h1 id="六-关于new和内存分配的其他"><a href="#六-关于new和内存分配的其他" class="headerlink" title="六. 关于new和内存分配的其他"></a>六. 关于new和内存分配的其他</h1><ol>
<li><p>set_new_handler<br>还有一些零散的东西没有介绍到，比如set_new_handler可以在malloc(需要调用set_new_mode(1))或operator new内存分配失败时指定一个入口函数new_handler，这个函数完成自定义处理(继续尝试分配，抛出异常，或终止程序)，如果new_handler返回，那么系统将继续尝试分配内存，如果失败，将继续重复调用它，直到内存分配完毕或new_handler不再返回(抛出异常，终止)。下面这段程序完成这个测试：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;new.h&gt;// 使用_set_new_mode和set_new_handler
void nomem_handler()
{
 std::cout&lt;&lt;&quot;call nomem_handler&quot;&lt;&lt;std::endl;
}
int main()
{
 _set_new_mode(1);  //使new_handler有效
 set_new_handler(nomem_handler);//指定入口函数 函数原型void f();
 std::cout&lt;&lt;&quot;try to alloc 2GB memory....&quot;&lt;&lt;std::endl;
 char* a = (char*)malloc(2*1024*1024*1024);
 if(a)
     std::cout&lt;&lt;&quot;ok...I got it&quot;&lt;&lt;std::endl;
 free(a);
 system(&quot;pause&quot;);
}</code></pre><p>程序运行后会一直输出call nomem_handler 因为函数里面只是简单输出，返回，系统尝试分配失败后，调用nomem_handler函数，由于该函数并没有起到实际作用(让可分配内存增大)，因此返回后系统再次尝试分配失败，再调用nomem_handler，循环下去。<br>在SGI STL中的也有个仿new_handler函数:oom_malloc</p>
</li>
<li><p>new分配数组<br>new[]和new类似，仍然会优先调用类中重载的operator new[]。另外还要注意的是，在operator new[](size_t size)中传入的并不是sizeof(A)*3。而要在对象数组的大小上加上一个额外数据，用于编译器区分对象数组指针和对象指针以及对象数组大小。在VS2008(32 bit)下这个额外数据占4个字节，一个int大小。测试代码如下</p>
<pre><code>//A.h
class A
{
public:
 A() {
     std::cout&lt;&lt;&quot;call A constructor&quot;&lt;&lt;std::endl;
 }

 ~A() {
     std::cout&lt;&lt;&quot;call A destructor&quot;&lt;&lt;std::endl;
 }

 void* operator new[](size_t size) {
     std::cout&lt;&lt;&quot;call A::operator new[] size:&quot;&lt;&lt;size&lt;&lt;std::endl;
     return malloc(size);
 }
 void operator delete[](void* p) {
     std::cout&lt;&lt;&quot;call A::operator delete[]&quot;&lt;&lt;std::endl;
     free(p);
 } 
 void operator delete(void* p) {
     free(p);
 } 
};
//Test.cpp
#include &lt;iostream&gt;
#include &quot;A.h&quot;
</code></pre></li>
</ol>
<p>void* operator new[](size_t size) {<br>    std::cout&lt;&lt;”call global new[] size: “&lt;&lt;size&lt;&lt;std::endl;<br>    return malloc(size);<br>}</p>
<p>void operator delete[](void* p) {<br>    std::cout&lt;&lt;”call global delete[] “&lt;&lt;std::endl;<br>}</p>
<p>int _tmain(int argc, _TCHAR* argv[]) {<br>    std::cout&lt;&lt;”sizeof A “&lt;&lt;sizeof(A)&lt;&lt;std::endl;<br>    A* p1 = new A[3];<br>    delete []p1;</p>
<pre><code>system(&quot;pause&quot;);
return 0;</code></pre><p>}</p>
<pre><code>输出：</code></pre><p>sizeof A 1<br>call global new[] size: 7<br>call A constructor<br>call A constructor<br>call A constructor<br>call A destructor<br>call A destructor<br>call A destructor<br>call A::operator delete[]</p>
<pre><code>简单跟踪了一下，operator new[]返回的是0x005b668 而最后new关键字返回给p的是0x005b66c。也就是说p就是数组的起始地址，这样程序看到的内存就是线性的，不包括前面的额外数据。

在内存中，可以看到前面的四个字节额外数据是0x00000003 也就是3，代表数组元素个数。后面三个cd是堆在Debug中的默认值(中文的cdcd就是”屯”，栈的初始值为cc，0xcccc中文”烫”)。再后面的0xfdfdfdfd应该是堆块的结束标志，前面我有博客专门跟踪过。

注：其实在malloc源码中也有内存池的运用，而且也比较复杂。最近在参考dlmalloc版本和STL空间适配器，真没有想到一个内存分配能涉及这么多的东西。

# 七. 参考文献:
1. http://www.cplusplus.com/reference/new/operator%20new/?kw=operator% operator new的三种形式 
2. http://www.relisoft.com/book/tech/9new.html c++ operator new重载和内存池技术 
3. 《STL源码剖析》 空间配置器 
4. http://blog.csdn.net/songthin/article/details/1703966 一篇关于理解C++ New的好文 
5. http://blog.csdn.net/solstice/article/details/6198937 陈硕的Blog</code></pre>
</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2020/08/19/06%20%E6%9D%82%E9%A1%B9/00%20%E7%A0%94%E5%8F%91%E9%A1%B9%E7%9B%AE%E4%BA%A4%E6%8E%A5%E5%86%85%E5%AE%B9/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2020/08/16/05%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93/03%20squid/00%20squid%20%E5%86%85%E5%AD%98%E6%B1%A0%E7%A0%94%E7%A9%B6/">
                00 squid 内存池研究
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: 'kqRG1YI357MX0zgAERzjbptL-gzGzoHsz',
			appKey: '2PLYnaLv42a7NAbLhpOadDfj',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Fly542</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Powered by <a href="//fly542.cn" target="_blank">Fly542</a>
	</p>
</div>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a630d6a8f1929d069d0a6c8ade4e9add";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>